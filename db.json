{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/tou_xiang.jpg","path":"images/tou_xiang.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1564451678711},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1564451678712},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1564451678714},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1564451678711},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1564451678714},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1564451678715},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1564451678715},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1564451678715},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1564451678716},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1564451678717},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1564451678718},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1564451678716},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1564451678720},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1564451678721},{"_id":"themes/next/_config.yml","hash":"e22ff39557730467eb91a98d9058cdafbab8870b","modified":1564451678720},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1564451678783},{"_id":"source/categories/index.md","hash":"27b13180dd69d8e546424fe7267856508ef8b610","modified":1564451678664},{"_id":"source/_posts/C-STL.md","hash":"68157697c051e1c1de300dd21af7e42d2274b47d","modified":1564451677989},{"_id":"source/_posts/C-函数.md","hash":"6e2e851e1b13f02342ffe95dfc1095106a5ae39b","modified":1564451677989},{"_id":"source/_posts/C-关键字.md","hash":"6bb9bcd91ef97c5f330e2defb035e3573b0a3a6d","modified":1564451677989},{"_id":"source/_posts/C-多态.md","hash":"098d542d0642d4ac630dc5700701d12ff8cc5769","modified":1564451677991},{"_id":"source/_posts/C-变量作用域.md","hash":"842a14386c3b6b40f321d74dcd52cc7dbc88c586","modified":1564451677990},{"_id":"source/_posts/C-循环语句与条件语句.md","hash":"0649b0518294a4106368288ce25f19f21c00e9d0","modified":1564451677992},{"_id":"source/_posts/C-引用.md","hash":"2969316e14a9ba190f07d75258ace7add76db72a","modified":1564451677992},{"_id":"source/_posts/C-存储类.md","hash":"baa09e6c4cfc4327389326512dd1ff43db6641da","modified":1564451677992},{"_id":"source/_posts/C-数字.md","hash":"35bcef4b82cb36e389589e7729bf5149d6ecccff","modified":1564451677994},{"_id":"source/_posts/C-指针.md","hash":"6e40e9f2fc0915be885a6dfe2e1dccfbbe0a28e2","modified":1564451677993},{"_id":"source/_posts/C-数据类型.md","hash":"f9e83212c959460f88aaa47ec19b8f4d586e17bd","modified":1564451677994},{"_id":"source/_posts/C-数组.md","hash":"1259d8c5f32512861c1305a003954ffa3a3fea2b","modified":1564451677996},{"_id":"source/_posts/C-环境配置.md","hash":"677c1c66e74f0373d2f7a8273019c3269ad73935","modified":1564451677996},{"_id":"source/_posts/C-类和对象.md","hash":"d3064cc4a550ac577d43c8f908750f6a7ce8008d","modified":1564451678003},{"_id":"source/_posts/C-结构体.md","hash":"d2568db2daae2f2b6f853a99aeea9ed5c24ea44a","modified":1564451678003},{"_id":"source/_posts/C-继承.md","hash":"7023105461c592c76aa61ef47e0a102c54262c3e","modified":1564451678004},{"_id":"source/_posts/C-运算符.md","hash":"332b8ed120fe4bd609bc77b775692466d707f90c","modified":1564451678005},{"_id":"source/_posts/C-重载运算符和重载函数.md","hash":"7213abacc9467758c7f09ecceef643fd6cbea0f5","modified":1564451678006},{"_id":"source/_posts/DCL-SQL.md","hash":"53ec5c4f20bbdae482ac27c25af8dc888199d18a","modified":1565328541405},{"_id":"source/_posts/DDL-SQL.md","hash":"d40af1fe0e4a0450a7ca8ec32cb4f0ca05bac2d6","modified":1565328531050},{"_id":"source/_posts/DML-SQL.md","hash":"9c5f0651ad2e3723b5c0e2dc49f0673072c213b1","modified":1565593008785},{"_id":"source/_posts/GBDT.md","hash":"775a541eaaa8b8c833288b65565b1f654599a07b","modified":1564451678007},{"_id":"source/_posts/HDFS.md","hash":"c14c155898c2946f3b678c7b1b453b922cd087eb","modified":1565938199153},{"_id":"source/_posts/MapReduce.md","hash":"2396fc6c6c26f72cc8cae004a9038b9afcde1fe9","modified":1565938205180},{"_id":"source/_posts/LDA线性判别分析.md","hash":"9ca915e791c500f4dff14410895cea8111a9c2ad","modified":1564451678021},{"_id":"source/_posts/PCA主成分分析.md","hash":"f5e0150b85a1367619db4e14979e310eef5b9797","modified":1564451678023},{"_id":"source/_posts/SQL-spark.md","hash":"d063eb5d60d42caf549108bd976c58a2f3e7a3f8","modified":1565771652412},{"_id":"source/_posts/RDD-Spark.md","hash":"f5dd033b61b620e138412e46c594d4ad9b7a6cd1","modified":1565679723023},{"_id":"source/_posts/SQL.md","hash":"25d5ab26272dbfb5b487d2615e91ef7af361fed6","modified":1565692828722},{"_id":"source/_posts/SVM支持向量机.md","hash":"c51942c7ad1bfe14417aaa590939fc8273fa2bb5","modified":1564451678025},{"_id":"source/_posts/hadoop.md","hash":"ef9e2e833a60c45333cdcb42c6ba43e9b8bf96ff","modified":1565938063186},{"_id":"source/_posts/hello-world.md","hash":"b3960b860f84c5ef6e652a2018f24059b7ab3698","modified":1564451678047},{"_id":"source/_posts/hive.md","hash":"46326bb348af1b50f60b0151e966b606cd6b4306","modified":1565936650182},{"_id":"source/_posts/linux命令.md","hash":"25ba6b6921ad9f317e5fc242c9bc00fa1dd17e4b","modified":1564972380165},{"_id":"source/_posts/python.md","hash":"51634f197a6aee0a7f96a0b4899678a3eff9a67c","modified":1565859490683},{"_id":"source/_posts/linux子系统-win10.md","hash":"ced89346fed151c8b9e8bbacf8d5ae3544357618","modified":1565056377807},{"_id":"source/_posts/shell.md","hash":"66eececb9da6b0282e36348a1bac65368cf3c71f","modified":1565592230580},{"_id":"source/_posts/test.md","hash":"38e4e3319fa802fac05d3fa9d8bef22a439a236c","modified":1565249338457},{"_id":"source/_posts/spark.md","hash":"eea09fc3af763da9eaa6ad356bd707c698251a17","modified":1565766285366},{"_id":"source/_posts/vim.md","hash":"26819e87d0cd8f0515fba27c8676699aa781a37b","modified":1565056350840},{"_id":"source/_posts/xgboost.md","hash":"97a0acdf1d8c19628b1ef896445ceb9e0125fb92","modified":1564451678048},{"_id":"source/_posts/一维随机变量.md","hash":"b26a868dfea6175ba82a1bf328c33803291caa3e","modified":1564451678082},{"_id":"source/_posts/二维随机变量.md","hash":"23a6fc1c82cce4d375838904f6102fbf71e49a9b","modified":1564451678093},{"_id":"source/_posts/先验概率与后验概率.md","hash":"c3c4240f9c9a29e71c26f1c62949779a59d81a67","modified":1564451678094},{"_id":"source/_posts/关系运算-SQL.md","hash":"7eaec2b10b31b528914296994b0b1f801fc788e8","modified":1565321122108},{"_id":"source/_posts/决策树.md","hash":"3fd1fb2606cf42dd296901b9fb6703f79fd02b3a","modified":1564451678095},{"_id":"source/_posts/凸集，凸函数和凸优化.md","hash":"4dc14ccea17e7038893c211597a8c5ef39d5ac96","modified":1564451678105},{"_id":"source/_posts/单链表.md","hash":"0b585ef66ac761019fe529b652f30ee792ca0454","modified":1564451678112},{"_id":"source/_posts/双循环链表.md","hash":"08e752dbbc0a2e05a8ebbe9509b3cb64d692b12e","modified":1564451678122},{"_id":"source/_posts/参数估计.md","hash":"c7abdcb9be97346c9a3593e3ec334bcb39488b33","modified":1564451678112},{"_id":"source/_posts/回归树.md","hash":"b5502728a96abcdbbe17f9ffdfde3d0b0c84d6af","modified":1564451678123},{"_id":"source/_posts/常见分布.md","hash":"bf0ddf65ebae576aacb25013ab538215b771ec49","modified":1564451678135},{"_id":"source/_posts/循环链表.md","hash":"4001badb6ba8e0d37061c28639632144c627ac28","modified":1564451678152},{"_id":"source/_posts/微积分.md","hash":"bc1f469031cd374db4ffb782df9096728535e895","modified":1564451678154},{"_id":"source/_posts/感知器梯度下降.md","hash":"289983bc119ef9a0cfe0a54673436e22ea1342e7","modified":1564451678158},{"_id":"source/_posts/拉格朗日.md","hash":"22ba9b1ac3e682f3ef4ea162f5843c2f3b50080a","modified":1564451678160},{"_id":"source/_posts/数据结构目录.md","hash":"62eda4855ea312a9f17e4938ac4f9331d5399b4c","modified":1564451678160},{"_id":"source/_posts/样本以及抽样分布.md","hash":"fd645dc3335276fe409af6191e30648b4d0db58a","modified":1564451678161},{"_id":"source/_posts/核函数.md","hash":"ecac45505478406d905b0420a61b0d4bd09abe92","modified":1564451678170},{"_id":"source/_posts/梯度类方法与对偶算法.md","hash":"b25ba527b8c665f5070ff38ae9dbbe794b472b8d","modified":1564451678178},{"_id":"source/_posts/概率.md","hash":"061ddbfebb060ad941bc7aacd257fe18f3465781","modified":1564451678179},{"_id":"source/_posts/正定二次型和正定矩阵.md","hash":"7edb9b7f02a980f08f3e0589db1114a831c0cf26","modified":1564451678181},{"_id":"source/_posts/矩阵求导.md","hash":"2ab9778f55fd38539f36acaec21c193608f7c8f9","modified":1564451678239},{"_id":"source/_posts/牛顿法和拟牛顿法.md","hash":"b662a6d0b2242b38cbdd4bf6357e70a346328c96","modified":1564451678182},{"_id":"source/_posts/特征值与特征向量.md","hash":"ec48156cde22bfd6a71c696066ee761304f6047b","modified":1564451678183},{"_id":"source/_posts/矩阵的基础概念.md","hash":"0e8bb3ed384e22e4a7a687bb3b158d3419286eb5","modified":1564451678239},{"_id":"source/_posts/矩阵的逆.md","hash":"75c5bcf539d6865c0ff204e117b51b9c7dc9d0fd","modified":1564451678240},{"_id":"source/_posts/积分学.md","hash":"ebc15e6a994fe70df3b16e0a3b8df1ba4fc5c57d","modified":1564451678240},{"_id":"source/_posts/线性代数基础.md","hash":"72ed9b0e212d9662e9ea0b3c885cf17705e55137","modified":1564451678241},{"_id":"source/_posts/线性方程求解.md","hash":"390e81cfcae99e69f652a58777e755fabffe6dd4","modified":1564451678607},{"_id":"source/_posts/行列式.md","hash":"bfcc4274f75ef67d361179c6e9bdf171fd7cb374","modified":1564451678655},{"_id":"source/_posts/随机变量的统计特征.md","hash":"97c2e8923e2691080293643ae0920a9eb71b23d2","modified":1564451678663},{"_id":"source/_posts/静态链表.md","hash":"623e76cce829a0bb95b7c3932cde0ed7e4fe75d7","modified":1564451678664},{"_id":"source/_posts/随机森林.md","hash":"694ba8a5089b5473b145c9a043bdf6639de5ca5b","modified":1564451678663},{"_id":"source/_posts/评估模型.md","hash":"817aaadabd5c29af687651fd229c8460d612c9c1","modified":1565868554906},{"_id":"source/_posts/顺序表.md","hash":"fdec4c7aff1ece7e4ec5d2ca6db0ace9b2cd0084","modified":1564451678664},{"_id":"source/tags/index.md","hash":"f063648a2ceb72cae5006baffbdb16b9f0a1d76c","modified":1564451678665},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1564451678712},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1564451678712},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1564451678713},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1564451678713},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1564451678732},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1564451678781},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1564451678780},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1564451678780},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1564451678782},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1564451678781},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1564451678781},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1564451678722},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1564451678723},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1564451678782},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1564451678724},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1564451678726},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1564451678722},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1564451678727},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1564451678728},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1564451678726},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1564451678728},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1564451678728},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1564451678729},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1564451678729},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1564451678730},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1564451678785},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1564451678731},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1564451678786},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1564451678729},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1564451678730},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1564451678994},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1564451678993},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1564451678994},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678873},{"_id":"source/_posts/C-变量作用域/C-变量作用域-c93f02eb.png","hash":"84fb7c00c86c46c02fc03234c49a1e95d144b8f2","modified":1564451677991},{"_id":"source/_posts/C-指针/C-指针-16dac5ec.png","hash":"696c622170689576d66f45b1bd2851d813972791","modified":1564451677993},{"_id":"source/_posts/C-数据类型/C-数据类型-271b9c4a.png","hash":"cafb9320545d3972b567c99de28394542696730d","modified":1564451677995},{"_id":"source/_posts/C-环境配置/C-环境配置-0b256cfe.png","hash":"5c78b697fc95ef59be62913fcca91b9fd39e799b","modified":1564451677996},{"_id":"source/_posts/C-环境配置/C-环境配置-3e1777ec.png","hash":"df9104530a7c476cf4a29838e3fcee46ccf92465","modified":1564451677998},{"_id":"source/_posts/C-环境配置/C-环境配置-66761a16.png","hash":"5bf896af9015c47824c290234b48fdeffe3ad173","modified":1564451677998},{"_id":"source/_posts/C-环境配置/C-环境配置-705b6f10.png","hash":"bf5fb9a710b5f0cede15d68044626958e3f7e6f3","modified":1564451677999},{"_id":"source/_posts/C-环境配置/C-环境配置-d8cb92d5.png","hash":"c288e567b38cc5e5df8005b38f5f582cee1a03d5","modified":1564451678000},{"_id":"source/_posts/C-环境配置/C-环境配置-7d04b421.png","hash":"28f5d7b8a79455a6931ccab89e97f66856d0d56b","modified":1564451677999},{"_id":"source/_posts/C-环境配置/C-环境配置-eb44ea5a.png","hash":"b52c43abe77a504f63f588dd5e96e7e90157bf54","modified":1564451678000},{"_id":"source/_posts/C-环境配置/C-环境配置-eed71799.png","hash":"e997b819429ca337b2c738843e6c72e0760436aa","modified":1564451678001},{"_id":"source/_posts/DML-SQL/sql.tgn","hash":"682e9c7775a6537ba2b3b58a0c27f36a779f7ecd","modified":1565836960067},{"_id":"source/_posts/GBDT/GBDT-19fece56.png","hash":"6252f31b1b7a71d908e495edd69d978b08bc9e06","modified":1564451678008},{"_id":"source/_posts/GBDT/GBDT-45e7f8e1.png","hash":"3b060853432a667314e6b2257ad995326bb90ab3","modified":1564451678011},{"_id":"source/_posts/GBDT/GBDT-4145988e.png","hash":"c7b2552b94eb79a8a05e12d5e36cc7629e2a94da","modified":1564451678010},{"_id":"source/_posts/GBDT/GBDT-8717e980.png","hash":"c2ee805e63de826f0d9e8ab94727221a84537d20","modified":1564451678013},{"_id":"source/_posts/HDFS/2608446-66ac838fbd1c4c6d.webp","hash":"793617c52edc2f62fd955edf0a73841a857242c7","modified":1565931670044},{"_id":"source/_posts/GBDT/GBDT-d03da63b.png","hash":"d3004639cd47144d16688ad073438eca1d700a28","modified":1564451678017},{"_id":"source/_posts/LDA线性判别分析/LDA线性判别分析-c7a32c02.png","hash":"fa2346233f4219e5b158ff5fb8f4842526849be2","modified":1564451678022},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-79fd8d28.png","hash":"6dfead38c5a14f218070e6c8dde43ea33359c04a","modified":1564451678023},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-81a55a1f.png","hash":"af4d0054ec399513b4ef5ebd51eeeef029b25f07","modified":1564451678024},{"_id":"source/_posts/SQL-spark/spark_sql_architecture.jpg","hash":"5fa69b6e839b0e25b44f2e88a028ca32055a5c73","modified":1565699245781},{"_id":"source/_posts/SQL/sql.tgn","hash":"682e9c7775a6537ba2b3b58a0c27f36a779f7ecd","modified":1565836960067},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-0ba6fdac.png","hash":"3e5e178bb3babc4cb6216b691af52843e23f260a","modified":1564451678026},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-124d9ba6.png","hash":"838c416e5c8c331911eff937f24a01816aad4d4f","modified":1564451678027},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-1369f690.png","hash":"bf56fcf76568347b2427b621d2fbd0e4af1220ac","modified":1564451678029},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-2b9c28f6.png","hash":"2a8cf699b357ad3c35d028e3d824bfa8086a66fc","modified":1564451678037},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-18baeb56.png","hash":"f4a4b833e7a0f3e94a06ce57dcf529553376529e","modified":1564451678035},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-51712dc0.png","hash":"0578d9d4737c313dc27a10ad90f39d6b8ff48371","modified":1564451678038},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-7a61442f.png","hash":"9f33d68a20c4dca1dfbba4b030c9c4d45c08b9b0","modified":1564451678039},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-f41dd70d.png","hash":"c0772b3a493f36860d465275f5b74e90d3926578","modified":1564451678046},{"_id":"source/_posts/assets/感知器梯度下降-ecffbab1.png","hash":"cd8dec03a6896d98325b280fb5c0258ffb32cfda","modified":1564451678047},{"_id":"source/_posts/hadoop/hadoop.tgn","hash":"218ccf518bf27063f7163d98dca91fb3c578fbe4","modified":1565875285082},{"_id":"source/_posts/linux子系统-win10/1565005612829.png","hash":"61bbbf6353e619fd750d148a3491fe38aba624b5","modified":1565005612842},{"_id":"source/_posts/hadoop/hadoopFamilyRoadmap.png","hash":"c769d55bb3172cc0b9725482fa04254dc7ee3462","modified":1565782109551},{"_id":"source/_posts/linux子系统-win10/1565005516655.png","hash":"61bbbf6353e619fd750d148a3491fe38aba624b5","modified":1565005516669},{"_id":"source/_posts/linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg","hash":"c0ac7f70527f8b37ca7e2b454914f1a0ab3920a6","modified":1565009064283},{"_id":"source/_posts/linux子系统-win10/tempsnip-1565012471202.png","hash":"28fd4822580180310f0124958770441ffd17b23e","modified":1565012471216},{"_id":"source/_posts/spark/211415584105513.jpg","hash":"3ea1f69f7386776d442f4ff74a51dd429ed06dca","modified":1565683987941},{"_id":"source/_posts/spark/1565692989730.png","hash":"24c2fb0df26ae49e536cc91575de55ce2e8169f6","modified":1565692989749},{"_id":"source/_posts/spark/211416257386962.gif","hash":"e18066c4a422901a75346b5c3c7977bf76f8be8c","modified":1565684025324},{"_id":"source/_posts/xgboost/h-22546ba5.png","hash":"1aa437f6137e36547419bae05b5f4632ea6ce083","modified":1564451678052},{"_id":"source/_posts/xgboost/h-234d5b3a.png","hash":"f964f9033dba63ef6d8a92c0a87df039489d1e38","modified":1564451678052},{"_id":"source/_posts/xgboost/h-2d09c3cb.png","hash":"509b711aed559858730f1f77bd1e886b96574a18","modified":1564451678053},{"_id":"source/_posts/xgboost/h-57908c27.png","hash":"90f36bcc51e1ef27e916a4d7503598fea33d10ce","modified":1564451678054},{"_id":"source/_posts/xgboost/h-ecc2bb96.png","hash":"5933b2f7ae4066c0e2b3c62e393e679b00adde59","modified":1564451678065},{"_id":"source/_posts/xgboost/xgboost-634b5dbd.png","hash":"50ce22aa180d9b9f820054ec3cd8bd026e1446e9","modified":1564451678077},{"_id":"source/_posts/一维随机变量/一维随机变量-42feaec2.png","hash":"57be89d043b7313c54f43d4b16d081fff56d7d84","modified":1564451678086},{"_id":"source/_posts/一维随机变量/一维随机变量-a7f11452.png","hash":"db3990182afb8070555d6129556a166f79f44b5e","modified":1564451678089},{"_id":"source/_posts/一维随机变量/一维随机变量-e5379494.png","hash":"13b621846f7ca774aab1fa6fef6fdb12f04fc3b3","modified":1564451678091},{"_id":"source/_posts/关系运算-SQL/1564974696180.png","hash":"105afef3ec11612269d6d4efe83efbee3af4f4f8","modified":1564974696193},{"_id":"source/_posts/二维随机变量/二维随机变量-a083d527.png","hash":"80a0b4ba44ba8cd2c012aefea5f5bfded9b2cfc7","modified":1564451678094},{"_id":"source/_posts/关系运算-SQL/1564974826998.png","hash":"d6456544e355281215cfbee96923d99191d568a7","modified":1564974827006},{"_id":"source/_posts/关系运算-SQL/1564974606036.png","hash":"15eabe54adadd63b1db78dd43d06ef33b8c8b02a","modified":1564974606062},{"_id":"source/_posts/关系运算-SQL/1564974788006.png","hash":"a03e0751446fc9791c2e3540433ceabd0999caf2","modified":1564974788013},{"_id":"source/_posts/关系运算-SQL/1564988154852.png","hash":"ec69ef9293423284450d59d3306df4340c72aafd","modified":1564988154873},{"_id":"source/_posts/关系运算-SQL/1564988631599.png","hash":"279d2506b0495c2524744248bd536ea02907e468","modified":1564988631604},{"_id":"source/_posts/关系运算-SQL/1564988876263.png","hash":"ae9b007d63cea712b706d1918e6cf5a001d6d4a7","modified":1564988876267},{"_id":"source/_posts/关系运算-SQL/1564989251630.png","hash":"b09b39afb3020b48dd21c456a6bac9084e7c286d","modified":1564989251635},{"_id":"source/_posts/关系运算-SQL/1564989369086.png","hash":"3f609ae2752672601fddf227edd7faa96d931332","modified":1564989369092},{"_id":"source/_posts/关系运算-SQL/1564994840753.png","hash":"5d9dd73e6d5a0c86e63641ad40c7c39f8f125dfc","modified":1564994840764},{"_id":"source/_posts/关系运算-SQL/1564994851980.png","hash":"0e410de1f02d92f1423d182a4e716fcd0529ac2b","modified":1564994851986},{"_id":"source/_posts/关系运算-SQL/1564994863174.png","hash":"ae1c22de0fbcad3e8ea632ceada20ffe7f73d444","modified":1564994863184},{"_id":"source/_posts/决策树/决策树-2ab90e01.png","hash":"694263ba0568cc1f91142101b3f39820ad10e542","modified":1564451678097},{"_id":"source/_posts/决策树/决策树-49620760.png","hash":"e945fc4ae187d975e1240d1ca3848a969fd02b83","modified":1564451678097},{"_id":"source/_posts/决策树/决策树-4abd1db5.png","hash":"4a0868b2807c649044cd318c29792730093bb2c9","modified":1564451678098},{"_id":"source/_posts/决策树/决策树-b46cf4a2.png","hash":"8a6132ff70f3b358e0353d7069d86fec203e637b","modified":1564451678099},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png","hash":"e84c7cf5a90d5719fa26c03c406699ccf82bc5fb","modified":1564451678106},{"_id":"source/_posts/决策树/决策树-f545d0d4.png","hash":"6f96b3960392926c72df867c8692ee1107d5d5b9","modified":1564451678104},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png","hash":"1fec5a9fbc2e73c71778c58432d87f41ba94287b","modified":1564451678111},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png","hash":"0c6eff3beca0da7dfae914021955e178e7b731b3","modified":1564451678110},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-a587ad27.png","hash":"052a4d8092712c6daba5afdee3cfbdf108a02753","modified":1564451678111},{"_id":"source/_posts/参数估计/参数估计-48556a99.png","hash":"91ecf5d7a2589cf772db4417669ad25de2aef023","modified":1564451678114},{"_id":"source/_posts/参数估计/参数估计-398aa4f1.png","hash":"56a6fe4dae76ff8b9f4ff3041f407e6d35a72de3","modified":1564451678113},{"_id":"source/_posts/参数估计/参数估计-7c030c8b.png","hash":"3b8577be8eec01d395fa19cd2321329634520573","modified":1564451678116},{"_id":"source/_posts/回归树/回归树-7ea432c5.png","hash":"c83ec59addf768ff0ca2a4b15b68e8074729ef63","modified":1564451678129},{"_id":"source/_posts/回归树/回归树-ae6f77ba.png","hash":"b475fb5603fc6c6f8ce69b48cf4b9429b181bee4","modified":1564451678130},{"_id":"source/_posts/回归树/回归树-ce859c9e.png","hash":"bd6ddbf8ccd1c68301c720d681e6f2b8fdd736b0","modified":1564451678130},{"_id":"source/_posts/回归树/回归树-e50e2ac3.png","hash":"2c1d8d8647819e66de3e9aef7ca421dabef8d709","modified":1564451678132},{"_id":"source/_posts/回归树/回归树-eb149128.png","hash":"509f84aaeb127a7eb3312343cf38de50b6fa3a6f","modified":1564451678133},{"_id":"source/_posts/常见分布/一维随机变量-42feaec2.png","hash":"57be89d043b7313c54f43d4b16d081fff56d7d84","modified":1564451678138},{"_id":"source/_posts/常见分布/一维随机变量-a7f11452.png","hash":"db3990182afb8070555d6129556a166f79f44b5e","modified":1564451678142},{"_id":"source/_posts/常见分布/一维随机变量-e5379494.png","hash":"13b621846f7ca774aab1fa6fef6fdb12f04fc3b3","modified":1564451678144},{"_id":"source/_posts/常见分布/样本以及抽样分布-0a6c68e5.png","hash":"9421b2cd21d8599f541026862e3e806be0865065","modified":1564451678144},{"_id":"source/_posts/常见分布/样本以及抽样分布-3e85fbb1.png","hash":"87527ed8033e5e51bf5fc0432c81b70d13567f16","modified":1564451678146},{"_id":"source/_posts/常见分布/样本以及抽样分布-35e6599e.png","hash":"f38f9aff80866162a3ca3da84f46ef0e7ad45eb5","modified":1564451678145},{"_id":"source/_posts/常见分布/样本以及抽样分布-79d1c781.png","hash":"a4269eca41a637a601da3953ea78e87efd8e7a29","modified":1564451678148},{"_id":"source/_posts/循环链表/循环链表-30ed5658.png","hash":"965cf090be344dbdeec1ad89ddc659e518848561","modified":1564451678153},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-0a6c68e5.png","hash":"9421b2cd21d8599f541026862e3e806be0865065","modified":1564451678162},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-35e6599e.png","hash":"f38f9aff80866162a3ca3da84f46ef0e7ad45eb5","modified":1564451678162},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-3e85fbb1.png","hash":"87527ed8033e5e51bf5fc0432c81b70d13567f16","modified":1564451678163},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-79d1c781.png","hash":"a4269eca41a637a601da3953ea78e87efd8e7a29","modified":1564451678165},{"_id":"source/_posts/核函数/核函数-f46521d0.png","hash":"657e5f4a53d2399f1efb8c8961b5c894e5b0dfae","modified":1564451678177},{"_id":"source/_posts/梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png","hash":"bb886c431e1c6aea87d62ff4fae7b0a0fae01b77","modified":1564451678178},{"_id":"source/_posts/核函数/核函数-e3fe62f2.png","hash":"66970103a10e10c3ebaa87d2dfcb8e5dfb0d4294","modified":1564451678176},{"_id":"source/_posts/正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png","hash":"bc05dc8ec726fc4689a093edccc6156791a25425","modified":1564451678182},{"_id":"source/_posts/正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png","hash":"04fc404d7244127d1e109230dab92ad465707b36","modified":1564451678181},{"_id":"source/_posts/矩阵的基础概念/矩阵的基础概念-bced7336.png","hash":"47506889a6268e879823ab19b5f91af668d03987","modified":1564451678240},{"_id":"source/_posts/线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg","hash":"910d195c02cdfd6e8e85ec486b2b5094cc1d0549","modified":1564451678433},{"_id":"source/_posts/线性代数基础/线性代数基础-20a01623.png","hash":"dde6b8787b0ef64f11f5ff8b6f1dfdfae74d4c28","modified":1564451678602},{"_id":"source/_posts/线性代数基础/线性代数基础-c1b237dd.png","hash":"6b835b9a0e0a16b36dcdf039259be757a5196e0c","modified":1564451678606},{"_id":"source/_posts/线性代数基础/线性代数基础-93e8ff75.png","hash":"a36d813b5cbce38b3bf79dc24913ceeb22bb436f","modified":1564451678605},{"_id":"source/_posts/线性代数基础/线性代数基础-76c02b4b.png","hash":"4e49c438d9209994691b37a528c09f86250b022d","modified":1564451678604},{"_id":"source/_posts/线性代数基础/线性代数基础-fb168ecc.png","hash":"90ca640e9810210d38e0e2d8f6ea3c1c9f9ed2d6","modified":1564451678606},{"_id":"source/_posts/行列式/行列式-1194e010.png","hash":"91bdf83ffdd41c50b41a4b6fc650968a27b603c7","modified":1564451678656},{"_id":"source/_posts/行列式/行列式-b8781bc3.png","hash":"5d00a7c897c7c878552ce7f329818a61e98ef996","modified":1564451678658},{"_id":"source/_posts/行列式/行列式-cc80fd31.png","hash":"101c5ace34d3a82e972309c296aa504acd871d68","modified":1564451678659},{"_id":"source/_posts/评估模型/1565855471447.png","hash":"8466f82a10ba61d45ad5a775909c73d2977e3500","modified":1565855471460},{"_id":"source/_posts/评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg","hash":"638cb50bbb51dbdfc9fa208965e77a677eb9cdc8","modified":1565174164957},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1564451678733},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1564451678733},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1564451678738},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1564451678737},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1564451678736},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1564451678736},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1564451678731},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1564451678732},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1564451678739},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7cb1153a51f78ae4d0a888f7cd5e0cdfdc1a367c","modified":1565345965847},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1564451678743},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1564451678745},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1564451678743},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1564451678740},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1564451678745},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1564451678749},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1564451678749},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1564451678754},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1564451678769},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1564451678770},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1564451678771},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1564451678772},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1564451678772},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1564451678773},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1564451678774},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1564451678787},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1564451678787},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1564451678788},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1564451678789},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1564451678790},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1564451678794},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1564451678793},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1564451678791},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1564451678794},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1564451678872},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1564451678877},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1564451678876},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1564451678878},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1564451678878},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1564451678879},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1564451678879},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1564451678880},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1564451678880},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1564451678881},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1564451678881},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1564451678882},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1564451678882},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564451678882},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564451678883},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1564451678883},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1564451678885},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1564451678886},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1564451678886},{"_id":"source/_posts/GBDT/GBDT-1ec8b0bd.png","hash":"20006ff2b0184c4aff0aee4cd99a9b736b3e9547","modified":1564451678009},{"_id":"source/_posts/GBDT/GBDT-42bbe544.png","hash":"7ba664efbdd6767120da5e9f6174c15942c44006","modified":1564451678011},{"_id":"source/_posts/GBDT/GBDT-b9b2986e.png","hash":"cfcbc48bdfe9ae4b69d6470f5503e407ef42d035","modified":1564451678017},{"_id":"source/_posts/GBDT/GBDT-94935eb2.png","hash":"8dd0eee4415c44655bd6bcc5cb08f7518d58eac3","modified":1564451678015},{"_id":"source/_posts/GBDT/GBDT-df9b76dd.png","hash":"ea14fbc64b004a440be43d8a55be5a202b280c2e","modified":1564451678018},{"_id":"source/_posts/GBDT/GBDT-f5523f89.png","hash":"070061d5ecf4d9e06c1af85f621a0c15bb77e8b1","modified":1564451678019},{"_id":"source/_posts/GBDT/GBDT-fca6b0f9.png","hash":"c945910687d6d0c72d898a5757c498cf5f3f7c24","modified":1564451678021},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-dc898119.png","hash":"c10e6c117bfd25495d0cd694b0e81972c69a2ce5","modified":1564451678025},{"_id":"source/_posts/RDD-Spark/15050364198942.jpg","hash":"cd4174676cdd500350bdf23ba579de0c33c34cbb","modified":1565602464467},{"_id":"source/_posts/hadoop/1565782138575.png","hash":"8bec6ff0373bfef017a3ec92b11701aa7aebd1a3","modified":1565782138621},{"_id":"source/_posts/linux子系统-win10/20171212111834391.jpg","hash":"1efbcef25e0db97967af5e1f99602be65390605e","modified":1565006201838},{"_id":"source/_posts/vim/1564556925963.png","hash":"5577af96b1ac4a7394aaea5deab79131e595ffd4","modified":1564556925996},{"_id":"source/_posts/spark/MLTable.png","hash":"e794582d3948dc2457aba98663446f963aabd664","modified":1565683950569},{"_id":"source/_posts/xgboost/h-18fe29f8.png","hash":"28e167bda452f8a9aa918d5e880e7bc7e140b472","modified":1564451678049},{"_id":"source/_posts/xgboost/h-597ed097.png","hash":"d0d68d1441ac4297b5887423a4774159556abdc7","modified":1564451678060},{"_id":"source/_posts/xgboost/h-a1fde941.png","hash":"4e62e9db3f36e6e3a98e407ff9e1d45f03daa25f","modified":1564451678062},{"_id":"source/_posts/xgboost/xgboost-b2122f64.png","hash":"0611f95f4cd23ddfd01422230c71d093b1ebca32","modified":1564451678081},{"_id":"source/_posts/xgboost/xgboost-b691aaff.png","hash":"86807d6157939466fd862dafe0de95d5ea6a133b","modified":1564451678082},{"_id":"source/_posts/一维随机变量/一维随机变量-0b775c82.png","hash":"ae76f90b865afd928d966b5f9c7c00b06e523b4a","modified":1564451678084},{"_id":"source/_posts/一维随机变量/一维随机变量-a664c725.png","hash":"06722d9d31860268e730b693ecaf914187d2735e","modified":1564451678088},{"_id":"source/_posts/关系运算-SQL/1564989613458.png","hash":"0dff9ee14fc3e5fbe50f44cef8037cb4fd1afd82","modified":1564989613489},{"_id":"source/_posts/关系运算-SQL/1565060172932.png","hash":"7e0f39a9a2a976db6adb7a6c42b6d282d1116c3a","modified":1565060172974},{"_id":"source/_posts/关系运算-SQL/1565060112787.png","hash":"4818fef803a9706ad81c7511d3c2851f6bb5232d","modified":1565060112822},{"_id":"source/_posts/关系运算-SQL/1565060913297.png","hash":"30252e09265129156ad8e1f1216002b18eb81aad","modified":1565060913337},{"_id":"source/_posts/决策树/决策树-03065a1a.png","hash":"8bf3edf72bf4b665fd08844710c13f78120e5512","modified":1564451678096},{"_id":"source/_posts/决策树/决策树-d82a16be.png","hash":"08ff9cde7583d9a08c8886155772c68c3a9d7521","modified":1564451678102},{"_id":"source/_posts/决策树/决策树-eaef32cd.png","hash":"f0d960f357f9044897c5ac4db61e7148f7be7d3f","modified":1564451678103},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png","hash":"04263d2f292818ff13968da9cad53360f6f2dbde","modified":1564451678109},{"_id":"source/_posts/参数估计/参数估计-494bd225.png","hash":"ef6c505d1a1fb8651c33620e2e7547fde0929d2b","modified":1564451678115},{"_id":"source/_posts/回归树/回归树-d82a16be.png","hash":"08ff9cde7583d9a08c8886155772c68c3a9d7521","modified":1564451678132},{"_id":"source/_posts/常见分布/一维随机变量-0b775c82.png","hash":"ae76f90b865afd928d966b5f9c7c00b06e523b4a","modified":1564451678137},{"_id":"source/_posts/常见分布/一维随机变量-a664c725.png","hash":"06722d9d31860268e730b693ecaf914187d2735e","modified":1564451678140},{"_id":"source/_posts/常见分布/样本以及抽样分布-7688d0c8.png","hash":"76b54a2c81cf6f5306c1d8f26f422ce0e325f280","modified":1564451678147},{"_id":"source/_posts/常见分布/样本以及抽样分布-80c1cca7.png","hash":"cf3a540f453bc7a8079c63700717b5439b7cddb9","modified":1564451678149},{"_id":"source/_posts/常见分布/样本以及抽样分布-bc11bcfe.png","hash":"830d09180091c4587b3d33f7ff80e3bda888a4d3","modified":1564451678150},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-7688d0c8.png","hash":"76b54a2c81cf6f5306c1d8f26f422ce0e325f280","modified":1564451678164},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-80c1cca7.png","hash":"cf3a540f453bc7a8079c63700717b5439b7cddb9","modified":1564451678166},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-bc11bcfe.png","hash":"830d09180091c4587b3d33f7ff80e3bda888a4d3","modified":1564451678169},{"_id":"source/_posts/概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif","hash":"603aaddb3be50947c17e10e5853b30445d324a3a","modified":1564451678180},{"_id":"source/_posts/评估模型/1565235635992.png","hash":"7e9e6b0a78352e9244d2a231aac3e9ea90417ee8","modified":1565235636028},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678752},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678752},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678849},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678849},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678852},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678869},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564451678871},{"_id":"themes/next/source/images/tou_xiang.jpg","hash":"770a399fe47d7366e7ccd6f059ed9eb81033d237","modified":1564451678888},{"_id":"source/_posts/RDD-Spark/15050362138086.jpg","hash":"dedaeefe519da90b7479f21c391cc0fabd7de6f5","modified":1565598859640},{"_id":"source/_posts/RDD-Spark/15050363083877.jpg","hash":"198791a62cc0c95bdce86991b10e76f352b40b4a","modified":1565600886640},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-92b2d31d.png","hash":"89f900c13c6722dcc3269c8ac0aaaac62439b4ea","modified":1564451678043},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-d7b11def.png","hash":"4762cf3b3d71080949d2ca0564f6ed0209b50e67","modified":1564451678045},{"_id":"source/_posts/spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg","hash":"44f85ff77c70e88dab6d89f0fe0cfaeb58438d2a","modified":1565579541475},{"_id":"source/_posts/关系运算-SQL/1564974862127.png","hash":"b4d5d69fc51392ca0f39a08dc384854a4b8a8938","modified":1564974862167},{"_id":"source/_posts/关系运算-SQL/1565058855783.png","hash":"5d4daca241ddd1e682b8990d158072da9a805a8c","modified":1565058855829},{"_id":"source/_posts/参数估计/参数估计-909cf753.png","hash":"3966febac2b0e4b220bb05f95c4b5801f1d7eec4","modified":1564451678119},{"_id":"source/_posts/参数估计/参数估计-cd1a5ccf.png","hash":"6b6a26ecc1b1f1b58983adf5f235f5ce5097ff08","modified":1564451678121},{"_id":"source/_posts/微积分/微积分-ce2b007e.png","hash":"f1cae6215df8184daabd4a168f4943549087eb46","modified":1564451678157},{"_id":"source/_posts/行列式/行列式-8ca7d05d.png","hash":"789dfc6e15d3846885afc3d4ffb4bff859b4a37a","modified":1564451678658},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1564451678741},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1564451678743},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1564451678746},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1564451678747},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1564451678746},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1564451678747},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1564451678748},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1564451678749},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1564451678752},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1564451678748},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1564451678748},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1564451678753},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1564451678755},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1564451678755},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1564451678756},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1564451678757},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1564451678758},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1564451678761},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1564451678761},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1564451678761},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1564451678762},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1564451678762},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1564451678762},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1564451678763},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1564451678763},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1564451678764},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1564451678764},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1564451678764},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1564451678765},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1564451678765},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1564451678766},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1564451678767},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1564451678769},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1564451678769},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1564451678778},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1564451678778},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1564451678778},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1564451678779},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"ae2f93bbbf8fc13843fa03d558a7398d0b98d808","modified":1564451678848},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1564451678848},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1564451678850},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1564451678852},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1564451678869},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1564451678869},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1564451678870},{"_id":"themes/next/source/css/_variables/base.styl","hash":"6d23f848b4da1d21af3f1784d37d494b5e323e70","modified":1564451678871},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1564451678910},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1564451678914},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1564451678914},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1564451678929},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1564451678930},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1564451678929},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1564451678932},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1564451678930},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1564451678933},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1564451678934},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1564451678936},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1564451678932},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1564451678956},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1564451678957},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1564451678960},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1564451678958},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1564451678961},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1564451678961},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1564451678953},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1564451678963},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1564451678963},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1564451678962},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1564451678964},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1564451678965},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1564451678966},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1564451678966},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1564451678964},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1564451678969},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1564451678970},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1564451678965},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1564451678971},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1564451678967},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1564451678970},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1564451678971},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1564451678972},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1564451678973},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1564451678974},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1564451678976},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1564451678977},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1564451678986},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1564451678983},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1564451678989},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1564451678990},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1564451678991},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1564451678891},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1564451678889},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1564451678890},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1564451678893},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1564451678894},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1564451678895},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1564451678896},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1564451678897},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1564451678895},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1564451678897},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1564451678898},{"_id":"source/_posts/linux子系统-win10/tempsnip.png","hash":"02372a9a5d517811e3c693308b3dea59e607c890","modified":1565005990493},{"_id":"source/_posts/spark/15052983161313.jpg","hash":"c1a20e5150e87b35ec98b25d64cd1f1a32a2bac0","modified":1565765072769},{"_id":"source/_posts/xgboost/h-d1f99bfd.png","hash":"dc10b923a2b8e26517126eb5741e8fb65c07b180","modified":1564451678064},{"_id":"source/_posts/关系运算-SQL/1564990536278.png","hash":"b50ee2cb2530e6bc994d1add8869ab99ebd3e8f1","modified":1564990536327},{"_id":"source/_posts/评估模型/1565246937404.png","hash":"ee2957220c9e77d62cbd76574dc21ad679e5caa2","modified":1565246937462},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1564451678955},{"_id":"source/_posts/xgboost/h-5847b944.png","hash":"1e5bd3e9c7e4195ed6e8ca57d08ab91e3d04f875","modified":1564451678059},{"_id":"source/_posts/xgboost/xgboost-5847b944.png","hash":"1e5bd3e9c7e4195ed6e8ca57d08ab91e3d04f875","modified":1564451678072},{"_id":"source/_posts/xgboost/xgboost-3eee29c4.png","hash":"450f78f78e05ed650361de23389b57908106fd72","modified":1564451678069},{"_id":"source/_posts/xgboost/xgboost-994eafca.png","hash":"938db7fc909a92d8873873532b380dd0314d21da","modified":1564451678080},{"_id":"source/_posts/核函数/核函数-7d4cb2e5.png","hash":"b89baafcfe7329a8d40c546281520833c6ce6a31","modified":1564451678174},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1564451678777},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1564451678795},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1564451678796},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1564451678797},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1564451678777},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1564451678796},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1564451678810},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1564451678796},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1564451678825},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"693af3c84aa9b0b13316e5bccede8421a909c17b","modified":1564451678845},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1564451678846},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1564451678846},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1564451678847},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1564451678847},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"c072515e08525a575bd4a9be091694c7bc2dcd83","modified":1564451678847},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1564451678845},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1564451678854},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1564451678855},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1564451678854},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1564451678856},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1564451678853},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1564451678857},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1564451678856},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1564451678860},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1564451678861},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1564451678862},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1564451678862},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1564451678863},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1564451678863},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1564451678864},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9921879fa3229a33d7534f9311750a377e213784","modified":1564451678864},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1564451678865},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1564451678865},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1564451678866},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1564451678866},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1564451678904},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1564451678915},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1564451678907},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1564451678909},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1564451678920},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1564451678915},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1564451678917},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1564451678916},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1564451678919},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1564451678928},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1564451678927},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1564451678928},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1564451678931},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1564451678931},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1564451678938},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1564451678939},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1564451678937},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1564451678982},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1564451678982},{"_id":"source/_posts/xgboost/xgboost-5a61a64a.png","hash":"45ee2a4ab5e14d2ec7642cafc471a0477afcdb9a","modified":1564451678076},{"_id":"source/_posts/关系运算-SQL/1565064351620.png","hash":"7b7719846e5a4a267d59a47794e10683a839d8ed","modified":1565064351759},{"_id":"source/_posts/回归树/回归树-23c9f784.png","hash":"69005abcf2ff9e03352901338b241ff4310ffa96","modified":1564451678128},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1564451678896},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1564451678905},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1564451678949},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1564451678988},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1564451678952},{"_id":"source/_posts/RDD-Spark/15051361379636.jpg","hash":"3f666263f06fb3ce973f0fae5c10ba36ca4569fb","modified":1565679632763},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1564451678798},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1564451678798},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1564451678799},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1564451678799},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1564451678802},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1564451678803},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1564451678805},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1564451678806},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1564451678808},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1564451678809},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1564451678810},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1564451678802},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1564451678803},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1564451678804},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1564451678812},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1564451678811},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1564451678813},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1564451678811},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1564451678812},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1564451678813},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1564451678814},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1564451678815},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1564451678815},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1564451678814},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1564451678815},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1564451678811},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1564451678818},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1564451678816},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1564451678816},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1564451678820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1564451678819},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1564451678820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1564451678821},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1564451678821},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1564451678813},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1564451678822},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1564451678823},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1564451678824},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1564451678823},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1564451678827},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1564451678828},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1564451678827},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1564451678828},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1564451678828},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1564451678829},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1564451678831},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1564451678830},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1564451678830},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1564451678833},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1564451678832},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1564451678837},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1564451678833},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1564451678836},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1564451678838},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1564451678840},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1564451678844},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1564451678839},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1564451678841},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1564451678860},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1564451678861},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1564451678863},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1564451678899},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1564451678899},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1564451678900},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1564451678902},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1564451678903},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1564451678921},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1564451678923},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1564451678923},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1564451678922},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1564451678927},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1564451678942},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1564451678924},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1564451678945},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1564451678948},{"_id":"source/_posts/线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif","hash":"f4e2b42ed72dd94779d470262b2bb698f5b7eb72","modified":1564451678627},{"_id":"source/_posts/RDD-Spark/15050414638959-1565678738397.jpg","hash":"6131aafa6b3d70e8cb1e2fa1ee98c4e2e4e913a9","modified":1565678772702},{"_id":"source/_posts/RDD-Spark/15050414638959.jpg","hash":"6131aafa6b3d70e8cb1e2fa1ee98c4e2e4e913a9","modified":1565678702247},{"_id":"source/_posts/行列式/行列式-ec72909a.png","hash":"3e84e25f2fb85e98c0f809f47c97a104410cef72","modified":1564451678662},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1564451678913},{"_id":"source/_posts/关系运算-SQL/1565063996276.png","hash":"5848efbaf884705bfcc099133f27f25aade93fde","modified":1565063996497},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1564451678981},{"_id":"source/_posts/特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif","hash":"3afb558e1358e7e1ca653c042ff196714f434871","modified":1564451678192},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1564451678947},{"_id":"source/_posts/线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif","hash":"d373590ad3200b63c23644754483de8170451831","modified":1564451678644},{"_id":"source/_posts/线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif","hash":"9e2822809690a7ad156551010f4be1bf21cd10e8","modified":1564451678636},{"_id":"source/_posts/线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif","hash":"1b866556f51742bed25d66dbb1ec7c3c358b1645","modified":1564451678655},{"_id":"source/_posts/特征值与特征向量/9553ee95232883adcf8266498d10940e.gif","hash":"2e4ff230688002608cbdedb21359e9c2ab11c400","modified":1564451678212},{"_id":"source/_posts/线性代数基础/5fed7bb9f99639d6299756bba298111b.gif","hash":"9e4cdea11fc9f485f7cdc784295af36ddcfe071f","modified":1564451678493},{"_id":"source/_posts/线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif","hash":"aff85e09efa22dfb50fe84c4ff80b1148bb4557e","modified":1564451678432},{"_id":"source/_posts/特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif","hash":"e4e423944224aae9ca0b153dbc689317160c2c51","modified":1564451678238},{"_id":"source/_posts/线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif","hash":"bcfc928b5f2c60578ec789267a525922238dc082","modified":1564451678472},{"_id":"source/_posts/线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif","hash":"136f70a6e18ace85a7e603bdee3e28c3a14dc85c","modified":1564451678596},{"_id":"source/_posts/线性代数基础/8d40107d18c971c5999be6beb599d618.gif","hash":"ebf1b77d131fc3d08bec66d58da78c6a3d919ffb","modified":1564451678540},{"_id":"source/_posts/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif","hash":"5a70f055ec9071162a520dd175a7bd35cfb79e30","modified":1564451678309},{"_id":"source/_posts/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif","hash":"c0fbe791613f29a222773476ef8cd548baa426b8","modified":1564451678410}],"Category":[{"name":"C++","_id":"cjzdr6iw70004homjcx63frb6"},{"name":"SQL","_id":"cjzdr6iy6001khomjla3rcwar"},{"name":"机器学习","_id":"cjzdr6iyr0025homjifo79ncy"},{"name":"Hadoop","_id":"cjzdr6iyw002dhomj19kst15r"},{"name":"spark","_id":"cjzdr6izc0035homj8ihi8mbo"},{"name":"测试","_id":"cjzdr6izj003khomjoe8hvwoy"},{"name":"linux","_id":"cjzdr6izp003uhomjwhpx3muf"},{"name":"test","_id":"cjzdr6j03004ghomjmlvuhj7p"},{"name":"数学","_id":"cjzdr6j0c004vhomjinsdd2i8"},{"name":"数据结构","_id":"cjzdr6j0t005mhomjmgst1nz7"},{"name":"深度学习","_id":"cjzdr6j1g006mhomjrehzmtn1"}],"Data":[],"Page":[{"title":"categories","date":"2018-08-12T11:40:42.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-08-12 19:40:42\ntype: \"categories\"\n---\n","updated":"2019-07-30T01:54:38.664Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjzdr6ivz0000homjwoyvyx3i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-08-12T11:39:20.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-08-12 19:39:20\ntype: \"tags\"\n---\n","updated":"2019-07-30T01:54:38.665Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjzdr6iw40002homjfwiil3yn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++STL","date":"2018-08-30T07:49:00.000Z","_content":"\n\n组件 | 描述\n-|-\n容器（Containers） | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。\n算法（Algorithms） | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。\n迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。\n\n<!--more-->\n\n# 容器\n\n\n容器 | 特征 | 内存结构 | 可随机存取 | 元素搜寻速度 | 头文件\n-|-|-|-|-|-\nvector | 在序列尾部进行插入和删除，访问和修改元素的时间复杂度为O(1)，但插入和删除的时间复杂度与到末尾的距离成正比。 | 单端数组 | 可以 | 慢 | ``<vector>``\nlist | 对任意元素的访问与两端的距离成正比，但对某个位置的插入和删除花费为常数时间，即O(1) | 双向链表 | 否 | 非常慢 | ``<list>``\ndeque | 与vector基本相同，唯一不同的是，在序列头部插入和删除的时间复杂度也是O(1) | 双端数组 | 可以  | 慢 | ``<deque>``\nset | 由节点组成的红黑树，具有快速查找的功能 | 二叉树 | 否 | 快 | ``<set>``\nmultiset | 可以支持重复元素，同样具有快速查找能力 | 二叉树 | 否 | 快 | ``<set>``\nmap | 由{键，值}对组成的集合，同样具有快速查找能力 | 二叉树 | 对key而言可以 | 对key而言快 |`` <map>``\nmultimap | 一个键可以对应于多个值，同样具有快速查找能力 | 二叉树 | 否 | 对key而言快 |`` <map>``\n\n\n# 算法\n\n算法是用来操作容器中数据的模板函数，它抽象了对数据结构的操作行为。要使用STL中定义的算法，应首先引入``<algorithm>``头文件。例如STL中的sort()函数可以对容器中的数据进行排序，可以使用find()函数来搜索容器中的某个元素。这里的算法可以与C#中泛型方法进行对比来理解。\n\n# 迭代器\nSTL实现要点是将容器和算法分开，使两者彼此独立。迭代器使两个联系起来，迭代器提供访问容器中的方法。迭代器实质上是一种智能指针，它重载了->和*操作符。事实上，C++指针也是一种迭代器。在C#中同样有迭代器的概念，具体参考[MSDN](http://msdn.microsoft.com/zh-cn/library/dscyy5s0(v=vs.90).aspx)，不同的是，在C++ 中迭代器分为五类，这五类分别为：\n\n- 输入迭代器（Input Iterator）——提供对数据的只读访问；\n- 输出迭代器（Output Iterator）——提供对数据的只写访问；\n- 前推迭代器（Forward Iterator）——提供对数据的读写操作，并能向前推进的迭代器；\n- 双向迭代器（Bidirectional Iterator）——提供对数据的读写操作，并能向前和向后操作；\n- 随机访问迭代器（Random Access Iterator）——提供对数据的读写操作，并能在数据中随机移动。\n\n# 函数对象\n函数对象，又称为仿函数，STL中的函数对象就是重载了运算符()的模板类的对象，因为该类对象的调用方式类似与函数的调用方式，所以称为函数对象.\n\n# 适配器\n适配器是用来修改其他组件接口，与设计模式中的适配器模的达到的效果是一样的。STL中定义了3种形式的适配器：容器适配器、迭代器适配和函数适配器\n- 容器适配器——包括栈（stack）、队列（queue）和优先队列（priority_queue），容器适配器是对基本容器类型进行进一步的封装，从而转换为新的接口类型。\n- 迭代器适配器——对STL中基本迭代器的功能进行扩展，该类适配器包括反向迭代器、插入迭代器和流迭代器。\n- 函数适配器——通过转换或修改来扩展其他函数对象的功能。该类适配器有否定器、绑定器和函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或将多参数的函数对象转换为少参数的函数对象，如STL中bind2nd()就是绑定器。\n\n# 空间配置器\n\n当容器中保存的是用户自定义类型数据时，有的数据类型结构简单，占用的空间很小，而有的数据类型结构复杂，占用的内存空间较大；并且有的应用程序需要频繁地进行数据的插入删除操作，这样就需要对内存空间进行频繁地申请和释放工作，然而对内存的频繁操作，会产生严重的性能问题，为了解决这个问题，STL中提供了两个空间配置器，一个是简单空间配置器，仅仅对C运行库中malloc和free进行了简单的封装操作，另一个是“基于内存池的控件配置器”，即容器在每次申请内存的时候，内存池会基于一定的策略，向操作系统申请交大的内存空间，从而避免每次都向OS申请内存。STL中的空间配置器就是负责内存的分配和释放的工作\n","source":"_posts/C-STL.md","raw":"---\ntitle: C++STL\ndate: 2018-08-30 15:49:00\ntags: [STL,语言]\ncategories: C++\n---\n\n\n组件 | 描述\n-|-\n容器（Containers） | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。\n算法（Algorithms） | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。\n迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。\n\n<!--more-->\n\n# 容器\n\n\n容器 | 特征 | 内存结构 | 可随机存取 | 元素搜寻速度 | 头文件\n-|-|-|-|-|-\nvector | 在序列尾部进行插入和删除，访问和修改元素的时间复杂度为O(1)，但插入和删除的时间复杂度与到末尾的距离成正比。 | 单端数组 | 可以 | 慢 | ``<vector>``\nlist | 对任意元素的访问与两端的距离成正比，但对某个位置的插入和删除花费为常数时间，即O(1) | 双向链表 | 否 | 非常慢 | ``<list>``\ndeque | 与vector基本相同，唯一不同的是，在序列头部插入和删除的时间复杂度也是O(1) | 双端数组 | 可以  | 慢 | ``<deque>``\nset | 由节点组成的红黑树，具有快速查找的功能 | 二叉树 | 否 | 快 | ``<set>``\nmultiset | 可以支持重复元素，同样具有快速查找能力 | 二叉树 | 否 | 快 | ``<set>``\nmap | 由{键，值}对组成的集合，同样具有快速查找能力 | 二叉树 | 对key而言可以 | 对key而言快 |`` <map>``\nmultimap | 一个键可以对应于多个值，同样具有快速查找能力 | 二叉树 | 否 | 对key而言快 |`` <map>``\n\n\n# 算法\n\n算法是用来操作容器中数据的模板函数，它抽象了对数据结构的操作行为。要使用STL中定义的算法，应首先引入``<algorithm>``头文件。例如STL中的sort()函数可以对容器中的数据进行排序，可以使用find()函数来搜索容器中的某个元素。这里的算法可以与C#中泛型方法进行对比来理解。\n\n# 迭代器\nSTL实现要点是将容器和算法分开，使两者彼此独立。迭代器使两个联系起来，迭代器提供访问容器中的方法。迭代器实质上是一种智能指针，它重载了->和*操作符。事实上，C++指针也是一种迭代器。在C#中同样有迭代器的概念，具体参考[MSDN](http://msdn.microsoft.com/zh-cn/library/dscyy5s0(v=vs.90).aspx)，不同的是，在C++ 中迭代器分为五类，这五类分别为：\n\n- 输入迭代器（Input Iterator）——提供对数据的只读访问；\n- 输出迭代器（Output Iterator）——提供对数据的只写访问；\n- 前推迭代器（Forward Iterator）——提供对数据的读写操作，并能向前推进的迭代器；\n- 双向迭代器（Bidirectional Iterator）——提供对数据的读写操作，并能向前和向后操作；\n- 随机访问迭代器（Random Access Iterator）——提供对数据的读写操作，并能在数据中随机移动。\n\n# 函数对象\n函数对象，又称为仿函数，STL中的函数对象就是重载了运算符()的模板类的对象，因为该类对象的调用方式类似与函数的调用方式，所以称为函数对象.\n\n# 适配器\n适配器是用来修改其他组件接口，与设计模式中的适配器模的达到的效果是一样的。STL中定义了3种形式的适配器：容器适配器、迭代器适配和函数适配器\n- 容器适配器——包括栈（stack）、队列（queue）和优先队列（priority_queue），容器适配器是对基本容器类型进行进一步的封装，从而转换为新的接口类型。\n- 迭代器适配器——对STL中基本迭代器的功能进行扩展，该类适配器包括反向迭代器、插入迭代器和流迭代器。\n- 函数适配器——通过转换或修改来扩展其他函数对象的功能。该类适配器有否定器、绑定器和函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或将多参数的函数对象转换为少参数的函数对象，如STL中bind2nd()就是绑定器。\n\n# 空间配置器\n\n当容器中保存的是用户自定义类型数据时，有的数据类型结构简单，占用的空间很小，而有的数据类型结构复杂，占用的内存空间较大；并且有的应用程序需要频繁地进行数据的插入删除操作，这样就需要对内存空间进行频繁地申请和释放工作，然而对内存的频繁操作，会产生严重的性能问题，为了解决这个问题，STL中提供了两个空间配置器，一个是简单空间配置器，仅仅对C运行库中malloc和free进行了简单的封装操作，另一个是“基于内存池的控件配置器”，即容器在每次申请内存的时候，内存池会基于一定的策略，向操作系统申请交大的内存空间，从而避免每次都向OS申请内存。STL中的空间配置器就是负责内存的分配和释放的工作\n","slug":"C-STL","published":1,"updated":"2019-07-30T01:54:37.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iw00001homji4ecgwlc","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>容器（Containers）</td>\n<td>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td>算法（Algorithms）</td>\n<td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td>迭代器（iterators）</td>\n<td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>特征</th>\n<th>内存结构</th>\n<th>可随机存取</th>\n<th>元素搜寻速度</th>\n<th>头文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vector</td>\n<td>在序列尾部进行插入和删除，访问和修改元素的时间复杂度为O(1)，但插入和删除的时间复杂度与到末尾的距离成正比。</td>\n<td>单端数组</td>\n<td>可以</td>\n<td>慢</td>\n<td><code>&lt;vector&gt;</code></td>\n</tr>\n<tr>\n<td>list</td>\n<td>对任意元素的访问与两端的距离成正比，但对某个位置的插入和删除花费为常数时间，即O(1)</td>\n<td>双向链表</td>\n<td>否</td>\n<td>非常慢</td>\n<td><code>&lt;list&gt;</code></td>\n</tr>\n<tr>\n<td>deque</td>\n<td>与vector基本相同，唯一不同的是，在序列头部插入和删除的时间复杂度也是O(1)</td>\n<td>双端数组</td>\n<td>可以</td>\n<td>慢</td>\n<td><code>&lt;deque&gt;</code></td>\n</tr>\n<tr>\n<td>set</td>\n<td>由节点组成的红黑树，具有快速查找的功能</td>\n<td>二叉树</td>\n<td>否</td>\n<td>快</td>\n<td><code>&lt;set&gt;</code></td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>可以支持重复元素，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>否</td>\n<td>快</td>\n<td><code>&lt;set&gt;</code></td>\n</tr>\n<tr>\n<td>map</td>\n<td>由{键，值}对组成的集合，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>对key而言可以</td>\n<td>对key而言快</td>\n<td><code>&lt;map&gt;</code></td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>一个键可以对应于多个值，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>否</td>\n<td>对key而言快</td>\n<td><code>&lt;map&gt;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>算法是用来操作容器中数据的模板函数，它抽象了对数据结构的操作行为。要使用STL中定义的算法，应首先引入<code>&lt;algorithm&gt;</code>头文件。例如STL中的sort()函数可以对容器中的数据进行排序，可以使用find()函数来搜索容器中的某个元素。这里的算法可以与C#中泛型方法进行对比来理解。</p>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><p>STL实现要点是将容器和算法分开，使两者彼此独立。迭代器使两个联系起来，迭代器提供访问容器中的方法。迭代器实质上是一种智能指针，它重载了-&gt;和*操作符。事实上，C++指针也是一种迭代器。在C#中同样有迭代器的概念，具体参考<a href=\"http://msdn.microsoft.com/zh-cn/library/dscyy5s0(v=vs.90\" target=\"_blank\" rel=\"noopener\">MSDN</a>.aspx)，不同的是，在C++ 中迭代器分为五类，这五类分别为：</p>\n<ul>\n<li>输入迭代器（Input Iterator）——提供对数据的只读访问；</li>\n<li>输出迭代器（Output Iterator）——提供对数据的只写访问；</li>\n<li>前推迭代器（Forward Iterator）——提供对数据的读写操作，并能向前推进的迭代器；</li>\n<li>双向迭代器（Bidirectional Iterator）——提供对数据的读写操作，并能向前和向后操作；</li>\n<li>随机访问迭代器（Random Access Iterator）——提供对数据的读写操作，并能在数据中随机移动。</li>\n</ul>\n<h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><p>函数对象，又称为仿函数，STL中的函数对象就是重载了运算符()的模板类的对象，因为该类对象的调用方式类似与函数的调用方式，所以称为函数对象.</p>\n<h1 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h1><p>适配器是用来修改其他组件接口，与设计模式中的适配器模的达到的效果是一样的。STL中定义了3种形式的适配器：容器适配器、迭代器适配和函数适配器</p>\n<ul>\n<li>容器适配器——包括栈（stack）、队列（queue）和优先队列（priority_queue），容器适配器是对基本容器类型进行进一步的封装，从而转换为新的接口类型。</li>\n<li>迭代器适配器——对STL中基本迭代器的功能进行扩展，该类适配器包括反向迭代器、插入迭代器和流迭代器。</li>\n<li>函数适配器——通过转换或修改来扩展其他函数对象的功能。该类适配器有否定器、绑定器和函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或将多参数的函数对象转换为少参数的函数对象，如STL中bind2nd()就是绑定器。</li>\n</ul>\n<h1 id=\"空间配置器\"><a href=\"#空间配置器\" class=\"headerlink\" title=\"空间配置器\"></a>空间配置器</h1><p>当容器中保存的是用户自定义类型数据时，有的数据类型结构简单，占用的空间很小，而有的数据类型结构复杂，占用的内存空间较大；并且有的应用程序需要频繁地进行数据的插入删除操作，这样就需要对内存空间进行频繁地申请和释放工作，然而对内存的频繁操作，会产生严重的性能问题，为了解决这个问题，STL中提供了两个空间配置器，一个是简单空间配置器，仅仅对C运行库中malloc和free进行了简单的封装操作，另一个是“基于内存池的控件配置器”，即容器在每次申请内存的时候，内存池会基于一定的策略，向操作系统申请交大的内存空间，从而避免每次都向OS申请内存。STL中的空间配置器就是负责内存的分配和释放的工作</p>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>容器（Containers）</td>\n<td>容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td>算法（Algorithms）</td>\n<td>算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td>迭代器（iterators）</td>\n<td>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>容器</th>\n<th>特征</th>\n<th>内存结构</th>\n<th>可随机存取</th>\n<th>元素搜寻速度</th>\n<th>头文件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vector</td>\n<td>在序列尾部进行插入和删除，访问和修改元素的时间复杂度为O(1)，但插入和删除的时间复杂度与到末尾的距离成正比。</td>\n<td>单端数组</td>\n<td>可以</td>\n<td>慢</td>\n<td><code>&lt;vector&gt;</code></td>\n</tr>\n<tr>\n<td>list</td>\n<td>对任意元素的访问与两端的距离成正比，但对某个位置的插入和删除花费为常数时间，即O(1)</td>\n<td>双向链表</td>\n<td>否</td>\n<td>非常慢</td>\n<td><code>&lt;list&gt;</code></td>\n</tr>\n<tr>\n<td>deque</td>\n<td>与vector基本相同，唯一不同的是，在序列头部插入和删除的时间复杂度也是O(1)</td>\n<td>双端数组</td>\n<td>可以</td>\n<td>慢</td>\n<td><code>&lt;deque&gt;</code></td>\n</tr>\n<tr>\n<td>set</td>\n<td>由节点组成的红黑树，具有快速查找的功能</td>\n<td>二叉树</td>\n<td>否</td>\n<td>快</td>\n<td><code>&lt;set&gt;</code></td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>可以支持重复元素，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>否</td>\n<td>快</td>\n<td><code>&lt;set&gt;</code></td>\n</tr>\n<tr>\n<td>map</td>\n<td>由{键，值}对组成的集合，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>对key而言可以</td>\n<td>对key而言快</td>\n<td><code>&lt;map&gt;</code></td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>一个键可以对应于多个值，同样具有快速查找能力</td>\n<td>二叉树</td>\n<td>否</td>\n<td>对key而言快</td>\n<td><code>&lt;map&gt;</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>算法是用来操作容器中数据的模板函数，它抽象了对数据结构的操作行为。要使用STL中定义的算法，应首先引入<code>&lt;algorithm&gt;</code>头文件。例如STL中的sort()函数可以对容器中的数据进行排序，可以使用find()函数来搜索容器中的某个元素。这里的算法可以与C#中泛型方法进行对比来理解。</p>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><p>STL实现要点是将容器和算法分开，使两者彼此独立。迭代器使两个联系起来，迭代器提供访问容器中的方法。迭代器实质上是一种智能指针，它重载了-&gt;和*操作符。事实上，C++指针也是一种迭代器。在C#中同样有迭代器的概念，具体参考<a href=\"http://msdn.microsoft.com/zh-cn/library/dscyy5s0(v=vs.90\" target=\"_blank\" rel=\"noopener\">MSDN</a>.aspx)，不同的是，在C++ 中迭代器分为五类，这五类分别为：</p>\n<ul>\n<li>输入迭代器（Input Iterator）——提供对数据的只读访问；</li>\n<li>输出迭代器（Output Iterator）——提供对数据的只写访问；</li>\n<li>前推迭代器（Forward Iterator）——提供对数据的读写操作，并能向前推进的迭代器；</li>\n<li>双向迭代器（Bidirectional Iterator）——提供对数据的读写操作，并能向前和向后操作；</li>\n<li>随机访问迭代器（Random Access Iterator）——提供对数据的读写操作，并能在数据中随机移动。</li>\n</ul>\n<h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><p>函数对象，又称为仿函数，STL中的函数对象就是重载了运算符()的模板类的对象，因为该类对象的调用方式类似与函数的调用方式，所以称为函数对象.</p>\n<h1 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h1><p>适配器是用来修改其他组件接口，与设计模式中的适配器模的达到的效果是一样的。STL中定义了3种形式的适配器：容器适配器、迭代器适配和函数适配器</p>\n<ul>\n<li>容器适配器——包括栈（stack）、队列（queue）和优先队列（priority_queue），容器适配器是对基本容器类型进行进一步的封装，从而转换为新的接口类型。</li>\n<li>迭代器适配器——对STL中基本迭代器的功能进行扩展，该类适配器包括反向迭代器、插入迭代器和流迭代器。</li>\n<li>函数适配器——通过转换或修改来扩展其他函数对象的功能。该类适配器有否定器、绑定器和函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或将多参数的函数对象转换为少参数的函数对象，如STL中bind2nd()就是绑定器。</li>\n</ul>\n<h1 id=\"空间配置器\"><a href=\"#空间配置器\" class=\"headerlink\" title=\"空间配置器\"></a>空间配置器</h1><p>当容器中保存的是用户自定义类型数据时，有的数据类型结构简单，占用的空间很小，而有的数据类型结构复杂，占用的内存空间较大；并且有的应用程序需要频繁地进行数据的插入删除操作，这样就需要对内存空间进行频繁地申请和释放工作，然而对内存的频繁操作，会产生严重的性能问题，为了解决这个问题，STL中提供了两个空间配置器，一个是简单空间配置器，仅仅对C运行库中malloc和free进行了简单的封装操作，另一个是“基于内存池的控件配置器”，即容器在每次申请内存的时候，内存池会基于一定的策略，向操作系统申请交大的内存空间，从而避免每次都向OS申请内存。STL中的空间配置器就是负责内存的分配和释放的工作</p>"},{"title":"C++函数","date":"2017-08-29T08:57:07.000Z","_content":"```C++\nreturn_type function_name( parameter list )\n{\n   body of the function\n}\n```\n\n- **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句\n<!--more-->\n\n# 函数参数\n调用类型 | 描述\n-|-\n传值调用 | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n指针调用 | 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n引用调用 | 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n## 传值调用\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int x, int y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   // 调用函数来交换值\n   swap(a, b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int x, int y)\n{\n   int temp;\n\n   temp = x; /* 保存 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y */\n\n   return;\n}\n```\n## 指针调用\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int *x, int *y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   /* 调用函数来交换值\n    * &a 表示指向 a 的指针，即变量 a 的地址\n    * &b 表示指向 b 的指针，即变量 b 的地址\n    */\n   swap(&a, &b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int *x, int *y)\n{\n   int temp;\n   temp = *x;    /* 保存地址 x 的值 */\n   *x = *y;        /* 把 y 赋值给 x */\n   *y = temp;    /* 把 x 赋值给 y */\n\n   return;\n}\n```\n\n\n## 引用调用\n向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int &x, int &y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   /* 调用函数来交换值 */\n   swap(a, b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int &x, int &y)\n{\n   int temp;\n   temp = x; /* 保存地址 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y  */\n\n   return;\n}\n```\n# 参数的默认值\n当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值\n```C++\n#include <iostream>\nusing namespace std;\n\nint sum(int a, int b=20)\n{\n  int result;\n\n  result = a + b;\n\n  return (result);\n}\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int result;\n\n   // 调用函数来添加值\n   result = sum(a, b);\n   cout << \"Total value is :\" << result << endl;\n\n   // 再次调用函数\n   result = sum(a);\n   cout << \"Total value is :\" << result << endl;\n\n   return 0;\n}\n```\n\n# [Lambda 函数与表达式](https://www.jianshu.com/p/d686ad9de817)\n```C++\n[capture](parameters)->return-type{body}\n```\n","source":"_posts/C-函数.md","raw":"---\ntitle: C++函数\ndate: 2017-08-29 16:57:07\ntags: [变量作用域,语言]\ncategories: C++\n---\n```C++\nreturn_type function_name( parameter list )\n{\n   body of the function\n}\n```\n\n- **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。\n- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数主体：**函数主体包含一组定义函数执行任务的语句\n<!--more-->\n\n# 函数参数\n调用类型 | 描述\n-|-\n传值调用 | 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。\n指针调用 | 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n引用调用 | 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n## 传值调用\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int x, int y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   // 调用函数来交换值\n   swap(a, b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int x, int y)\n{\n   int temp;\n\n   temp = x; /* 保存 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y */\n\n   return;\n}\n```\n## 指针调用\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int *x, int *y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   /* 调用函数来交换值\n    * &a 表示指向 a 的指针，即变量 a 的地址\n    * &b 表示指向 b 的指针，即变量 b 的地址\n    */\n   swap(&a, &b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int *x, int *y)\n{\n   int temp;\n   temp = *x;    /* 保存地址 x 的值 */\n   *x = *y;        /* 把 y 赋值给 x */\n   *y = temp;    /* 把 x 赋值给 y */\n\n   return;\n}\n```\n\n\n## 引用调用\n向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n```C++\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nvoid swap(int &x, int &y);\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n\n   cout << \"交换前，a 的值：\" << a << endl;\n   cout << \"交换前，b 的值：\" << b << endl;\n\n   /* 调用函数来交换值 */\n   swap(a, b);\n\n   cout << \"交换后，a 的值：\" << a << endl;\n   cout << \"交换后，b 的值：\" << b << endl;\n\n   return 0;\n}\n\n// 函数定义\nvoid swap(int &x, int &y)\n{\n   int temp;\n   temp = x; /* 保存地址 x 的值 */\n   x = y;    /* 把 y 赋值给 x */\n   y = temp; /* 把 x 赋值给 y  */\n\n   return;\n}\n```\n# 参数的默认值\n当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值\n```C++\n#include <iostream>\nusing namespace std;\n\nint sum(int a, int b=20)\n{\n  int result;\n\n  result = a + b;\n\n  return (result);\n}\n\nint main ()\n{\n   // 局部变量声明\n   int a = 100;\n   int b = 200;\n   int result;\n\n   // 调用函数来添加值\n   result = sum(a, b);\n   cout << \"Total value is :\" << result << endl;\n\n   // 再次调用函数\n   result = sum(a);\n   cout << \"Total value is :\" << result << endl;\n\n   return 0;\n}\n```\n\n# [Lambda 函数与表达式](https://www.jianshu.com/p/d686ad9de817)\n```C++\n[capture](parameters)->return-type{body}\n```\n","slug":"C-函数","published":1,"updated":"2019-07-30T01:54:37.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iw50003homjgx9qahiz","content":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter <span class=\"built_in\">list</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   body of the function</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>返回类型：</strong>一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。</li>\n<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>\n<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>\n<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句<a id=\"more\"></a>\n</li>\n</ul>\n<h1 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>调用类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传值调用</td>\n<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td>指针调用</td>\n<td>该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td>引用调用</td>\n<td>该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"传值调用\"><a href=\"#传值调用\" class=\"headerlink\" title=\"传值调用\"></a>传值调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来交换值</span></span><br><span class=\"line\">   swap(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">   temp = x; <span class=\"comment\">/* 保存 x 的值 */</span></span><br><span class=\"line\">   x = y;    <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   y = temp; <span class=\"comment\">/* 把 x 赋值给 y */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指针调用\"><a href=\"#指针调用\" class=\"headerlink\" title=\"指针调用\"></a>指针调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 调用函数来交换值</span></span><br><span class=\"line\"><span class=\"comment\">    * &amp;a 表示指向 a 的指针，即变量 a 的地址</span></span><br><span class=\"line\"><span class=\"comment\">    * &amp;b 表示指向 b 的指针，即变量 b 的地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   swap(&amp;a, &amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">   temp = *x;    <span class=\"comment\">/* 保存地址 x 的值 */</span></span><br><span class=\"line\">   *x = *y;        <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   *y = temp;    <span class=\"comment\">/* 把 x 赋值给 y */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用调用\"><a href=\"#引用调用\" class=\"headerlink\" title=\"引用调用\"></a>引用调用</h2><p>向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 调用函数来交换值 */</span></span><br><span class=\"line\">   swap(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">   temp = x; <span class=\"comment\">/* 保存地址 x 的值 */</span></span><br><span class=\"line\">   x = y;    <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   y = temp; <span class=\"comment\">/* 把 x 赋值给 y  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"参数的默认值\"><a href=\"#参数的默认值\" class=\"headerlink\" title=\"参数的默认值\"></a>参数的默认值</h1><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b=<span class=\"number\">20</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来添加值</span></span><br><span class=\"line\">   result = sum(a, b);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total value is :\"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 再次调用函数</span></span><br><span class=\"line\">   result = sum(a);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total value is :\"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Lambda-函数与表达式\"><a href=\"#Lambda-函数与表达式\" class=\"headerlink\" title=\"Lambda 函数与表达式\"></a><a href=\"https://www.jianshu.com/p/d686ad9de817\" target=\"_blank\" rel=\"noopener\">Lambda 函数与表达式</a></h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)-&gt;<span class=\"keyword\">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">return_type <span class=\"title\">function_name</span><span class=\"params\">( parameter <span class=\"built_in\">list</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   body of the function</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>返回类型：</strong>一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。</li>\n<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>\n<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>\n<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句</li></ul>","more":"\n\n<h1 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>调用类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传值调用</td>\n<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td>指针调用</td>\n<td>该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td>引用调用</td>\n<td>该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"传值调用\"><a href=\"#传值调用\" class=\"headerlink\" title=\"传值调用\"></a>传值调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来交换值</span></span><br><span class=\"line\">   swap(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">   temp = x; <span class=\"comment\">/* 保存 x 的值 */</span></span><br><span class=\"line\">   x = y;    <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   y = temp; <span class=\"comment\">/* 把 x 赋值给 y */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指针调用\"><a href=\"#指针调用\" class=\"headerlink\" title=\"指针调用\"></a>指针调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 调用函数来交换值</span></span><br><span class=\"line\"><span class=\"comment\">    * &amp;a 表示指向 a 的指针，即变量 a 的地址</span></span><br><span class=\"line\"><span class=\"comment\">    * &amp;b 表示指向 b 的指针，即变量 b 的地址</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   swap(&amp;a, &amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> *x, <span class=\"keyword\">int</span> *y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">   temp = *x;    <span class=\"comment\">/* 保存地址 x 的值 */</span></span><br><span class=\"line\">   *x = *y;        <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   *y = temp;    <span class=\"comment\">/* 把 x 赋值给 y */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用调用\"><a href=\"#引用调用\" class=\"headerlink\" title=\"引用调用\"></a>引用调用</h2><p>向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换前，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 调用函数来交换值 */</span></span><br><span class=\"line\">   swap(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，a 的值：\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"交换后，b 的值：\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">   temp = x; <span class=\"comment\">/* 保存地址 x 的值 */</span></span><br><span class=\"line\">   x = y;    <span class=\"comment\">/* 把 y 赋值给 x */</span></span><br><span class=\"line\">   y = temp; <span class=\"comment\">/* 把 x 赋值给 y  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"参数的默认值\"><a href=\"#参数的默认值\" class=\"headerlink\" title=\"参数的默认值\"></a>参数的默认值</h1><p>当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b=<span class=\"number\">20</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 调用函数来添加值</span></span><br><span class=\"line\">   result = sum(a, b);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total value is :\"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 再次调用函数</span></span><br><span class=\"line\">   result = sum(a);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total value is :\"</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Lambda-函数与表达式\"><a href=\"#Lambda-函数与表达式\" class=\"headerlink\" title=\"Lambda 函数与表达式\"></a><a href=\"https://www.jianshu.com/p/d686ad9de817\" target=\"_blank\" rel=\"noopener\">Lambda 函数与表达式</a></h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture](parameters)-&gt;<span class=\"keyword\">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++关键字","date":"2017-08-29T02:37:53.000Z","_content":"# [关键字](https://www.runoob.com/w3cnote/cpp-keyword-intro.html)\nasm | else | new | this\n-|-|-|-\nauto | enum | operator | throw\nbool | explicit | private | true\nbreak | export | protected | try\ncase | extern | public | typedef\ncatch | false | register | typeid\nchar | float | reinterpret_cast | typename\nclass | for | return | union\nconst | friend | short | unsigned\nconst_cast | goto | signed | using\ncontinue | if | sizeof | virtual\ndefault | inline | static | void\ndelete | int | static_cast | volatile\ndo | long | struct | wchar_t\ndouble | mutable | switch | while\ndynamic_cast | namespace | template |\n<!--more-->\n","source":"_posts/C-关键字.md","raw":"---\ntitle: C++关键字\ndate: 2017-08-29 10:37:53\ntags: [关键字,语言]\ncategories: C++\n---\n# [关键字](https://www.runoob.com/w3cnote/cpp-keyword-intro.html)\nasm | else | new | this\n-|-|-|-\nauto | enum | operator | throw\nbool | explicit | private | true\nbreak | export | protected | try\ncase | extern | public | typedef\ncatch | false | register | typeid\nchar | float | reinterpret_cast | typename\nclass | for | return | union\nconst | friend | short | unsigned\nconst_cast | goto | signed | using\ncontinue | if | sizeof | virtual\ndefault | inline | static | void\ndelete | int | static_cast | volatile\ndo | long | struct | wchar_t\ndouble | mutable | switch | while\ndynamic_cast | namespace | template |\n<!--more-->\n","slug":"C-关键字","published":1,"updated":"2019-07-30T01:54:37.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwa0006homjxw6989t5","content":"<h1 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a><a href=\"https://www.runoob.com/w3cnote/cpp-keyword-intro.html\" target=\"_blank\" rel=\"noopener\">关键字</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>asm</th>\n<th>else</th>\n<th>new</th>\n<th>this</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed</td>\n<td>using</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch</td>\n<td>while</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<h1 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a><a href=\"https://www.runoob.com/w3cnote/cpp-keyword-intro.html\" target=\"_blank\" rel=\"noopener\">关键字</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>asm</th>\n<th>else</th>\n<th>new</th>\n<th>this</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>enum</td>\n<td>operator</td>\n<td>throw</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>explicit</td>\n<td>private</td>\n<td>true</td>\n</tr>\n<tr>\n<td>break</td>\n<td>export</td>\n<td>protected</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>extern</td>\n<td>public</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>false</td>\n<td>register</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>char</td>\n<td>float</td>\n<td>reinterpret_cast</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>class</td>\n<td>for</td>\n<td>return</td>\n<td>union</td>\n</tr>\n<tr>\n<td>const</td>\n<td>friend</td>\n<td>short</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>goto</td>\n<td>signed</td>\n<td>using</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>if</td>\n<td>sizeof</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>default</td>\n<td>inline</td>\n<td>static</td>\n<td>void</td>\n</tr>\n<tr>\n<td>delete</td>\n<td>int</td>\n<td>static_cast</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>do</td>\n<td>long</td>\n<td>struct</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>double</td>\n<td>mutable</td>\n<td>switch</td>\n<td>while</td>\n</tr>\n<tr>\n<td>dynamic_cast</td>\n<td>namespace</td>\n<td>template</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>","more":""},{"title":"C++多态","date":"2018-08-30T03:36:31.000Z","_content":"\n# 虚函数\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n\n\n# 多态\n父类调用子类的函数需要用到虚函数\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Shape {\nprotected:\n\tint width, height;\npublic:\n\tShape(int a = 0, int b = 0)\n\t{\n\t\twidth = a;\n\t\theight = b;\n\t}\n\tvirtual int area()\n\t{\n\t\tcout << \"Parent class area :\" << endl;\n\t\treturn 0;\n\t}\n};\nclass Rectangle : public Shape{\npublic:\n\tRectangle(int a = 0, int b = 0) :Shape(a, b) { }\n\tint area()\n\t{\n\t\tcout << \"Rectangle class area :\" << endl;\n\t\treturn (width * height);\n\t}\n};\nclass Triangle : public Shape{\npublic:\n\tTriangle(int a = 0, int b = 0) :Shape(a, b) { }\n\tint area()\n\t{\n\t\tcout << \"Triangle class area :\" << endl;\n\t\treturn (width * height / 2);\n\t}\n};\n// 程序的主函数\nint main()\n{\n\tShape *shape;\n\tRectangle rec(10, 7);\n\tTriangle  tri(10, 5);\n\n\t// 存储矩形的地址\n\tshape = &rec;\n\t// 调用矩形的求面积函数 area\n\tshape->area();\n\n\t// 存储三角形的地址\n\tshape = &tri;\n\t// 调用三角形的求面积函数 area\n\tshape->area();\n\n\treturn 0;\n}\n```\n","source":"_posts/C-多态.md","raw":"---\ntitle: C++多态\ndate: 2018-08-30 11:36:31\ntags: [多态,虚函数,语言]\ncategories: C++\n---\n\n# 虚函数\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n\n\n# 多态\n父类调用子类的函数需要用到虚函数\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Shape {\nprotected:\n\tint width, height;\npublic:\n\tShape(int a = 0, int b = 0)\n\t{\n\t\twidth = a;\n\t\theight = b;\n\t}\n\tvirtual int area()\n\t{\n\t\tcout << \"Parent class area :\" << endl;\n\t\treturn 0;\n\t}\n};\nclass Rectangle : public Shape{\npublic:\n\tRectangle(int a = 0, int b = 0) :Shape(a, b) { }\n\tint area()\n\t{\n\t\tcout << \"Rectangle class area :\" << endl;\n\t\treturn (width * height);\n\t}\n};\nclass Triangle : public Shape{\npublic:\n\tTriangle(int a = 0, int b = 0) :Shape(a, b) { }\n\tint area()\n\t{\n\t\tcout << \"Triangle class area :\" << endl;\n\t\treturn (width * height / 2);\n\t}\n};\n// 程序的主函数\nint main()\n{\n\tShape *shape;\n\tRectangle rec(10, 7);\n\tTriangle  tri(10, 5);\n\n\t// 存储矩形的地址\n\tshape = &rec;\n\t// 调用矩形的求面积函数 area\n\tshape->area();\n\n\t// 存储三角形的地址\n\tshape = &tri;\n\t// 调用三角形的求面积函数 area\n\tshape->area();\n\n\treturn 0;\n}\n```\n","slug":"C-多态","published":1,"updated":"2019-07-30T01:54:37.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwb0007homjyqsem5mj","content":"<h1 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h1><p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>父类调用子类的函数需要用到虚函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> width, height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tShape(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twidth = a;</span><br><span class=\"line\">\t\theight = b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parent class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> :</span> <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tRectangle(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>) :Shape(a, b) &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Rectangle class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> :</span> <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTriangle(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>) :Shape(a, b) &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Triangle class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (width * height / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tShape *shape;</span><br><span class=\"line\">\t<span class=\"function\">Rectangle <span class=\"title\">rec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Triangle  <span class=\"title\">tri</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 存储矩形的地址</span></span><br><span class=\"line\">\tshape = &amp;rec;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用矩形的求面积函数 area</span></span><br><span class=\"line\">\tshape-&gt;area();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 存储三角形的地址</span></span><br><span class=\"line\">\tshape = &amp;tri;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用三角形的求面积函数 area</span></span><br><span class=\"line\">\tshape-&gt;area();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h1><p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>父类调用子类的函数需要用到虚函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> width, height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tShape(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twidth = a;</span><br><span class=\"line\">\t\theight = b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parent class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> :</span> <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tRectangle(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>) :Shape(a, b) &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Rectangle class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> :</span> <span class=\"keyword\">public</span> Shape&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTriangle(<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>) :Shape(a, b) &#123; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">area</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Triangle class area :\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (width * height / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tShape *shape;</span><br><span class=\"line\">\t<span class=\"function\">Rectangle <span class=\"title\">rec</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">Triangle  <span class=\"title\">tri</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 存储矩形的地址</span></span><br><span class=\"line\">\tshape = &amp;rec;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用矩形的求面积函数 area</span></span><br><span class=\"line\">\tshape-&gt;area();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 存储三角形的地址</span></span><br><span class=\"line\">\tshape = &amp;tri;</span><br><span class=\"line\">\t<span class=\"comment\">// 调用三角形的求面积函数 area</span></span><br><span class=\"line\">\tshape-&gt;area();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"C++变量作用域","date":"2017-08-29T03:36:17.000Z","_content":"![](C-变量作用域/C-变量作用域-c93f02eb.png)\n<!--more-->\n# 局部变量\n在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n  // 局部变量声明\n  int a, b;\n  int c;\n\n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n\n  cout << c;\n\n  return 0;\n}\n```\n\n# 全局变量\n\n在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n```C++`\n#include <iostream>\nusing namespace std;\n\n// 全局变量声明\nint g;\n\nint main ()\n{\n  // 局部变量声明\n  int a, b;\n\n  // 实际初始化\n  a = 10;\n  b = 20;\n  g = a + b;\n\n  cout << g;\n\n  return 0;\n}\n```\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n\n```C++\n#include <iostream>\nusing namespace std;\n\n// 全局变量声明\nint g = 20;\n\nint main ()\n{\n  // 局部变量声明\n  int g = 10;\n\n  cout << g;\n\n  return 0;\n}\n```\n当上面的代码被编译和执行时，它会产生下列结果：\n```C++\n10\n```\n","source":"_posts/C-变量作用域.md","raw":"---\ntitle: C++变量作用域\ndate: 2017-08-29 11:36:17\ntags: [变量作用域,语言]\ncategories: C++\n---\n![](C-变量作用域/C-变量作用域-c93f02eb.png)\n<!--more-->\n# 局部变量\n在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n  // 局部变量声明\n  int a, b;\n  int c;\n\n  // 实际初始化\n  a = 10;\n  b = 20;\n  c = a + b;\n\n  cout << c;\n\n  return 0;\n}\n```\n\n# 全局变量\n\n在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n```C++`\n#include <iostream>\nusing namespace std;\n\n// 全局变量声明\nint g;\n\nint main ()\n{\n  // 局部变量声明\n  int a, b;\n\n  // 实际初始化\n  a = 10;\n  b = 20;\n  g = a + b;\n\n  cout << g;\n\n  return 0;\n}\n```\n在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：\n\n```C++\n#include <iostream>\nusing namespace std;\n\n// 全局变量声明\nint g = 20;\n\nint main ()\n{\n  // 局部变量声明\n  int g = 10;\n\n  cout << g;\n\n  return 0;\n}\n```\n当上面的代码被编译和执行时，它会产生下列结果：\n```C++\n10\n```\n","slug":"C-变量作用域","published":1,"updated":"2019-07-30T01:54:37.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwd0008homjejpnxwjt","content":"<p><img src=\"/2017/08/29/C-变量作用域/C-变量作用域-c93f02eb.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h1 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h1><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h1><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 全局变量声明</span><br><span class=\"line\">int g;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 局部变量声明</span><br><span class=\"line\">  int a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 实际初始化</span><br><span class=\"line\">  a = 10;</span><br><span class=\"line\">  b = 20;</span><br><span class=\"line\">  g = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量声明</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> g = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; g;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2017/08/29/C-变量作用域/C-变量作用域-c93f02eb.png\" alt=\"\"><br></p>","more":"<p></p>\n<h1 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h1><p>在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实际初始化</span></span><br><span class=\"line\">  a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  b = <span class=\"number\">20</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h1><p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 全局变量声明</span><br><span class=\"line\">int g;</span><br><span class=\"line\"></span><br><span class=\"line\">int main ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 局部变量声明</span><br><span class=\"line\">  int a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 实际初始化</span><br><span class=\"line\">  a = 10;</span><br><span class=\"line\">  b = 20;</span><br><span class=\"line\">  g = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">  cout &lt;&lt; g;</span><br><span class=\"line\"></span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局变量声明</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 局部变量声明</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> g = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; g;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure></p>"},{"title":"C++循环语句与条件语句","date":"2017-08-29T08:31:00.000Z","_content":"# 循环语句\n循环类型 | 描述\n-|-\nwhile 循环 | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。\nfor 循环 | 多次执行一个语句序列，简化管理循环变量的代码。\n[do...while 循环](http://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。\n嵌套循环 | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。\n<!--more-->\n## 循环控制语句\n控制语句 | 描述\n- | -\n[break 语句](http://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。\n[continue 语句](http://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，立即重新开始测试条件。\n[goto 语句](http://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。\n\n\n# 判断语句\n语句 | 描述\n-|-\nif 语句 | 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。\nif...else 语句 | 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。\n嵌套 if 语句 | 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。\nswitch 语句 | 一个 switch 语句允许测试一个变量等于多个值时的情况。\n嵌套 switch 语句 | 您可以在一个 switch 语句内使用另一个 switch 语句。\n\n## ? : 运算符\n```C++\nExp1 ? Exp2 : Exp3;\n```\n- Exp1为真，则计算Exp2\n- Exp1为假，则计算Exp3\n","source":"_posts/C-循环语句与条件语句.md","raw":"---\ntitle: C++循环语句与条件语句\ndate: 2017-08-29 16:31:00\ntags: [循环语句,条件语句,语言]\ncategories: C++\n---\n# 循环语句\n循环类型 | 描述\n-|-\nwhile 循环 | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。\nfor 循环 | 多次执行一个语句序列，简化管理循环变量的代码。\n[do...while 循环](http://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。\n嵌套循环 | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。\n<!--more-->\n## 循环控制语句\n控制语句 | 描述\n- | -\n[break 语句](http://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。\n[continue 语句](http://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，立即重新开始测试条件。\n[goto 语句](http://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。\n\n\n# 判断语句\n语句 | 描述\n-|-\nif 语句 | 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。\nif...else 语句 | 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。\n嵌套 if 语句 | 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。\nswitch 语句 | 一个 switch 语句允许测试一个变量等于多个值时的情况。\n嵌套 switch 语句 | 您可以在一个 switch 语句内使用另一个 switch 语句。\n\n## ? : 运算符\n```C++\nExp1 ? Exp2 : Exp3;\n```\n- Exp1为真，则计算Exp2\n- Exp1为假，则计算Exp3\n","slug":"C-循环语句与条件语句","published":1,"updated":"2019-07-30T01:54:37.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwg000bhomjzxq6vaz5","content":"<h1 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>循环类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>while 循环</td>\n<td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>\n</tr>\n<tr>\n<td>for 循环</td>\n<td>多次执行一个语句序列，简化管理循环变量的代码。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-do-while-loop.html\" target=\"_blank\" rel=\"noopener\">do…while 循环</a></td>\n<td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>\n</tr>\n<tr>\n<td>嵌套循环</td>\n<td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h2 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>控制语句</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-break-statement.html\" target=\"_blank\" rel=\"noopener\">break 语句</a></td>\n<td>终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-continue-statement.html\" target=\"_blank\" rel=\"noopener\">continue 语句</a></td>\n<td>引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-goto-statement.html\" target=\"_blank\" rel=\"noopener\">goto 语句</a></td>\n<td>将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>语句</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if 语句</td>\n<td>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</td>\n</tr>\n<tr>\n<td>if…else 语句</td>\n<td>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</td>\n</tr>\n<tr>\n<td>嵌套 if 语句</td>\n<td>您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</td>\n</tr>\n<tr>\n<td>switch 语句</td>\n<td>一个 switch 语句允许测试一个变量等于多个值时的情况。</td>\n</tr>\n<tr>\n<td>嵌套 switch 语句</td>\n<td>您可以在一个 switch 语句内使用另一个 switch 语句。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"? : 运算符\"></a>? : 运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Exp1为真，则计算Exp2</li>\n<li>Exp1为假，则计算Exp3</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>循环类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>while 循环</td>\n<td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>\n</tr>\n<tr>\n<td>for 循环</td>\n<td>多次执行一个语句序列，简化管理循环变量的代码。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-do-while-loop.html\" target=\"_blank\" rel=\"noopener\">do…while 循环</a></td>\n<td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>\n</tr>\n<tr>\n<td>嵌套循环</td>\n<td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h2 id=\"循环控制语句\"><a href=\"#循环控制语句\" class=\"headerlink\" title=\"循环控制语句\"></a>循环控制语句</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>控制语句</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-break-statement.html\" target=\"_blank\" rel=\"noopener\">break 语句</a></td>\n<td>终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-continue-statement.html\" target=\"_blank\" rel=\"noopener\">continue 语句</a></td>\n<td>引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/cplusplus/cpp-goto-statement.html\" target=\"_blank\" rel=\"noopener\">goto 语句</a></td>\n<td>将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>语句</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>if 语句</td>\n<td>一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。</td>\n</tr>\n<tr>\n<td>if…else 语句</td>\n<td>一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。</td>\n</tr>\n<tr>\n<td>嵌套 if 语句</td>\n<td>您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。</td>\n</tr>\n<tr>\n<td>switch 语句</td>\n<td>一个 switch 语句允许测试一个变量等于多个值时的情况。</td>\n</tr>\n<tr>\n<td>嵌套 switch 语句</td>\n<td>您可以在一个 switch 语句内使用另一个 switch 语句。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"? : 运算符\"></a>? : 运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Exp1为真，则计算Exp2</li>\n<li>Exp1为假，则计算Exp3</li>\n</ul>"},{"title":"C++引用","date":"2017-08-29T13:08:43.000Z","_content":"引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n<!--more-->\n\n# C++ 引用 vs 指针\n引用很容易与指针混淆，它们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n# C++ 中创建引用\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n\n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n\n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n\n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n\n   return 0;\n}\n```\n\n- 输出\n```C++\nValue of i : 5\nValue of i reference : 5\nValue of d : 11.7\nValue of d reference : 11.7\n```\n","source":"_posts/C-引用.md","raw":"---\ntitle: C++引用\ndate: 2017-08-29 21:08:43\ntags: [引用,语言]\ncategories: C++\n---\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n<!--more-->\n\n# C++ 引用 vs 指针\n引用很容易与指针混淆，它们之间有三个主要的不同：\n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n# C++ 中创建引用\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n\n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n\n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n\n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n\n   return 0;\n}\n```\n\n- 输出\n```C++\nValue of i : 5\nValue of i reference : 5\nValue of d : 11.7\nValue of d reference : 11.7\n```\n","slug":"C-引用","published":1,"updated":"2019-07-30T01:54:37.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwj000chomjpyt79yb0","content":"<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br><a id=\"more\"></a></p>\n<h1 id=\"C-引用-vs-指针\"><a href=\"#C-引用-vs-指针\" class=\"headerlink\" title=\"C++ 引用 vs 指针\"></a>C++ 引用 vs 指针</h1><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<h1 id=\"C-中创建引用\"><a href=\"#C-中创建引用\" class=\"headerlink\" title=\"C++ 中创建引用\"></a>C++ 中创建引用</h1><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 声明简单的变量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>    i;</span><br><span class=\"line\">   <span class=\"keyword\">double</span> d;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 声明引用变量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>&amp;    r = i;</span><br><span class=\"line\">   <span class=\"keyword\">double</span>&amp; s = d;</span><br><span class=\"line\"></span><br><span class=\"line\">   i = <span class=\"number\">5</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of i : \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of i reference : \"</span> &lt;&lt; r  &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   d = <span class=\"number\">11.7</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of d : \"</span> &lt;&lt; d &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of d reference : \"</span> &lt;&lt; s  &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of i : <span class=\"number\">5</span></span><br><span class=\"line\">Value of i reference : <span class=\"number\">5</span></span><br><span class=\"line\">Value of d : <span class=\"number\">11.7</span></span><br><span class=\"line\">Value of d reference : <span class=\"number\">11.7</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br></p>","more":"<p></p>\n<h1 id=\"C-引用-vs-指针\"><a href=\"#C-引用-vs-指针\" class=\"headerlink\" title=\"C++ 引用 vs 指针\"></a>C++ 引用 vs 指针</h1><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<h1 id=\"C-中创建引用\"><a href=\"#C-中创建引用\" class=\"headerlink\" title=\"C++ 中创建引用\"></a>C++ 中创建引用</h1><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 声明简单的变量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>    i;</span><br><span class=\"line\">   <span class=\"keyword\">double</span> d;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 声明引用变量</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>&amp;    r = i;</span><br><span class=\"line\">   <span class=\"keyword\">double</span>&amp; s = d;</span><br><span class=\"line\"></span><br><span class=\"line\">   i = <span class=\"number\">5</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of i : \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of i reference : \"</span> &lt;&lt; r  &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   d = <span class=\"number\">11.7</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of d : \"</span> &lt;&lt; d &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Value of d reference : \"</span> &lt;&lt; s  &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of i : <span class=\"number\">5</span></span><br><span class=\"line\">Value of i reference : <span class=\"number\">5</span></span><br><span class=\"line\">Value of d : <span class=\"number\">11.7</span></span><br><span class=\"line\">Value of d reference : <span class=\"number\">11.7</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"C++存储类","date":"2017-07-29T07:45:48.000Z","_content":"\n存储类|描述\n-|-\nauto | 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符\nregister | register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。\nstatic | static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\nextern | 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\nmutable | mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\nthread_local | 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。\n\n<!--more-->\n# auto 存储类\n```C++\nauto f=3.14;      //double\nauto s(\"hello\");  //const char*\nauto z = new auto(9); // int*\nauto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n```\n\n# register 存储类\n```C++\nregister int  miles;\n```\n\n# static 存储类\n```C++\n#include <iostream>\n\n// 函数声明\nvoid func(void);\n\nstatic int count = 10; /* 全局变量 */\n\nint main()\n{\n    while(count--)\n    {\n       func();\n    }\n    return 0;\n}\n// 函数定义\nvoid func( void )\n{\n    static int i = 5; // 局部静态变量\n    i++;\n    std::cout << \"变量 i 为 \" << i ;\n    std::cout << \" , 变量 count 为 \" << count << std::endl;\n}\n```\n\n- 输出\n```C++\n变量 i 为 6 , 变量 count 为 9\n变量 i 为 7 , 变量 count 为 8\n变量 i 为 8 , 变量 count 为 7\n变量 i 为 9 , 变量 count 为 6\n变量 i 为 10 , 变量 count 为 5\n变量 i 为 11 , 变量 count 为 4\n变量 i 为 12 , 变量 count 为 3\n变量 i 为 13 , 变量 count 为 2\n变量 i 为 14 , 变量 count 为 1\n变量 i 为 15 , 变量 count 为 0\n```\n\n# extern 存储类\n## 第一个个文件\n```C++\n#include <iostream>\n\nint count ;\nextern void write_extern();\n\nint main()\n{\n   count = 5;\n   write_extern();\n}\n```\n## 第二个文件\n\n```C++\n#include <iostream>\n\nextern int count;\n\nvoid write_extern(void)\n{\n   std::cout << \"Count is \" << count << std::endl;\n}\n```\n# mutable 存储类\n# thread_local 存储类\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\nthread_local 说明符可以与 static 或 extern 合并。\n```C++\nthread_local int x;  // 命名空间下的全局变量\nclass X\n{\n    static thread_local std::string s; // 类的static成员变量\n};\nstatic thread_local std::string X::s;  // X::s 是需要定义的\n\nvoid foo()\n{\n    thread_local std::vector<int> v;  // 本地变量\n}\n```\n","source":"_posts/C-存储类.md","raw":"---\ntitle: C++存储类\ndate: 2017-07-29 15:45:48\ntags: [存储类,语言]\ncategories: C++\n---\n\n存储类|描述\n-|-\nauto | 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符\nregister | register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。\nstatic | static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\nextern | 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\nmutable | mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。\nthread_local | 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。\n\n<!--more-->\n# auto 存储类\n```C++\nauto f=3.14;      //double\nauto s(\"hello\");  //const char*\nauto z = new auto(9); // int*\nauto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型\n```\n\n# register 存储类\n```C++\nregister int  miles;\n```\n\n# static 存储类\n```C++\n#include <iostream>\n\n// 函数声明\nvoid func(void);\n\nstatic int count = 10; /* 全局变量 */\n\nint main()\n{\n    while(count--)\n    {\n       func();\n    }\n    return 0;\n}\n// 函数定义\nvoid func( void )\n{\n    static int i = 5; // 局部静态变量\n    i++;\n    std::cout << \"变量 i 为 \" << i ;\n    std::cout << \" , 变量 count 为 \" << count << std::endl;\n}\n```\n\n- 输出\n```C++\n变量 i 为 6 , 变量 count 为 9\n变量 i 为 7 , 变量 count 为 8\n变量 i 为 8 , 变量 count 为 7\n变量 i 为 9 , 变量 count 为 6\n变量 i 为 10 , 变量 count 为 5\n变量 i 为 11 , 变量 count 为 4\n变量 i 为 12 , 变量 count 为 3\n变量 i 为 13 , 变量 count 为 2\n变量 i 为 14 , 变量 count 为 1\n变量 i 为 15 , 变量 count 为 0\n```\n\n# extern 存储类\n## 第一个个文件\n```C++\n#include <iostream>\n\nint count ;\nextern void write_extern();\n\nint main()\n{\n   count = 5;\n   write_extern();\n}\n```\n## 第二个文件\n\n```C++\n#include <iostream>\n\nextern int count;\n\nvoid write_extern(void)\n{\n   std::cout << \"Count is \" << count << std::endl;\n}\n```\n# mutable 存储类\n# thread_local 存储类\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\nthread_local 说明符可以与 static 或 extern 合并。\n```C++\nthread_local int x;  // 命名空间下的全局变量\nclass X\n{\n    static thread_local std::string s; // 类的static成员变量\n};\nstatic thread_local std::string X::s;  // X::s 是需要定义的\n\nvoid foo()\n{\n    thread_local std::vector<int> v;  // 本地变量\n}\n```\n","slug":"C-存储类","published":1,"updated":"2019-07-30T01:54:37.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwm000ghomjv1auwm32","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>存储类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</td>\n</tr>\n<tr>\n<td>register</td>\n<td>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</td>\n</tr>\n<tr>\n<td>static</td>\n<td>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</td>\n</tr>\n<tr>\n<td>extern</td>\n<td>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</td>\n</tr>\n<tr>\n<td>mutable</td>\n<td>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</td>\n</tr>\n<tr>\n<td>thread_local</td>\n<td>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"auto-存储类\"><a href=\"#auto-存储类\" class=\"headerlink\" title=\"auto 存储类\"></a>auto 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f=<span class=\"number\">3.14</span>;      <span class=\"comment\">//double</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"hello\"</span>)</span></span>;  <span class=\"comment\">//const char*</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> z = <span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(<span class=\"number\">9</span>); <span class=\"comment\">// int*</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> x1 = <span class=\"number\">5</span>, x2 = <span class=\"number\">5.0</span>, x3=<span class=\"string\">'r'</span>;<span class=\"comment\">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"register-存储类\"><a href=\"#register-存储类\" class=\"headerlink\" title=\"register 存储类\"></a>register 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span> <span class=\"keyword\">int</span>  miles;</span><br></pre></td></tr></table></figure>\n<h1 id=\"static-存储类\"><a href=\"#static-存储类\" class=\"headerlink\" title=\"static 存储类\"></a>static 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>; <span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       func();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">5</span>; <span class=\"comment\">// 局部静态变量</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"变量 i 为 \"</span> &lt;&lt; i ;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" , 变量 count 为 \"</span> &lt;&lt; count &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 i 为 <span class=\"number\">6</span> , 变量 count 为 <span class=\"number\">9</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">7</span> , 变量 count 为 <span class=\"number\">8</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">8</span> , 变量 count 为 <span class=\"number\">7</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">9</span> , 变量 count 为 <span class=\"number\">6</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">10</span> , 变量 count 为 <span class=\"number\">5</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">11</span> , 变量 count 为 <span class=\"number\">4</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">12</span> , 变量 count 为 <span class=\"number\">3</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">13</span> , 变量 count 为 <span class=\"number\">2</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">14</span> , 变量 count 为 <span class=\"number\">1</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">15</span> , 变量 count 为 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"extern-存储类\"><a href=\"#extern-存储类\" class=\"headerlink\" title=\"extern 存储类\"></a>extern 存储类</h1><h2 id=\"第一个个文件\"><a href=\"#第一个个文件\" class=\"headerlink\" title=\"第一个个文件\"></a>第一个个文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> count ;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   count = <span class=\"number\">5</span>;</span><br><span class=\"line\">   write_extern();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二个文件\"><a href=\"#第二个文件\" class=\"headerlink\" title=\"第二个文件\"></a>第二个文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Count is \"</span> &lt;&lt; count &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"mutable-存储类\"><a href=\"#mutable-存储类\" class=\"headerlink\" title=\"mutable 存储类\"></a>mutable 存储类</h1><h1 id=\"thread-local-存储类\"><a href=\"#thread-local-存储类\" class=\"headerlink\" title=\"thread_local 存储类\"></a>thread_local 存储类</h1><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">thread_local</span> <span class=\"keyword\">int</span> x;  <span class=\"comment\">// 命名空间下的全局变量</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s; <span class=\"comment\">// 类的static成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> X::s;  <span class=\"comment\">// X::s 是需要定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;  <span class=\"comment\">// 本地变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>存储类</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>auto</td>\n<td>声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</td>\n</tr>\n<tr>\n<td>register</td>\n<td>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</td>\n</tr>\n<tr>\n<td>static</td>\n<td>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。<br>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</td>\n</tr>\n<tr>\n<td>extern</td>\n<td>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。</td>\n</tr>\n<tr>\n<td>mutable</td>\n<td>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</td>\n</tr>\n<tr>\n<td>thread_local</td>\n<td>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"auto-存储类\"><a href=\"#auto-存储类\" class=\"headerlink\" title=\"auto 存储类\"></a>auto 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f=<span class=\"number\">3.14</span>;      <span class=\"comment\">//double</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"hello\"</span>)</span></span>;  <span class=\"comment\">//const char*</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> z = <span class=\"keyword\">new</span> <span class=\"keyword\">auto</span>(<span class=\"number\">9</span>); <span class=\"comment\">// int*</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> x1 = <span class=\"number\">5</span>, x2 = <span class=\"number\">5.0</span>, x3=<span class=\"string\">'r'</span>;<span class=\"comment\">//错误，必须是初始化为同一类型</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"register-存储类\"><a href=\"#register-存储类\" class=\"headerlink\" title=\"register 存储类\"></a>register 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">register</span> <span class=\"keyword\">int</span>  miles;</span><br></pre></td></tr></table></figure>\n<h1 id=\"static-存储类\"><a href=\"#static-存储类\" class=\"headerlink\" title=\"static 存储类\"></a>static 存储类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>; <span class=\"comment\">/* 全局变量 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       func();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">5</span>; <span class=\"comment\">// 局部静态变量</span></span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"变量 i 为 \"</span> &lt;&lt; i ;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" , 变量 count 为 \"</span> &lt;&lt; count &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量 i 为 <span class=\"number\">6</span> , 变量 count 为 <span class=\"number\">9</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">7</span> , 变量 count 为 <span class=\"number\">8</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">8</span> , 变量 count 为 <span class=\"number\">7</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">9</span> , 变量 count 为 <span class=\"number\">6</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">10</span> , 变量 count 为 <span class=\"number\">5</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">11</span> , 变量 count 为 <span class=\"number\">4</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">12</span> , 变量 count 为 <span class=\"number\">3</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">13</span> , 变量 count 为 <span class=\"number\">2</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">14</span> , 变量 count 为 <span class=\"number\">1</span></span><br><span class=\"line\">变量 i 为 <span class=\"number\">15</span> , 变量 count 为 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"extern-存储类\"><a href=\"#extern-存储类\" class=\"headerlink\" title=\"extern 存储类\"></a>extern 存储类</h1><h2 id=\"第一个个文件\"><a href=\"#第一个个文件\" class=\"headerlink\" title=\"第一个个文件\"></a>第一个个文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> count ;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   count = <span class=\"number\">5</span>;</span><br><span class=\"line\">   write_extern();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二个文件\"><a href=\"#第二个文件\" class=\"headerlink\" title=\"第二个文件\"></a>第二个文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write_extern</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Count is \"</span> &lt;&lt; count &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"mutable-存储类\"><a href=\"#mutable-存储类\" class=\"headerlink\" title=\"mutable 存储类\"></a>mutable 存储类</h1><h1 id=\"thread-local-存储类\"><a href=\"#thread-local-存储类\" class=\"headerlink\" title=\"thread_local 存储类\"></a>thread_local 存储类</h1><p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。<br>thread_local 说明符可以与 static 或 extern 合并。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">thread_local</span> <span class=\"keyword\">int</span> x;  <span class=\"comment\">// 命名空间下的全局变量</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s; <span class=\"comment\">// 类的static成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> X::s;  <span class=\"comment\">// X::s 是需要定义的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">thread_local</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;  <span class=\"comment\">// 本地变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"C++数字","date":"2017-08-29T11:09:41.000Z","_content":"\n#  数学运算\n为了利用这些函数，您需要引用数学头文件 <cmath>。\n\n序号 | 函数 & 描述\n-|-\n1 | double cos(double);<br>该函数返回弧度角（double 型）的余弦。\n2 | double sin(double);<br>该函数返回弧度角（double 型）的正弦。\n3 | double tan(double);<br>该函数返回弧度角（double 型）的正切。\n4 | double log(double);<br>该函数返回参数的自然对数。\n5 | double pow(double, double);<br>假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。\n6 | double hypot(double, double);<br>该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。\n7 | double sqrt(double);<br>该函数返回参数的平方根。\n8 | int abs(int);<br>该函数返回整数的绝对值。\n9 | double fabs(double);<br>该函数返回任意一个十进制数的绝对值。\n10 | double floor(double);<br>该函数返回一个小于或等于传入参数的最大整数。\n<!--more-->\n# C++ 随机数\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数\n\n```C++\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nint main ()\n{\n   int i,j;\n\n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n\n   return 0;\n}\n```\n","source":"_posts/C-数字.md","raw":"---\ntitle: C++数字\ndate: 2017-08-29 19:09:41\ntags: [数字,语言]\ncategories: C++\n---\n\n#  数学运算\n为了利用这些函数，您需要引用数学头文件 <cmath>。\n\n序号 | 函数 & 描述\n-|-\n1 | double cos(double);<br>该函数返回弧度角（double 型）的余弦。\n2 | double sin(double);<br>该函数返回弧度角（double 型）的正弦。\n3 | double tan(double);<br>该函数返回弧度角（double 型）的正切。\n4 | double log(double);<br>该函数返回参数的自然对数。\n5 | double pow(double, double);<br>假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。\n6 | double hypot(double, double);<br>该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。\n7 | double sqrt(double);<br>该函数返回参数的平方根。\n8 | int abs(int);<br>该函数返回整数的绝对值。\n9 | double fabs(double);<br>该函数返回任意一个十进制数的绝对值。\n10 | double floor(double);<br>该函数返回一个小于或等于传入参数的最大整数。\n<!--more-->\n# C++ 随机数\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数\n\n```C++\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nint main ()\n{\n   int i,j;\n\n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n\n   return 0;\n}\n```\n","slug":"C-数字","published":1,"updated":"2019-07-30T01:54:37.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwp000jhomj1dxclsu1","content":"<h1 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h1><p>为了利用这些函数，您需要引用数学头文件 <cmath>。</cmath></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>double cos(double);<br>该函数返回弧度角（double 型）的余弦。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>double sin(double);<br>该函数返回弧度角（double 型）的正弦。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>double tan(double);<br>该函数返回弧度角（double 型）的正切。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>double log(double);<br>该函数返回参数的自然对数。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>double pow(double, double);<br>假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>double hypot(double, double);<br>该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>double sqrt(double);<br>该函数返回参数的平方根。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>int abs(int);<br>该函数返回整数的绝对值。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>double fabs(double);<br>该函数返回任意一个十进制数的绝对值。</td>\n</tr>\n<tr>\n<td>10</td>\n<td>double floor(double);<br>该函数返回一个小于或等于传入参数的最大整数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h1><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">   srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 生成 10 个随机数 */</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成实际的随机数</span></span><br><span class=\"line\">      j= rand();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"随机数： \"</span> &lt;&lt; j &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h1><p>为了利用这些函数，您需要引用数学头文件 <cmath>。</cmath></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>函数 &amp; 描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>double cos(double);<br>该函数返回弧度角（double 型）的余弦。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>double sin(double);<br>该函数返回弧度角（double 型）的正弦。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>double tan(double);<br>该函数返回弧度角（double 型）的正切。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>double log(double);<br>该函数返回参数的自然对数。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>double pow(double, double);<br>假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>double hypot(double, double);<br>该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>double sqrt(double);<br>该函数返回参数的平方根。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>int abs(int);<br>该函数返回整数的绝对值。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>double fabs(double);<br>该函数返回任意一个十进制数的绝对值。</td>\n</tr>\n<tr>\n<td>10</td>\n<td>double floor(double);<br>该函数返回一个小于或等于传入参数的最大整数。</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h1><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">   srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/* 生成 10 个随机数 */</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成实际的随机数</span></span><br><span class=\"line\">      j= rand();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"随机数： \"</span> &lt;&lt; j &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++指针","date":"2017-08-29T11:27:32.000Z","_content":"# 概括\n```c++\nint *p    //声明指针变量\nint i      //声明变量\nint temp //声明变量temp\np=&i    //&为取地址符，获取变量i的地址\ntemp = *p   //获取地址p的值\n```\n<!--more-->\n# 指针的声明\n```c++\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar  *ch;    /* 一个字符型的指针 */\nint  *ptr = NULL;   /* 声明空的指针 */\n```\n# 指针的算术运算\n指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：\n```c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t//\n\tint *ptr;\n\tint a;\n\n\tptr = &a;\n\n\t// 输出返回值\n\tcout << \"&a是：\" << &a << endl;\n\tcout << \"ptr：\" << ptr << endl;\n\tcout << \"ptr++：\" << ptr++ << endl;\n\tcout << \"ptr：\" << ptr << endl;\n\tcout << \"++ptr：\" << ++ptr << endl;\n\n\treturn 0;\n}\n```\n在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。\n```C++\n&a是：007FFDB0\nptr：007FFDB0\nptr++：007FFDB0\nptr：007FFDB4\n++ptr：007FFDB8\n```\n\n# 指针数组\n一个数组，数组的数据类型为指针\n## 示例一\n```c++\n#include <stdio.h>\n\nconst int MAX = 3;\n\nint main()\n{\n    int  var[] = { 10, 100, 200 };    //数组\n    int i, *ptr[MAX];                 //指针数组\n\n    for (i = 0; i < MAX; i++)\n    {\n        ptr[i] = &var[i];             /* 将var元素的地址赋值给对应的ptr */\n    }\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of *ptr[%d] = %d\\n\", i, *ptr[i]);     //打印*ptr的值,ptr存储的地址所指向的值\n    }\n\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of var[%d] = %d\\n\", i, var[i]);       //打印var数组的值\n    }\n\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of ptr[%d] = %d\\n\", i, ptr[i]);       //打印ptr的值,ptr存储的地址\n    }\n\n\n    return 0;\n}\n```\n\n- 输出\n```c++\nValue of *ptr[0] = 10\nValue of *ptr[1] = 100\nValue of *ptr[2] = 200\nValue of var[0] = 10\nValue of var[1] = 100\nValue of var[2] = 200\nValue of ptr[0] = 19921128\nValue of ptr[1] = 19921132\nValue of ptr[2] = 19921136\n```\n## 示例二\n```c++\n#include <stdio.h>\n\nconst int MAX = 4;\n\nint main ()\n{\n  char *names[] = {\n                  \"Zara Ali\",\n                  \"Hina Ali\",\n                  \"Nuha Ali\",\n                  \"Sara Ali\",\n  };\n  int i = 0;\n\n  for ( i = 0; i < MAX; i++)\n  {\n      printf(\"Value of names[%d] = %s\\n\", i, names[i] );\n  }\n  return 0;\n}\n```\n\n- 输出\n```c++\nValue of names[0] = Zara Ali\nValue of names[1] = Hina Ali\nValue of names[2] = Nuha Ali\nValue of names[3] = Sara Ali\n```\n# 指针的指针——二级指针\n**二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。**\n![](C-指针/C-指针-16dac5ec.png)\n\n```c++\n#include<iostream>\nusing namespace std;\n\nint a = 10;\nint b = 100;\nint *q;\nvoid func(int *p)\n{\n\tcout << \"func:&p(p的地址)=\" << &p << \",p(p指向的地址)=\" << p << endl;  //note:3\n\tp = &b;\n\tcout << \"func:&p(p的地址)=\" << &p << \",p(p指向的地址)=\" << p << endl;  //note:4\n}\nint main()\n{\n\tcout << \"&a(a的地址)=\" << &a << \",&b(b的地址)=\" << &b << \",&q(q的地址)=\" << &q << endl;  //note:1\n\tq = &a;\n\t//q指向的地址为&a ,q=&a;q 指向地址的取值 即a; &q为指针q的取值\n\tcout << \"*q(指向地址的取值)=\" << *q << \",q(指向的地址)=\" << q << \",&q(q的地址)=\" << &q << endl;  //note:2\n\tfunc(q);  //p与q指向同一个地址，但是p与q为不同的指针，所以p=q但是&p不封于&q\n\tcout << \"*q=\" << *q << \",q=\" << q << \",&q=\" << &q << endl;  //note:5\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n- 输出\n```c++\n&a(a的地址)=00C3F000,&b(b的地址)=00C3F004,&q(q的地址)=00C3F364\n*q(指向地址的取值)=10,q(指向的地址)=00C3F000,&q(q的地址)=00C3F364\nfunc:&p(p的地址)=008FFC80,p(p指向的地址)=00C3F000\nfunc:&p(p的地址)=008FFC80,p(p指向的地址)=00C3F004\n*q=10,q=00C3F000,&q=00C3F364\n```\n# 传递指针给函数\n```c++\n#include <stdio.h>\n\n/* 函数声明 */\ndouble getAverage(int *arr, int size);\n\nint main ()\n{\n  /* 带有 5 个元素的整型数组  */\n  int balance[5] = {1000, 2, 3, 17, 50};\n  double avg;\n\n  /* 传递一个指向数组的指针作为参数 */\n  avg = getAverage( balance, 5 ) ;\n\n  /* 输出返回值  */\n  printf(\"Average value is: %f\\n\", avg );\n\n  return 0;\n}\n\ndouble getAverage(int *arr, int size)\n{\n  int i, sum = 0;\n  double avg;\n\n  for (i = 0; i < size; ++i)\n  {\n    sum += arr[i];\n  }\n\n  avg = (double)sum / size;\n\n  return avg;\n}\n```\n# 从函数返回指针\n函数返回数组\n```c++\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n\n/* 要生成和返回随机数的函数 */\nint * getRandom( )\n{\n  static int  r[10];\n  int i;\n\n  /* 设置种子 */\n  srand( (unsigned)time( NULL ) );\n  for ( i = 0; i < 10; ++i)\n  {\n      r[i] = rand();\n      printf(\"%d\\n\", r[i] );\n  }\n\n  return r;\n}\n\n/* 要调用上面定义函数的主函数 */\nint main ()\n{\n  /* 一个指向整数的指针 */\n  int *p;\n  int i;\n\n  p = getRandom();\n  for ( i = 0; i < 10; i++ )\n  {\n      printf(\"*(p + [%d]) : %d\\n\", i, *(p + i) );\n  }\n\n  return 0;\n}\n```\n- 输出\n```C++\n1523198053\n1187214107\n1108300978\n430494959\n1421301276\n930971084\n123250484\n106932140\n1604461820\n149169022\n*(p + [0]) : 1523198053\n*(p + [1]) : 1187214107\n*(p + [2]) : 1108300978\n*(p + [3]) : 430494959\n*(p + [4]) : 1421301276\n*(p + [5]) : 930971084\n*(p + [6]) : 123250484\n*(p + [7]) : 106932140\n*(p + [8]) : 1604461820\n*(p + [9]) : 149169022\n```\n# 函数指针\n通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。\n```c++\n#include<iostream>\nusing namespace std;\n\n/* 要生成和返回随机数的函数 */\nint *getRandom()\n{\n\tstatic int  r[10];\n\tint i;\n\n\t/* 设置种子 */\n\tsrand((unsigned)time(NULL));\n\tfor (i = 0; i < 10; ++i)\n\t{\n\t\tr[i] = rand();\n\t\tprintf(\"%d\\n\", r[i]);\n\t}\n\n\treturn r;\n}\n\n#include <stdio.h>\n\nint max(int x, int y)\n{\n\treturn x > y ? x : y;      //如果x>y，返回x否则返回y\n}\n\nint main(void)\n{\n\t/* p 是函数指针 */\n\tint(*p)(int, int) = &max; // &可以省略\n\tint a, b, c, d;\n\n\tcout << \"请输入三个数字:\" <<endl;\n\tcin >> a >> b >> c;\n\n\t/* 与直接调用函数等价，d = max(max(a, b), c) */\n\td = p(p(a, b), c);\n\n\tprintf(\"最大的数字是: %d\\n\", d);\n\n\treturn 0;\n}\n```\n# 回调函数\n函数指针作为某个函数的参数，函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。简单讲：回调函数是由别人的函数执行时调用你实现的函数。\n```c++\n#include<iostream>\nusing namespace std;\n\n// 回调函数\nvoid populate_array(int *array, size_t arraySize, int(*getNextValue)(void))\n{\n\tfor (size_t i = 0; i<arraySize; i++)\n\t\tarray[i] = getNextValue();\n}\n\n// 获取随机值\nint getNextRandomValue(void)\n{\n\treturn rand();\n}\n\nint main(void)\n{\n\tint myarray[10];\n\tpopulate_array(myarray, 10, getNextRandomValue);\n\tfor (int i = 0; i < 10; i++) {\n\t\tcout << myarray[i] << endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/C-指针.md","raw":"---\ntitle: C++指针\ndate: 2017-08-29 19:27:32\ntags: [指针,语言]\ncategories: C++\n---\n# 概括\n```c++\nint *p    //声明指针变量\nint i      //声明变量\nint temp //声明变量temp\np=&i    //&为取地址符，获取变量i的地址\ntemp = *p   //获取地址p的值\n```\n<!--more-->\n# 指针的声明\n```c++\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar  *ch;    /* 一个字符型的指针 */\nint  *ptr = NULL;   /* 声明空的指针 */\n```\n# 指针的算术运算\n指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：\n```c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t//\n\tint *ptr;\n\tint a;\n\n\tptr = &a;\n\n\t// 输出返回值\n\tcout << \"&a是：\" << &a << endl;\n\tcout << \"ptr：\" << ptr << endl;\n\tcout << \"ptr++：\" << ptr++ << endl;\n\tcout << \"ptr：\" << ptr << endl;\n\tcout << \"++ptr：\" << ++ptr << endl;\n\n\treturn 0;\n}\n```\n在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。\n```C++\n&a是：007FFDB0\nptr：007FFDB0\nptr++：007FFDB0\nptr：007FFDB4\n++ptr：007FFDB8\n```\n\n# 指针数组\n一个数组，数组的数据类型为指针\n## 示例一\n```c++\n#include <stdio.h>\n\nconst int MAX = 3;\n\nint main()\n{\n    int  var[] = { 10, 100, 200 };    //数组\n    int i, *ptr[MAX];                 //指针数组\n\n    for (i = 0; i < MAX; i++)\n    {\n        ptr[i] = &var[i];             /* 将var元素的地址赋值给对应的ptr */\n    }\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of *ptr[%d] = %d\\n\", i, *ptr[i]);     //打印*ptr的值,ptr存储的地址所指向的值\n    }\n\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of var[%d] = %d\\n\", i, var[i]);       //打印var数组的值\n    }\n\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"Value of ptr[%d] = %d\\n\", i, ptr[i]);       //打印ptr的值,ptr存储的地址\n    }\n\n\n    return 0;\n}\n```\n\n- 输出\n```c++\nValue of *ptr[0] = 10\nValue of *ptr[1] = 100\nValue of *ptr[2] = 200\nValue of var[0] = 10\nValue of var[1] = 100\nValue of var[2] = 200\nValue of ptr[0] = 19921128\nValue of ptr[1] = 19921132\nValue of ptr[2] = 19921136\n```\n## 示例二\n```c++\n#include <stdio.h>\n\nconst int MAX = 4;\n\nint main ()\n{\n  char *names[] = {\n                  \"Zara Ali\",\n                  \"Hina Ali\",\n                  \"Nuha Ali\",\n                  \"Sara Ali\",\n  };\n  int i = 0;\n\n  for ( i = 0; i < MAX; i++)\n  {\n      printf(\"Value of names[%d] = %s\\n\", i, names[i] );\n  }\n  return 0;\n}\n```\n\n- 输出\n```c++\nValue of names[0] = Zara Ali\nValue of names[1] = Hina Ali\nValue of names[2] = Nuha Ali\nValue of names[3] = Sara Ali\n```\n# 指针的指针——二级指针\n**二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。**\n![](C-指针/C-指针-16dac5ec.png)\n\n```c++\n#include<iostream>\nusing namespace std;\n\nint a = 10;\nint b = 100;\nint *q;\nvoid func(int *p)\n{\n\tcout << \"func:&p(p的地址)=\" << &p << \",p(p指向的地址)=\" << p << endl;  //note:3\n\tp = &b;\n\tcout << \"func:&p(p的地址)=\" << &p << \",p(p指向的地址)=\" << p << endl;  //note:4\n}\nint main()\n{\n\tcout << \"&a(a的地址)=\" << &a << \",&b(b的地址)=\" << &b << \",&q(q的地址)=\" << &q << endl;  //note:1\n\tq = &a;\n\t//q指向的地址为&a ,q=&a;q 指向地址的取值 即a; &q为指针q的取值\n\tcout << \"*q(指向地址的取值)=\" << *q << \",q(指向的地址)=\" << q << \",&q(q的地址)=\" << &q << endl;  //note:2\n\tfunc(q);  //p与q指向同一个地址，但是p与q为不同的指针，所以p=q但是&p不封于&q\n\tcout << \"*q=\" << *q << \",q=\" << q << \",&q=\" << &q << endl;  //note:5\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n- 输出\n```c++\n&a(a的地址)=00C3F000,&b(b的地址)=00C3F004,&q(q的地址)=00C3F364\n*q(指向地址的取值)=10,q(指向的地址)=00C3F000,&q(q的地址)=00C3F364\nfunc:&p(p的地址)=008FFC80,p(p指向的地址)=00C3F000\nfunc:&p(p的地址)=008FFC80,p(p指向的地址)=00C3F004\n*q=10,q=00C3F000,&q=00C3F364\n```\n# 传递指针给函数\n```c++\n#include <stdio.h>\n\n/* 函数声明 */\ndouble getAverage(int *arr, int size);\n\nint main ()\n{\n  /* 带有 5 个元素的整型数组  */\n  int balance[5] = {1000, 2, 3, 17, 50};\n  double avg;\n\n  /* 传递一个指向数组的指针作为参数 */\n  avg = getAverage( balance, 5 ) ;\n\n  /* 输出返回值  */\n  printf(\"Average value is: %f\\n\", avg );\n\n  return 0;\n}\n\ndouble getAverage(int *arr, int size)\n{\n  int i, sum = 0;\n  double avg;\n\n  for (i = 0; i < size; ++i)\n  {\n    sum += arr[i];\n  }\n\n  avg = (double)sum / size;\n\n  return avg;\n}\n```\n# 从函数返回指针\n函数返回数组\n```c++\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n\n/* 要生成和返回随机数的函数 */\nint * getRandom( )\n{\n  static int  r[10];\n  int i;\n\n  /* 设置种子 */\n  srand( (unsigned)time( NULL ) );\n  for ( i = 0; i < 10; ++i)\n  {\n      r[i] = rand();\n      printf(\"%d\\n\", r[i] );\n  }\n\n  return r;\n}\n\n/* 要调用上面定义函数的主函数 */\nint main ()\n{\n  /* 一个指向整数的指针 */\n  int *p;\n  int i;\n\n  p = getRandom();\n  for ( i = 0; i < 10; i++ )\n  {\n      printf(\"*(p + [%d]) : %d\\n\", i, *(p + i) );\n  }\n\n  return 0;\n}\n```\n- 输出\n```C++\n1523198053\n1187214107\n1108300978\n430494959\n1421301276\n930971084\n123250484\n106932140\n1604461820\n149169022\n*(p + [0]) : 1523198053\n*(p + [1]) : 1187214107\n*(p + [2]) : 1108300978\n*(p + [3]) : 430494959\n*(p + [4]) : 1421301276\n*(p + [5]) : 930971084\n*(p + [6]) : 123250484\n*(p + [7]) : 106932140\n*(p + [8]) : 1604461820\n*(p + [9]) : 149169022\n```\n# 函数指针\n通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。\n```c++\n#include<iostream>\nusing namespace std;\n\n/* 要生成和返回随机数的函数 */\nint *getRandom()\n{\n\tstatic int  r[10];\n\tint i;\n\n\t/* 设置种子 */\n\tsrand((unsigned)time(NULL));\n\tfor (i = 0; i < 10; ++i)\n\t{\n\t\tr[i] = rand();\n\t\tprintf(\"%d\\n\", r[i]);\n\t}\n\n\treturn r;\n}\n\n#include <stdio.h>\n\nint max(int x, int y)\n{\n\treturn x > y ? x : y;      //如果x>y，返回x否则返回y\n}\n\nint main(void)\n{\n\t/* p 是函数指针 */\n\tint(*p)(int, int) = &max; // &可以省略\n\tint a, b, c, d;\n\n\tcout << \"请输入三个数字:\" <<endl;\n\tcin >> a >> b >> c;\n\n\t/* 与直接调用函数等价，d = max(max(a, b), c) */\n\td = p(p(a, b), c);\n\n\tprintf(\"最大的数字是: %d\\n\", d);\n\n\treturn 0;\n}\n```\n# 回调函数\n函数指针作为某个函数的参数，函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。简单讲：回调函数是由别人的函数执行时调用你实现的函数。\n```c++\n#include<iostream>\nusing namespace std;\n\n// 回调函数\nvoid populate_array(int *array, size_t arraySize, int(*getNextValue)(void))\n{\n\tfor (size_t i = 0; i<arraySize; i++)\n\t\tarray[i] = getNextValue();\n}\n\n// 获取随机值\nint getNextRandomValue(void)\n{\n\treturn rand();\n}\n\nint main(void)\n{\n\tint myarray[10];\n\tpopulate_array(myarray, 10, getNextRandomValue);\n\tfor (int i = 0; i < 10; i++) {\n\t\tcout << myarray[i] << endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"C-指针","published":1,"updated":"2019-07-30T01:54:37.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwr000nhomjkfr10pxw","content":"<h1 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p    <span class=\"comment\">//声明指针变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i      <span class=\"comment\">//声明变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> temp <span class=\"comment\">//声明变量temp</span></span><br><span class=\"line\">p=&amp;i    <span class=\"comment\">//&amp;为取地址符，获取变量i的地址</span></span><br><span class=\"line\">temp = *p   <span class=\"comment\">//获取地址p的值</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"指针的声明\"><a href=\"#指针的声明\" class=\"headerlink\" title=\"指针的声明\"></a>指针的声明</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>    *ip;    <span class=\"comment\">/* 一个整型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> *dp;    <span class=\"comment\">/* 一个 double 型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">float</span>  *fp;    <span class=\"comment\">/* 一个浮点型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>  *ch;    <span class=\"comment\">/* 一个字符型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>  *ptr = <span class=\"literal\">NULL</span>;   <span class=\"comment\">/* 声明空的指针 */</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"指针的算术运算\"><a href=\"#指针的算术运算\" class=\"headerlink\" title=\"指针的算术运算\"></a>指针的算术运算</h1><p>指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、—、+、-。假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">\tptr = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 输出返回值</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"&amp;a是：\"</span> &lt;&lt; &amp;a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr：\"</span> &lt;&lt; ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr++：\"</span> &lt;&lt; ptr++ &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr：\"</span> &lt;&lt; ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"++ptr：\"</span> &lt;&lt; ++ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a是：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr++：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr：<span class=\"number\">007F</span>FDB4</span><br><span class=\"line\">++ptr：<span class=\"number\">007F</span>FDB8</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h1><p>一个数组，数组的数据类型为指针</p>\n<h2 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  var[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">200</span> &#125;;    <span class=\"comment\">//数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, *ptr[MAX];                 <span class=\"comment\">//指针数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ptr[i] = &amp;var[i];             <span class=\"comment\">/* 将var元素的地址赋值给对应的ptr */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of *ptr[%d] = %d\\n\"</span>, i, *ptr[i]);     <span class=\"comment\">//打印*ptr的值,ptr存储的地址所指向的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of var[%d] = %d\\n\"</span>, i, var[i]);       <span class=\"comment\">//打印var数组的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of ptr[%d] = %d\\n\"</span>, i, ptr[i]);       <span class=\"comment\">//打印ptr的值,ptr存储的地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of *ptr[<span class=\"number\">0</span>] = <span class=\"number\">10</span></span><br><span class=\"line\">Value of *ptr[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br><span class=\"line\">Value of *ptr[<span class=\"number\">2</span>] = <span class=\"number\">200</span></span><br><span class=\"line\">Value of var[<span class=\"number\">0</span>] = <span class=\"number\">10</span></span><br><span class=\"line\">Value of var[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br><span class=\"line\">Value of var[<span class=\"number\">2</span>] = <span class=\"number\">200</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">0</span>] = <span class=\"number\">19921128</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">1</span>] = <span class=\"number\">19921132</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">2</span>] = <span class=\"number\">19921136</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"示例二\"><a href=\"#示例二\" class=\"headerlink\" title=\"示例二\"></a>示例二</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *names[] = &#123;</span><br><span class=\"line\">                  <span class=\"string\">\"Zara Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Hina Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Nuha Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Sara Ali\"</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of names[%d] = %s\\n\"</span>, i, names[i] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of names[<span class=\"number\">0</span>] = Zara Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">1</span>] = Hina Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">2</span>] = Nuha Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">3</span>] = Sara Ali</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"指针的指针——二级指针\"><a href=\"#指针的指针——二级指针\" class=\"headerlink\" title=\"指针的指针——二级指针\"></a>指针的指针——二级指针</h1><p><strong>二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。</strong><br><img src=\"/2017/08/29/C-指针/C-指针-16dac5ec.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func:&amp;p(p的地址)=\"</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"string\">\",p(p指向的地址)=\"</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:3</span></span><br><span class=\"line\">\tp = &amp;b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func:&amp;p(p的地址)=\"</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"string\">\",p(p指向的地址)=\"</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"&amp;a(a的地址)=\"</span> &lt;&lt; &amp;a &lt;&lt; <span class=\"string\">\",&amp;b(b的地址)=\"</span> &lt;&lt; &amp;b &lt;&lt; <span class=\"string\">\",&amp;q(q的地址)=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:1</span></span><br><span class=\"line\">\tq = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//q指向的地址为&amp;a ,q=&amp;a;q 指向地址的取值 即a; &amp;q为指针q的取值</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*q(指向地址的取值)=\"</span> &lt;&lt; *q &lt;&lt; <span class=\"string\">\",q(指向的地址)=\"</span> &lt;&lt; q &lt;&lt; <span class=\"string\">\",&amp;q(q的地址)=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:2</span></span><br><span class=\"line\">\tfunc(q);  <span class=\"comment\">//p与q指向同一个地址，但是p与q为不同的指针，所以p=q但是&amp;p不封于&amp;q</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*q=\"</span> &lt;&lt; *q &lt;&lt; <span class=\"string\">\",q=\"</span> &lt;&lt; q &lt;&lt; <span class=\"string\">\",&amp;q=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:5</span></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a(a的地址)=<span class=\"number\">00</span>C3F000,&amp;b(b的地址)=<span class=\"number\">00</span>C3F004,&amp;q(q的地址)=<span class=\"number\">00</span>C3F364</span><br><span class=\"line\">*q(指向地址的取值)=<span class=\"number\">10</span>,q(指向的地址)=<span class=\"number\">00</span>C3F000,&amp;q(q的地址)=<span class=\"number\">00</span>C3F364</span><br><span class=\"line\">func:&amp;p(p的地址)=<span class=\"number\">008F</span>FC80,p(p指向的地址)=<span class=\"number\">00</span>C3F000</span><br><span class=\"line\">func:&amp;p(p的地址)=<span class=\"number\">008F</span>FC80,p(p指向的地址)=<span class=\"number\">00</span>C3F004</span><br><span class=\"line\">*q=<span class=\"number\">10</span>,q=<span class=\"number\">00</span>C3F000,&amp;q=<span class=\"number\">00</span>C3F364</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"传递指针给函数\"><a href=\"#传递指针给函数\" class=\"headerlink\" title=\"传递指针给函数\"></a>传递指针给函数</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getAverage</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 带有 5 个元素的整型数组  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">17</span>, <span class=\"number\">50</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> avg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class=\"line\">  avg = getAverage( balance, <span class=\"number\">5</span> ) ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 输出返回值  */</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Average value is: %f\\n\"</span>, avg );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getAverage</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> avg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  avg = (<span class=\"keyword\">double</span>)sum / size;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> avg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"从函数返回指针\"><a href=\"#从函数返回指针\" class=\"headerlink\" title=\"从函数返回指针\"></a>从函数返回指针</h1><p>函数返回数组<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要生成和返回随机数的函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">getRandom</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 设置种子 */</span></span><br><span class=\"line\">  srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      r[i] = rand();</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r[i] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要调用上面定义函数的主函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 一个指向整数的指针 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  p = getRandom();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"*(p + [%d]) : %d\\n\"</span>, i, *(p + i) );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1523198053</span></span><br><span class=\"line\"><span class=\"number\">1187214107</span></span><br><span class=\"line\"><span class=\"number\">1108300978</span></span><br><span class=\"line\"><span class=\"number\">430494959</span></span><br><span class=\"line\"><span class=\"number\">1421301276</span></span><br><span class=\"line\"><span class=\"number\">930971084</span></span><br><span class=\"line\"><span class=\"number\">123250484</span></span><br><span class=\"line\"><span class=\"number\">106932140</span></span><br><span class=\"line\"><span class=\"number\">1604461820</span></span><br><span class=\"line\"><span class=\"number\">149169022</span></span><br><span class=\"line\">*(p + [<span class=\"number\">0</span>]) : <span class=\"number\">1523198053</span></span><br><span class=\"line\">*(p + [<span class=\"number\">1</span>]) : <span class=\"number\">1187214107</span></span><br><span class=\"line\">*(p + [<span class=\"number\">2</span>]) : <span class=\"number\">1108300978</span></span><br><span class=\"line\">*(p + [<span class=\"number\">3</span>]) : <span class=\"number\">430494959</span></span><br><span class=\"line\">*(p + [<span class=\"number\">4</span>]) : <span class=\"number\">1421301276</span></span><br><span class=\"line\">*(p + [<span class=\"number\">5</span>]) : <span class=\"number\">930971084</span></span><br><span class=\"line\">*(p + [<span class=\"number\">6</span>]) : <span class=\"number\">123250484</span></span><br><span class=\"line\">*(p + [<span class=\"number\">7</span>]) : <span class=\"number\">106932140</span></span><br><span class=\"line\">*(p + [<span class=\"number\">8</span>]) : <span class=\"number\">1604461820</span></span><br><span class=\"line\">*(p + [<span class=\"number\">9</span>]) : <span class=\"number\">149169022</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要生成和返回随机数的函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">getRandom</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 设置种子 */</span></span><br><span class=\"line\">\tsrand((<span class=\"keyword\">unsigned</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tr[i] = rand();</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x &gt; y ? x : y;      <span class=\"comment\">//如果x&gt;y，返回x否则返回y</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>(*p)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a, b, c, d;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入三个数字:\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">\td = p(p(a, b), c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"最大的数字是: %d\\n\"</span>, d);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h1><p>函数指针作为某个函数的参数，函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。简单讲：回调函数是由别人的函数执行时调用你实现的函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回调函数</span></span><br><span class=\"line\">void populate_array(int *array, size_t arraySize, int(*getNextValue)(void))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;arraySize; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">array</span>[i] = getNextValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取随机值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNextRandomValue</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rand();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> myarray[<span class=\"number\">10</span>];</span><br><span class=\"line\">\tpopulate_array(myarray, <span class=\"number\">10</span>, getNextRandomValue);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; myarray[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p    <span class=\"comment\">//声明指针变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i      <span class=\"comment\">//声明变量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> temp <span class=\"comment\">//声明变量temp</span></span><br><span class=\"line\">p=&amp;i    <span class=\"comment\">//&amp;为取地址符，获取变量i的地址</span></span><br><span class=\"line\">temp = *p   <span class=\"comment\">//获取地址p的值</span></span><br></pre></td></tr></table></figure>","more":"<h1 id=\"指针的声明\"><a href=\"#指针的声明\" class=\"headerlink\" title=\"指针的声明\"></a>指针的声明</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>    *ip;    <span class=\"comment\">/* 一个整型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> *dp;    <span class=\"comment\">/* 一个 double 型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">float</span>  *fp;    <span class=\"comment\">/* 一个浮点型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>  *ch;    <span class=\"comment\">/* 一个字符型的指针 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>  *ptr = <span class=\"literal\">NULL</span>;   <span class=\"comment\">/* 声明空的指针 */</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"指针的算术运算\"><a href=\"#指针的算术运算\" class=\"headerlink\" title=\"指针的算术运算\"></a>指针的算术运算</h1><p>指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、—、+、-。假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> *ptr;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">\tptr = &amp;a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 输出返回值</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"&amp;a是：\"</span> &lt;&lt; &amp;a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr：\"</span> &lt;&lt; ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr++：\"</span> &lt;&lt; ptr++ &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ptr：\"</span> &lt;&lt; ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"++ptr：\"</span> &lt;&lt; ++ptr &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a是：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr++：<span class=\"number\">007F</span>FDB0</span><br><span class=\"line\">ptr：<span class=\"number\">007F</span>FDB4</span><br><span class=\"line\">++ptr：<span class=\"number\">007F</span>FDB8</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h1><p>一个数组，数组的数据类型为指针</p>\n<h2 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>  var[] = &#123; <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">200</span> &#125;;    <span class=\"comment\">//数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, *ptr[MAX];                 <span class=\"comment\">//指针数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ptr[i] = &amp;var[i];             <span class=\"comment\">/* 将var元素的地址赋值给对应的ptr */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of *ptr[%d] = %d\\n\"</span>, i, *ptr[i]);     <span class=\"comment\">//打印*ptr的值,ptr存储的地址所指向的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of var[%d] = %d\\n\"</span>, i, var[i]);       <span class=\"comment\">//打印var数组的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of ptr[%d] = %d\\n\"</span>, i, ptr[i]);       <span class=\"comment\">//打印ptr的值,ptr存储的地址</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of *ptr[<span class=\"number\">0</span>] = <span class=\"number\">10</span></span><br><span class=\"line\">Value of *ptr[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br><span class=\"line\">Value of *ptr[<span class=\"number\">2</span>] = <span class=\"number\">200</span></span><br><span class=\"line\">Value of var[<span class=\"number\">0</span>] = <span class=\"number\">10</span></span><br><span class=\"line\">Value of var[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br><span class=\"line\">Value of var[<span class=\"number\">2</span>] = <span class=\"number\">200</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">0</span>] = <span class=\"number\">19921128</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">1</span>] = <span class=\"number\">19921132</span></span><br><span class=\"line\">Value of ptr[<span class=\"number\">2</span>] = <span class=\"number\">19921136</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"示例二\"><a href=\"#示例二\" class=\"headerlink\" title=\"示例二\"></a>示例二</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *names[] = &#123;</span><br><span class=\"line\">                  <span class=\"string\">\"Zara Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Hina Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Nuha Ali\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"Sara Ali\"</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; MAX; i++)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Value of names[%d] = %s\\n\"</span>, i, names[i] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of names[<span class=\"number\">0</span>] = Zara Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">1</span>] = Hina Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">2</span>] = Nuha Ali</span><br><span class=\"line\">Value of names[<span class=\"number\">3</span>] = Sara Ali</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"指针的指针——二级指针\"><a href=\"#指针的指针——二级指针\" class=\"headerlink\" title=\"指针的指针——二级指针\"></a>指针的指针——二级指针</h1><p><strong>二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。</strong><br><img src=\"/2017/08/29/C-指针/C-指针-16dac5ec.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func:&amp;p(p的地址)=\"</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"string\">\",p(p指向的地址)=\"</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:3</span></span><br><span class=\"line\">\tp = &amp;b;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"func:&amp;p(p的地址)=\"</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"string\">\",p(p指向的地址)=\"</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"&amp;a(a的地址)=\"</span> &lt;&lt; &amp;a &lt;&lt; <span class=\"string\">\",&amp;b(b的地址)=\"</span> &lt;&lt; &amp;b &lt;&lt; <span class=\"string\">\",&amp;q(q的地址)=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:1</span></span><br><span class=\"line\">\tq = &amp;a;</span><br><span class=\"line\">\t<span class=\"comment\">//q指向的地址为&amp;a ,q=&amp;a;q 指向地址的取值 即a; &amp;q为指针q的取值</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*q(指向地址的取值)=\"</span> &lt;&lt; *q &lt;&lt; <span class=\"string\">\",q(指向的地址)=\"</span> &lt;&lt; q &lt;&lt; <span class=\"string\">\",&amp;q(q的地址)=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:2</span></span><br><span class=\"line\">\tfunc(q);  <span class=\"comment\">//p与q指向同一个地址，但是p与q为不同的指针，所以p=q但是&amp;p不封于&amp;q</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*q=\"</span> &lt;&lt; *q &lt;&lt; <span class=\"string\">\",q=\"</span> &lt;&lt; q &lt;&lt; <span class=\"string\">\",&amp;q=\"</span> &lt;&lt; &amp;q &lt;&lt; <span class=\"built_in\">endl</span>;  <span class=\"comment\">//note:5</span></span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a(a的地址)=<span class=\"number\">00</span>C3F000,&amp;b(b的地址)=<span class=\"number\">00</span>C3F004,&amp;q(q的地址)=<span class=\"number\">00</span>C3F364</span><br><span class=\"line\">*q(指向地址的取值)=<span class=\"number\">10</span>,q(指向的地址)=<span class=\"number\">00</span>C3F000,&amp;q(q的地址)=<span class=\"number\">00</span>C3F364</span><br><span class=\"line\">func:&amp;p(p的地址)=<span class=\"number\">008F</span>FC80,p(p指向的地址)=<span class=\"number\">00</span>C3F000</span><br><span class=\"line\">func:&amp;p(p的地址)=<span class=\"number\">008F</span>FC80,p(p指向的地址)=<span class=\"number\">00</span>C3F004</span><br><span class=\"line\">*q=<span class=\"number\">10</span>,q=<span class=\"number\">00</span>C3F000,&amp;q=<span class=\"number\">00</span>C3F364</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"传递指针给函数\"><a href=\"#传递指针给函数\" class=\"headerlink\" title=\"传递指针给函数\"></a>传递指针给函数</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getAverage</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 带有 5 个元素的整型数组  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">17</span>, <span class=\"number\">50</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> avg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 传递一个指向数组的指针作为参数 */</span></span><br><span class=\"line\">  avg = getAverage( balance, <span class=\"number\">5</span> ) ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 输出返回值  */</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Average value is: %f\\n\"</span>, avg );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getAverage</span><span class=\"params\">(<span class=\"keyword\">int</span> *arr, <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> avg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; size; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sum += arr[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  avg = (<span class=\"keyword\">double</span>)sum / size;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> avg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"从函数返回指针\"><a href=\"#从函数返回指针\" class=\"headerlink\" title=\"从函数返回指针\"></a>从函数返回指针</h1><p>函数返回数组<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要生成和返回随机数的函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">getRandom</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 设置种子 */</span></span><br><span class=\"line\">  srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      r[i] = rand();</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r[i] );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要调用上面定义函数的主函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 一个指向整数的指针 */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *p;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  p = getRandom();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"*(p + [%d]) : %d\\n\"</span>, i, *(p + i) );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1523198053</span></span><br><span class=\"line\"><span class=\"number\">1187214107</span></span><br><span class=\"line\"><span class=\"number\">1108300978</span></span><br><span class=\"line\"><span class=\"number\">430494959</span></span><br><span class=\"line\"><span class=\"number\">1421301276</span></span><br><span class=\"line\"><span class=\"number\">930971084</span></span><br><span class=\"line\"><span class=\"number\">123250484</span></span><br><span class=\"line\"><span class=\"number\">106932140</span></span><br><span class=\"line\"><span class=\"number\">1604461820</span></span><br><span class=\"line\"><span class=\"number\">149169022</span></span><br><span class=\"line\">*(p + [<span class=\"number\">0</span>]) : <span class=\"number\">1523198053</span></span><br><span class=\"line\">*(p + [<span class=\"number\">1</span>]) : <span class=\"number\">1187214107</span></span><br><span class=\"line\">*(p + [<span class=\"number\">2</span>]) : <span class=\"number\">1108300978</span></span><br><span class=\"line\">*(p + [<span class=\"number\">3</span>]) : <span class=\"number\">430494959</span></span><br><span class=\"line\">*(p + [<span class=\"number\">4</span>]) : <span class=\"number\">1421301276</span></span><br><span class=\"line\">*(p + [<span class=\"number\">5</span>]) : <span class=\"number\">930971084</span></span><br><span class=\"line\">*(p + [<span class=\"number\">6</span>]) : <span class=\"number\">123250484</span></span><br><span class=\"line\">*(p + [<span class=\"number\">7</span>]) : <span class=\"number\">106932140</span></span><br><span class=\"line\">*(p + [<span class=\"number\">8</span>]) : <span class=\"number\">1604461820</span></span><br><span class=\"line\">*(p + [<span class=\"number\">9</span>]) : <span class=\"number\">149169022</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 要生成和返回随机数的函数 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">getRandom</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 设置种子 */</span></span><br><span class=\"line\">\tsrand((<span class=\"keyword\">unsigned</span>)time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tr[i] = rand();</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, r[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x &gt; y ? x : y;      <span class=\"comment\">//如果x&gt;y，返回x否则返回y</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* p 是函数指针 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span>(*p)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>) = &amp;max; <span class=\"comment\">// &amp;可以省略</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a, b, c, d;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入三个数字:\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class=\"line\">\td = p(p(a, b), c);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"最大的数字是: %d\\n\"</span>, d);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h1><p>函数指针作为某个函数的参数，函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。简单讲：回调函数是由别人的函数执行时调用你实现的函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回调函数</span></span><br><span class=\"line\">void populate_array(int *array, size_t arraySize, int(*getNextValue)(void))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;arraySize; i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">array</span>[i] = getNextValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取随机值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNextRandomValue</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rand();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> myarray[<span class=\"number\">10</span>];</span><br><span class=\"line\">\tpopulate_array(myarray, <span class=\"number\">10</span>, getNextRandomValue);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; myarray[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"C++数据类型","date":"2017-08-29T03:08:06.000Z","_content":"\n# 数据类型\n![](C-数据类型/C-数据类型-271b9c4a.png)\n<!--more-->\n# 初始值\n数据类型 | 初始化默认值\n-|-\nint | 0\nchar | '\\0'\nfloat | 0\ndouble | 0\npointer | NULL\n\n# typedef 声明\n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n```C++\ntypedef int feet;\n```\n\n# 枚举类型\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n```C++\nenum 枚举名{\n     标识符[=整型常数],\n     标识符[=整型常数],\n...\n    标识符[=整型常数]\n} 枚举变量;\n```\n如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。\n\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。\n```C++\nenum color { red, green, blue } c;\nc = blue;\n```\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。\n```C++\nenum color { red, green=5, blue };\n```\n在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。\n\n# C++ 中的左值（Lvalues）和右值（Rvalues）\n\nC++ 中有两种类型的表达式：\n\n- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\n···C++\nint g = 20;\n···\n","source":"_posts/C-数据类型.md","raw":"---\ntitle: C++数据类型\ndate: 2017-08-29 11:08:06\ntags: [数据类型,语言]\ncategories: C++\n---\n\n# 数据类型\n![](C-数据类型/C-数据类型-271b9c4a.png)\n<!--more-->\n# 初始值\n数据类型 | 初始化默认值\n-|-\nint | 0\nchar | '\\0'\nfloat | 0\ndouble | 0\npointer | NULL\n\n# typedef 声明\n例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n```C++\ntypedef int feet;\n```\n\n# 枚举类型\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n```C++\nenum 枚举名{\n     标识符[=整型常数],\n     标识符[=整型常数],\n...\n    标识符[=整型常数]\n} 枚举变量;\n```\n如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。\n\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。\n```C++\nenum color { red, green, blue } c;\nc = blue;\n```\n默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。\n```C++\nenum color { red, green=5, blue };\n```\n在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。\n\n# C++ 中的左值（Lvalues）和右值（Rvalues）\n\nC++ 中有两种类型的表达式：\n\n- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：\n···C++\nint g = 20;\n···\n","slug":"C-数据类型","published":1,"updated":"2019-07-30T01:54:37.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwt000phomjcv5wuwx0","content":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p><img src=\"/2017/08/29/C-数据类型/C-数据类型-271b9c4a.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h1 id=\"初始值\"><a href=\"#初始值\" class=\"headerlink\" title=\"初始值\"></a>初始值</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>初始化默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘\\0’</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h1><p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> feet;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h1><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> 枚举名&#123;</span><br><span class=\"line\">     标识符[=整型常数],</span><br><span class=\"line\">     标识符[=整型常数],</span><br><span class=\"line\">...</span><br><span class=\"line\">    标识符[=整型常数]</span><br><span class=\"line\">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></p>\n<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green, blue &#125; c;</span><br><span class=\"line\">c = blue;</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>\n<h1 id=\"C-中的左值（Lvalues）和右值（Rvalues）\"><a href=\"#C-中的左值（Lvalues）和右值（Rvalues）\" class=\"headerlink\" title=\"C++ 中的左值（Lvalues）和右值（Rvalues）\"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h1><p>C++ 中有两种类型的表达式：</p>\n<ul>\n<li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>\n<li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>\n</ul>\n<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：<br>···C++<br>int g = 20;<br>···</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p><img src=\"/2017/08/29/C-数据类型/C-数据类型-271b9c4a.png\" alt=\"\"><br></p>","more":"<p></p>\n<h1 id=\"初始值\"><a href=\"#初始值\" class=\"headerlink\" title=\"初始值\"></a>初始值</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>初始化默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘\\0’</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>NULL</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h1><p>例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> feet;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h1><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> 枚举名&#123;</span><br><span class=\"line\">     标识符[=整型常数],</span><br><span class=\"line\">     标识符[=整型常数],</span><br><span class=\"line\">...</span><br><span class=\"line\">    标识符[=整型常数]</span><br><span class=\"line\">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></p>\n<p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green, blue &#125; c;</span><br><span class=\"line\">c = blue;</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>\n<h1 id=\"C-中的左值（Lvalues）和右值（Rvalues）\"><a href=\"#C-中的左值（Lvalues）和右值（Rvalues）\" class=\"headerlink\" title=\"C++ 中的左值（Lvalues）和右值（Rvalues）\"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h1><p>C++ 中有两种类型的表达式：</p>\n<ul>\n<li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>\n<li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>\n</ul>\n<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：<br>···C++<br>int g = 20;<br>···</p>"},{"title":"C++数组","date":"2017-08-29T11:10:45.000Z","_content":"# 数组\n\n```C++\ntype arrayName [ arraySize ];\n\ndouble balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n```\n<!--more-->\n\n# 多维数组\n```C++\ntype name[size1][size2]...[sizeN];\n\n//二维数组\nint a[3][4] = {\n {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */\n {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */\n {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */\n};\n```\n\n# 指向数组的指针\n\n数组名是一个指向数组中第一个元素的常量指针。balance 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址：\n```C++\ndouble *p;\ndouble balance[10];\n\np = balance;\n```\n使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。\n\n# 传递数组给函数\n## 方式 1\n形式参数是一个指针：\n```C++\nvoid myFunction(int *param)\n{\n.\n.\n.\n}\n```\n## 方式 2\n形式参数是一个已定义大小的数组：\n```C++\nvoid myFunction(int param[10])\n{\n.\n.\n.\n}\n```\n## 方式 3\n形式参数是一个未定义大小的数组：\n```C++\nvoid myFunction(int param[])\n{\n.\n.\n.\n}\n```\n\n# 从函数返回数组\nC++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。\n\n如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下\n```C++\nint * myFunction()\n{\n.\n.\n.\n}\n```\n\n## 实例\n```C++\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n// 要生成和返回随机数的函数\nint * getRandom( )\n{\n  static int  r[10];\n\n  // 设置种子\n  srand( (unsigned)time( NULL ) );\n  for (int i = 0; i < 10; ++i)\n  {\n    r[i] = rand();\n    cout << r[i] << endl;\n  }\n\n  return r;\n}\n\n// 要调用上面定义函数的主函数\nint main ()\n{\n   // 一个指向整数的指针\n   int *p;\n\n   p = getRandom();\n   for ( int i = 0; i < 10; i++ )\n   {\n       cout << \"*(p + \" << i << \") : \";\n       cout << *(p + i) << endl;\n   }\n\n   return 0;\n}\n```\n","source":"_posts/C-数组.md","raw":"---\ntitle: C++数组\ndate: 2017-08-29 19:10:45\ntags: [变量作用域,语言]\ncategories: C++\n---\n# 数组\n\n```C++\ntype arrayName [ arraySize ];\n\ndouble balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n```\n<!--more-->\n\n# 多维数组\n```C++\ntype name[size1][size2]...[sizeN];\n\n//二维数组\nint a[3][4] = {\n {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */\n {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */\n {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */\n};\n```\n\n# 指向数组的指针\n\n数组名是一个指向数组中第一个元素的常量指针。balance 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址：\n```C++\ndouble *p;\ndouble balance[10];\n\np = balance;\n```\n使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。\n\n# 传递数组给函数\n## 方式 1\n形式参数是一个指针：\n```C++\nvoid myFunction(int *param)\n{\n.\n.\n.\n}\n```\n## 方式 2\n形式参数是一个已定义大小的数组：\n```C++\nvoid myFunction(int param[10])\n{\n.\n.\n.\n}\n```\n## 方式 3\n形式参数是一个未定义大小的数组：\n```C++\nvoid myFunction(int param[])\n{\n.\n.\n.\n}\n```\n\n# 从函数返回数组\nC++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。\n\n如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下\n```C++\nint * myFunction()\n{\n.\n.\n.\n}\n```\n\n## 实例\n```C++\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n// 要生成和返回随机数的函数\nint * getRandom( )\n{\n  static int  r[10];\n\n  // 设置种子\n  srand( (unsigned)time( NULL ) );\n  for (int i = 0; i < 10; ++i)\n  {\n    r[i] = rand();\n    cout << r[i] << endl;\n  }\n\n  return r;\n}\n\n// 要调用上面定义函数的主函数\nint main ()\n{\n   // 一个指向整数的指针\n   int *p;\n\n   p = getRandom();\n   for ( int i = 0; i < 10; i++ )\n   {\n       cout << \"*(p + \" << i << \") : \";\n       cout << *(p + i) << endl;\n   }\n\n   return 0;\n}\n```\n","slug":"C-数组","published":1,"updated":"2019-07-30T01:54:37.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iwy000shomjnvr661uy","content":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName [ arraySize ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">7.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type name[size1][size2]...[sizeN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>][<span class=\"number\">4</span>] = &#123;</span><br><span class=\"line\"> &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125; ,   <span class=\"comment\">/*  初始化索引号为 0 的行 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125; ,   <span class=\"comment\">/*  初始化索引号为 1 的行 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;   <span class=\"comment\">/*  初始化索引号为 2 的行 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"指向数组的指针\"><a href=\"#指向数组的指针\" class=\"headerlink\" title=\"指向数组的指针\"></a>指向数组的指针</h1><p>数组名是一个指向数组中第一个元素的常量指针。balance 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> *p;</span><br><span class=\"line\"><span class=\"keyword\">double</span> balance[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">p = balance;</span><br></pre></td></tr></table></figure></p>\n<p>使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。</p>\n<h1 id=\"传递数组给函数\"><a href=\"#传递数组给函数\" class=\"headerlink\" title=\"传递数组给函数\"></a>传递数组给函数</h1><h2 id=\"方式-1\"><a href=\"#方式-1\" class=\"headerlink\" title=\"方式 1\"></a>方式 1</h2><p>形式参数是一个指针：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> *param)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方式-2\"><a href=\"#方式-2\" class=\"headerlink\" title=\"方式 2\"></a>方式 2</h2><p>形式参数是一个已定义大小的数组：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方式-3\"><a href=\"#方式-3\" class=\"headerlink\" title=\"方式 3\"></a>方式 3</h2><p>形式参数是一个未定义大小的数组：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"从函数返回数组\"><a href=\"#从函数返回数组\" class=\"headerlink\" title=\"从函数返回数组\"></a>从函数返回数组</h1><p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。</p>\n<p>如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要生成和返回随机数的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">getRandom</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">  srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r[i] = rand();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; r[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要调用上面定义函数的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 一个指向整数的指针</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">   p = getRandom();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*(p + \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\") : \"</span>;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; *(p + i) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName [ arraySize ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> balance[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1000.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.4</span>, <span class=\"number\">7.0</span>, <span class=\"number\">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type name[size1][size2]...[sizeN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">3</span>][<span class=\"number\">4</span>] = &#123;</span><br><span class=\"line\"> &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125; ,   <span class=\"comment\">/*  初始化索引号为 0 的行 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125; ,   <span class=\"comment\">/*  初始化索引号为 1 的行 */</span></span><br><span class=\"line\"> &#123;<span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;   <span class=\"comment\">/*  初始化索引号为 2 的行 */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"指向数组的指针\"><a href=\"#指向数组的指针\" class=\"headerlink\" title=\"指向数组的指针\"></a>指向数组的指针</h1><p>数组名是一个指向数组中第一个元素的常量指针。balance 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 p 赋值为 balance 的第一个元素的地址：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> *p;</span><br><span class=\"line\"><span class=\"keyword\">double</span> balance[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">p = balance;</span><br></pre></td></tr></table></figure></p>\n<p>使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。</p>\n<h1 id=\"传递数组给函数\"><a href=\"#传递数组给函数\" class=\"headerlink\" title=\"传递数组给函数\"></a>传递数组给函数</h1><h2 id=\"方式-1\"><a href=\"#方式-1\" class=\"headerlink\" title=\"方式 1\"></a>方式 1</h2><p>形式参数是一个指针：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> *param)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方式-2\"><a href=\"#方式-2\" class=\"headerlink\" title=\"方式 2\"></a>方式 2</h2><p>形式参数是一个已定义大小的数组：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方式-3\"><a href=\"#方式-3\" class=\"headerlink\" title=\"方式 3\"></a>方式 3</h2><p>形式参数是一个未定义大小的数组：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">int</span> param[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"从函数返回数组\"><a href=\"#从函数返回数组\" class=\"headerlink\" title=\"从函数返回数组\"></a>从函数返回数组</h1><p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。</p>\n<p>如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要生成和返回随机数的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> * <span class=\"title\">getRandom</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>  r[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 设置种子</span></span><br><span class=\"line\">  srand( (<span class=\"keyword\">unsigned</span>)time( <span class=\"literal\">NULL</span> ) );</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    r[i] = rand();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; r[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要调用上面定义函数的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 一个指向整数的指针</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">   p = getRandom();</span><br><span class=\"line\">   <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*(p + \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\") : \"</span>;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; *(p + i) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++环境配置","date":"2017-08-29T02:19:20.000Z","_content":"# 使用 Visual Studio (Graphical Interface) 编译\n1、下载及安装 Visual Studio Community 2015。\n2、打开 Visual Studio Community\n3、点击 File -> New -> Project\n<!--more-->\n![](C-环境配置/C-环境配置-eb44ea5a.png)\n\n4、左侧列表选择 Templates -> Visual C++ -> Win32 Console Application，并设置项目名为 MyFirstProgram。\n\n![](C-环境配置/C-环境配置-7d04b421.png)\n\n5、点击 OK。\n6、在以下窗口中点击 Next\n\n![](C-环境配置/C-环境配置-eed71799.png)\n\n7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：\n8、右击文件夹 Source File 并点击 Add --> New Item... :\n\n![](C-环境配置/C-环境配置-3e1777ec.png)\n\n9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：\n\n![](C-环境配置/C-环境配置-66761a16.png)\n\n10、拷贝以下代码到 main.cpp 中：\n```C++\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n    return 0;\n}\n```\n界面如下所示：\n\n![](C-环境配置/C-环境配置-0b256cfe.png)\n\n11、点击菜单上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :\n\n![](C-环境配置/C-环境配置-d8cb92d5.png)\n\n12、完成以上操作后，你可以看到以下输出\n\n![](C-环境配置/C-环境配置-705b6f10.png)\n","source":"_posts/C-环境配置.md","raw":"---\ntitle: C++环境配置\ndate: 2017-08-29 10:19:20\ntags: [环境配置,语言]\ncategories: C++\n---\n# 使用 Visual Studio (Graphical Interface) 编译\n1、下载及安装 Visual Studio Community 2015。\n2、打开 Visual Studio Community\n3、点击 File -> New -> Project\n<!--more-->\n![](C-环境配置/C-环境配置-eb44ea5a.png)\n\n4、左侧列表选择 Templates -> Visual C++ -> Win32 Console Application，并设置项目名为 MyFirstProgram。\n\n![](C-环境配置/C-环境配置-7d04b421.png)\n\n5、点击 OK。\n6、在以下窗口中点击 Next\n\n![](C-环境配置/C-环境配置-eed71799.png)\n\n7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：\n8、右击文件夹 Source File 并点击 Add --> New Item... :\n\n![](C-环境配置/C-环境配置-3e1777ec.png)\n\n9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：\n\n![](C-环境配置/C-环境配置-66761a16.png)\n\n10、拷贝以下代码到 main.cpp 中：\n```C++\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n    return 0;\n}\n```\n界面如下所示：\n\n![](C-环境配置/C-环境配置-0b256cfe.png)\n\n11、点击菜单上的 Debug -> Start Without Debugging (或按下 ctrl + F5) :\n\n![](C-环境配置/C-环境配置-d8cb92d5.png)\n\n12、完成以上操作后，你可以看到以下输出\n\n![](C-环境配置/C-环境配置-705b6f10.png)\n","slug":"C-环境配置","published":1,"updated":"2019-07-30T01:54:37.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ix3000vhomj8vk2j2ps","content":"<h1 id=\"使用-Visual-Studio-Graphical-Interface-编译\"><a href=\"#使用-Visual-Studio-Graphical-Interface-编译\" class=\"headerlink\" title=\"使用 Visual Studio (Graphical Interface) 编译\"></a>使用 Visual Studio (Graphical Interface) 编译</h1><p>1、下载及安装 Visual Studio Community 2015。<br>2、打开 Visual Studio Community<br>3、点击 File -&gt; New -&gt; Project<br><a id=\"more\"></a><br><img src=\"/2017/08/29/C-环境配置/C-环境配置-eb44ea5a.png\" alt=\"\"></p>\n<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-7d04b421.png\" alt=\"\"></p>\n<p>5、点击 OK。<br>6、在以下窗口中点击 Next</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-eed71799.png\" alt=\"\"></p>\n<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：<br>8、右击文件夹 Source File 并点击 Add —&gt; New Item… :</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-3e1777ec.png\" alt=\"\"></p>\n<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-66761a16.png\" alt=\"\"></p>\n<p>10、拷贝以下代码到 main.cpp 中：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello World!\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>界面如下所示：</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-0b256cfe.png\" alt=\"\"></p>\n<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-d8cb92d5.png\" alt=\"\"></p>\n<p>12、完成以上操作后，你可以看到以下输出</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-705b6f10.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用-Visual-Studio-Graphical-Interface-编译\"><a href=\"#使用-Visual-Studio-Graphical-Interface-编译\" class=\"headerlink\" title=\"使用 Visual Studio (Graphical Interface) 编译\"></a>使用 Visual Studio (Graphical Interface) 编译</h1><p>1、下载及安装 Visual Studio Community 2015。<br>2、打开 Visual Studio Community<br>3、点击 File -&gt; New -&gt; Project<br></p>","more":"<br><img src=\"/2017/08/29/C-环境配置/C-环境配置-eb44ea5a.png\" alt=\"\"><p></p>\n<p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-7d04b421.png\" alt=\"\"></p>\n<p>5、点击 OK。<br>6、在以下窗口中点击 Next</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-eed71799.png\" alt=\"\"></p>\n<p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：<br>8、右击文件夹 Source File 并点击 Add —&gt; New Item… :</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-3e1777ec.png\" alt=\"\"></p>\n<p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-66761a16.png\" alt=\"\"></p>\n<p>10、拷贝以下代码到 main.cpp 中：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello World!\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>界面如下所示：</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-0b256cfe.png\" alt=\"\"></p>\n<p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-d8cb92d5.png\" alt=\"\"></p>\n<p>12、完成以上操作后，你可以看到以下输出</p>\n<p><img src=\"/2017/08/29/C-环境配置/C-环境配置-705b6f10.png\" alt=\"\"></p>"},{"title":"C++类和对象","date":"2017-08-29T13:41:12.000Z","_content":"# C++ 类定义\n类由内部成员(属性与方法)组成，属性指变量，方法指行为。\n```C++\n\n#include<iostream>\nusing namespace std;\n\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n//属性\npublic:\n\tdouble length;   // 长度\n\tdouble breadth;  // 宽度\n\tdouble height;   // 高度\n\n\tdouble volume()\n\t{\n\t\treturn height * length * breadth;\n\t}\n\n};\n//方法\nint main()\n{\n\tBox Box1;        // 声明 Box1，类型为 Box\n\tBox Box2;        // 声明 Box2，类型为 Box\n\tdouble volume = 0.0;     // 用于存储体积\n\n\t// box 1 详述\n\tBox1.height = 5.0;\n\tBox1.length = 6.0;\n\tBox1.breadth = 7.0;\n\n\t// box 2 详述\n\tBox2.height = 10.0;\n\tBox2.length = 12.0;\n\tBox2.breadth = 13.0;\n\n\t// box 1 的体积\n\tvolume = Box1.volume();\n\tcout << \"Box1 的体积：\" << volume << endl;\n\n\t// box 2 的体积\n\tvolume = Box2.volume();\n\tcout << \"Box2 的体积：\" << volume << endl;\n\treturn 0;\n}\n```\n\n# C++ 类访问修饰符\n数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员（属性和方法）。\n\n修饰符 | 描述\n-|-\npublic | 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。\nprivate | 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。\nprotected | 保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n\n```C++\nclass Base {\n\n   public:\n\n  // 公有成员\n\n   protected:\n\n  // 受保护成员\n\n   private:\n\n  // 私有成员\n\n};\n```\n\n## 公有（public）成员\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      double length;\n      void setLength( double len );\n      double getLength( void );\n};\n\n// 成员函数定义\ndouble Line::getLength(void)\n{\n    return length ;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\n// 程序的主函数\nint main( )\n{\n   Line line;\n\n   // 设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   // 不使用成员函数设置长度\n   line.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of line : \" << line.length <<endl;\n   return 0;\n}\n```\n## 私有（private）成员\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      double length;\n      void setWidth( double wid );\n      double getWidth( void );\n\n   private:\n      double width;\n};\n\n// 成员函数定义\ndouble Box::getWidth(void)\n{\n    return width ;\n}\n\nvoid Box::setWidth( double wid )\n{\n    width = wid;\n}\n\n// 程序的主函数\nint main()\n{\n   Box box;\n\n   // 不使用成员函数设置长度\n   box.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of box : \" << box.length <<endl;\n\n   // 不使用成员函数设置宽度\n   // box.width = 10.0; // Error: 因为 width 是私有的\n   box.setWidth(10.0);  // 使用成员函数设置宽度\n   cout << \"Width of box : \" << box.getWidth() <<endl;\n\n   return 0;\n}\n```\n## 保护（protected）成员\n\n保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。\n下面的实例与前面的实例类似，在这里 **width 成员可被派生类 smallBox 的任何成员函数访问。**\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\n   protected:\n      double width;\n};\n\nclass SmallBox:Box // SmallBox 是派生类\n{\n   public:\n      void setSmallWidth( double wid );\n      double getSmallWidth( void );\n};\n\n// 子类的成员函数\ndouble SmallBox::getSmallWidth(void)\n{\n    return width ;\n}\n\nvoid SmallBox::setSmallWidth( double wid )\n{\n    width = wid;\n}\n\n// 程序的主函数\nint main( )\n{\n   SmallBox box;\n\n   // 使用成员函数设置宽度\n   box.setSmallWidth(5.0);\n   cout << \"Width of box : \"<< box.getSmallWidth() << endl;\n\n   return 0;\n}\n```\n# 继承的修饰符\n有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。但无论哪种继承方式，上面两点都没有改变\n- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；\n- protected 成员可以被派生类访问。\n\n继承模式 | 描述\n-|-\npublic 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\nprotected 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\nprivate 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n## public 继承\n\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\n\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : public A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中仍是public成员。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;\n  cout << b.a1 << endl;   //正确\n  cout << b.a2 << endl;   //错误，类外不能访问protected成员\n  cout << b.a3 << endl;   //错误，类外不能访问private成员\n  system(\"pause\");\n  return 0;\n}\n```\n\n## protected 继承\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : protected A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a2 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n## private 继承\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : private A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，private成员不能在类外访问。\n  cout << b.a2 << endl;      //错误, private成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n# 构造函数\n类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。\n\n构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      void setLength( double len );\n      double getLength( void );\n      Line();  // 这是构造函数\n\n   private:\n      double length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(void)\n{\n    cout << \"Object is being created\" << endl;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\ndouble Line::getLength( void )\n{\n    return length;\n}\n// 程序的主函数\nint main( )\n{\n   Line line;\n\n   // 设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   return 0;\n}\n```\n\n## 带参数的构造函数\n默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      void setLength( double len );\n      double getLength( void );\n      Line(double len);  // 这是构造函数\n\n   private:\n      double length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line( double len)\n{\n    cout << \"Object is being created, length = \" << len << endl;\n    length = len;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\ndouble Line::getLength( void )\n{\n    return length;\n}\n// 程序的主函数\nint main( )\n{\n   Line line(10.0);\n\n   // 获取默认设置的长度\n   cout << \"Length of line : \" << line.getLength() <<endl;\n   // 再次设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   return 0;\n}\n```\n\n# 类的析构函数\n类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。\n\n析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\npublic:\n\tvoid setLength(double len);\n\tdouble getLength(void);\n\tLine();   // 这是构造函数声明\n\t~Line();  // 这是析构函数声明\n\nprivate:\n\tdouble length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(void)\n{\n\tcout << \"Object is being created\" << endl;\n}\nLine::~Line(void)\n{\n\tcout << \"Object is being deleted\" << endl;\n}\n\nvoid Line::setLength(double len)\n{\n\tlength = len;\n}\n\ndouble Line::getLength(void)\n{\n\treturn length;\n}\n// 程序的主函数\nint main()\n{\n\tLine line;\n\n\t// 设置长度\n\tline.setLength(6.0);\n\tcout << \"Length of line : \" << line.getLength() << endl;\n\n\treturn 0;  //结束后，对象销毁，此时返回析构函数\n}\n```\n\n# C++ 拷贝构造函数\n拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：\n\n- 通过使用另一个同类型的对象来初始化新创建的对象。\n- 复制对象把它作为参数传递给函数。\n- 复制对象，并从函数返回这个对象\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      int getLength( void );\n      Line( int len );             // 简单的构造函数\n      Line( const Line &obj);      // 拷贝构造函数\n      ~Line();                     // 析构函数\n\n   private:\n      int *ptr;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(int len)\n{\n    cout << \"调用构造函数\" << endl;\n    // 为指针分配内存\n    ptr = new int;\n    *ptr = len;\n}\n\nLine::Line(const Line &obj)\n{\n    cout << \"调用拷贝构造函数并为指针 ptr 分配内存\" << endl;\n    ptr = new int;\n    *ptr = *obj.ptr; // 拷贝值\n}\n\nLine::~Line(void)\n{\n    cout << \"释放内存\" << endl;\n    delete ptr;\n}\nint Line::getLength( void )\n{\n    return *ptr;\n}\n\nvoid display(Line obj)\n{\n   cout << \"line 大小 : \" << obj.getLength() <<endl;\n}\n\n// 程序的主函数\nint main( )\n{\n   Line line1(10);\n\n   Line line2 = line1; // 这里也调用了拷贝构造函数\n\n   display(line1);\n   display(line2);\n\n   return 0;\n}\n```\n\n# C++ 友元函数\n类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。\n\n友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。\n如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   double width;\npublic:\n   friend void printWidth( Box box );\n   void setWidth( double wid );\n};\n\n// 成员函数定义\nvoid Box::setWidth( double wid )\n{\n    width = wid;\n}\n\n// 请注意：printWidth() 不是任何类的成员函数\nvoid printWidth( Box box )\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n\n// 程序的主函数\nint main( )\n{\n   Box box;\n\n   // 使用成员函数设置宽度\n   box.setWidth(10.0);\n\n   // 使用友元函数输出宽度\n   printWidth( box );\n\n   return 0;\n}\n```\n# C++内联函数\n调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行\nC++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。\n对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。\n如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\ninline int Max(int x, int y)\n{\n   return (x > y)? x : y;\n}\n\n// 程序的主函数\nint main( )\n{\n\n   cout << \"Max (20,10): \" << Max(20,10) << endl;\n   cout << \"Max (0,200): \" << Max(0,200) << endl;\n   cout << \"Max (100,1010): \" << Max(100,1010) << endl;\n   return 0;\n}\n```\n\n# C++ this 指针\n在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。\n\n友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n      int compare(Box box)\n      {\n         return this->Volume() > box.Volume();\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n\n   if(Box1.compare(Box2))\n   {\n      cout << \"Box2 is smaller than Box1\" <<endl;\n   }\n   else\n   {\n      cout << \"Box2 is equal to or larger than Box1\" <<endl;\n   }\n   return 0;\n}\n```\n\n# C++ 指向类的指针\n一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n   Box *ptrBox;                // Declare pointer to a class.\n\n   // 保存第一个对象的地址\n   ptrBox = &Box1;\n\n   // 现在尝试使用成员访问运算符来访问成员\n   cout << \"Volume of Box1: \" << ptrBox->Volume() << endl;\n\n   // 保存第二个对象的地址\n   ptrBox = &Box2;\n\n   // 现在尝试使用成员访问运算符来访问成员\n   cout << \"Volume of Box2: \" << ptrBox->Volume() << endl;\n\n   return 0;\n}\n```\n\n# C++类的静态成员\n我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。\n\n静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // 每次创建对象时增加 1\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;     // 长度\n      double breadth;    // 宽度\n      double height;     // 高度\n};\n\n// 初始化类 Box 的静态成员\nint Box::objectCount = 0;\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // 声明 box1\n   Box Box2(8.5, 6.0, 2.0);    // 声明 box2\n\n   // 输出对象的总数\n   cout << \"Total objects: \" << Box::objectCount << endl;\n\n   return 0;\n}\n```\n\n- 输出\n```C++\nConstructor called.\nConstructor called.\nTotal objects: 2\n```\n\n## 静态成员函数\n- 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。\n- 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。\n- 静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // 每次创建对象时增加 1\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n      static int getCount()\n      {\n         return objectCount;\n      }\n   private:\n      double length;     // 长度\n      double breadth;    // 宽度\n      double height;     // 高度\n};\n\n// 初始化类 Box 的静态成员\nint Box::objectCount = 0;\n\nint main(void)\n{\n\n   // 在创建对象之前输出对象的总数\n   cout << \"Inital Stage Count: \" << Box::getCount() << endl;\n\n   Box Box1(3.3, 1.2, 1.5);    // 声明 box1\n   Box Box2(8.5, 6.0, 2.0);    // 声明 box2\n\n   // 在创建对象之后输出对象的总数\n   cout << \"Final Stage Count: \" << Box::getCount() << endl;\n\n   return 0;\n}\n```\n- 输出\n```C++\nInital Stage Count: 0\nConstructor called.\nConstructor called.\nFinal Stage Count: 2\n```\n","source":"_posts/C-类和对象.md","raw":"---\ntitle: C++类和对象\ndate: 2017-08-29 21:41:12\ntags: [类和对象,语言]\ncategories: C++\n---\n# C++ 类定义\n类由内部成员(属性与方法)组成，属性指变量，方法指行为。\n```C++\n\n#include<iostream>\nusing namespace std;\n\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n//属性\npublic:\n\tdouble length;   // 长度\n\tdouble breadth;  // 宽度\n\tdouble height;   // 高度\n\n\tdouble volume()\n\t{\n\t\treturn height * length * breadth;\n\t}\n\n};\n//方法\nint main()\n{\n\tBox Box1;        // 声明 Box1，类型为 Box\n\tBox Box2;        // 声明 Box2，类型为 Box\n\tdouble volume = 0.0;     // 用于存储体积\n\n\t// box 1 详述\n\tBox1.height = 5.0;\n\tBox1.length = 6.0;\n\tBox1.breadth = 7.0;\n\n\t// box 2 详述\n\tBox2.height = 10.0;\n\tBox2.length = 12.0;\n\tBox2.breadth = 13.0;\n\n\t// box 1 的体积\n\tvolume = Box1.volume();\n\tcout << \"Box1 的体积：\" << volume << endl;\n\n\t// box 2 的体积\n\tvolume = Box2.volume();\n\tcout << \"Box2 的体积：\" << volume << endl;\n\treturn 0;\n}\n```\n\n# C++ 类访问修饰符\n数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员（属性和方法）。\n\n修饰符 | 描述\n-|-\npublic | 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。\nprivate | 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。\nprotected | 保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n\n```C++\nclass Base {\n\n   public:\n\n  // 公有成员\n\n   protected:\n\n  // 受保护成员\n\n   private:\n\n  // 私有成员\n\n};\n```\n\n## 公有（public）成员\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      double length;\n      void setLength( double len );\n      double getLength( void );\n};\n\n// 成员函数定义\ndouble Line::getLength(void)\n{\n    return length ;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\n// 程序的主函数\nint main( )\n{\n   Line line;\n\n   // 设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   // 不使用成员函数设置长度\n   line.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of line : \" << line.length <<endl;\n   return 0;\n}\n```\n## 私有（private）成员\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      double length;\n      void setWidth( double wid );\n      double getWidth( void );\n\n   private:\n      double width;\n};\n\n// 成员函数定义\ndouble Box::getWidth(void)\n{\n    return width ;\n}\n\nvoid Box::setWidth( double wid )\n{\n    width = wid;\n}\n\n// 程序的主函数\nint main()\n{\n   Box box;\n\n   // 不使用成员函数设置长度\n   box.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of box : \" << box.length <<endl;\n\n   // 不使用成员函数设置宽度\n   // box.width = 10.0; // Error: 因为 width 是私有的\n   box.setWidth(10.0);  // 使用成员函数设置宽度\n   cout << \"Width of box : \" << box.getWidth() <<endl;\n\n   return 0;\n}\n```\n## 保护（protected）成员\n\n保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。\n下面的实例与前面的实例类似，在这里 **width 成员可被派生类 smallBox 的任何成员函数访问。**\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\n   protected:\n      double width;\n};\n\nclass SmallBox:Box // SmallBox 是派生类\n{\n   public:\n      void setSmallWidth( double wid );\n      double getSmallWidth( void );\n};\n\n// 子类的成员函数\ndouble SmallBox::getSmallWidth(void)\n{\n    return width ;\n}\n\nvoid SmallBox::setSmallWidth( double wid )\n{\n    width = wid;\n}\n\n// 程序的主函数\nint main( )\n{\n   SmallBox box;\n\n   // 使用成员函数设置宽度\n   box.setSmallWidth(5.0);\n   cout << \"Width of box : \"<< box.getSmallWidth() << endl;\n\n   return 0;\n}\n```\n# 继承的修饰符\n有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。但无论哪种继承方式，上面两点都没有改变\n- private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；\n- protected 成员可以被派生类访问。\n\n继承模式 | 描述\n-|-\npublic 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\nprotected 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\nprivate 继承 | 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n## public 继承\n\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\n\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : public A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中仍是public成员。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;\n  cout << b.a1 << endl;   //正确\n  cout << b.a2 << endl;   //错误，类外不能访问protected成员\n  cout << b.a3 << endl;   //错误，类外不能访问private成员\n  system(\"pause\");\n  return 0;\n}\n```\n\n## protected 继承\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : protected A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a2 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n## private 继承\n```C++\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : private A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，private成员不能在类外访问。\n  cout << b.a2 << endl;      //错误, private成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n# 构造函数\n类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。\n\n构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      void setLength( double len );\n      double getLength( void );\n      Line();  // 这是构造函数\n\n   private:\n      double length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(void)\n{\n    cout << \"Object is being created\" << endl;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\ndouble Line::getLength( void )\n{\n    return length;\n}\n// 程序的主函数\nint main( )\n{\n   Line line;\n\n   // 设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   return 0;\n}\n```\n\n## 带参数的构造函数\n默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      void setLength( double len );\n      double getLength( void );\n      Line(double len);  // 这是构造函数\n\n   private:\n      double length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line( double len)\n{\n    cout << \"Object is being created, length = \" << len << endl;\n    length = len;\n}\n\nvoid Line::setLength( double len )\n{\n    length = len;\n}\n\ndouble Line::getLength( void )\n{\n    return length;\n}\n// 程序的主函数\nint main( )\n{\n   Line line(10.0);\n\n   // 获取默认设置的长度\n   cout << \"Length of line : \" << line.getLength() <<endl;\n   // 再次设置长度\n   line.setLength(6.0);\n   cout << \"Length of line : \" << line.getLength() <<endl;\n\n   return 0;\n}\n```\n\n# 类的析构函数\n类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。\n\n析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\npublic:\n\tvoid setLength(double len);\n\tdouble getLength(void);\n\tLine();   // 这是构造函数声明\n\t~Line();  // 这是析构函数声明\n\nprivate:\n\tdouble length;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(void)\n{\n\tcout << \"Object is being created\" << endl;\n}\nLine::~Line(void)\n{\n\tcout << \"Object is being deleted\" << endl;\n}\n\nvoid Line::setLength(double len)\n{\n\tlength = len;\n}\n\ndouble Line::getLength(void)\n{\n\treturn length;\n}\n// 程序的主函数\nint main()\n{\n\tLine line;\n\n\t// 设置长度\n\tline.setLength(6.0);\n\tcout << \"Length of line : \" << line.getLength() << endl;\n\n\treturn 0;  //结束后，对象销毁，此时返回析构函数\n}\n```\n\n# C++ 拷贝构造函数\n拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：\n\n- 通过使用另一个同类型的对象来初始化新创建的对象。\n- 复制对象把它作为参数传递给函数。\n- 复制对象，并从函数返回这个对象\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Line\n{\n   public:\n      int getLength( void );\n      Line( int len );             // 简单的构造函数\n      Line( const Line &obj);      // 拷贝构造函数\n      ~Line();                     // 析构函数\n\n   private:\n      int *ptr;\n};\n\n// 成员函数定义，包括构造函数\nLine::Line(int len)\n{\n    cout << \"调用构造函数\" << endl;\n    // 为指针分配内存\n    ptr = new int;\n    *ptr = len;\n}\n\nLine::Line(const Line &obj)\n{\n    cout << \"调用拷贝构造函数并为指针 ptr 分配内存\" << endl;\n    ptr = new int;\n    *ptr = *obj.ptr; // 拷贝值\n}\n\nLine::~Line(void)\n{\n    cout << \"释放内存\" << endl;\n    delete ptr;\n}\nint Line::getLength( void )\n{\n    return *ptr;\n}\n\nvoid display(Line obj)\n{\n   cout << \"line 大小 : \" << obj.getLength() <<endl;\n}\n\n// 程序的主函数\nint main( )\n{\n   Line line1(10);\n\n   Line line2 = line1; // 这里也调用了拷贝构造函数\n\n   display(line1);\n   display(line2);\n\n   return 0;\n}\n```\n\n# C++ 友元函数\n类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。\n\n友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。\n如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   double width;\npublic:\n   friend void printWidth( Box box );\n   void setWidth( double wid );\n};\n\n// 成员函数定义\nvoid Box::setWidth( double wid )\n{\n    width = wid;\n}\n\n// 请注意：printWidth() 不是任何类的成员函数\nvoid printWidth( Box box )\n{\n   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n\n// 程序的主函数\nint main( )\n{\n   Box box;\n\n   // 使用成员函数设置宽度\n   box.setWidth(10.0);\n\n   // 使用友元函数输出宽度\n   printWidth( box );\n\n   return 0;\n}\n```\n# C++内联函数\n调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行\nC++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。\n对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。\n如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\ninline int Max(int x, int y)\n{\n   return (x > y)? x : y;\n}\n\n// 程序的主函数\nint main( )\n{\n\n   cout << \"Max (20,10): \" << Max(20,10) << endl;\n   cout << \"Max (0,200): \" << Max(0,200) << endl;\n   cout << \"Max (100,1010): \" << Max(100,1010) << endl;\n   return 0;\n}\n```\n\n# C++ this 指针\n在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。\n\n友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n      int compare(Box box)\n      {\n         return this->Volume() > box.Volume();\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n\n   if(Box1.compare(Box2))\n   {\n      cout << \"Box2 is smaller than Box1\" <<endl;\n   }\n   else\n   {\n      cout << \"Box2 is equal to or larger than Box1\" <<endl;\n   }\n   return 0;\n}\n```\n\n# C++ 指向类的指针\n一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;     // Length of a box\n      double breadth;    // Breadth of a box\n      double height;     // Height of a box\n};\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // Declare box1\n   Box Box2(8.5, 6.0, 2.0);    // Declare box2\n   Box *ptrBox;                // Declare pointer to a class.\n\n   // 保存第一个对象的地址\n   ptrBox = &Box1;\n\n   // 现在尝试使用成员访问运算符来访问成员\n   cout << \"Volume of Box1: \" << ptrBox->Volume() << endl;\n\n   // 保存第二个对象的地址\n   ptrBox = &Box2;\n\n   // 现在尝试使用成员访问运算符来访问成员\n   cout << \"Volume of Box2: \" << ptrBox->Volume() << endl;\n\n   return 0;\n}\n```\n\n# C++类的静态成员\n我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。\n\n静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // 每次创建对象时增加 1\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n   private:\n      double length;     // 长度\n      double breadth;    // 宽度\n      double height;     // 高度\n};\n\n// 初始化类 Box 的静态成员\nint Box::objectCount = 0;\n\nint main(void)\n{\n   Box Box1(3.3, 1.2, 1.5);    // 声明 box1\n   Box Box2(8.5, 6.0, 2.0);    // 声明 box2\n\n   // 输出对象的总数\n   cout << \"Total objects: \" << Box::objectCount << endl;\n\n   return 0;\n}\n```\n\n- 输出\n```C++\nConstructor called.\nConstructor called.\nTotal objects: 2\n```\n\n## 静态成员函数\n- 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。\n- 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。\n- 静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\n   public:\n      static int objectCount;\n      // 构造函数定义\n      Box(double l=2.0, double b=2.0, double h=2.0)\n      {\n         cout <<\"Constructor called.\" << endl;\n         length = l;\n         breadth = b;\n         height = h;\n         // 每次创建对象时增加 1\n         objectCount++;\n      }\n      double Volume()\n      {\n         return length * breadth * height;\n      }\n      static int getCount()\n      {\n         return objectCount;\n      }\n   private:\n      double length;     // 长度\n      double breadth;    // 宽度\n      double height;     // 高度\n};\n\n// 初始化类 Box 的静态成员\nint Box::objectCount = 0;\n\nint main(void)\n{\n\n   // 在创建对象之前输出对象的总数\n   cout << \"Inital Stage Count: \" << Box::getCount() << endl;\n\n   Box Box1(3.3, 1.2, 1.5);    // 声明 box1\n   Box Box2(8.5, 6.0, 2.0);    // 声明 box2\n\n   // 在创建对象之后输出对象的总数\n   cout << \"Final Stage Count: \" << Box::getCount() << endl;\n\n   return 0;\n}\n```\n- 输出\n```C++\nInital Stage Count: 0\nConstructor called.\nConstructor called.\nFinal Stage Count: 2\n```\n","slug":"C-类和对象","published":1,"updated":"2019-07-30T01:54:38.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ix8000zhomju23h5t6n","content":"<h1 id=\"C-类定义\"><a href=\"#C-类定义\" class=\"headerlink\" title=\"C++ 类定义\"></a>C++ 类定义</h1><p>类由内部成员(属性与方法)组成，属性指变量，方法指行为。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//属性</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> height;   <span class=\"comment\">// 高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> height * length * breadth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBox Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">\tBox Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">\tBox1.height = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">\tBox1.length = <span class=\"number\">6.0</span>;</span><br><span class=\"line\">\tBox1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">\tBox2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">\tBox2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">\tBox2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">\tvolume = Box1.volume();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box1 的体积：\"</span> &lt;&lt; volume &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">\tvolume = Box2.volume();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 的体积：\"</span> &lt;&lt; volume &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-类访问修饰符\"><a href=\"#C-类访问修饰符\" class=\"headerlink\" title=\"C++ 类访问修饰符\"></a>C++ 类访问修饰符</h1><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员（属性和方法）。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 公有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 受保护成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 私有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公有（public）成员\"><a href=\"#公有（public）成员\" class=\"headerlink\" title=\"公有（public）成员\"></a>公有（public）成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   line.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.length &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"私有（private）成员\"><a href=\"#私有（private）成员\" class=\"headerlink\" title=\"私有（private）成员\"></a>私有（private）成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getWidth</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> Box::getWidth(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Box::setWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   box.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of box : \"</span> &lt;&lt; box.length &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置宽度</span></span><br><span class=\"line\">   <span class=\"comment\">// box.width = 10.0; // Error: 因为 width 是私有的</span></span><br><span class=\"line\">   box.setWidth(<span class=\"number\">10.0</span>);  <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span> &lt;&lt; box.getWidth() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"保护（protected）成员\"><a href=\"#保护（protected）成员\" class=\"headerlink\" title=\"保护（protected）成员\"></a>保护（protected）成员</h2><p>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</p>\n<p>在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。<br>下面的实例与前面的实例类似，在这里 <strong>width 成员可被派生类 smallBox 的任何成员函数访问。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallBox</span>:</span>Box <span class=\"comment\">// SmallBox 是派生类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setSmallWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getSmallWidth</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类的成员函数</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> SmallBox::getSmallWidth(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> SmallBox::setSmallWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   SmallBox box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   box.setSmallWidth(<span class=\"number\">5.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span>&lt;&lt; box.getSmallWidth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承的修饰符\"><a href=\"#继承的修饰符\" class=\"headerlink\" title=\"继承的修饰符\"></a>继承的修饰符</h1><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。但无论哪种继承方式，上面两点都没有改变</p>\n<ul>\n<li>private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>\n<li>protected 成员可以被派生类访问。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>继承模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"public-继承\"><a href=\"#public-继承\" class=\"headerlink\" title=\"public 继承\"></a>public 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的public成员，在派生类中仍是public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//错误，类外不能访问protected成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//错误，类外不能访问private成员</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"protected-继承\"><a href=\"#protected-继承\" class=\"headerlink\" title=\"protected 继承\"></a>protected 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">protected</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"private-继承\"><a href=\"#private-继承\" class=\"headerlink\" title=\"private 继承\"></a>private 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">private</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类public成员,在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误, private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>\n<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line();  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"带参数的构造函数\"><a href=\"#带参数的构造函数\" class=\"headerlink\" title=\"带参数的构造函数\"></a>带参数的构造函数</h2><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line(<span class=\"keyword\">double</span> len);  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Line <span class=\"title\">line</span><span class=\"params\">(<span class=\"number\">10.0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 获取默认设置的长度</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 再次设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h1><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>\n<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">(<span class=\"keyword\">double</span> len)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\">\tLine();   <span class=\"comment\">// 这是构造函数声明</span></span><br><span class=\"line\">\t~Line();  <span class=\"comment\">// 这是析构函数声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Line::~Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being deleted\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength(<span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlength = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tLine line;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">\tline.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">//结束后，对象销毁，此时返回析构函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-拷贝构造函数\"><a href=\"#C-拷贝构造函数\" class=\"headerlink\" title=\"C++ 拷贝构造函数\"></a>C++ 拷贝构造函数</h1><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>\n<ul>\n<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>\n<li>复制对象把它作为参数传递给函数。</li>\n<li>复制对象，并从函数返回这个对象</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line( <span class=\"keyword\">int</span> len );             <span class=\"comment\">// 简单的构造函数</span></span><br><span class=\"line\">      Line( <span class=\"keyword\">const</span> Line &amp;obj);      <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">      ~Line();                     <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> *ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"调用构造函数\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 为指针分配内存</span></span><br><span class=\"line\">    ptr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    *ptr = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">const</span> Line &amp;obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"调用拷贝构造函数并为指针 ptr 分配内存\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ptr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    *ptr = *obj.ptr; <span class=\"comment\">// 拷贝值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Line::~Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"释放内存\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Line obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"line 大小 : \"</span> &lt;&lt; obj.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Line <span class=\"title\">line1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   Line line2 = line1; <span class=\"comment\">// 这里也调用了拷贝构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   display(line1);</span><br><span class=\"line\">   display(line2);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-友元函数\"><a href=\"#C-友元函数\" class=\"headerlink\" title=\"C++ 友元函数\"></a>C++ 友元函数</h1><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>\n<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。<br>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">( Box box )</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Box::setWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">( Box box )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span> &lt;&lt; box.width &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   box.setWidth(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用友元函数输出宽度</span></span><br><span class=\"line\">   printWidth( box );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h1><p>调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行<br>C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。<br>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。<br>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (x &gt; y)? x : y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (20,10): \"</span> &lt;&lt; Max(<span class=\"number\">20</span>,<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (0,200): \"</span> &lt;&lt; Max(<span class=\"number\">0</span>,<span class=\"number\">200</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (100,1010): \"</span> &lt;&lt; Max(<span class=\"number\">100</span>,<span class=\"number\">1010</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-this-指针\"><a href=\"#C-this-指针\" class=\"headerlink\" title=\"C++ this 指针\"></a>C++ this 指针</h1><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>\n<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;Volume() &gt; box.Volume();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// Length of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// Breadth of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// Height of a box</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// Declare box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// Declare box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(Box1.compare(Box2))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 is smaller than Box1\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 is equal to or larger than Box1\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-指向类的指针\"><a href=\"#C-指向类的指针\" class=\"headerlink\" title=\"C++ 指向类的指针\"></a>C++ 指向类的指针</h1><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// Length of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// Breadth of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// Height of a box</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// Declare box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// Declare box2</span></span><br><span class=\"line\">   Box *ptrBox;                <span class=\"comment\">// Declare pointer to a class.</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 保存第一个对象的地址</span></span><br><span class=\"line\">   ptrBox = &amp;Box1;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 现在尝试使用成员访问运算符来访问成员</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box1: \"</span> &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 保存第二个对象的地址</span></span><br><span class=\"line\">   ptrBox = &amp;Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 现在尝试使用成员访问运算符来访问成员</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box2: \"</span> &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-类的静态成员\"><a href=\"#C-类的静态成员\" class=\"headerlink\" title=\"C++类的静态成员\"></a>C++类的静态成员</h1><p>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>\n<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCount;</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">         <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">         objectCount++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total objects: \"</span> &lt;&lt; Box::objectCount &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor called.</span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Total objects: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h2><ul>\n<li>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。</li>\n<li>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</li>\n<li>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCount;</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">         <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">         objectCount++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> objectCount;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在创建对象之前输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inital Stage Count: \"</span> &lt;&lt; Box::getCount() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在创建对象之后输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Final Stage Count: \"</span> &lt;&lt; Box::getCount() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inital Stage Count: <span class=\"number\">0</span></span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Final Stage Count: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-类定义\"><a href=\"#C-类定义\" class=\"headerlink\" title=\"C++ 类定义\"></a>C++ 类定义</h1><p>类由内部成员(属性与方法)组成，属性指变量，方法指行为。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//属性</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> length;   <span class=\"comment\">// 长度</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> breadth;  <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> height;   <span class=\"comment\">// 高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> height * length * breadth;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tBox Box1;        <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">\tBox Box2;        <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 用于存储体积</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 1 详述</span></span><br><span class=\"line\">\tBox1.height = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">\tBox1.length = <span class=\"number\">6.0</span>;</span><br><span class=\"line\">\tBox1.breadth = <span class=\"number\">7.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 2 详述</span></span><br><span class=\"line\">\tBox2.height = <span class=\"number\">10.0</span>;</span><br><span class=\"line\">\tBox2.length = <span class=\"number\">12.0</span>;</span><br><span class=\"line\">\tBox2.breadth = <span class=\"number\">13.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 1 的体积</span></span><br><span class=\"line\">\tvolume = Box1.volume();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box1 的体积：\"</span> &lt;&lt; volume &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// box 2 的体积</span></span><br><span class=\"line\">\tvolume = Box2.volume();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 的体积：\"</span> &lt;&lt; volume &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-类访问修饰符\"><a href=\"#C-类访问修饰符\" class=\"headerlink\" title=\"C++ 类访问修饰符\"></a>C++ 类访问修饰符</h1><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员（属性和方法）。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 公有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 受保护成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 私有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公有（public）成员\"><a href=\"#公有（public）成员\" class=\"headerlink\" title=\"公有（public）成员\"></a>公有（public）成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   line.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.length &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"私有（private）成员\"><a href=\"#私有（private）成员\" class=\"headerlink\" title=\"私有（private）成员\"></a>私有（private）成员</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getWidth</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> Box::getWidth(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Box::setWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置长度</span></span><br><span class=\"line\">   box.length = <span class=\"number\">10.0</span>; <span class=\"comment\">// OK: 因为 length 是公有的</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of box : \"</span> &lt;&lt; box.length &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 不使用成员函数设置宽度</span></span><br><span class=\"line\">   <span class=\"comment\">// box.width = 10.0; // Error: 因为 width 是私有的</span></span><br><span class=\"line\">   box.setWidth(<span class=\"number\">10.0</span>);  <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span> &lt;&lt; box.getWidth() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"保护（protected）成员\"><a href=\"#保护（protected）成员\" class=\"headerlink\" title=\"保护（protected）成员\"></a>保护（protected）成员</h2><p>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</p>\n<p>在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。<br>下面的实例与前面的实例类似，在这里 <strong>width 成员可被派生类 smallBox 的任何成员函数访问。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> width;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallBox</span>:</span>Box <span class=\"comment\">// SmallBox 是派生类</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setSmallWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getSmallWidth</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类的成员函数</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> SmallBox::getSmallWidth(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> width ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> SmallBox::setSmallWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   SmallBox box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   box.setSmallWidth(<span class=\"number\">5.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span>&lt;&lt; box.getSmallWidth() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"继承的修饰符\"><a href=\"#继承的修饰符\" class=\"headerlink\" title=\"继承的修饰符\"></a>继承的修饰符</h1><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。但无论哪种继承方式，上面两点都没有改变</p>\n<ul>\n<li>private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>\n<li>protected 成员可以被派生类访问。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>继承模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"public-继承\"><a href=\"#public-继承\" class=\"headerlink\" title=\"public 继承\"></a>public 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的public成员，在派生类中仍是public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//错误，类外不能访问protected成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//错误，类外不能访问private成员</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"protected-继承\"><a href=\"#protected-继承\" class=\"headerlink\" title=\"protected 继承\"></a>protected 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">protected</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，protected成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"private-继承\"><a href=\"#private-继承\" class=\"headerlink\" title=\"private 继承\"></a>private 继承</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  A()&#123;</span><br><span class=\"line\">    a1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">    a3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;   <span class=\"comment\">//正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">private</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  B(<span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    a = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，public成员。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a1 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类public成员,在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a2 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。</span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; a3 &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//错误，基类的private成员不能被派生类访问。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">B <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a &lt;&lt; <span class=\"built_in\">endl</span>;       <span class=\"comment\">//正确。public成员</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a1 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a2 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误, private成员不能在类外访问。</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; b.a3 &lt;&lt; <span class=\"built_in\">endl</span>;      <span class=\"comment\">//错误，private成员不能在类外访问。</span></span><br><span class=\"line\">  system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>\n<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line();  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Line line;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"带参数的构造函数\"><a href=\"#带参数的构造函数\" class=\"headerlink\" title=\"带参数的构造函数\"></a>带参数的构造函数</h2><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line(<span class=\"keyword\">double</span> len);  <span class=\"comment\">// 这是构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line( <span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created, length = \"</span> &lt;&lt; len &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength( <span class=\"keyword\">double</span> len )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    length = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Line <span class=\"title\">line</span><span class=\"params\">(<span class=\"number\">10.0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 获取默认设置的长度</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 再次设置长度</span></span><br><span class=\"line\">   line.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h1><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>\n<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">(<span class=\"keyword\">double</span> len)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getLength</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\">\tLine();   <span class=\"comment\">// 这是构造函数声明</span></span><br><span class=\"line\">\t~Line();  <span class=\"comment\">// 这是析构函数声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being created\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Line::~Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Object is being deleted\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> Line::setLength(<span class=\"keyword\">double</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlength = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> Line::getLength(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tLine line;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置长度</span></span><br><span class=\"line\">\tline.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Length of line : \"</span> &lt;&lt; line.getLength() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">//结束后，对象销毁，此时返回析构函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-拷贝构造函数\"><a href=\"#C-拷贝构造函数\" class=\"headerlink\" title=\"C++ 拷贝构造函数\"></a>C++ 拷贝构造函数</h1><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>\n<ul>\n<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>\n<li>复制对象把它作为参数传递给函数。</li>\n<li>复制对象，并从函数返回这个对象</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>;</span><br><span class=\"line\">      Line( <span class=\"keyword\">int</span> len );             <span class=\"comment\">// 简单的构造函数</span></span><br><span class=\"line\">      Line( <span class=\"keyword\">const</span> Line &amp;obj);      <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">      ~Line();                     <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> *ptr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义，包括构造函数</span></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">int</span> len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"调用构造函数\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 为指针分配内存</span></span><br><span class=\"line\">    ptr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    *ptr = len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Line::Line(<span class=\"keyword\">const</span> Line &amp;obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"调用拷贝构造函数并为指针 ptr 分配内存\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    ptr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    *ptr = *obj.ptr; <span class=\"comment\">// 拷贝值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Line::~Line(<span class=\"keyword\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"释放内存\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Line::getLength( <span class=\"keyword\">void</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Line obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"line 大小 : \"</span> &lt;&lt; obj.getLength() &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Line <span class=\"title\">line1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   Line line2 = line1; <span class=\"comment\">// 这里也调用了拷贝构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">   display(line1);</span><br><span class=\"line\">   display(line2);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-友元函数\"><a href=\"#C-友元函数\" class=\"headerlink\" title=\"C++ 友元函数\"></a>C++ 友元函数</h1><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>\n<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。<br>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">double</span> width;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">( Box box )</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">( <span class=\"keyword\">double</span> wid )</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数定义</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Box::setWidth( <span class=\"keyword\">double</span> wid )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    width = wid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请注意：printWidth() 不是任何类的成员函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printWidth</span><span class=\"params\">( Box box )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Width of box : \"</span> &lt;&lt; box.width &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box box;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用成员函数设置宽度</span></span><br><span class=\"line\">   box.setWidth(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 使用友元函数输出宽度</span></span><br><span class=\"line\">   printWidth( box );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h1><p>调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行<br>C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。<br>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。<br>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">Max</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (x &gt; y)? x : y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (20,10): \"</span> &lt;&lt; Max(<span class=\"number\">20</span>,<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (0,200): \"</span> &lt;&lt; Max(<span class=\"number\">0</span>,<span class=\"number\">200</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Max (100,1010): \"</span> &lt;&lt; Max(<span class=\"number\">100</span>,<span class=\"number\">1010</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"C-this-指针\"><a href=\"#C-this-指针\" class=\"headerlink\" title=\"C++ this 指针\"></a>C++ this 指针</h1><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>\n<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Box box)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;Volume() &gt; box.Volume();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// Length of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// Breadth of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// Height of a box</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// Declare box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// Declare box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(Box1.compare(Box2))</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 is smaller than Box1\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Box2 is equal to or larger than Box1\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-指向类的指针\"><a href=\"#C-指向类的指针\" class=\"headerlink\" title=\"C++ 指向类的指针\"></a>C++ 指向类的指针</h1><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// Length of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// Breadth of a box</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// Height of a box</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// Declare box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// Declare box2</span></span><br><span class=\"line\">   Box *ptrBox;                <span class=\"comment\">// Declare pointer to a class.</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 保存第一个对象的地址</span></span><br><span class=\"line\">   ptrBox = &amp;Box1;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 现在尝试使用成员访问运算符来访问成员</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box1: \"</span> &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 保存第二个对象的地址</span></span><br><span class=\"line\">   ptrBox = &amp;Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 现在尝试使用成员访问运算符来访问成员</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box2: \"</span> &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-类的静态成员\"><a href=\"#C-类的静态成员\" class=\"headerlink\" title=\"C++类的静态成员\"></a>C++类的静态成员</h1><p>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>\n<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCount;</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">         <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">         objectCount++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total objects: \"</span> &lt;&lt; Box::objectCount &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor called.</span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Total objects: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"静态成员函数\"><a href=\"#静态成员函数\" class=\"headerlink\" title=\"静态成员函数\"></a>静态成员函数</h2><ul>\n<li>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。</li>\n<li>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</li>\n<li>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCount;</span><br><span class=\"line\">      <span class=\"comment\">// 构造函数定义</span></span><br><span class=\"line\">      Box(<span class=\"keyword\">double</span> l=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> b=<span class=\"number\">2.0</span>, <span class=\"keyword\">double</span> h=<span class=\"number\">2.0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"Constructor called.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">         length = l;</span><br><span class=\"line\">         breadth = b;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">         <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">         objectCount++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> objectCount;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;     <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;    <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;     <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在创建对象之前输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Inital Stage Count: \"</span> &lt;&lt; Box::getCount() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">   <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 在创建对象之后输出对象的总数</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Final Stage Count: \"</span> &lt;&lt; Box::getCount() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Inital Stage Count: <span class=\"number\">0</span></span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Constructor called.</span><br><span class=\"line\">Final Stage Count: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"C++结构体","date":"2017-08-29T13:28:32.000Z","_content":"# 结构体声明\n```c++\nstruct stu{\n    char *name;  //姓名\n    int num;  //学号\n    int age;  //年龄\n    char group;  //所在学习小组\n    float score;  //成绩\n} stu1, stu2;            //stu1与stu2为结构体变量\n\n//给结构体成员赋值\n    stu1.name = \"Tom\";\n    stu1.num = 12;\n    stu1.age = 18;\n    stu1.group = 'A';\n    stu1.score = 136.5;\n```\n<!--more-->\n# 结构体数组\n```c++\n#include <stdio.h>\n\nstruct{\n\tchar *name;  //姓名\n\tint num;  //学号\n\tint age;  //年龄\n\tchar group;  //所在小组\n\tfloat score;  //成绩\n}class1[] = {\n\t{ \"Li ping\", 5, 18, 'C', 145.0 },\n\t{ \"Zhang ping\", 4, 19, 'A', 130.5 },\n\t{ \"He fang\", 1, 18, 'A', 148.5 },\n\t{ \"Cheng ling\", 2, 17, 'F', 139.0 },\n\t{ \"Wang ming\", 3, 17, 'B', 144.5 }\n};\n\nint main(){\n\tint i, num_140 = 0;\n\tfloat sum = 0;\n\tfor (i = 0; i<5; i++){\n\t\tsum += class1[i].score;\n\t\tif (class1[i].score < 140) num_140++;\n\t}\n\tprintf(\"sum=%.2f\\naverage=%.2f\\nnum_140=%d\\n\", sum, sum / 5, num_140);\n\tfor (i = 0; i<5; i++){\n\t\tcout << \"name:\" << class1[i].name << endl;\n\t}\n\treturn 0;\n}\n```\n- 输出\n```C++\nsum=707.50\naverage=141.50\nnum_140=2\nname:Li ping\nname:Zhang ping\nname:He fang\nname:Cheng ling\nname:Wang ming\n```\n# 结构体枚举数据类型\n```c++\nenum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };   //枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。\n```\n\n# 结构体作为函数参数\n```c++\nstruct Books\n{\n  char  title[50];\n  char  author[50];\n  char  subject[100];\n  int  book_id;\n};\n\nvoid printBook( struct Books book )\n{\n  printf( \"Book title : %s\\n\", book.title);\n  printf( \"Book author : %s\\n\", book.author);\n  printf( \"Book subject : %s\\n\", book.subject);\n  printf( \"Book book_id : %d\\n\", book.book_id);\n}\n```\n# 指向结构的指针\n为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符\n```c++\nstruct Books *struct_pointer;\nstruct_pointer = &Book1;\nstruct_pointer->title;   //为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符\n```\n","source":"_posts/C-结构体.md","raw":"---\ntitle: C++结构体\ndate: 2017-08-29 21:28:32\ntags: [结构体,语言]\ncategories: C++\n---\n# 结构体声明\n```c++\nstruct stu{\n    char *name;  //姓名\n    int num;  //学号\n    int age;  //年龄\n    char group;  //所在学习小组\n    float score;  //成绩\n} stu1, stu2;            //stu1与stu2为结构体变量\n\n//给结构体成员赋值\n    stu1.name = \"Tom\";\n    stu1.num = 12;\n    stu1.age = 18;\n    stu1.group = 'A';\n    stu1.score = 136.5;\n```\n<!--more-->\n# 结构体数组\n```c++\n#include <stdio.h>\n\nstruct{\n\tchar *name;  //姓名\n\tint num;  //学号\n\tint age;  //年龄\n\tchar group;  //所在小组\n\tfloat score;  //成绩\n}class1[] = {\n\t{ \"Li ping\", 5, 18, 'C', 145.0 },\n\t{ \"Zhang ping\", 4, 19, 'A', 130.5 },\n\t{ \"He fang\", 1, 18, 'A', 148.5 },\n\t{ \"Cheng ling\", 2, 17, 'F', 139.0 },\n\t{ \"Wang ming\", 3, 17, 'B', 144.5 }\n};\n\nint main(){\n\tint i, num_140 = 0;\n\tfloat sum = 0;\n\tfor (i = 0; i<5; i++){\n\t\tsum += class1[i].score;\n\t\tif (class1[i].score < 140) num_140++;\n\t}\n\tprintf(\"sum=%.2f\\naverage=%.2f\\nnum_140=%d\\n\", sum, sum / 5, num_140);\n\tfor (i = 0; i<5; i++){\n\t\tcout << \"name:\" << class1[i].name << endl;\n\t}\n\treturn 0;\n}\n```\n- 输出\n```C++\nsum=707.50\naverage=141.50\nnum_140=2\nname:Li ping\nname:Zhang ping\nname:He fang\nname:Cheng ling\nname:Wang ming\n```\n# 结构体枚举数据类型\n```c++\nenum week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };   //枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。\n```\n\n# 结构体作为函数参数\n```c++\nstruct Books\n{\n  char  title[50];\n  char  author[50];\n  char  subject[100];\n  int  book_id;\n};\n\nvoid printBook( struct Books book )\n{\n  printf( \"Book title : %s\\n\", book.title);\n  printf( \"Book author : %s\\n\", book.author);\n  printf( \"Book subject : %s\\n\", book.subject);\n  printf( \"Book book_id : %d\\n\", book.book_id);\n}\n```\n# 指向结构的指针\n为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符\n```c++\nstruct Books *struct_pointer;\nstruct_pointer = &Book1;\nstruct_pointer->title;   //为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符\n```\n","slug":"C-结构体","published":1,"updated":"2019-07-30T01:54:38.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ixd0012homjhi8szbmd","content":"<h1 id=\"结构体声明\"><a href=\"#结构体声明\" class=\"headerlink\" title=\"结构体声明\"></a>结构体声明</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stu</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在学习小组</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125; stu1, stu2;            <span class=\"comment\">//stu1与stu2为结构体变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给结构体成员赋值</span></span><br><span class=\"line\">    stu1.name = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\">    stu1.num = <span class=\"number\">12</span>;</span><br><span class=\"line\">    stu1.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu1.group = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    stu1.score = <span class=\"number\">136.5</span>;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在小组</span></span><br><span class=\"line\">\t<span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125;class1[] = &#123;</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Li ping\"</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"string\">'C'</span>, <span class=\"number\">145.0</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Zhang ping\"</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"string\">'A'</span>, <span class=\"number\">130.5</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"He fang\"</span>, <span class=\"number\">1</span>, <span class=\"number\">18</span>, <span class=\"string\">'A'</span>, <span class=\"number\">148.5</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Cheng ling\"</span>, <span class=\"number\">2</span>, <span class=\"number\">17</span>, <span class=\"string\">'F'</span>, <span class=\"number\">139.0</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Wang ming\"</span>, <span class=\"number\">3</span>, <span class=\"number\">17</span>, <span class=\"string\">'B'</span>, <span class=\"number\">144.5</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, num_140 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t\tsum += class1[i].score;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (class1[i].score &lt; <span class=\"number\">140</span>) num_140++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"sum=%.2f\\naverage=%.2f\\nnum_140=%d\\n\"</span>, sum, sum / <span class=\"number\">5</span>, num_140);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"name:\"</span> &lt;&lt; class1[i].name &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum=<span class=\"number\">707.50</span></span><br><span class=\"line\">average=<span class=\"number\">141.50</span></span><br><span class=\"line\">num_140=<span class=\"number\">2</span></span><br><span class=\"line\">name:Li ping</span><br><span class=\"line\">name:Zhang ping</span><br><span class=\"line\">name:He fang</span><br><span class=\"line\">name:Cheng ling</span><br><span class=\"line\">name:Wang ming</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"结构体枚举数据类型\"><a href=\"#结构体枚举数据类型\" class=\"headerlink\" title=\"结构体枚举数据类型\"></a>结构体枚举数据类型</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> week&#123; Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;   <span class=\"comment\">//枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"结构体作为函数参数\"><a href=\"#结构体作为函数参数\" class=\"headerlink\" title=\"结构体作为函数参数\"></a>结构体作为函数参数</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Books</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span>  book_id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( struct Books book )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book title : %s\\n\"</span>, book.title);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book author : %s\\n\"</span>, book.author);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book subject : %s\\n\"</span>, book.subject);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book book_id : %d\\n\"</span>, book.book_id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"指向结构的指针\"><a href=\"#指向结构的指针\" class=\"headerlink\" title=\"指向结构的指针\"></a>指向结构的指针</h1><p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Books</span> *<span class=\"title\">struct_pointer</span>;</span></span><br><span class=\"line\">struct_pointer = &amp;Book1;</span><br><span class=\"line\">struct_pointer-&gt;title;   <span class=\"comment\">//为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"结构体声明\"><a href=\"#结构体声明\" class=\"headerlink\" title=\"结构体声明\"></a>结构体声明</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stu</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在学习小组</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125; stu1, stu2;            <span class=\"comment\">//stu1与stu2为结构体变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//给结构体成员赋值</span></span><br><span class=\"line\">    stu1.name = <span class=\"string\">\"Tom\"</span>;</span><br><span class=\"line\">    stu1.num = <span class=\"number\">12</span>;</span><br><span class=\"line\">    stu1.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu1.group = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    stu1.score = <span class=\"number\">136.5</span>;</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> num;  <span class=\"comment\">//学号</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age;  <span class=\"comment\">//年龄</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> group;  <span class=\"comment\">//所在小组</span></span><br><span class=\"line\">\t<span class=\"keyword\">float</span> score;  <span class=\"comment\">//成绩</span></span><br><span class=\"line\">&#125;class1[] = &#123;</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Li ping\"</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"string\">'C'</span>, <span class=\"number\">145.0</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Zhang ping\"</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"string\">'A'</span>, <span class=\"number\">130.5</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"He fang\"</span>, <span class=\"number\">1</span>, <span class=\"number\">18</span>, <span class=\"string\">'A'</span>, <span class=\"number\">148.5</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Cheng ling\"</span>, <span class=\"number\">2</span>, <span class=\"number\">17</span>, <span class=\"string\">'F'</span>, <span class=\"number\">139.0</span> &#125;,</span><br><span class=\"line\">\t&#123; <span class=\"string\">\"Wang ming\"</span>, <span class=\"number\">3</span>, <span class=\"number\">17</span>, <span class=\"string\">'B'</span>, <span class=\"number\">144.5</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, num_140 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t\tsum += class1[i].score;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (class1[i].score &lt; <span class=\"number\">140</span>) num_140++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"sum=%.2f\\naverage=%.2f\\nnum_140=%d\\n\"</span>, sum, sum / <span class=\"number\">5</span>, num_140);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"name:\"</span> &lt;&lt; class1[i].name &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum=<span class=\"number\">707.50</span></span><br><span class=\"line\">average=<span class=\"number\">141.50</span></span><br><span class=\"line\">num_140=<span class=\"number\">2</span></span><br><span class=\"line\">name:Li ping</span><br><span class=\"line\">name:Zhang ping</span><br><span class=\"line\">name:He fang</span><br><span class=\"line\">name:Cheng ling</span><br><span class=\"line\">name:Wang ming</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"结构体枚举数据类型\"><a href=\"#结构体枚举数据类型\" class=\"headerlink\" title=\"结构体枚举数据类型\"></a>结构体枚举数据类型</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> week&#123; Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;   <span class=\"comment\">//枚举值默认从 0 开始，往后逐个加 1（递增）；也就是说，week 中的 Mon、Tues ...... Sun 对应的值分别为 0、1 ...... 6。</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"结构体作为函数参数\"><a href=\"#结构体作为函数参数\" class=\"headerlink\" title=\"结构体作为函数参数\"></a>结构体作为函数参数</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Books</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>  title[<span class=\"number\">50</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span>  author[<span class=\"number\">50</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span>  subject[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"keyword\">int</span>  book_id;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printBook</span><span class=\"params\">( struct Books book )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book title : %s\\n\"</span>, book.title);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book author : %s\\n\"</span>, book.author);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book subject : %s\\n\"</span>, book.subject);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>( <span class=\"string\">\"Book book_id : %d\\n\"</span>, book.book_id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"指向结构的指针\"><a href=\"#指向结构的指针\" class=\"headerlink\" title=\"指向结构的指针\"></a>指向结构的指针</h1><p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Books</span> *<span class=\"title\">struct_pointer</span>;</span></span><br><span class=\"line\">struct_pointer = &amp;Book1;</span><br><span class=\"line\">struct_pointer-&gt;title;   <span class=\"comment\">//为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符</span></span><br></pre></td></tr></table></figure></p>"},{"title":"C++继承","date":"2017-08-29T13:41:22.000Z","_content":"面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。\n\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。\n\n<!--more-->\n\n# 父类&子类\n```C++\nclass derived-class: access-specifier base-class\n```\n其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n\n继承模式|描述\n-|-\npublic 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\nprotected 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\nprivate 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n```C++\nusing namespace std;\n\n// 基类\nclass Shape\n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n\n// 派生类\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      {\n         return (width * height);\n      }\n};\n\nint main(void)\n{\n   Rectangle Rect;\n\n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   return 0;\n}\n```\n- 输出\n```C++\nTotal area: 35\n```\n\n# 访问控制和继承\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n访问 | public | protected | private\n-|-|-|-\n同一个类 | yes | yes | yes\n派生类 | yes | yes | no\n外部的类 | yes | no | no\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n# 多继承\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：\n\n```C++\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…\n{\n<派生类类体>\n};\n```\n其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\n// 基类 Shape\nclass Shape\n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n\n// 基类 PaintCost\nclass PaintCost\n{\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }\n};\n\n// 派生类\nclass Rectangle: public Shape, public PaintCost\n{\n   public:\n      int getArea()\n      {\n         return (width * height);\n      }\n};\n\nint main(void)\n{\n   Rectangle Rect;\n   int area;\n\n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   area = Rect.getArea();\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   // 输出总花费\n   cout << \"Total paint cost: $\" << Rect.getCost(area) << endl;\n\n   return 0;\n}\n```\n","source":"_posts/C-继承.md","raw":"---\ntitle: C++继承\ndate: 2017-08-29 21:41:22\ntags: [继承,语言]\ncategories: C++\n---\n面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。\n\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。\n\n<!--more-->\n\n# 父类&子类\n```C++\nclass derived-class: access-specifier base-class\n```\n其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n\n继承模式|描述\n-|-\npublic 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\nprotected 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\nprivate 继承|基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n```C++\nusing namespace std;\n\n// 基类\nclass Shape\n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n\n// 派生类\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      {\n         return (width * height);\n      }\n};\n\nint main(void)\n{\n   Rectangle Rect;\n\n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   return 0;\n}\n```\n- 输出\n```C++\nTotal area: 35\n```\n\n# 访问控制和继承\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n访问 | public | protected | private\n-|-|-|-\n同一个类 | yes | yes | yes\n派生类 | yes | yes | no\n外部的类 | yes | no | no\n\n一个派生类继承了所有的基类方法，但下列情况除外：\n\n- 基类的构造函数、析构函数和拷贝构造函数。\n- 基类的重载运算符。\n- 基类的友元函数。\n\n# 多继承\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：\n\n```C++\nclass <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…\n{\n<派生类类体>\n};\n```\n其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\n// 基类 Shape\nclass Shape\n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n\n// 基类 PaintCost\nclass PaintCost\n{\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }\n};\n\n// 派生类\nclass Rectangle: public Shape, public PaintCost\n{\n   public:\n      int getArea()\n      {\n         return (width * height);\n      }\n};\n\nint main(void)\n{\n   Rectangle Rect;\n   int area;\n\n   Rect.setWidth(5);\n   Rect.setHeight(7);\n\n   area = Rect.getArea();\n\n   // 输出对象的面积\n   cout << \"Total area: \" << Rect.getArea() << endl;\n\n   // 输出总花费\n   cout << \"Total paint cost: $\" << Rect.getCost(area) << endl;\n\n   return 0;\n}\n```\n","slug":"C-继承","published":1,"updated":"2019-07-30T01:54:38.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ixi0016homj37fqr4xn","content":"<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</p>\n<a id=\"more\"></a>\n<h1 id=\"父类-amp-子类\"><a href=\"#父类-amp-子类\" class=\"headerlink\" title=\"父类&amp;子类\"></a>父类&amp;子类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derived</span>-<span class=\"title\">class</span>:</span> access-specifier base-<span class=\"class\"><span class=\"keyword\">class</span></span></span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>继承模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> width;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\"></span><br><span class=\"line\">   Rect.setWidth(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.setHeight(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total area: \"</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: <span class=\"number\">35</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"访问控制和继承\"><a href=\"#访问控制和继承\" class=\"headerlink\" title=\"访问控制和继承\"></a>访问控制和继承</h1><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。<br>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>访问</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同一个类</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>派生类</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>外部的类</td>\n<td>yes</td>\n<td>no</td>\n<td>no</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<h1 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h1><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&lt;派生类类体&gt;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类 Shape</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> width;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类 PaintCost</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaintCost</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"keyword\">int</span> area)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> area * <span class=\"number\">70</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span> <span class=\"keyword\">public</span> Shape, <span class=\"keyword\">public</span> PaintCost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> area;</span><br><span class=\"line\"></span><br><span class=\"line\">   Rect.setWidth(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.setHeight(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   area = Rect.getArea();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total area: \"</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出总花费</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total paint cost: $\"</span> &lt;&lt; Rect.getCost(area) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</p>","more":"<h1 id=\"父类-amp-子类\"><a href=\"#父类-amp-子类\" class=\"headerlink\" title=\"父类&amp;子类\"></a>父类&amp;子类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">derived</span>-<span class=\"title\">class</span>:</span> access-specifier base-<span class=\"class\"><span class=\"keyword\">class</span></span></span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>继承模式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</td>\n</tr>\n<tr>\n<td>protected 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</td>\n</tr>\n<tr>\n<td>private 继承</td>\n<td>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> width;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span> <span class=\"keyword\">public</span> Shape</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\"></span><br><span class=\"line\">   Rect.setWidth(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.setHeight(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total area: \"</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Total area: <span class=\"number\">35</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"访问控制和继承\"><a href=\"#访问控制和继承\" class=\"headerlink\" title=\"访问控制和继承\"></a>访问控制和继承</h1><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。<br>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>访问</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同一个类</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>派生类</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>外部的类</td>\n<td>yes</td>\n<td>no</td>\n<td>no</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul>\n<li>基类的构造函数、析构函数和拷贝构造函数。</li>\n<li>基类的重载运算符。</li>\n<li>基类的友元函数。</li>\n</ul>\n<h1 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h1><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class=\"number\">1</span>&gt;&lt;基类名<span class=\"number\">1</span>&gt;,&lt;继承方式<span class=\"number\">2</span>&gt;&lt;基类名<span class=\"number\">2</span>&gt;,…</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&lt;派生类类体&gt;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类 Shape</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWidth</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         width = w;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         height = h;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> width;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类 PaintCost</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PaintCost</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCost</span><span class=\"params\">(<span class=\"keyword\">int</span> area)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> area * <span class=\"number\">70</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span>:</span> <span class=\"keyword\">public</span> Shape, <span class=\"keyword\">public</span> PaintCost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (width * height);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Rectangle Rect;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> area;</span><br><span class=\"line\"></span><br><span class=\"line\">   Rect.setWidth(<span class=\"number\">5</span>);</span><br><span class=\"line\">   Rect.setHeight(<span class=\"number\">7</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   area = Rect.getArea();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出对象的面积</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total area: \"</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出总花费</span></span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Total paint cost: $\"</span> &lt;&lt; Rect.getCost(area) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++运算符","date":"2017-08-29T08:18:02.000Z","_content":"运算符 | 描述 | 实例\n-|-|-\n+ | 把两个操作数相加 | A + B 将得到 30\n- | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10\n* | 把两个操作数相乘 | A * B 将得到 200\n/ | 分子除以分母 | B / A 将得到 2\n% | 取模运算符，整除后的余数 | B % A 将得到 0\n++ | 自增运算符，整数值增加 1 | A++ 将得到 11\n-- | 自减运算符，整数值减少 1 | A-- 将得到 9\n== | 检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 不为真。\n!= | 检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。\n> | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A > B) 不为真。\n< | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A < B) 为真。\n>= | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。\n<= | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。\n&& | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 | (A && B) 为假。\n&#124;&#124; | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A &#124;&#124; B) 为真。\n! | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。\n& | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100\n&#124; | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 | (A &#124; B) 将得到 61，即为 0011 1101\n^ | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001\n~ | 二进制补码运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。\n<< | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 | A << 2 将得到 240，即为 1111 0000\n>> | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 | A >> 2 将得到 15，即为 0000 1111\n= | 简单的赋值运算符，把右边操作数的值赋给左边操作数 | C = A + B 将把 A + B 的值赋给 C\n+= | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A\n-= | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A\n*= | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A\n/= | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A\n%= | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 | C %= A 相当于 C = C % A\n<<= | 左移且赋值运算符 | C <<= 2 等同于 C = C << 2\n>>= | 右移且赋值运算符 | C >>= 2 等同于 C = C >> 2\n&= | 按位与且赋值运算符 | C &= 2 等同于 C = C & 2\n^= | 按位异或且赋值运算符 | C ^= 2 等同于 C = C ^ 2\n&#124;= | 按位或且赋值运算符 | C &#124;= 2 等同于 C = C &#124; 2\n\n\n<!--more-->\n# 优先级\n类别  | 运算符  | 结合性\n-|-|-\n后缀  | () [] -> . ++ - -   | 从左到右\n一元  | + - ! ~ ++ - - (type)* & sizeof  | 从右到左\n乘除  | * / %  | 从左到右\n加减  | + -  | 从左到右\n移位  | << >>  | 从左到右\n关系  | < <= > >=  | 从左到右\n相等  | == !=  | 从左到右\n位与 AND  | &  | 从左到右\n位异或 XOR  | ^  | 从左到右\n位或 OR  | &#124;  | 从左到右\n逻辑与 AND  | &&  | 从左到右\n逻辑或 OR  | &#124;&#124;  | 从左到右\n条件  | ?:  | 从右到左\n赋值  | = += -= *= /= %=>>= <<= &= ^= &#124;=  | 从右到左\n逗号  | ,  | 从左到右\n","source":"_posts/C-运算符.md","raw":"---\ntitle: C++运算符\ndate: 2017-08-29 16:18:02\ntags: [数据类型,语言]\ncategories: C++\n---\n运算符 | 描述 | 实例\n-|-|-\n+ | 把两个操作数相加 | A + B 将得到 30\n- | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10\n* | 把两个操作数相乘 | A * B 将得到 200\n/ | 分子除以分母 | B / A 将得到 2\n% | 取模运算符，整除后的余数 | B % A 将得到 0\n++ | 自增运算符，整数值增加 1 | A++ 将得到 11\n-- | 自减运算符，整数值减少 1 | A-- 将得到 9\n== | 检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 不为真。\n!= | 检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。\n> | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A > B) 不为真。\n< | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A < B) 为真。\n>= | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。\n<= | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。\n&& | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 | (A && B) 为假。\n&#124;&#124; | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A &#124;&#124; B) 为真。\n! | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。\n& | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100\n&#124; | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 | (A &#124; B) 将得到 61，即为 0011 1101\n^ | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001\n~ | 二进制补码运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。\n<< | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 | A << 2 将得到 240，即为 1111 0000\n>> | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 | A >> 2 将得到 15，即为 0000 1111\n= | 简单的赋值运算符，把右边操作数的值赋给左边操作数 | C = A + B 将把 A + B 的值赋给 C\n+= | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A\n-= | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A\n*= | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A\n/= | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A\n%= | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 | C %= A 相当于 C = C % A\n<<= | 左移且赋值运算符 | C <<= 2 等同于 C = C << 2\n>>= | 右移且赋值运算符 | C >>= 2 等同于 C = C >> 2\n&= | 按位与且赋值运算符 | C &= 2 等同于 C = C & 2\n^= | 按位异或且赋值运算符 | C ^= 2 等同于 C = C ^ 2\n&#124;= | 按位或且赋值运算符 | C &#124;= 2 等同于 C = C &#124; 2\n\n\n<!--more-->\n# 优先级\n类别  | 运算符  | 结合性\n-|-|-\n后缀  | () [] -> . ++ - -   | 从左到右\n一元  | + - ! ~ ++ - - (type)* & sizeof  | 从右到左\n乘除  | * / %  | 从左到右\n加减  | + -  | 从左到右\n移位  | << >>  | 从左到右\n关系  | < <= > >=  | 从左到右\n相等  | == !=  | 从左到右\n位与 AND  | &  | 从左到右\n位异或 XOR  | ^  | 从左到右\n位或 OR  | &#124;  | 从左到右\n逻辑与 AND  | &&  | 从左到右\n逻辑或 OR  | &#124;&#124;  | 从左到右\n条件  | ?:  | 从右到左\n赋值  | = += -= *= /= %=>>= <<= &= ^= &#124;=  | 从右到左\n逗号  | ,  | 从左到右\n","slug":"C-运算符","published":1,"updated":"2019-07-30T01:54:38.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ixm0019homjoltnusqs","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>把两个操作数相加</td>\n<td>A + B 将得到 30</td>\n</tr>\n<tr>\n<td>-</td>\n<td>从第一个操作数中减去第二个操作数</td>\n<td>A - B 将得到 -10</td>\n</tr>\n<tr>\n<td>*</td>\n<td>把两个操作数相乘</td>\n<td>A * B 将得到 200</td>\n</tr>\n<tr>\n<td>/</td>\n<td>分子除以分母</td>\n<td>B / A 将得到 2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算符，整除后的余数</td>\n<td>B % A 将得到 0</td>\n</tr>\n<tr>\n<td>++</td>\n<td>自增运算符，整数值增加 1</td>\n<td>A++ 将得到 11</td>\n</tr>\n<tr>\n<td>—</td>\n<td>自减运算符，整数值减少 1</td>\n<td>A— 将得到 9</td>\n</tr>\n<tr>\n<td>==</td>\n<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td>(A == B) 不为真。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td>(A != B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt; B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt;= B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt;= B) 为真。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td>(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td>(A &#124;&#124; B) 为真。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td>!(A &amp;&amp; B) 为真。</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>(A &#124; B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>^</td>\n<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n<tr>\n<td>=</td>\n<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td>C = A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td>C += A 相当于 C = C + A</td>\n</tr>\n<tr>\n<td>-=</td>\n<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td>C -= A 相当于 C = C - A</td>\n</tr>\n<tr>\n<td>*=</td>\n<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td>C <em>= A 相当于 C = C </em> A</td>\n</tr>\n<tr>\n<td>/=</td>\n<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td>C /= A 相当于 C = C / A</td>\n</tr>\n<tr>\n<td>%=</td>\n<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td>C %= A 相当于 C = C % A</td>\n</tr>\n<tr>\n<td>&lt;&lt;=</td>\n<td>左移且赋值运算符</td>\n<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td>&gt;&gt;=</td>\n<td>右移且赋值运算符</td>\n<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td>&amp;=</td>\n<td>按位与且赋值运算符</td>\n<td>C &amp;= 2 等同于 C = C &amp; 2</td>\n</tr>\n<tr>\n<td>^=</td>\n<td>按位异或且赋值运算符</td>\n<td>C ^= 2 等同于 C = C ^ 2</td>\n</tr>\n<tr>\n<td>&#124;=</td>\n<td>按位或且赋值运算符</td>\n<td>C &#124;= 2 等同于 C = C &#124; 2</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>运算符</th>\n<th>结合性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>后缀</td>\n<td>() [] -&gt; . ++ - -</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>一元</td>\n<td>+ - ! ~ ++ - - (type)* &amp; sizeof</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>乘除</td>\n<td>* / %</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>加减</td>\n<td>+ -</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>移位</td>\n<td>&lt;&lt; &gt;&gt;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>关系</td>\n<td>&lt; &lt;= &gt; &gt;=</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>相等</td>\n<td>== !=</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位与 AND</td>\n<td>&amp;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位异或 XOR</td>\n<td>^</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位或 OR</td>\n<td>&#124;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>逻辑与 AND</td>\n<td>&amp;&amp;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>逻辑或 OR</td>\n<td>&#124;&#124;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>条件</td>\n<td>?:</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>赋值</td>\n<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= &#124;=</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>逗号</td>\n<td>,</td>\n<td>从左到右</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>把两个操作数相加</td>\n<td>A + B 将得到 30</td>\n</tr>\n<tr>\n<td>-</td>\n<td>从第一个操作数中减去第二个操作数</td>\n<td>A - B 将得到 -10</td>\n</tr>\n<tr>\n<td>*</td>\n<td>把两个操作数相乘</td>\n<td>A * B 将得到 200</td>\n</tr>\n<tr>\n<td>/</td>\n<td>分子除以分母</td>\n<td>B / A 将得到 2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算符，整除后的余数</td>\n<td>B % A 将得到 0</td>\n</tr>\n<tr>\n<td>++</td>\n<td>自增运算符，整数值增加 1</td>\n<td>A++ 将得到 11</td>\n</tr>\n<tr>\n<td>—</td>\n<td>自减运算符，整数值减少 1</td>\n<td>A— 将得到 9</td>\n</tr>\n<tr>\n<td>==</td>\n<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td>(A == B) 不为真。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td>(A != B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt; B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt;= B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt;= B) 为真。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td>(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td>(A &#124;&#124; B) 为真。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td>!(A &amp;&amp; B) 为真。</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>(A &#124; B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>^</td>\n<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n<tr>\n<td>=</td>\n<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td>C = A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td>C += A 相当于 C = C + A</td>\n</tr>\n<tr>\n<td>-=</td>\n<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td>C -= A 相当于 C = C - A</td>\n</tr>\n<tr>\n<td>*=</td>\n<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td>C <em>= A 相当于 C = C </em> A</td>\n</tr>\n<tr>\n<td>/=</td>\n<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td>C /= A 相当于 C = C / A</td>\n</tr>\n<tr>\n<td>%=</td>\n<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td>C %= A 相当于 C = C % A</td>\n</tr>\n<tr>\n<td>&lt;&lt;=</td>\n<td>左移且赋值运算符</td>\n<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td>&gt;&gt;=</td>\n<td>右移且赋值运算符</td>\n<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td>&amp;=</td>\n<td>按位与且赋值运算符</td>\n<td>C &amp;= 2 等同于 C = C &amp; 2</td>\n</tr>\n<tr>\n<td>^=</td>\n<td>按位异或且赋值运算符</td>\n<td>C ^= 2 等同于 C = C ^ 2</td>\n</tr>\n<tr>\n<td>&#124;=</td>\n<td>按位或且赋值运算符</td>\n<td>C &#124;= 2 等同于 C = C &#124; 2</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>运算符</th>\n<th>结合性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>后缀</td>\n<td>() [] -&gt; . ++ - -</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>一元</td>\n<td>+ - ! ~ ++ - - (type)* &amp; sizeof</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>乘除</td>\n<td>* / %</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>加减</td>\n<td>+ -</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>移位</td>\n<td>&lt;&lt; &gt;&gt;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>关系</td>\n<td>&lt; &lt;= &gt; &gt;=</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>相等</td>\n<td>== !=</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位与 AND</td>\n<td>&amp;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位异或 XOR</td>\n<td>^</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>位或 OR</td>\n<td>&#124;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>逻辑与 AND</td>\n<td>&amp;&amp;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>逻辑或 OR</td>\n<td>&#124;&#124;</td>\n<td>从左到右</td>\n</tr>\n<tr>\n<td>条件</td>\n<td>?:</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>赋值</td>\n<td>= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= &#124;=</td>\n<td>从右到左</td>\n</tr>\n<tr>\n<td>逗号</td>\n<td>,</td>\n<td>从左到右</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"C++重载运算符和重载函数","date":"2017-08-29T13:42:15.000Z","_content":"- C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。\n- 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n- 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。\n<!--mpre-->\n\n# C++ 中的函数重载\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n```C++\n#include <iostream>\nusing namespace std;\n\nclass printData\n{\n   public:\n      void print(int i) {\n        cout << \"整数为: \" << i << endl;\n      }\n\n      void print(double  f) {\n        cout << \"浮点数为: \" << f << endl;\n      }\n\n      void print(char c[]) {\n        cout << \"字符串为: \" << c << endl;\n      }\n};\n\nint main(void)\n{\n   printData pd;\n\n   // 输出整数\n   pd.print(5);\n   // 输出浮点数\n   pd.print(500.263);\n   // 输出字符串\n   char c[] = \"Hello C++\";\n   pd.print(c);\n\n   return 0;\n}\n```\n\n\n# C++ 中的运算符重载\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n## 一元运算符\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\nprivate:\n\tint feet;             // 0 到无穷\n\tint inches;           // 0 到 12\npublic:\n\t// 所需的构造函数\n\tDistance(){\n\t\tfeet = 0;\n\t\tinches = 0;\n\t}\n\tDistance(int f, int i){\n\t\tfeet = f;\n\t\tinches = i;\n\t}\n\t// 显示距离的方法\n\tvoid displayDistance()\n\t{\n\t\tcout << \"F: \" << feet << \" I:\" << inches << endl;\n\t}\n\t// 重载负运算符（ - ）\n\tDistance operator- ()\n\t{\n\t\tfeet = -feet;\n\t\tinches = -inches;\n\t\treturn Distance(feet, inches);\n\t}\n};\nint main()\n{\n\tDistance D1(11, 10), D2(-5, 11);\n\n\tD1.displayDistance();\n\tD2.displayDistance();\n\n\t-D1;                     // 取相反数\n\tD1.displayDistance();    // 距离 D1\n\n\t-D2;                     // 取相反数\n\tD2.displayDistance();    // 距离 D2\n\n\treturn 0;\n}\n```\n- 输出\n```C++\nF: 11 I:10\nF: -5 I:11\nF: -11 I:-10\nF: 5 I:-11\n```\n\n## 二元运算符\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\n   public:\n\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n\n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n\n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n};\n// 程序的主函数\nint main( )\n{\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n\n   // Box1 详述\n   Box1.setLength(6.0);\n   Box1.setBreadth(7.0);\n   Box1.setHeight(5.0);\n\n   // Box2 详述\n   Box2.setLength(12.0);\n   Box2.setBreadth(13.0);\n   Box2.setHeight(10.0);\n\n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n\n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n\n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n\n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n\n   return 0;\n}\n```\n\n## 关系运算符重载\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\n   private:\n      int feet;             // 0 到无穷\n      int inches;           // 0 到 12\n   public:\n      // 所需的构造函数\n      Distance(){\n         feet = 0;\n         inches = 0;\n      }\n      Distance(int f, int i){\n         feet = f;\n         inches = i;\n      }\n      // 显示距离的方法\n      void displayDistance()\n      {\n         cout << \"F: \" << feet << \" I:\" << inches <<endl;\n      }\n      // 重载负运算符（ - ）\n      Distance operator- ()\n      {\n         feet = -feet;\n         inches = -inches;\n         return Distance(feet, inches);\n      }\n      // 重载小于运算符（ < ）\n      bool operator <(const Distance& d)\n      {\n         if(feet < d.feet)\n         {\n            return true;\n         }\n         if(feet == d.feet && inches < d.inches)\n         {\n            return true;\n         }\n         return false;\n      }\n};\nint main()\n{\n   Distance D1(11, 10), D2(5, 11);\n\n   if( D1 < D2 )\n   {\n      cout << \"D1 is less than D2 \" << endl;\n   }\n   else\n   {\n      cout << \"D2 is less than D1 \" << endl;\n   }\n   return 0;\n}\n```\n\n## C++ 输入/输出运算符重载\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\nprivate:\n\tint feet;             // 0 到无穷\n\tint inches;           // 0 到 12\npublic:\n\t// 所需的构造函数\n\tDistance(){\n\t\tfeet = 0;\n\t\tinches = 0;\n\t}\n\tDistance(int f, int i){\n\t\tfeet = f;\n\t\tinches = i;\n\t}\n\tfriend ostream &operator<<(ostream &output,\n\t\tconst Distance &D)\n\t{\n\t\toutput << \"F : \" << D.feet << \" I : \" << D.inches;\n\t\treturn output;\n\t}\n\n\tfriend istream &operator>>(istream  &input, Distance &D)\n\t{\n\t\tinput >> D.feet >> D.inches;\n\t\treturn input;\n\t}\n};\nint main()\n{\n\tDistance D1(11, 10), D2(5, 11), D3;\n\n\tcout << \"Enter the value of object : \" << endl;\n\tcin >> D3;\n\tcout << \"First Distance : \" << D1 << endl;\n\tcout << \"Second Distance :\" << D2 << endl;\n\tcout << \"Third Distance :\" << D3 << endl;\n\n\treturn 0;\n}\n```\n\n# 可重载运算符\n类别|运算符\n-|-\n双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)\n关系运算符 | ==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于)\n逻辑运算符 | &#124;&#124;(逻辑或)，&&(逻辑与)，&#124;(逻辑非)\n单目运算符 | + (正)，-(负)，*(指针)，&(取地址)\n自增自减运算符 | ++(自增)，--(自减)\n位运算符 | &#124; (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)\n赋值运算符 | =, +=, -=, *=, /= , % = , &=, &#124;=, ^=, <<=, >>=\n空间申请与释放 | new, delete, new[ ] , delete[]\n其他运算符 | ()(函数调用)，->(成员访问)，,(逗号)，[](下标)\n\n\n\n[参考](http://www.runoob.com/cplusplus/cpp-overloading.html)\n","source":"_posts/C-重载运算符和重载函数.md","raw":"---\ntitle: C++重载运算符和重载函数\ndate: 2017-08-29 21:42:15\ntags: [指针,语言]\ncategories: C++\n---\n- C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。\n- 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n- 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。\n<!--mpre-->\n\n# C++ 中的函数重载\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n```C++\n#include <iostream>\nusing namespace std;\n\nclass printData\n{\n   public:\n      void print(int i) {\n        cout << \"整数为: \" << i << endl;\n      }\n\n      void print(double  f) {\n        cout << \"浮点数为: \" << f << endl;\n      }\n\n      void print(char c[]) {\n        cout << \"字符串为: \" << c << endl;\n      }\n};\n\nint main(void)\n{\n   printData pd;\n\n   // 输出整数\n   pd.print(5);\n   // 输出浮点数\n   pd.print(500.263);\n   // 输出字符串\n   char c[] = \"Hello C++\";\n   pd.print(c);\n\n   return 0;\n}\n```\n\n\n# C++ 中的运算符重载\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n## 一元运算符\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\nprivate:\n\tint feet;             // 0 到无穷\n\tint inches;           // 0 到 12\npublic:\n\t// 所需的构造函数\n\tDistance(){\n\t\tfeet = 0;\n\t\tinches = 0;\n\t}\n\tDistance(int f, int i){\n\t\tfeet = f;\n\t\tinches = i;\n\t}\n\t// 显示距离的方法\n\tvoid displayDistance()\n\t{\n\t\tcout << \"F: \" << feet << \" I:\" << inches << endl;\n\t}\n\t// 重载负运算符（ - ）\n\tDistance operator- ()\n\t{\n\t\tfeet = -feet;\n\t\tinches = -inches;\n\t\treturn Distance(feet, inches);\n\t}\n};\nint main()\n{\n\tDistance D1(11, 10), D2(-5, 11);\n\n\tD1.displayDistance();\n\tD2.displayDistance();\n\n\t-D1;                     // 取相反数\n\tD1.displayDistance();    // 距离 D1\n\n\t-D2;                     // 取相反数\n\tD2.displayDistance();    // 距离 D2\n\n\treturn 0;\n}\n```\n- 输出\n```C++\nF: 11 I:10\nF: -5 I:11\nF: -11 I:-10\nF: 5 I:-11\n```\n\n## 二元运算符\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Box\n{\n   public:\n\n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n\n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n\n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n};\n// 程序的主函数\nint main( )\n{\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n\n   // Box1 详述\n   Box1.setLength(6.0);\n   Box1.setBreadth(7.0);\n   Box1.setHeight(5.0);\n\n   // Box2 详述\n   Box2.setLength(12.0);\n   Box2.setBreadth(13.0);\n   Box2.setHeight(10.0);\n\n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n\n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n\n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n\n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n\n   return 0;\n}\n```\n\n## 关系运算符重载\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\n   private:\n      int feet;             // 0 到无穷\n      int inches;           // 0 到 12\n   public:\n      // 所需的构造函数\n      Distance(){\n         feet = 0;\n         inches = 0;\n      }\n      Distance(int f, int i){\n         feet = f;\n         inches = i;\n      }\n      // 显示距离的方法\n      void displayDistance()\n      {\n         cout << \"F: \" << feet << \" I:\" << inches <<endl;\n      }\n      // 重载负运算符（ - ）\n      Distance operator- ()\n      {\n         feet = -feet;\n         inches = -inches;\n         return Distance(feet, inches);\n      }\n      // 重载小于运算符（ < ）\n      bool operator <(const Distance& d)\n      {\n         if(feet < d.feet)\n         {\n            return true;\n         }\n         if(feet == d.feet && inches < d.inches)\n         {\n            return true;\n         }\n         return false;\n      }\n};\nint main()\n{\n   Distance D1(11, 10), D2(5, 11);\n\n   if( D1 < D2 )\n   {\n      cout << \"D1 is less than D2 \" << endl;\n   }\n   else\n   {\n      cout << \"D2 is less than D1 \" << endl;\n   }\n   return 0;\n}\n```\n\n## C++ 输入/输出运算符重载\n```C++\n#include <iostream>\nusing namespace std;\n\nclass Distance\n{\nprivate:\n\tint feet;             // 0 到无穷\n\tint inches;           // 0 到 12\npublic:\n\t// 所需的构造函数\n\tDistance(){\n\t\tfeet = 0;\n\t\tinches = 0;\n\t}\n\tDistance(int f, int i){\n\t\tfeet = f;\n\t\tinches = i;\n\t}\n\tfriend ostream &operator<<(ostream &output,\n\t\tconst Distance &D)\n\t{\n\t\toutput << \"F : \" << D.feet << \" I : \" << D.inches;\n\t\treturn output;\n\t}\n\n\tfriend istream &operator>>(istream  &input, Distance &D)\n\t{\n\t\tinput >> D.feet >> D.inches;\n\t\treturn input;\n\t}\n};\nint main()\n{\n\tDistance D1(11, 10), D2(5, 11), D3;\n\n\tcout << \"Enter the value of object : \" << endl;\n\tcin >> D3;\n\tcout << \"First Distance : \" << D1 << endl;\n\tcout << \"Second Distance :\" << D2 << endl;\n\tcout << \"Third Distance :\" << D3 << endl;\n\n\treturn 0;\n}\n```\n\n# 可重载运算符\n类别|运算符\n-|-\n双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)\n关系运算符 | ==(等于)，!= (不等于)，< (小于)，> (大于>，<=(小于等于)，>=(大于等于)\n逻辑运算符 | &#124;&#124;(逻辑或)，&&(逻辑与)，&#124;(逻辑非)\n单目运算符 | + (正)，-(负)，*(指针)，&(取地址)\n自增自减运算符 | ++(自增)，--(自减)\n位运算符 | &#124; (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移)\n赋值运算符 | =, +=, -=, *=, /= , % = , &=, &#124;=, ^=, <<=, >>=\n空间申请与释放 | new, delete, new[ ] , delete[]\n其他运算符 | ()(函数调用)，->(成员访问)，,(逗号)，[](下标)\n\n\n\n[参考](http://www.runoob.com/cplusplus/cpp-overloading.html)\n","slug":"C-重载运算符和重载函数","published":1,"updated":"2019-07-30T01:54:38.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ixr001chomjn7pymlyk","content":"<ul>\n<li>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</li>\n<li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</li>\n<li>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。<!--mpre-->\n</li>\n</ul>\n<h1 id=\"C-中的函数重载\"><a href=\"#C-中的函数重载\" class=\"headerlink\" title=\"C++ 中的函数重载\"></a>C++ 中的函数重载</h1><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">printData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"整数为: \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"浮点数为: \"</span> &lt;&lt; f &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c[])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"字符串为: \"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出整数</span></span><br><span class=\"line\">   pd.print(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出浮点数</span></span><br><span class=\"line\">   pd.print(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出字符串</span></span><br><span class=\"line\">   <span class=\"keyword\">char</span> c[] = <span class=\"string\">\"Hello C++\"</span>;</span><br><span class=\"line\">   pd.print(c);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-中的运算符重载\"><a href=\"#C-中的运算符重载\" class=\"headerlink\" title=\"C++ 中的运算符重载\"></a>C++ 中的运算符重载</h1><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<h2 id=\"一元运算符\"><a href=\"#一元运算符\" class=\"headerlink\" title=\"一元运算符\"></a>一元运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">\tDistance()&#123;</span><br><span class=\"line\">\t\tfeet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tinches = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDistance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">\t\tfeet = f;</span><br><span class=\"line\">\t\tinches = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 显示距离的方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">displayDistance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"F: \"</span> &lt;&lt; feet &lt;&lt; <span class=\"string\">\" I:\"</span> &lt;&lt; inches &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载负运算符（ - ）</span></span><br><span class=\"line\">\tDistance <span class=\"keyword\">operator</span>- ()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfeet = -feet;</span><br><span class=\"line\">\t\tinches = -inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Distance(feet, inches);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDistance D1(11, 10), D2(-5, 11);</span><br><span class=\"line\"></span><br><span class=\"line\">\tD1.displayDistance();</span><br><span class=\"line\">\tD2.displayDistance();</span><br><span class=\"line\"></span><br><span class=\"line\">\t-D1;                     <span class=\"comment\">// 取相反数</span></span><br><span class=\"line\">\tD1.displayDistance();    <span class=\"comment\">// 距离 D1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t-D2;                     <span class=\"comment\">// 取相反数</span></span><br><span class=\"line\">\tD2.displayDistance();    <span class=\"comment\">// 距离 D2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F: <span class=\"number\">11</span> I:<span class=\"number\">10</span></span><br><span class=\"line\">F: <span class=\"number\">-5</span> I:<span class=\"number\">11</span></span><br><span class=\"line\">F: <span class=\"number\">-11</span> I:<span class=\"number\">-10</span></span><br><span class=\"line\">F: <span class=\"number\">5</span> I:<span class=\"number\">-11</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二元运算符\"><a href=\"#二元运算符\" class=\"headerlink\" title=\"二元运算符\"></a>二元运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          length = len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBreadth</span><span class=\"params\">( <span class=\"keyword\">double</span> bre )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          breadth = bre;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">( <span class=\"keyword\">double</span> hei )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          height = hei;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class=\"line\">      Box <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Box&amp; b)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         Box box;</span><br><span class=\"line\">         box.length = <span class=\"keyword\">this</span>-&gt;length + b.length;</span><br><span class=\"line\">         box.breadth = <span class=\"keyword\">this</span>-&gt;breadth + b.breadth;</span><br><span class=\"line\">         box.height = <span class=\"keyword\">this</span>-&gt;height + b.height;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box Box1;                <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;                <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;                <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"keyword\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 把体积存储在该变量中</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box1 详述</span></span><br><span class=\"line\">   Box1.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   Box1.setBreadth(<span class=\"number\">7.0</span>);</span><br><span class=\"line\">   Box1.setHeight(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box2 详述</span></span><br><span class=\"line\">   Box2.setLength(<span class=\"number\">12.0</span>);</span><br><span class=\"line\">   Box2.setBreadth(<span class=\"number\">13.0</span>);</span><br><span class=\"line\">   Box2.setHeight(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box1 的体积</span></span><br><span class=\"line\">   volume = Box1.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box1 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box2 的体积</span></span><br><span class=\"line\">   volume = Box2.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box2 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把两个对象相加，得到 Box3</span></span><br><span class=\"line\">   Box3 = Box1 + Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box3 的体积</span></span><br><span class=\"line\">   volume = Box3.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box3 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">      Distance()&#123;</span><br><span class=\"line\">         feet = <span class=\"number\">0</span>;</span><br><span class=\"line\">         inches = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Distance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">         feet = f;</span><br><span class=\"line\">         inches = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 显示距离的方法</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">displayDistance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"F: \"</span> &lt;&lt; feet &lt;&lt; <span class=\"string\">\" I:\"</span> &lt;&lt; inches &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载负运算符（ - ）</span></span><br><span class=\"line\">      Distance <span class=\"keyword\">operator</span>- ()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         feet = -feet;</span><br><span class=\"line\">         inches = -inches;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> Distance(feet, inches);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载小于运算符（ &lt; ）</span></span><br><span class=\"line\">      <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> Distance&amp; d)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(feet &lt; d.feet)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Distance D1(11, 10), D2(5, 11);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span>( D1 &lt; D2 )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"D1 is less than D2 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"D2 is less than D1 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-输入-输出运算符重载\"><a href=\"#C-输入-输出运算符重载\" class=\"headerlink\" title=\"C++ 输入/输出运算符重载\"></a>C++ 输入/输出运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">\tDistance()&#123;</span><br><span class=\"line\">\t\tfeet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tinches = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDistance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">\t\tfeet = f;</span><br><span class=\"line\">\t\tinches = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;output,</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> Distance &amp;D)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\toutput &lt;&lt; <span class=\"string\">\"F : \"</span> &lt;&lt; D.feet &lt;&lt; <span class=\"string\">\" I : \"</span> &lt;&lt; D.inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> output;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> istream &amp;<span class=\"keyword\">operator</span>&gt;&gt;(istream  &amp;input, Distance &amp;D)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinput &gt;&gt; D.feet &gt;&gt; D.inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> input;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDistance D1(11, 10), D2(5, 11), D3;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter the value of object : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; D3;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"First Distance : \"</span> &lt;&lt; D1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Second Distance :\"</span> &lt;&lt; D2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Third Distance :\"</span> &lt;&lt; D3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"可重载运算符\"><a href=\"#可重载运算符\" class=\"headerlink\" title=\"可重载运算符\"></a>可重载运算符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>双目算术运算符</td>\n<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>\n</tr>\n<tr>\n<td>关系运算符</td>\n<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，&#124;(逻辑非)</td>\n</tr>\n<tr>\n<td>单目运算符</td>\n<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>\n</tr>\n<tr>\n<td>自增自减运算符</td>\n<td>++(自增)，—(自减)</td>\n</tr>\n<tr>\n<td>位运算符</td>\n<td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>\n</tr>\n<tr>\n<td>赋值运算符</td>\n<td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td>\n</tr>\n<tr>\n<td>空间申请与释放</td>\n<td>new, delete, new[ ] , delete[]</td>\n</tr>\n<tr>\n<td>其他运算符</td>\n<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，<a href=\"下标\"></a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><a href=\"http://www.runoob.com/cplusplus/cpp-overloading.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</li>\n<li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</li>\n<li>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。<!--mpre-->\n</li>\n</ul>\n<h1 id=\"C-中的函数重载\"><a href=\"#C-中的函数重载\" class=\"headerlink\" title=\"C++ 中的函数重载\"></a>C++ 中的函数重载</h1><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">printData</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"整数为: \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">double</span>  f)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"浮点数为: \"</span> &lt;&lt; f &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c[])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"字符串为: \"</span> &lt;&lt; c &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   printData pd;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出整数</span></span><br><span class=\"line\">   pd.print(<span class=\"number\">5</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出浮点数</span></span><br><span class=\"line\">   pd.print(<span class=\"number\">500.263</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 输出字符串</span></span><br><span class=\"line\">   <span class=\"keyword\">char</span> c[] = <span class=\"string\">\"Hello C++\"</span>;</span><br><span class=\"line\">   pd.print(c);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"C-中的运算符重载\"><a href=\"#C-中的运算符重载\" class=\"headerlink\" title=\"C++ 中的运算符重载\"></a>C++ 中的运算符重载</h1><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<h2 id=\"一元运算符\"><a href=\"#一元运算符\" class=\"headerlink\" title=\"一元运算符\"></a>一元运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">\tDistance()&#123;</span><br><span class=\"line\">\t\tfeet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tinches = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDistance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">\t\tfeet = f;</span><br><span class=\"line\">\t\tinches = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 显示距离的方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">displayDistance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"F: \"</span> &lt;&lt; feet &lt;&lt; <span class=\"string\">\" I:\"</span> &lt;&lt; inches &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 重载负运算符（ - ）</span></span><br><span class=\"line\">\tDistance <span class=\"keyword\">operator</span>- ()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfeet = -feet;</span><br><span class=\"line\">\t\tinches = -inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Distance(feet, inches);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDistance D1(11, 10), D2(-5, 11);</span><br><span class=\"line\"></span><br><span class=\"line\">\tD1.displayDistance();</span><br><span class=\"line\">\tD2.displayDistance();</span><br><span class=\"line\"></span><br><span class=\"line\">\t-D1;                     <span class=\"comment\">// 取相反数</span></span><br><span class=\"line\">\tD1.displayDistance();    <span class=\"comment\">// 距离 D1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t-D2;                     <span class=\"comment\">// 取相反数</span></span><br><span class=\"line\">\tD2.displayDistance();    <span class=\"comment\">// 距离 D2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">F: <span class=\"number\">11</span> I:<span class=\"number\">10</span></span><br><span class=\"line\">F: <span class=\"number\">-5</span> I:<span class=\"number\">11</span></span><br><span class=\"line\">F: <span class=\"number\">-11</span> I:<span class=\"number\">-10</span></span><br><span class=\"line\">F: <span class=\"number\">5</span> I:<span class=\"number\">-11</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二元运算符\"><a href=\"#二元运算符\" class=\"headerlink\" title=\"二元运算符\"></a>二元运算符</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getVolume</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setLength</span><span class=\"params\">( <span class=\"keyword\">double</span> len )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          length = len;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setBreadth</span><span class=\"params\">( <span class=\"keyword\">double</span> bre )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          breadth = bre;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setHeight</span><span class=\"params\">( <span class=\"keyword\">double</span> hei )</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          height = hei;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载 + 运算符，用于把两个 Box 对象相加</span></span><br><span class=\"line\">      Box <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Box&amp; b)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         Box box;</span><br><span class=\"line\">         box.length = <span class=\"keyword\">this</span>-&gt;length + b.length;</span><br><span class=\"line\">         box.breadth = <span class=\"keyword\">this</span>-&gt;breadth + b.breadth;</span><br><span class=\"line\">         box.height = <span class=\"keyword\">this</span>-&gt;height + b.height;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> box;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">double</span> length;      <span class=\"comment\">// 长度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> breadth;     <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">      <span class=\"keyword\">double</span> height;      <span class=\"comment\">// 高度</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 程序的主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Box Box1;                <span class=\"comment\">// 声明 Box1，类型为 Box</span></span><br><span class=\"line\">   Box Box2;                <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br><span class=\"line\">   Box Box3;                <span class=\"comment\">// 声明 Box3，类型为 Box</span></span><br><span class=\"line\">   <span class=\"keyword\">double</span> volume = <span class=\"number\">0.0</span>;     <span class=\"comment\">// 把体积存储在该变量中</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box1 详述</span></span><br><span class=\"line\">   Box1.setLength(<span class=\"number\">6.0</span>);</span><br><span class=\"line\">   Box1.setBreadth(<span class=\"number\">7.0</span>);</span><br><span class=\"line\">   Box1.setHeight(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box2 详述</span></span><br><span class=\"line\">   Box2.setLength(<span class=\"number\">12.0</span>);</span><br><span class=\"line\">   Box2.setBreadth(<span class=\"number\">13.0</span>);</span><br><span class=\"line\">   Box2.setHeight(<span class=\"number\">10.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box1 的体积</span></span><br><span class=\"line\">   volume = Box1.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box1 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box2 的体积</span></span><br><span class=\"line\">   volume = Box2.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box2 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 把两个对象相加，得到 Box3</span></span><br><span class=\"line\">   Box3 = Box1 + Box2;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Box3 的体积</span></span><br><span class=\"line\">   volume = Box3.getVolume();</span><br><span class=\"line\">   <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Volume of Box3 : \"</span> &lt;&lt; volume &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      <span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">      Distance()&#123;</span><br><span class=\"line\">         feet = <span class=\"number\">0</span>;</span><br><span class=\"line\">         inches = <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Distance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">         feet = f;</span><br><span class=\"line\">         inches = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 显示距离的方法</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">displayDistance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"F: \"</span> &lt;&lt; feet &lt;&lt; <span class=\"string\">\" I:\"</span> &lt;&lt; inches &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载负运算符（ - ）</span></span><br><span class=\"line\">      Distance <span class=\"keyword\">operator</span>- ()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         feet = -feet;</span><br><span class=\"line\">         inches = -inches;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> Distance(feet, inches);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 重载小于运算符（ &lt; ）</span></span><br><span class=\"line\">      <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> Distance&amp; d)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(feet &lt; d.feet)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(feet == d.feet &amp;&amp; inches &lt; d.inches)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   Distance D1(11, 10), D2(5, 11);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span>( D1 &lt; D2 )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"D1 is less than D2 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span></span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"D2 is less than D1 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"C-输入-输出运算符重载\"><a href=\"#C-输入-输出运算符重载\" class=\"headerlink\" title=\"C++ 输入/输出运算符重载\"></a>C++ 输入/输出运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Distance</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> feet;             <span class=\"comment\">// 0 到无穷</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> inches;           <span class=\"comment\">// 0 到 12</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// 所需的构造函数</span></span><br><span class=\"line\">\tDistance()&#123;</span><br><span class=\"line\">\t\tfeet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tinches = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tDistance(<span class=\"keyword\">int</span> f, <span class=\"keyword\">int</span> i)&#123;</span><br><span class=\"line\">\t\tfeet = f;</span><br><span class=\"line\">\t\tinches = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;output,</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> Distance &amp;D)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\toutput &lt;&lt; <span class=\"string\">\"F : \"</span> &lt;&lt; D.feet &lt;&lt; <span class=\"string\">\" I : \"</span> &lt;&lt; D.inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> output;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> istream &amp;<span class=\"keyword\">operator</span>&gt;&gt;(istream  &amp;input, Distance &amp;D)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tinput &gt;&gt; D.feet &gt;&gt; D.inches;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> input;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tDistance D1(11, 10), D2(5, 11), D3;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter the value of object : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; D3;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"First Distance : \"</span> &lt;&lt; D1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Second Distance :\"</span> &lt;&lt; D2 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Third Distance :\"</span> &lt;&lt; D3 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"可重载运算符\"><a href=\"#可重载运算符\" class=\"headerlink\" title=\"可重载运算符\"></a>可重载运算符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>双目算术运算符</td>\n<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>\n</tr>\n<tr>\n<td>关系运算符</td>\n<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，&#124;(逻辑非)</td>\n</tr>\n<tr>\n<td>单目运算符</td>\n<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>\n</tr>\n<tr>\n<td>自增自减运算符</td>\n<td>++(自增)，—(自减)</td>\n</tr>\n<tr>\n<td>位运算符</td>\n<td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>\n</tr>\n<tr>\n<td>赋值运算符</td>\n<td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td>\n</tr>\n<tr>\n<td>空间申请与释放</td>\n<td>new, delete, new[ ] , delete[]</td>\n</tr>\n<tr>\n<td>其他运算符</td>\n<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，<a href=\"下标\"></a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><a href=\"http://www.runoob.com/cplusplus/cpp-overloading.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n"},{"title":"DCL-SQL","date":"2019-07-31T13:07:59.000Z","_content":"\n1. 用户对不同的数据对象有不同的存取权限\n2. 不同的用户对同一对象也有不同的权限\n3. 用户还可将其拥有的存取权限转授给其他用户\n\n<!--more-->","source":"_posts/DCL-SQL.md","raw":"---\ntitle: DCL-SQL\ndate: 2019-07-31 21:07:59\ntags: [数据库,编程语言]\ncategories: SQL\npermalink: SQL/DCL-SQL.md\n---\n\n1. 用户对不同的数据对象有不同的存取权限\n2. 不同的用户对同一对象也有不同的权限\n3. 用户还可将其拥有的存取权限转授给其他用户\n\n<!--more-->","slug":"SQL/DCL-SQL.md","published":1,"updated":"2019-08-09T05:29:01.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6ixw001fhomji28hop5r","content":"<ol>\n<li>用户对不同的数据对象有不同的存取权限</li>\n<li>不同的用户对同一对象也有不同的权限</li>\n<li>用户还可将其拥有的存取权限转授给其他用户</li>\n</ol>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<ol>\n<li>用户对不同的数据对象有不同的存取权限</li>\n<li>不同的用户对同一对象也有不同的权限</li>\n<li>用户还可将其拥有的存取权限转授给其他用户</li>\n</ol>","more":""},{"title":"DDL-SQL","date":"2019-07-31T13:07:59.000Z","_content":"\n# 数据库\n\n```sql\n-- 创建数据库\nCreate database my_db; \n-- 删除数据库\nDrop database my_db;\n-- 指定数据库\nuse my_db;\n-- 关闭数据库\nclose my_db; \n```\n\n<!--more-->\n\n# 表\n\n```sql\n--  创建表格\nCREATE TABLE table_name\n--  修改表格\nalter table tablename \n--  删除表格\nDROP TABLE Persons\n```\n\n## 创建表格\n\n```sql\nCREATE TABLE Persons\n(\n    P_Id int NOT NULL PRIMARY KEY CHECK (P_Id>0),  --不为空，主键，删选条件：P_Id>0\n    LastName varchar(255) NOT NULL,      \t\t   --不为空\n    FirstName varchar(255),\n    Address varchar(255),\n    City varchar(255) DEFAULT 'Sandnes'            --默认值为'Sandnes'\n);\n```\n\n```sql\nCREATE TABLE table_name\n(\n    列名1  数据类型(size)  约束条件,\n    列名2  数据类型(size)  约束条件,\n    列名3  数据类型(size)  约束条件,\n    ....\n);\n```\n\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td>列名</td>\n    <td colspan=\"2\">规定表中列的名称</td>\n  </tr>\n  <tr>\n    <td>数据类型</td>\n    <td colspan=\"2\">例如varchar、integer、decimal、date。不同的数据库有不同的数据类型</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">约束条件</td>\n    <td>Primary key</td>\n    <td>主键约束。每个表只能创建一个主键约束</td>\n  </tr>\n  <tr>\n    <td>Unique</td>\n    <td>唯一性约束（即候选键）。每个表可以有多个唯一性约束，但只能有一个Primary key。</td>\n  </tr>\n  <tr>\n    <td>Not null</td>\n    <td>非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。</td>\n  </tr>\n  <tr>\n    <td>CHECK (search_cond)</td>\n    <td>约束用于限制列中的值的范围,search_cond为条件。如果对单个列定义 CHECK 约束，那么该列只允许特定的值；如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</td>\n  </tr>\n  <tr>\n    <td>FOREIGN KEY</td>\n    <td>一个表中的 FOREIGN KEY指向另一个表中的PRIMARY KEY</td>\n  </tr>\n  <tr>\n    <td>DEFAULT</td>\n    <td>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</td>\n  </tr>\n  <tr>\n    <td>AUTO_INCREMENT</td>\n    <td>每次插入时，自动生成主键的值</td>\n  </tr>\n</table>\n\n## 修改表格\n\n```sql\nalter table tablename \n    - add      增加新列 \n    - drop     删除列或者完整性约束条件 \n    - modify   修改列定义\n```\n\n```sql\n-- 在表 \"Person\" 中添加一个名为 \"Birthday\" 的新列。\nALTER TABLE Person ADD Birthday date;\n-- 删除 \"Person\" 表中的 \"Birthday\" 列：\nALTER TABLE Person DROP COLUMN Birthday;\n-- 删除 \"Person\" 表中 \"P_Id\" 的主键：\nALTER TABLE Person DROP PRIMARY KEY(P_Id);\n-- 改变 \"Person\" 表中 \"Birthday\" 列的数据类型。\nALTER TABLE Person Modify Birthday year;\n```\n\n## 删除表格\n\n```sql\nDROP TABLE table_name   -- 删除表\n```\n\n# 视图\n\n表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的` SELECT `语句。一般来说你可以用`update，insert，delete`等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的`update，insert和delete`等操作最终会作用于与其相关的表中数据。\n\n## 创建视图\n\n<font color=red>**定义视图时不能使用 ORDER BY 子句**</font>\n\n```sql\nCREATE VIEW view_name AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition\n[with check option]  -- 指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式\n```\n\n```sql\nCREATE VIEW CUSTOMERS_VIEW AS\nSELECT name, age\nFROM  CUSTOMERS\nWHERE age IS NOT NULL\nWITH CHECK OPTION; --这里 WITH CHECK OPTION 使得视图拒绝任何 AGE 字段为 NULL 的条目，因为视图的定义中，AGE 字段不能为空。对视图不管修改前还是修改后都必须遵从此规定。\n```\n\n## 使用视图\n\n```sql\nSelect * From view_name\n```\n\n## 视图的更新（增、删、改）\n\n一般来说你可以用`update，insert，delete`等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的`update，insert`和`delete`等操作最终会作用于与其相关的表中数据。\n\n对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。如果视图包含下述结构中的任何一种，那么它就是不可更新的：\n\n| 分类     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| 非一对一 | DISTINCT关键字、GROUP BY子句、UNION运算符、位于选择列表中的子查询 |\n| 未知     | 聚合函数、ORDER BY子句、HAVING子句、FROM子句中包含多个表、WHERE子句中的子查询，引用FROM子句中的表 |\n| 其他     | SELECT语句中引用了不可更新视图<br>ALGORITHM 选项指定为TEMPTABLE（使用临时表总会使视图成为不可更新的） |\n\n### 插入数据\n\n```sql\nINSERT INTO CUSTOMERS_VIEW\n     VALUES('李牧',50);\n```\n\n### 修改数据\n\n```sql\nUPDATE CUSTOMERS_VIEW SET age = 58 where name = '李牧';\n```\n\n### 删除数据\n\n```sql\nDELETE FROM CUSTOMERS_VIEW  WHERE name = '李牧';\n```\n\n## 删除视图\n\n```sql\nDrop View view_name\n```\n","source":"_posts/DDL-SQL.md","raw":"---\ntitle: DDL-SQL\ndate: 2019-07-31 21:07:59\ntags: [数据库,编程语言]\ncategories: SQL\npermalink: SQL/DDL-SQL.md\n---\n\n# 数据库\n\n```sql\n-- 创建数据库\nCreate database my_db; \n-- 删除数据库\nDrop database my_db;\n-- 指定数据库\nuse my_db;\n-- 关闭数据库\nclose my_db; \n```\n\n<!--more-->\n\n# 表\n\n```sql\n--  创建表格\nCREATE TABLE table_name\n--  修改表格\nalter table tablename \n--  删除表格\nDROP TABLE Persons\n```\n\n## 创建表格\n\n```sql\nCREATE TABLE Persons\n(\n    P_Id int NOT NULL PRIMARY KEY CHECK (P_Id>0),  --不为空，主键，删选条件：P_Id>0\n    LastName varchar(255) NOT NULL,      \t\t   --不为空\n    FirstName varchar(255),\n    Address varchar(255),\n    City varchar(255) DEFAULT 'Sandnes'            --默认值为'Sandnes'\n);\n```\n\n```sql\nCREATE TABLE table_name\n(\n    列名1  数据类型(size)  约束条件,\n    列名2  数据类型(size)  约束条件,\n    列名3  数据类型(size)  约束条件,\n    ....\n);\n```\n\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td>列名</td>\n    <td colspan=\"2\">规定表中列的名称</td>\n  </tr>\n  <tr>\n    <td>数据类型</td>\n    <td colspan=\"2\">例如varchar、integer、decimal、date。不同的数据库有不同的数据类型</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">约束条件</td>\n    <td>Primary key</td>\n    <td>主键约束。每个表只能创建一个主键约束</td>\n  </tr>\n  <tr>\n    <td>Unique</td>\n    <td>唯一性约束（即候选键）。每个表可以有多个唯一性约束，但只能有一个Primary key。</td>\n  </tr>\n  <tr>\n    <td>Not null</td>\n    <td>非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。</td>\n  </tr>\n  <tr>\n    <td>CHECK (search_cond)</td>\n    <td>约束用于限制列中的值的范围,search_cond为条件。如果对单个列定义 CHECK 约束，那么该列只允许特定的值；如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</td>\n  </tr>\n  <tr>\n    <td>FOREIGN KEY</td>\n    <td>一个表中的 FOREIGN KEY指向另一个表中的PRIMARY KEY</td>\n  </tr>\n  <tr>\n    <td>DEFAULT</td>\n    <td>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</td>\n  </tr>\n  <tr>\n    <td>AUTO_INCREMENT</td>\n    <td>每次插入时，自动生成主键的值</td>\n  </tr>\n</table>\n\n## 修改表格\n\n```sql\nalter table tablename \n    - add      增加新列 \n    - drop     删除列或者完整性约束条件 \n    - modify   修改列定义\n```\n\n```sql\n-- 在表 \"Person\" 中添加一个名为 \"Birthday\" 的新列。\nALTER TABLE Person ADD Birthday date;\n-- 删除 \"Person\" 表中的 \"Birthday\" 列：\nALTER TABLE Person DROP COLUMN Birthday;\n-- 删除 \"Person\" 表中 \"P_Id\" 的主键：\nALTER TABLE Person DROP PRIMARY KEY(P_Id);\n-- 改变 \"Person\" 表中 \"Birthday\" 列的数据类型。\nALTER TABLE Person Modify Birthday year;\n```\n\n## 删除表格\n\n```sql\nDROP TABLE table_name   -- 删除表\n```\n\n# 视图\n\n表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的` SELECT `语句。一般来说你可以用`update，insert，delete`等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的`update，insert和delete`等操作最终会作用于与其相关的表中数据。\n\n## 创建视图\n\n<font color=red>**定义视图时不能使用 ORDER BY 子句**</font>\n\n```sql\nCREATE VIEW view_name AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition\n[with check option]  -- 指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式\n```\n\n```sql\nCREATE VIEW CUSTOMERS_VIEW AS\nSELECT name, age\nFROM  CUSTOMERS\nWHERE age IS NOT NULL\nWITH CHECK OPTION; --这里 WITH CHECK OPTION 使得视图拒绝任何 AGE 字段为 NULL 的条目，因为视图的定义中，AGE 字段不能为空。对视图不管修改前还是修改后都必须遵从此规定。\n```\n\n## 使用视图\n\n```sql\nSelect * From view_name\n```\n\n## 视图的更新（增、删、改）\n\n一般来说你可以用`update，insert，delete`等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的`update，insert`和`delete`等操作最终会作用于与其相关的表中数据。\n\n对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。如果视图包含下述结构中的任何一种，那么它就是不可更新的：\n\n| 分类     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| 非一对一 | DISTINCT关键字、GROUP BY子句、UNION运算符、位于选择列表中的子查询 |\n| 未知     | 聚合函数、ORDER BY子句、HAVING子句、FROM子句中包含多个表、WHERE子句中的子查询，引用FROM子句中的表 |\n| 其他     | SELECT语句中引用了不可更新视图<br>ALGORITHM 选项指定为TEMPTABLE（使用临时表总会使视图成为不可更新的） |\n\n### 插入数据\n\n```sql\nINSERT INTO CUSTOMERS_VIEW\n     VALUES('李牧',50);\n```\n\n### 修改数据\n\n```sql\nUPDATE CUSTOMERS_VIEW SET age = 58 where name = '李牧';\n```\n\n### 删除数据\n\n```sql\nDELETE FROM CUSTOMERS_VIEW  WHERE name = '李牧';\n```\n\n## 删除视图\n\n```sql\nDrop View view_name\n```\n","slug":"SQL/DDL-SQL.md","published":1,"updated":"2019-08-09T05:28:51.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iy1001hhomjftfztunx","content":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">database</span> my_db; </span><br><span class=\"line\"><span class=\"comment\">-- 删除数据库</span></span><br><span class=\"line\"><span class=\"keyword\">Drop</span> <span class=\"keyword\">database</span> my_db;</span><br><span class=\"line\"><span class=\"comment\">-- 指定数据库</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> my_db;</span><br><span class=\"line\"><span class=\"comment\">-- 关闭数据库</span></span><br><span class=\"line\">close my_db;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--  创建表格</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"comment\">--  修改表格</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tablename </span><br><span class=\"line\"><span class=\"comment\">--  删除表格</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> Persons</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表格\"><a href=\"#创建表格\" class=\"headerlink\" title=\"创建表格\"></a>创建表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Persons</span><br><span class=\"line\">(</span><br><span class=\"line\">    P_Id <span class=\"built_in\">int</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span> <span class=\"keyword\">CHECK</span> (P_Id&gt;<span class=\"number\">0</span>),  <span class=\"comment\">--不为空，主键，删选条件：P_Id&gt;0</span></span><br><span class=\"line\">    LastName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,      \t\t   <span class=\"comment\">--不为空</span></span><br><span class=\"line\">    FirstName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">'Sandnes'</span>            <span class=\"comment\">--默认值为'Sandnes'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\">    列名<span class=\"number\">1</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    列名<span class=\"number\">2</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    列名<span class=\"number\">3</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    ....</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td>列名</td>\n    <td colspan=\"2\">规定表中列的名称</td>\n  </tr>\n  <tr>\n    <td>数据类型</td>\n    <td colspan=\"2\">例如varchar、integer、decimal、date。不同的数据库有不同的数据类型</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">约束条件</td>\n    <td>Primary key</td>\n    <td>主键约束。每个表只能创建一个主键约束</td>\n  </tr>\n  <tr>\n    <td>Unique</td>\n    <td>唯一性约束（即候选键）。每个表可以有多个唯一性约束，但只能有一个Primary key。</td>\n  </tr>\n  <tr>\n    <td>Not null</td>\n    <td>非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。</td>\n  </tr>\n  <tr>\n    <td>CHECK (search_cond)</td>\n    <td>约束用于限制列中的值的范围,search_cond为条件。如果对单个列定义 CHECK 约束，那么该列只允许特定的值；如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</td>\n  </tr>\n  <tr>\n    <td>FOREIGN KEY</td>\n    <td>一个表中的 FOREIGN KEY指向另一个表中的PRIMARY KEY</td>\n  </tr>\n  <tr>\n    <td>DEFAULT</td>\n    <td>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</td>\n  </tr>\n  <tr>\n    <td>AUTO_INCREMENT</td>\n    <td>每次插入时，自动生成主键的值</td>\n  </tr>\n</table>\n\n<h2 id=\"修改表格\"><a href=\"#修改表格\" class=\"headerlink\" title=\"修改表格\"></a>修改表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tablename </span><br><span class=\"line\">    - <span class=\"keyword\">add</span>      增加新列 </span><br><span class=\"line\">    - <span class=\"keyword\">drop</span>     删除列或者完整性约束条件 </span><br><span class=\"line\">    - <span class=\"keyword\">modify</span>   修改列定义</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 在表 \"Person\" 中添加一个名为 \"Birthday\" 的新列。</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">ADD</span> Birthday <span class=\"built_in\">date</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 删除 \"Person\" 表中的 \"Birthday\" 列：</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> Birthday;</span><br><span class=\"line\"><span class=\"comment\">-- 删除 \"Person\" 表中 \"P_Id\" 的主键：</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">DROP</span> PRIMARY <span class=\"keyword\">KEY</span>(P_Id);</span><br><span class=\"line\"><span class=\"comment\">-- 改变 \"Person\" 表中 \"Birthday\" 列的数据类型。</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">Modify</span> Birthday <span class=\"keyword\">year</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除表格\"><a href=\"#删除表格\" class=\"headerlink\" title=\"删除表格\"></a>删除表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> table_name   <span class=\"comment\">-- 删除表</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><p>表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的<code>SELECT</code>语句。一般来说你可以用<code>update，insert，delete</code>等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的<code>update，insert和delete</code>等操作最终会作用于与其相关的表中数据。</p>\n<h2 id=\"创建视图\"><a href=\"#创建视图\" class=\"headerlink\" title=\"创建视图\"></a>创建视图</h2><font color=\"red\">**定义视图时不能使用 ORDER BY 子句**</font>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> view_name <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> condition</span><br><span class=\"line\">[<span class=\"keyword\">with</span> <span class=\"keyword\">check</span> <span class=\"keyword\">option</span>]  <span class=\"comment\">-- 指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> CUSTOMERS_VIEW <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, age</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>  CUSTOMERS</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> age <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>; <span class=\"comment\">--这里 WITH CHECK OPTION 使得视图拒绝任何 AGE 字段为 NULL 的条目，因为视图的定义中，AGE 字段不能为空。对视图不管修改前还是修改后都必须遵从此规定。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用视图\"><a href=\"#使用视图\" class=\"headerlink\" title=\"使用视图\"></a>使用视图</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">From</span> view_name</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图的更新（增、删、改）\"><a href=\"#视图的更新（增、删、改）\" class=\"headerlink\" title=\"视图的更新（增、删、改）\"></a>视图的更新（增、删、改）</h2><p>一般来说你可以用<code>update，insert，delete</code>等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的<code>update，insert</code>和<code>delete</code>等操作最终会作用于与其相关的表中数据。</p>\n<p>对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。如果视图包含下述结构中的任何一种，那么它就是不可更新的：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>非一对一</td>\n<td>DISTINCT关键字、GROUP BY子句、UNION运算符、位于选择列表中的子查询</td>\n</tr>\n<tr>\n<td>未知</td>\n<td>聚合函数、ORDER BY子句、HAVING子句、FROM子句中包含多个表、WHERE子句中的子查询，引用FROM子句中的表</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>SELECT语句中引用了不可更新视图<br>ALGORITHM 选项指定为TEMPTABLE（使用临时表总会使视图成为不可更新的）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CUSTOMERS_VIEW</span><br><span class=\"line\">     <span class=\"keyword\">VALUES</span>(<span class=\"string\">'李牧'</span>,<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> CUSTOMERS_VIEW <span class=\"keyword\">SET</span> age = <span class=\"number\">58</span> <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">'李牧'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> CUSTOMERS_VIEW  <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'李牧'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Drop</span> <span class=\"keyword\">View</span> view_name</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库</span></span><br><span class=\"line\"><span class=\"keyword\">Create</span> <span class=\"keyword\">database</span> my_db; </span><br><span class=\"line\"><span class=\"comment\">-- 删除数据库</span></span><br><span class=\"line\"><span class=\"keyword\">Drop</span> <span class=\"keyword\">database</span> my_db;</span><br><span class=\"line\"><span class=\"comment\">-- 指定数据库</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> my_db;</span><br><span class=\"line\"><span class=\"comment\">-- 关闭数据库</span></span><br><span class=\"line\">close my_db;</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"表\"><a href=\"#表\" class=\"headerlink\" title=\"表\"></a>表</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--  创建表格</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"comment\">--  修改表格</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tablename </span><br><span class=\"line\"><span class=\"comment\">--  删除表格</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> Persons</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建表格\"><a href=\"#创建表格\" class=\"headerlink\" title=\"创建表格\"></a>创建表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> Persons</span><br><span class=\"line\">(</span><br><span class=\"line\">    P_Id <span class=\"built_in\">int</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span> <span class=\"keyword\">CHECK</span> (P_Id&gt;<span class=\"number\">0</span>),  <span class=\"comment\">--不为空，主键，删选条件：P_Id&gt;0</span></span><br><span class=\"line\">    LastName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,      \t\t   <span class=\"comment\">--不为空</span></span><br><span class=\"line\">    FirstName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    Address <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">    City <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">'Sandnes'</span>            <span class=\"comment\">--默认值为'Sandnes'</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\">(</span><br><span class=\"line\">    列名<span class=\"number\">1</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    列名<span class=\"number\">2</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    列名<span class=\"number\">3</span>  数据类型(<span class=\"keyword\">size</span>)  约束条件,</span><br><span class=\"line\">    ....</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td>列名</td>\n    <td colspan=\"2\">规定表中列的名称</td>\n  </tr>\n  <tr>\n    <td>数据类型</td>\n    <td colspan=\"2\">例如varchar、integer、decimal、date。不同的数据库有不同的数据类型</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">约束条件</td>\n    <td>Primary key</td>\n    <td>主键约束。每个表只能创建一个主键约束</td>\n  </tr>\n  <tr>\n    <td>Unique</td>\n    <td>唯一性约束（即候选键）。每个表可以有多个唯一性约束，但只能有一个Primary key。</td>\n  </tr>\n  <tr>\n    <td>Not null</td>\n    <td>非空约束。是指该列允许不允许有空值出现，如选择了Not null表明该列不允许有空值出现。</td>\n  </tr>\n  <tr>\n    <td>CHECK (search_cond)</td>\n    <td>约束用于限制列中的值的范围,search_cond为条件。如果对单个列定义 CHECK 约束，那么该列只允许特定的值；如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</td>\n  </tr>\n  <tr>\n    <td>FOREIGN KEY</td>\n    <td>一个表中的 FOREIGN KEY指向另一个表中的PRIMARY KEY</td>\n  </tr>\n  <tr>\n    <td>DEFAULT</td>\n    <td>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</td>\n  </tr>\n  <tr>\n    <td>AUTO_INCREMENT</td>\n    <td>每次插入时，自动生成主键的值</td>\n  </tr>\n</table>\n\n<h2 id=\"修改表格\"><a href=\"#修改表格\" class=\"headerlink\" title=\"修改表格\"></a>修改表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> tablename </span><br><span class=\"line\">    - <span class=\"keyword\">add</span>      增加新列 </span><br><span class=\"line\">    - <span class=\"keyword\">drop</span>     删除列或者完整性约束条件 </span><br><span class=\"line\">    - <span class=\"keyword\">modify</span>   修改列定义</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 在表 \"Person\" 中添加一个名为 \"Birthday\" 的新列。</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">ADD</span> Birthday <span class=\"built_in\">date</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 删除 \"Person\" 表中的 \"Birthday\" 列：</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">DROP</span> <span class=\"keyword\">COLUMN</span> Birthday;</span><br><span class=\"line\"><span class=\"comment\">-- 删除 \"Person\" 表中 \"P_Id\" 的主键：</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">DROP</span> PRIMARY <span class=\"keyword\">KEY</span>(P_Id);</span><br><span class=\"line\"><span class=\"comment\">-- 改变 \"Person\" 表中 \"Birthday\" 列的数据类型。</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Person <span class=\"keyword\">Modify</span> Birthday <span class=\"keyword\">year</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除表格\"><a href=\"#删除表格\" class=\"headerlink\" title=\"删除表格\"></a>删除表格</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> table_name   <span class=\"comment\">-- 删除表</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><p>表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的<code>SELECT</code>语句。一般来说你可以用<code>update，insert，delete</code>等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的<code>update，insert和delete</code>等操作最终会作用于与其相关的表中数据。</p>\n<h2 id=\"创建视图\"><a href=\"#创建视图\" class=\"headerlink\" title=\"创建视图\"></a>创建视图</h2><font color=\"red\">**定义视图时不能使用 ORDER BY 子句**</font>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> view_name <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> condition</span><br><span class=\"line\">[<span class=\"keyword\">with</span> <span class=\"keyword\">check</span> <span class=\"keyword\">option</span>]  <span class=\"comment\">-- 指明当对视图进行insert，update，delete时，要检查进行insert/update/delete的元组是否满足视图定义中子查询中定义的条件表达式</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> CUSTOMERS_VIEW <span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, age</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>  CUSTOMERS</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> age <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>; <span class=\"comment\">--这里 WITH CHECK OPTION 使得视图拒绝任何 AGE 字段为 NULL 的条目，因为视图的定义中，AGE 字段不能为空。对视图不管修改前还是修改后都必须遵从此规定。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"使用视图\"><a href=\"#使用视图\" class=\"headerlink\" title=\"使用视图\"></a>使用视图</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">From</span> view_name</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图的更新（增、删、改）\"><a href=\"#视图的更新（增、删、改）\" class=\"headerlink\" title=\"视图的更新（增、删、改）\"></a>视图的更新（增、删、改）</h2><p>一般来说你可以用<code>update，insert，delete</code>等sql语句修改表中的数据，而对视图只能进行select操作。但是也存在可更新的视图，对于这类视图的<code>update，insert</code>和<code>delete</code>等操作最终会作用于与其相关的表中数据。</p>\n<p>对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。还有一些特定的其他结构，这类结构会使得视图不可更新。如果视图包含下述结构中的任何一种，那么它就是不可更新的：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>非一对一</td>\n<td>DISTINCT关键字、GROUP BY子句、UNION运算符、位于选择列表中的子查询</td>\n</tr>\n<tr>\n<td>未知</td>\n<td>聚合函数、ORDER BY子句、HAVING子句、FROM子句中包含多个表、WHERE子句中的子查询，引用FROM子句中的表</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>SELECT语句中引用了不可更新视图<br>ALGORITHM 选项指定为TEMPTABLE（使用临时表总会使视图成为不可更新的）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> CUSTOMERS_VIEW</span><br><span class=\"line\">     <span class=\"keyword\">VALUES</span>(<span class=\"string\">'李牧'</span>,<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> CUSTOMERS_VIEW <span class=\"keyword\">SET</span> age = <span class=\"number\">58</span> <span class=\"keyword\">where</span> <span class=\"keyword\">name</span> = <span class=\"string\">'李牧'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> CUSTOMERS_VIEW  <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> = <span class=\"string\">'李牧'</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Drop</span> <span class=\"keyword\">View</span> view_name</span><br></pre></td></tr></table></figure>"},{"title":"DML-SQL","date":"2019-07-31T13:07:59.000Z","_content":"\n| 命令     | 作用                                                         |\n| -------- | ------------------------------------------------------------ |\n| `insert` | 插入语句<br>`insert into`:追加数据<br>`insert overwrite`:覆盖数据 |\n| `UPDATE` | 更新语句                                                     |\n| `DELETE` | 删除语句                                                     |\n\n<!--more-->\n\n# 增、删、改\n\n```sql\n-- 插入语句\nInsert Into Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees')\nInsert Into St (S#, Sname, avgScore)\n            Select S#, Sname, Avg(Score) From Student, SC\n            Where Student.S# = SC.S#\n            Group by Student.S# ;\nInsert overwrite St (S#, Sname, avgScore)\n            Select S#, Sname, Avg(Score) From Student, SC\n            Where Student.S# = SC.S#\n            Group by Student.S# ;\n-- 更新语句-UPDATE  修改某一行数据\nUPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson'\n\n-- 删除语句-DELETE\nDELETE FROM Person WHERE LastName = 'Wilson'        --删除行名为Wilson\n```\n\n# 查询语句\n\n```sql\nselect expr,列名 as 列的别名,function(列名) as 列的别名\nfrom 表名 as 表的别名\nwhere 条件(对每一个元组进行过滤)\ngroup by 列名(分组) having 对每一组进行过滤\nOrder by 列名 [asc|desc] \n```\n\n<table>\n  <tr>\n    <th>命令</th>\n    <th>关键字</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"16\">select</td>\n    <td>expr</td>\n    <td colspan=\"2\">常量</td>\n  </tr>\n  <tr>\n    <td>when case</td>\n    <td colspan=\"2\">select when st.score&gt;90 then 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when st.score&lt;60 then 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end label</td>\n  </tr>\n  <tr>\n    <td rowspan=\"14\">function</td>\n    <td>count</td>\n    <td>求个数</td>\n  </tr>\n  <tr>\n    <td>sum</td>\n    <td>求和</td>\n  </tr>\n  <tr>\n    <td>avg</td>\n    <td>求平均</td>\n  </tr>\n  <tr>\n    <td>max</td>\n    <td>求最大</td>\n  </tr>\n  <tr>\n    <td>min</td>\n    <td>求最小</td>\n  </tr>\n  <tr>\n    <td>first</td>\n    <td>返回列中第一个记录的值</td>\n  </tr>\n  <tr>\n    <td>last </td>\n    <td>返回列中最后一个记录的值</td>\n  </tr>\n  <tr>\n    <td>UCASE</td>\n    <td>把字段的值转换为大写</td>\n  </tr>\n  <tr>\n    <td>LCASE</td>\n    <td>把字段的值转换为小写</td>\n  </tr>\n  <tr>\n    <td>MID</td>\n    <td>从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name;<br>column_name：必需。要提取字符的字段。<br>Start：必需。规定开始位置（起始值是 1）。<br>Length：可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。<br></td>\n  </tr>\n  <tr>\n    <td>LEN</td>\n    <td>函数返回文本字段中值的长度</td>\n  </tr>\n  <tr>\n    <td>ROUND</td>\n    <td>函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name;<br>column_name 必需。要舍入的字段。<br>decimals 必需。规定要返回的小数位数。</td>\n  </tr>\n  <tr>\n    <td>NOW</td>\n    <td>函数返回当前系统的日期和时间</td>\n  </tr>\n  <tr>\n    <td>FORMAT</td>\n    <td>FORMAT 函数用于对字段的显示进行格式化。<br><br><br>SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDate<br>FROM Products<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">from</td>\n    <td>原理</td>\n    <td colspan=\"2\">从表格中选取数据，采用<span style=\"font-weight:bold\">笛卡尔积</span></td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">join连接</td>\n    <td>join on<br>inner join on</td>\n    <td>INNER JOIN 与 JOIN 是相同的<br>不保留空值</td>\n  </tr>\n  <tr>\n    <td>Left join on</td>\n    <td>保留左表中所有的数据，右表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Right join on</td>\n    <td>保留右表中所有的数据，左表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Full join on</td>\n    <td>保留两个表中所有的数据，，两个表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">where</td>\n    <td>运算符</td>\n    <td colspan=\"2\">=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">函数</td>\n    <td>between</td>\n    <td>BETWEEN ... AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期</td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">like</td>\n    <td>\"%\" : 可以匹配0个或者多个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“ _ ” :只可以匹配一个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“\\” : 转义字符，用于去掉一些特殊字符 ，使其变为普通字符。比如用\"\\%\"可以去匹配字符%,而“”是去匹配字符“_”.<br></td>\n  </tr>\n  <tr>\n    <td>[charlist]：字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>[^charlist]或者[!charlist]：不在字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>in = exists</td>\n    <td>是否存在</td>\n  </tr>\n  <tr>\n    <td>group by</td>\n    <td>列名</td>\n    <td colspan=\"2\">分组计算</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">having</td>\n    <td rowspan=\"2\">条件</td>\n    <td>函数</td>\n    <td>count、sum、avg、max、min、first、last、UCASE、LCASE、MID、LEN、ROUND、NOW、FORMAT</td>\n  </tr>\n  <tr>\n    <td>运算符</td>\n    <td>=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=；like；in = exists</td>\n  </tr>\n</table>\n\n# 关系代数操作\n\n```sql\n-- 并：求学过002号课的同学或学过003号课的同学学号\nSelect S# From SC Where C# = ‘002’\nUNION [ALL]     --使用ALL命令之后会保留所有重复的元组\nSelect S# From SC Where C# = ‘003’;\n\n-- 交：求既学过002号课，又学过003号课的同学学号\nSelect S# From SC Where C# = ‘002’\nINTERSECT\nSelect S# From SC Where C# = ‘003’;\n\n-- 差：假定所有学生都有选课，求没学过002号课程的学生学号\nSelect DISTINCT S# From SC\nEXCEPT\nSelect S# From SC Where C# = ‘002’;\n```\n\n","source":"_posts/DML-SQL.md","raw":"---\ntitle: DML-SQL\ndate: 2019-07-31 21:07:59\ntags: [数据库,编程语言]\ncategories: SQL\npermalink: SQL/DML-SQL.md\n---\n\n| 命令     | 作用                                                         |\n| -------- | ------------------------------------------------------------ |\n| `insert` | 插入语句<br>`insert into`:追加数据<br>`insert overwrite`:覆盖数据 |\n| `UPDATE` | 更新语句                                                     |\n| `DELETE` | 删除语句                                                     |\n\n<!--more-->\n\n# 增、删、改\n\n```sql\n-- 插入语句\nInsert Into Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees')\nInsert Into St (S#, Sname, avgScore)\n            Select S#, Sname, Avg(Score) From Student, SC\n            Where Student.S# = SC.S#\n            Group by Student.S# ;\nInsert overwrite St (S#, Sname, avgScore)\n            Select S#, Sname, Avg(Score) From Student, SC\n            Where Student.S# = SC.S#\n            Group by Student.S# ;\n-- 更新语句-UPDATE  修改某一行数据\nUPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson'\n\n-- 删除语句-DELETE\nDELETE FROM Person WHERE LastName = 'Wilson'        --删除行名为Wilson\n```\n\n# 查询语句\n\n```sql\nselect expr,列名 as 列的别名,function(列名) as 列的别名\nfrom 表名 as 表的别名\nwhere 条件(对每一个元组进行过滤)\ngroup by 列名(分组) having 对每一组进行过滤\nOrder by 列名 [asc|desc] \n```\n\n<table>\n  <tr>\n    <th>命令</th>\n    <th>关键字</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"16\">select</td>\n    <td>expr</td>\n    <td colspan=\"2\">常量</td>\n  </tr>\n  <tr>\n    <td>when case</td>\n    <td colspan=\"2\">select when st.score&gt;90 then 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when st.score&lt;60 then 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end label</td>\n  </tr>\n  <tr>\n    <td rowspan=\"14\">function</td>\n    <td>count</td>\n    <td>求个数</td>\n  </tr>\n  <tr>\n    <td>sum</td>\n    <td>求和</td>\n  </tr>\n  <tr>\n    <td>avg</td>\n    <td>求平均</td>\n  </tr>\n  <tr>\n    <td>max</td>\n    <td>求最大</td>\n  </tr>\n  <tr>\n    <td>min</td>\n    <td>求最小</td>\n  </tr>\n  <tr>\n    <td>first</td>\n    <td>返回列中第一个记录的值</td>\n  </tr>\n  <tr>\n    <td>last </td>\n    <td>返回列中最后一个记录的值</td>\n  </tr>\n  <tr>\n    <td>UCASE</td>\n    <td>把字段的值转换为大写</td>\n  </tr>\n  <tr>\n    <td>LCASE</td>\n    <td>把字段的值转换为小写</td>\n  </tr>\n  <tr>\n    <td>MID</td>\n    <td>从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name;<br>column_name：必需。要提取字符的字段。<br>Start：必需。规定开始位置（起始值是 1）。<br>Length：可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。<br></td>\n  </tr>\n  <tr>\n    <td>LEN</td>\n    <td>函数返回文本字段中值的长度</td>\n  </tr>\n  <tr>\n    <td>ROUND</td>\n    <td>函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name;<br>column_name 必需。要舍入的字段。<br>decimals 必需。规定要返回的小数位数。</td>\n  </tr>\n  <tr>\n    <td>NOW</td>\n    <td>函数返回当前系统的日期和时间</td>\n  </tr>\n  <tr>\n    <td>FORMAT</td>\n    <td>FORMAT 函数用于对字段的显示进行格式化。<br><br><br>SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDate<br>FROM Products<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">from</td>\n    <td>原理</td>\n    <td colspan=\"2\">从表格中选取数据，采用<span style=\"font-weight:bold\">笛卡尔积</span></td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">join连接</td>\n    <td>join on<br>inner join on</td>\n    <td>INNER JOIN 与 JOIN 是相同的<br>不保留空值</td>\n  </tr>\n  <tr>\n    <td>Left join on</td>\n    <td>保留左表中所有的数据，右表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Right join on</td>\n    <td>保留右表中所有的数据，左表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Full join on</td>\n    <td>保留两个表中所有的数据，，两个表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">where</td>\n    <td>运算符</td>\n    <td colspan=\"2\">=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">函数</td>\n    <td>between</td>\n    <td>BETWEEN ... AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期</td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">like</td>\n    <td>\"%\" : 可以匹配0个或者多个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“ _ ” :只可以匹配一个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“\\” : 转义字符，用于去掉一些特殊字符 ，使其变为普通字符。比如用\"\\%\"可以去匹配字符%,而“”是去匹配字符“_”.<br></td>\n  </tr>\n  <tr>\n    <td>[charlist]：字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>[^charlist]或者[!charlist]：不在字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>in = exists</td>\n    <td>是否存在</td>\n  </tr>\n  <tr>\n    <td>group by</td>\n    <td>列名</td>\n    <td colspan=\"2\">分组计算</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">having</td>\n    <td rowspan=\"2\">条件</td>\n    <td>函数</td>\n    <td>count、sum、avg、max、min、first、last、UCASE、LCASE、MID、LEN、ROUND、NOW、FORMAT</td>\n  </tr>\n  <tr>\n    <td>运算符</td>\n    <td>=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=；like；in = exists</td>\n  </tr>\n</table>\n\n# 关系代数操作\n\n```sql\n-- 并：求学过002号课的同学或学过003号课的同学学号\nSelect S# From SC Where C# = ‘002’\nUNION [ALL]     --使用ALL命令之后会保留所有重复的元组\nSelect S# From SC Where C# = ‘003’;\n\n-- 交：求既学过002号课，又学过003号课的同学学号\nSelect S# From SC Where C# = ‘002’\nINTERSECT\nSelect S# From SC Where C# = ‘003’;\n\n-- 差：假定所有学生都有选课，求没学过002号课程的学生学号\nSelect DISTINCT S# From SC\nEXCEPT\nSelect S# From SC Where C# = ‘002’;\n```\n\n","slug":"SQL/DML-SQL.md","published":1,"updated":"2019-08-12T06:56:48.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iy6001lhomjjvm1s79z","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert</code></td>\n<td>插入语句<br><code>insert into</code>:追加数据<br><code>insert overwrite</code>:覆盖数据</td>\n</tr>\n<tr>\n<td><code>UPDATE</code></td>\n<td>更新语句</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>删除语句</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"增、删、改\"><a href=\"#增、删、改\" class=\"headerlink\" title=\"增、删、改\"></a>增、删、改</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入语句</span></span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">Into</span> Persons (LastName, Address) <span class=\"keyword\">VALUES</span> (<span class=\"string\">'Wilson'</span>, <span class=\"string\">'Champs-Elysees'</span>)</span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">Into</span> St (S#, Sname, avgScore)</span><br><span class=\"line\">            <span class=\"keyword\">Select</span> S#, Sname, <span class=\"keyword\">Avg</span>(Score) <span class=\"keyword\">From</span> Student, SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Student.S# = SC.S#</span><br><span class=\"line\">            <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> Student.S# ;</span><br><span class=\"line\"><span class=\"keyword\">Insert</span> overwrite St (S#, Sname, avgScore)</span><br><span class=\"line\">            <span class=\"keyword\">Select</span> S#, Sname, <span class=\"keyword\">Avg</span>(Score) <span class=\"keyword\">From</span> Student, SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Student.S# = SC.S#</span><br><span class=\"line\">            <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> Student.S# ;</span><br><span class=\"line\"><span class=\"comment\">-- 更新语句-UPDATE  修改某一行数据</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Person <span class=\"keyword\">SET</span> Address = <span class=\"string\">'Zhongshan 23'</span>, City = <span class=\"string\">'Nanjing'</span> <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除语句-DELETE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Person <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span>        <span class=\"comment\">--删除行名为Wilson</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> expr,列名 <span class=\"keyword\">as</span> 列的别名,<span class=\"keyword\">function</span>(列名) <span class=\"keyword\">as</span> 列的别名</span><br><span class=\"line\"><span class=\"keyword\">from</span> 表名 <span class=\"keyword\">as</span> 表的别名</span><br><span class=\"line\"><span class=\"keyword\">where</span> 条件(对每一个元组进行过滤)</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> 列名(分组) <span class=\"keyword\">having</span> 对每一组进行过滤</span><br><span class=\"line\"><span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> 列名 [<span class=\"keyword\">asc</span>|<span class=\"keyword\">desc</span>]</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>命令</th>\n    <th>关键字</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"16\">select</td>\n    <td>expr</td>\n    <td colspan=\"2\">常量</td>\n  </tr>\n  <tr>\n    <td>when case</td>\n    <td colspan=\"2\">select when st.score&gt;90 then 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when st.score&lt;60 then 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end label</td>\n  </tr>\n  <tr>\n    <td rowspan=\"14\">function</td>\n    <td>count</td>\n    <td>求个数</td>\n  </tr>\n  <tr>\n    <td>sum</td>\n    <td>求和</td>\n  </tr>\n  <tr>\n    <td>avg</td>\n    <td>求平均</td>\n  </tr>\n  <tr>\n    <td>max</td>\n    <td>求最大</td>\n  </tr>\n  <tr>\n    <td>min</td>\n    <td>求最小</td>\n  </tr>\n  <tr>\n    <td>first</td>\n    <td>返回列中第一个记录的值</td>\n  </tr>\n  <tr>\n    <td>last </td>\n    <td>返回列中最后一个记录的值</td>\n  </tr>\n  <tr>\n    <td>UCASE</td>\n    <td>把字段的值转换为大写</td>\n  </tr>\n  <tr>\n    <td>LCASE</td>\n    <td>把字段的值转换为小写</td>\n  </tr>\n  <tr>\n    <td>MID</td>\n    <td>从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name;<br>column_name：必需。要提取字符的字段。<br>Start：必需。规定开始位置（起始值是 1）。<br>Length：可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。<br></td>\n  </tr>\n  <tr>\n    <td>LEN</td>\n    <td>函数返回文本字段中值的长度</td>\n  </tr>\n  <tr>\n    <td>ROUND</td>\n    <td>函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name;<br>column_name 必需。要舍入的字段。<br>decimals 必需。规定要返回的小数位数。</td>\n  </tr>\n  <tr>\n    <td>NOW</td>\n    <td>函数返回当前系统的日期和时间</td>\n  </tr>\n  <tr>\n    <td>FORMAT</td>\n    <td>FORMAT 函数用于对字段的显示进行格式化。<br><br><br>SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDate<br>FROM Products<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">from</td>\n    <td>原理</td>\n    <td colspan=\"2\">从表格中选取数据，采用<span style=\"font-weight:bold\">笛卡尔积</span></td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">join连接</td>\n    <td>join on<br>inner join on</td>\n    <td>INNER JOIN 与 JOIN 是相同的<br>不保留空值</td>\n  </tr>\n  <tr>\n    <td>Left join on</td>\n    <td>保留左表中所有的数据，右表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Right join on</td>\n    <td>保留右表中所有的数据，左表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Full join on</td>\n    <td>保留两个表中所有的数据，，两个表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">where</td>\n    <td>运算符</td>\n    <td colspan=\"2\">=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">函数</td>\n    <td>between</td>\n    <td>BETWEEN ... AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期</td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">like</td>\n    <td>\"%\" : 可以匹配0个或者多个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“ _ ” :只可以匹配一个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“\\” : 转义字符，用于去掉一些特殊字符 ，使其变为普通字符。比如用\"\\%\"可以去匹配字符%,而“”是去匹配字符“_”.<br></td>\n  </tr>\n  <tr>\n    <td>[charlist]：字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>[^charlist]或者[!charlist]：不在字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>in = exists</td>\n    <td>是否存在</td>\n  </tr>\n  <tr>\n    <td>group by</td>\n    <td>列名</td>\n    <td colspan=\"2\">分组计算</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">having</td>\n    <td rowspan=\"2\">条件</td>\n    <td>函数</td>\n    <td>count、sum、avg、max、min、first、last、UCASE、LCASE、MID、LEN、ROUND、NOW、FORMAT</td>\n  </tr>\n  <tr>\n    <td>运算符</td>\n    <td>=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=；like；in = exists</td>\n  </tr>\n</table>\n\n<h1 id=\"关系代数操作\"><a href=\"#关系代数操作\" class=\"headerlink\" title=\"关系代数操作\"></a>关系代数操作</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 并：求学过002号课的同学或学过003号课的同学学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> [ALL]     <span class=\"comment\">--使用ALL命令之后会保留所有重复的元组</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">003</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 交：求既学过002号课，又学过003号课的同学学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">INTERSECT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">003</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 差：假定所有学生都有选课，求没学过002号课程的学生学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC</span><br><span class=\"line\"><span class=\"keyword\">EXCEPT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>insert</code></td>\n<td>插入语句<br><code>insert into</code>:追加数据<br><code>insert overwrite</code>:覆盖数据</td>\n</tr>\n<tr>\n<td><code>UPDATE</code></td>\n<td>更新语句</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>删除语句</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"增、删、改\"><a href=\"#增、删、改\" class=\"headerlink\" title=\"增、删、改\"></a>增、删、改</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入语句</span></span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">Into</span> Persons (LastName, Address) <span class=\"keyword\">VALUES</span> (<span class=\"string\">'Wilson'</span>, <span class=\"string\">'Champs-Elysees'</span>)</span><br><span class=\"line\"><span class=\"keyword\">Insert</span> <span class=\"keyword\">Into</span> St (S#, Sname, avgScore)</span><br><span class=\"line\">            <span class=\"keyword\">Select</span> S#, Sname, <span class=\"keyword\">Avg</span>(Score) <span class=\"keyword\">From</span> Student, SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Student.S# = SC.S#</span><br><span class=\"line\">            <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> Student.S# ;</span><br><span class=\"line\"><span class=\"keyword\">Insert</span> overwrite St (S#, Sname, avgScore)</span><br><span class=\"line\">            <span class=\"keyword\">Select</span> S#, Sname, <span class=\"keyword\">Avg</span>(Score) <span class=\"keyword\">From</span> Student, SC</span><br><span class=\"line\">            <span class=\"keyword\">Where</span> Student.S# = SC.S#</span><br><span class=\"line\">            <span class=\"keyword\">Group</span> <span class=\"keyword\">by</span> Student.S# ;</span><br><span class=\"line\"><span class=\"comment\">-- 更新语句-UPDATE  修改某一行数据</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> Person <span class=\"keyword\">SET</span> Address = <span class=\"string\">'Zhongshan 23'</span>, City = <span class=\"string\">'Nanjing'</span> <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除语句-DELETE</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Person <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span>        <span class=\"comment\">--删除行名为Wilson</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"查询语句\"><a href=\"#查询语句\" class=\"headerlink\" title=\"查询语句\"></a>查询语句</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> expr,列名 <span class=\"keyword\">as</span> 列的别名,<span class=\"keyword\">function</span>(列名) <span class=\"keyword\">as</span> 列的别名</span><br><span class=\"line\"><span class=\"keyword\">from</span> 表名 <span class=\"keyword\">as</span> 表的别名</span><br><span class=\"line\"><span class=\"keyword\">where</span> 条件(对每一个元组进行过滤)</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> 列名(分组) <span class=\"keyword\">having</span> 对每一组进行过滤</span><br><span class=\"line\"><span class=\"keyword\">Order</span> <span class=\"keyword\">by</span> 列名 [<span class=\"keyword\">asc</span>|<span class=\"keyword\">desc</span>]</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>命令</th>\n    <th>关键字</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"16\">select</td>\n    <td>expr</td>\n    <td colspan=\"2\">常量</td>\n  </tr>\n  <tr>\n    <td>when case</td>\n    <td colspan=\"2\">select when st.score&gt;90 then 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when st.score&lt;60 then 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end label</td>\n  </tr>\n  <tr>\n    <td rowspan=\"14\">function</td>\n    <td>count</td>\n    <td>求个数</td>\n  </tr>\n  <tr>\n    <td>sum</td>\n    <td>求和</td>\n  </tr>\n  <tr>\n    <td>avg</td>\n    <td>求平均</td>\n  </tr>\n  <tr>\n    <td>max</td>\n    <td>求最大</td>\n  </tr>\n  <tr>\n    <td>min</td>\n    <td>求最小</td>\n  </tr>\n  <tr>\n    <td>first</td>\n    <td>返回列中第一个记录的值</td>\n  </tr>\n  <tr>\n    <td>last </td>\n    <td>返回列中最后一个记录的值</td>\n  </tr>\n  <tr>\n    <td>UCASE</td>\n    <td>把字段的值转换为大写</td>\n  </tr>\n  <tr>\n    <td>LCASE</td>\n    <td>把字段的值转换为小写</td>\n  </tr>\n  <tr>\n    <td>MID</td>\n    <td>从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name;<br>column_name：必需。要提取字符的字段。<br>Start：必需。规定开始位置（起始值是 1）。<br>Length：可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。<br></td>\n  </tr>\n  <tr>\n    <td>LEN</td>\n    <td>函数返回文本字段中值的长度</td>\n  </tr>\n  <tr>\n    <td>ROUND</td>\n    <td>函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name;<br>column_name 必需。要舍入的字段。<br>decimals 必需。规定要返回的小数位数。</td>\n  </tr>\n  <tr>\n    <td>NOW</td>\n    <td>函数返回当前系统的日期和时间</td>\n  </tr>\n  <tr>\n    <td>FORMAT</td>\n    <td>FORMAT 函数用于对字段的显示进行格式化。<br><br><br>SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDate<br>FROM Products<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">from</td>\n    <td>原理</td>\n    <td colspan=\"2\">从表格中选取数据，采用<span style=\"font-weight:bold\">笛卡尔积</span></td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">join连接</td>\n    <td>join on<br>inner join on</td>\n    <td>INNER JOIN 与 JOIN 是相同的<br>不保留空值</td>\n  </tr>\n  <tr>\n    <td>Left join on</td>\n    <td>保留左表中所有的数据，右表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Right join on</td>\n    <td>保留右表中所有的数据，左表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td>Full join on</td>\n    <td>保留两个表中所有的数据，，两个表中不能匹配的数据使用空值填充</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">where</td>\n    <td>运算符</td>\n    <td colspan=\"2\">=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=</td>\n  </tr>\n  <tr>\n    <td rowspan=\"7\">函数</td>\n    <td>between</td>\n    <td>BETWEEN ... AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期</td>\n  </tr>\n  <tr>\n    <td rowspan=\"5\">like</td>\n    <td>\"%\" : 可以匹配0个或者多个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“ _ ” :只可以匹配一个字符 <br></td>\n  </tr>\n  <tr>\n    <td>“\\” : 转义字符，用于去掉一些特殊字符 ，使其变为普通字符。比如用\"\\%\"可以去匹配字符%,而“”是去匹配字符“_”.<br></td>\n  </tr>\n  <tr>\n    <td>[charlist]：字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>[^charlist]或者[!charlist]：不在字符列中的任何单一字符</td>\n  </tr>\n  <tr>\n    <td>in = exists</td>\n    <td>是否存在</td>\n  </tr>\n  <tr>\n    <td>group by</td>\n    <td>列名</td>\n    <td colspan=\"2\">分组计算</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">having</td>\n    <td rowspan=\"2\">条件</td>\n    <td>函数</td>\n    <td>count、sum、avg、max、min、first、last、UCASE、LCASE、MID、LEN、ROUND、NOW、FORMAT</td>\n  </tr>\n  <tr>\n    <td>运算符</td>\n    <td>=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=；like；in = exists</td>\n  </tr>\n</table>\n\n<h1 id=\"关系代数操作\"><a href=\"#关系代数操作\" class=\"headerlink\" title=\"关系代数操作\"></a>关系代数操作</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 并：求学过002号课的同学或学过003号课的同学学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> [ALL]     <span class=\"comment\">--使用ALL命令之后会保留所有重复的元组</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">003</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 交：求既学过002号课，又学过003号课的同学学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’</span><br><span class=\"line\"><span class=\"keyword\">INTERSECT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">003</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 差：假定所有学生都有选课，求没学过002号课程的学生学号</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> <span class=\"keyword\">DISTINCT</span> S# <span class=\"keyword\">From</span> SC</span><br><span class=\"line\"><span class=\"keyword\">EXCEPT</span></span><br><span class=\"line\"><span class=\"keyword\">Select</span> S# <span class=\"keyword\">From</span> SC <span class=\"keyword\">Where</span> C# = ‘<span class=\"number\">002</span>’;</span><br></pre></td></tr></table></figure>"},{"title":"GBDT","date":"2017-10-20T07:50:16.000Z","_content":"\n\n# [简介](https://www.cnblogs.com/pinard/p/6140514.html)\nGBDT也是集成学习Boosting家族的成员,由梯度提升方法与回归树结合而成。\n分类|损失函数\n回归|$(y-\\hat y)^2$\n分类|$p_K log_2 \\; p_K$\n\n\n\n<!--more-->\n## [回归树](/2017/07/21/回归树)\n回归树生成算法\n![](GBDT/GBDT-f5523f89.png)\n\n## 提升树\n提升树可以表示为以下形式：这里我们约定 $T(x;Θ_m)$ 表示第 $m$ 棵决策树；$Θ_m$表示决策树的参数；$M$ 为树的个数。强分类器 $f_M(x)$ 可以由多个弱分类器 $T(x;Θ_m)$ 线性相加而成\n$$f_M (x)=\\sum_{m=1}^MT(x;Θ_m )$$\n提升树的前向分步算法。第$m$步的模型可以写成\n$$f_m (x)=f_{m-1} (x)+ T(x;Θ_m )$$\n然后得到损失函数\n$$L(f_m (x),y)=L(f_{m-1} (x)+ T(x;Θ_m ),y)$$\n迭代的目的是构建 $T(x;Θ_m)$，使得本轮损失 $L(f_m(x),y)$ 最小。思想其实并不复杂，但是问题也很明显，对于不同的任务会有不同的损失函数，当损失函数是平方损失和指数损失函数时，每一步的优化还是简单的。但是对于一般损失函数而言，每一步的优化并不容易\n### 提升树算法\n\n![](GBDT/GBDT-8717e980.png)\n\n## 梯度提升树\n**采用泰勒展开式将上式中的残差展开，**\n### [泰勒公式](/2017/08/14/微积分)\n一元函数在点$x_k$处的泰勒展开式为：\n$$f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n$$\n\n### 拟合残差的近似\n梯度提升思想正是为了解决上面的问题。它的主要思想是先求$h_m$，再求$β_m$。观察式子\n$$\\sum _{i=1}^N = L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))$$\n我们要最小化的式子由N部分相加而成，如果能够最小化每一部分，自然也就最小化了整个式子。考察其中任一部分，并将其进行泰勒一阶展开\n$$L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))=L(y_i,f_{m-1}(x_i))+\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} \\\\\nL(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))=\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} $$\n由于需要\n$$L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))<0\\Rightarrow \\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} <0$$\n由于$β$是大于0的，则$$h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}$$\n这说明，我们已经成功地降低了在第$i$个样本点上的预测损失。同理，我们可以降低在每一个样本点上的预测损失。条件就是\n$$h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}$$\n这个条件其实告诉了我们如何去寻找基学习器$h_m$，用回归树拟合$h_m(x_i)$。我们已经有了$h_m$，下面优化求解$β$，很显然，这是一个一维搜索问题，如下：\n$$β_m=\\underset{β}{argmin}\\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+βh_m(x_i))$$\n在上面的泰勒一阶展开时，有一个条件就是$βh_m(x_i)$要足够小，显然，执行一维搜索后得到的β会满足这个条件\n# GBDT算法\n\n![](GBDT/GBDT-df9b76dd.png)\n\n以上算法将回归树和提升树的算法结合起来，在第5步中求解 $c_{m,j}$ ，如果损失函数为平方损失函数，则解法与前面的回归树一致，直接取均值即可。如果是其他损失函数，则需要具体进行求解。具体而言，就是取导数为零来解等式\n\n# GBDT回归算法\n\n![](GBDT/GBDT-94935eb2.png)\n\n## 实例\n\n编号 | 年龄(岁) | 体重（kg） | 身高(m)(标签值)\n-|-|-|-\n1 | 5 | 20 | 1.1\n2 | 7 | 30 | 1.3\n3 | 21 | 70 | 1.7\n4 | 30 | 60 | 1.8\n5(要预测的) | 25 | 65 | ？\n\n**设损失函数为平方差函数**\n$$ L(y_i,f(x_i))=\\left(\\frac{1}{2}\\right)*(y_i-f(x_i))^2$$\n\n\n### 1、初始化学习器 $f_0(x)$\n$$f_0(x) =arg\\; \\underset{c}{min}\\sum\\limits_{i=1}^{N}L(y_i, c)=arg\\; \\underset{c}{min}\\sum _{i=1}^N(y_i-c)^2$$\n由于此时只有根结点，样本１,２，３,４都在根结点，此时要找到使得平方损失函数最小的参数$c$，怎么求呢？平方损失显然是一个凸函数，直接求导，倒数等于零，得到$c$。\n$$\\frac{\\partial L(y_i,c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i)$$\n令$\\sum _{i=1}^N (c-y_i)=0$，得$c=\\overline{y}$。\n所以初始化时，$c$取值为所有训练样本标签值的均值。$c=(1.1+1.3+1.7+1.8)/4=1.475$，此时得到初始学习器 $f_0(x)$。\n$$f_0(x)=c=1.475$$\n### 2、对迭代轮数m=1:\n计算负梯度——残差\n$$r_{i1} = -\\bigg[\\frac{\\partial L(y_i, f(x_i))}{\\partial f(x_i)}\\bigg]_{f(x) = f_{0} (x)}=-\\frac{\\partial \\sum _{i=1}^N(y_i- f_0(x_i))^2}{2\\partial f_0(x_i)}=\\sum _{i=1}^N(y_i- f_0(x_i))$$\n说白了，就是残差（上面已经解释过了），在此例中，残差在下表列出：\n\n编号 | 年龄(岁) | 体重（kg） | 身高(m)(标签值) | $f_0(x)$ | 残差\n:-:|:-:|:-:|:-:|:-:|:-:\n1 | 5 | 20 | 1.1 | 1.475 | -0.375\n2 | 7 | 30 | 1.3 | 1.475 | -0.175\n3 | 21 | 70 | 1.7 | 1.475 | 0.225\n4 | 30 | 60 | 1.8 | 1.475 | 0.325\n\n此时将残差作为样本的目标值训练$f_1(x)$，寻找回归树的最佳划分结点，遍历每个特征的每个可能取值。从年龄特征的5开始，到体重特征的70结束，分别计算方差，找到使损失函数最小的那个划分结点即为最佳划分结点。例如：以年龄7为划分结点，将小于7的样本划分为一类，大于等于7的样本划分为另一类。样本1为一组，样本2，3，4为一组，两组的方差分别为0，0.047，两组方差之和为0.047。所有可能划分情况如下表所示\n$$\\overline{x} = (-0.175+0.225+0.325)/3=0.125\\\\\n0.047 =[ (-0.175-\\overline{x})^2+(0.225-\\overline{x})^2+(0.325-\\overline{x})^2]/3\n$$\n\n划分点 | 小于划分点的样本 | 大于等于划分点的样本 | 总方差\n-|-|-|-\n年龄5 | / | 1，2，3，4 | 0.082\n年龄7 | 1 | 2，3，4 | 0.047\n年龄21 | 1，2 | 3，4 | 0.0125\n年龄30 | 1，2，3 | 4 | 0.062\n体重20 | / | 1，2，3，4 | 0.082\n体重30 | 1 | 2，3，4 | 0.047\n体重60 | 1，2 | 3，4 | 0.0125\n体重70 | 1，2，4 | 3 | 0.0867\n\n\n以上划分点的损失函数最小为0.0125，有两个划分点分别为年龄21和体重60，所以随机选一个作为划分点，这里我们选年龄21。\n此时还需要做一件事情，给这两个叶子结点分别赋一个参数，来拟合残差。\n$$c_{j1} =arg\\; \\underset{c}{min}\\sum\\limits_{x_i \\in R_{j1}} L(y_i,f_{0}(x_i) +c)$$\n\n这里其实和上面初始化学习器是一个道理，平方损失，求导，\n$$\\frac{\\partial L(y_i,f_0(x_i)+c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-f_0(x_i)-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i+f_0(x_i))$$\n令导数等于零$\\sum _{i=1}^N (c-y_i+f_0(x_i))=0$化简之后得到每个叶子结点的参数$c$，其实就是标签值的均值$c=\\overline{y_i-f_0(x_i)}$。\n根据上述划分结点：\n- 样本1，2为左叶子结点，$(x_1,x_2 \\in R_{11})$，所以$c_{11}=(−0.375−0.175)/2=−0.275。 $\n- 样本3，4为右叶子结点，$(x_3,x_4 \\in R_{11})$，所以$c_{21}=(0.225+0.325)/2=0.275。 $\n\n此时可更新强学习器 $$f_{1}(x) = f_{0}(x) + \\sum\\limits_{j=1}^{2}c_{j1}I(x \\in R_{j1})$$\n\n### 3、对迭代轮数m=2,3,4,5,…,M:\n循环迭代$M$次，$M$是人为控制的参数，迭代结束生成M棵树\n\n### 4、得到最后的强学习器：\n为了方别展示和理解，我们假设$Ｍ＝１$，根据上述结果得到强学习器：\n$$f(x) = f_M(x) =f_0(x) + \\sum\\limits_{m=1}^{M}\\sum\\limits_{j=1}^{J}c_{jm}I(x \\in R_{jm})$$\n\n![](GBDT/GBDT-19fece56.png)\n\n\n# GBDT分类算法\n## 二元GBDT分类算法\n### 假设条件\n- 类别1的概率为:$p_1=\\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}}$\n- 类别2的概率为:$p_2=1-p_2=\\frac{e^{f_2(x)}}{e^{f_1(x)}+e^{f_2(x)}}$\n\n$$\\begin{align*}\np_1 &= \\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}} = \\frac{1}{1+e^{f_2(x)/f_1(x)}}=\\frac{1}{1+e^{f(x)}}   \\\\\np_2 &= 1-p_1  =\\frac{e^{f(x)}}{1+e^{f(x)}}\n\\end{align*}$$\n\n### 损失函数化简\n对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：\n$$\\large L\\left(y,f(x)\\right)=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}$$\n其中$\\large p=\\frac{1}{1+e^{f(x)}}$\n$$\\begin{align*}\n\\large L\\left(y,f(x)\\right)&=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}\\\\\n &=-\\left \\{ ylog\\frac{e^{f(x)}}{1+e^{f(x)}} + (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=-\\left \\{ ylog\\frac{1}{1+e^{f(x)}} + ylog\\; e^{f(x)}+ (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=- \\left \\{ yf(x)-log\\left [ 1+e^{f(x)} \\right ] \\right \\}\n\\end{align*}$$\n\n### 算法简介\n\n![](GBDT/GBDT-42bbe544.png)\n### 实例\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$y_i$ | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1\n\n#### 第一棵树\n##### 推导\n$$\\begin{align*}\nL\\left(y_i,c\\right)&=-\\left\\{y_ic-log\\left(1+e^{c}\\right)\\right\\} \\\\\n\\frac{\\partial L\\left(y_i,c\\right)}{\\partial c} &= \\frac{e^{c}}{1+e^{c}}-y=0 \\\\\n\\frac{e^{c}}{1+e^{c}}&=y \\\\\nc &= log \\frac{y}{1-y}=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)\n\\end{align*}$$\n##### 计算\n$$f_0(x)=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)=log\\left(\\frac{4}{6}\\right)=-0.4054$$\n\n#### 对迭代轮数m=1\n$$r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N$$\n\n$$r_{1,i}=y_1-\\frac{1}{1+e^{-f_{0}(x_1)}}=0-\\frac{1}{1+e^{-0.4054}}=-0.4$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$r_{1,i}$ | -0.4 | -0.4 | -0.4 | 0.6 | 0.6 | -0.4 | -0.4 | -0.4 | 0.6 | 0.6\n\n接着，我们需要以$r_{1,i}$为目标，拟合一颗树。\n\n划分点 | 小于等于划分点的样本 | 大于划分点的样本 | 总方差\n-|-|-|-\n1 | 1 | 2，3，4，5，6，7，8，9，10 | 0.2469\n2 | 1，2 | 3，4，5，6，7，8，9，10 | 0.25\n3 | 1，2，3 | 4，5，6，7，8，9，10 | 0.2449\n4 | 1，2，3，4 | 5，6，7，8，9，10 | 0.4375\n5 | 1，2，3，4，5 | 6，7，8，9，10 | 0.48\n6 | 1，2，3，4，5，6 | 7，8，9，10 | 0.4722\n7 | 1，2，3，4，5，6，7 | 8，9，10 | 0.4263\n8 | 1，2，3，4，5，6，7，8 | 9，10 | 0.1875\n9 | 1，2，3，4，5，6，7，8，9 | 10 | 0.2222\n10 | 1，2，3，4，5，6，7，8，9，10 | \\ | 0.24\n\n由此可知当切分点为8时，总方差最小。所以$R_{11}:x_i\\leqslant 8,R_{11}:x_i> 8$\n\n##### 输出$c_{m,j}$\n$$c_{m,j} =\\left. \\sum_{x_i\\in R_{m,j}} r_{m,i} \\middle / \\sum_{x_i\\in R_{m,j}} |r_{m,i}|(1-|r_{m,i}|) \\right. $$\n\n$$c_{1,1}=-0.625 \\;\\;\\;\\;\\;\\;\\; c_{1,2}=2.5$$\n\n$$f_{1,i}=\\sum_{j=1}^Jc_{jm}I(x \\in R_{jm})=\\left\\{\\begin{matrix}\n-0.4054-0.625=--1.0304\\\\\n-0.4054+2.5=2.0946\n\\end{matrix}\\right.$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$f_{1,i}(x_i)$ | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | 2.0946 | 2.0946\n\n\n#### 对迭代轮数m=2\n\n其残差为\n$$$$r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N$$$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$f_{1,i}(x_i)$ | -0.3569  | -0.3569  | -0.3569  | 0.6431  | 0.6431  | -0.3569  | -0.3569  | -0.3569  | -7.1222  | -7.1222\n\n继续拟合第二可数\n\n#### 综上\n一共拟合$M$棵树\n\n\n## 多元GBDT分类算法\n\n![](GBDT/GBDT-b9b2986e.png)\n\n\n### 示例\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_i$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2\n$y_{i,0}$ | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0\n$y_{i,1}$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0\n$y_{i,2}$ | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1\n\n#### 根学习器\n首先进行初始化$f_{k0}(x_i)=0$，对所有的样本\n$$ \\begin{align*}\np_{m,k}(x)&=\\frac{e^{f_{m,k}(x)}}{\\sum_{l=1}^K e^{f_{m,l(x)}}}\\\\\np_{0,0}(x)&=\\frac{e^{f_{0,0}(x)}}{\\sum_{l=1}^K e^{f_{0,l(x)}}}=0.3333\n\\end{align*}$$\n#### 迭代轮数m=1\n##### 第一个类别$(y_i=0)$拟合第一棵树$(m=1)$\n\n$$\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}$$\n\n$x_i$|6|12|14|18|20|65|31|40|1|2|100|101|65|54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_{i,0}$ | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0\n$p_{0,0}$|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333\n$r_{1,i,0}$|0.6667|0.6667|0.6667|0.6667|0.6667|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333\n\n- 选择切分点进行拟合\n计算完后可以发现，当选择31做为分裂点时，可以得到最小的$MSE，MSE=0.4879$\n\n划分点 | 小于等于划分点的样本 | 大于划分点的样本 | 总方差\n-|-|-|-\n1 | 1 | 2，6，12，14，18，20，31，40，54，65，65，100，101| 1.0036\n2 | 1，2 | 6，12，14，18，20，31，40，54，65，65，100，101 | 0.5063\n6 | 1，2，6 | 12，14，18，20，31，40，54，65，65，100，101 | 0.5149\n12 | 1，2，6，12 | 14，18，20，31，40，54，65，65，100，101 | 0.5222\n14 | 1，2，6，12，14 | 18，20，31，40，54，65，65，100，101 | 0.5270\n18 | 1，2，6，12，14，18 | 20，31，40，54，65，65，100，101 | 0.5270\n20 | 1，2，6，12，14，18，20 | 31，40，54，65，65，100，101 | 0.5175\n31 | 1，2，6，12，14，18，20，31 | 40，54，65，65，100，101 | 0.4879\n40 | 1，2，6，12，14，18，20，31，40 | 54，65，65，100，101 | 0.5163\n54 | 1，2，6，12，14，18，20，31，40，54 | 65，65，100，101 | 0.9012\n65 | 1，2，6，12，14，18，20，31，40，54，65，65 | 100，101 | 1.060\n100 | 1，14，18，20，31，40，54，65，65，100| 101 | 0.5045\n101 | 1，2，6，12，14，18，20，31，40，54，65，65，100，101| \\ | 0.5149\n\n- 计算$c_{m,j,l}$\n$$\\begin{align*}\nc_{mjl}&=\\frac{K-1}{K}\\frac{\\sum\\limits_{x_i \\in R_{mjl}}r_{mil}}{\\sum\\limits_{x_i \\in R_{mil}}|r_{mil}|(1-|r_{mil}|)}\\\\\nc_{110} &= 0.8751 \\\\\nc_{120} &= -0.9999\n\\end{align*}$$\n\n$$f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})$$\n\n\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$f_{m,k}(x_i)=f_{1,0}(x_i)$ | 1.1428 | 1.1428 | 1.1428 | 1.1428 | 1.1428 | -0.999 | -0.999 | -0.999 | 1.1428 | 1.1428 | -0.999 | -0.999 | -0.999 | -0.999\n\n##### 第二个类别（y_i=1)拟合第一颗树$(m=1)$\n$$\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}$$\n\n$x_i$|6|12|14|18|20|65|31|40|1|2|100|101|65|54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_{i,1}$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0\n$p_{0,1}$|0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333\n$r_{1,i,1}$|-0.3333 | -0.3333 | -0.3333 | -0.3333 | -0.3333 | 0.6667 | 0.6667 | 0.6667 | 0.6667 | 0.6667 | -0.3333 | -0.3333 | -0.3333 | -0.3333\n\n以$r_{1,i,1}$拟合一颗回归树，（以6为分裂点）,可计算得到叶子结点\n$$c_{111}=2 \\;\\;\\;\\;\\;c_{121}=0.2499$$\n\n$$f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})$$\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$f_{m,k}(x_i)=f_{1,1}(x_i)$ | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | 2 | 2 | -0.2499 | -0.2499 | -0.2499 | -0.2499\n\n### 综上\n然后再拟合第三个类别（类别2）的第一颗树，过程也是重复上述步骤，所以这里就不再重复了。在拟合完所有类别的第一颗树后就开始拟合第二颗树。反复进行，直到训练了$M$轮。\n","source":"_posts/GBDT.md","raw":"---\ntitle: GBDT\ndate: 2017-10-20 15:50:16\ntags: [人工智能,模型,树模型,集成学习]\ncategories: 机器学习\n---\n\n\n# [简介](https://www.cnblogs.com/pinard/p/6140514.html)\nGBDT也是集成学习Boosting家族的成员,由梯度提升方法与回归树结合而成。\n分类|损失函数\n回归|$(y-\\hat y)^2$\n分类|$p_K log_2 \\; p_K$\n\n\n\n<!--more-->\n## [回归树](/2017/07/21/回归树)\n回归树生成算法\n![](GBDT/GBDT-f5523f89.png)\n\n## 提升树\n提升树可以表示为以下形式：这里我们约定 $T(x;Θ_m)$ 表示第 $m$ 棵决策树；$Θ_m$表示决策树的参数；$M$ 为树的个数。强分类器 $f_M(x)$ 可以由多个弱分类器 $T(x;Θ_m)$ 线性相加而成\n$$f_M (x)=\\sum_{m=1}^MT(x;Θ_m )$$\n提升树的前向分步算法。第$m$步的模型可以写成\n$$f_m (x)=f_{m-1} (x)+ T(x;Θ_m )$$\n然后得到损失函数\n$$L(f_m (x),y)=L(f_{m-1} (x)+ T(x;Θ_m ),y)$$\n迭代的目的是构建 $T(x;Θ_m)$，使得本轮损失 $L(f_m(x),y)$ 最小。思想其实并不复杂，但是问题也很明显，对于不同的任务会有不同的损失函数，当损失函数是平方损失和指数损失函数时，每一步的优化还是简单的。但是对于一般损失函数而言，每一步的优化并不容易\n### 提升树算法\n\n![](GBDT/GBDT-8717e980.png)\n\n## 梯度提升树\n**采用泰勒展开式将上式中的残差展开，**\n### [泰勒公式](/2017/08/14/微积分)\n一元函数在点$x_k$处的泰勒展开式为：\n$$f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n$$\n\n### 拟合残差的近似\n梯度提升思想正是为了解决上面的问题。它的主要思想是先求$h_m$，再求$β_m$。观察式子\n$$\\sum _{i=1}^N = L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))$$\n我们要最小化的式子由N部分相加而成，如果能够最小化每一部分，自然也就最小化了整个式子。考察其中任一部分，并将其进行泰勒一阶展开\n$$L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))=L(y_i,f_{m-1}(x_i))+\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} \\\\\nL(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))=\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} $$\n由于需要\n$$L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))<0\\Rightarrow \\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} <0$$\n由于$β$是大于0的，则$$h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}$$\n这说明，我们已经成功地降低了在第$i$个样本点上的预测损失。同理，我们可以降低在每一个样本点上的预测损失。条件就是\n$$h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}$$\n这个条件其实告诉了我们如何去寻找基学习器$h_m$，用回归树拟合$h_m(x_i)$。我们已经有了$h_m$，下面优化求解$β$，很显然，这是一个一维搜索问题，如下：\n$$β_m=\\underset{β}{argmin}\\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+βh_m(x_i))$$\n在上面的泰勒一阶展开时，有一个条件就是$βh_m(x_i)$要足够小，显然，执行一维搜索后得到的β会满足这个条件\n# GBDT算法\n\n![](GBDT/GBDT-df9b76dd.png)\n\n以上算法将回归树和提升树的算法结合起来，在第5步中求解 $c_{m,j}$ ，如果损失函数为平方损失函数，则解法与前面的回归树一致，直接取均值即可。如果是其他损失函数，则需要具体进行求解。具体而言，就是取导数为零来解等式\n\n# GBDT回归算法\n\n![](GBDT/GBDT-94935eb2.png)\n\n## 实例\n\n编号 | 年龄(岁) | 体重（kg） | 身高(m)(标签值)\n-|-|-|-\n1 | 5 | 20 | 1.1\n2 | 7 | 30 | 1.3\n3 | 21 | 70 | 1.7\n4 | 30 | 60 | 1.8\n5(要预测的) | 25 | 65 | ？\n\n**设损失函数为平方差函数**\n$$ L(y_i,f(x_i))=\\left(\\frac{1}{2}\\right)*(y_i-f(x_i))^2$$\n\n\n### 1、初始化学习器 $f_0(x)$\n$$f_0(x) =arg\\; \\underset{c}{min}\\sum\\limits_{i=1}^{N}L(y_i, c)=arg\\; \\underset{c}{min}\\sum _{i=1}^N(y_i-c)^2$$\n由于此时只有根结点，样本１,２，３,４都在根结点，此时要找到使得平方损失函数最小的参数$c$，怎么求呢？平方损失显然是一个凸函数，直接求导，倒数等于零，得到$c$。\n$$\\frac{\\partial L(y_i,c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i)$$\n令$\\sum _{i=1}^N (c-y_i)=0$，得$c=\\overline{y}$。\n所以初始化时，$c$取值为所有训练样本标签值的均值。$c=(1.1+1.3+1.7+1.8)/4=1.475$，此时得到初始学习器 $f_0(x)$。\n$$f_0(x)=c=1.475$$\n### 2、对迭代轮数m=1:\n计算负梯度——残差\n$$r_{i1} = -\\bigg[\\frac{\\partial L(y_i, f(x_i))}{\\partial f(x_i)}\\bigg]_{f(x) = f_{0} (x)}=-\\frac{\\partial \\sum _{i=1}^N(y_i- f_0(x_i))^2}{2\\partial f_0(x_i)}=\\sum _{i=1}^N(y_i- f_0(x_i))$$\n说白了，就是残差（上面已经解释过了），在此例中，残差在下表列出：\n\n编号 | 年龄(岁) | 体重（kg） | 身高(m)(标签值) | $f_0(x)$ | 残差\n:-:|:-:|:-:|:-:|:-:|:-:\n1 | 5 | 20 | 1.1 | 1.475 | -0.375\n2 | 7 | 30 | 1.3 | 1.475 | -0.175\n3 | 21 | 70 | 1.7 | 1.475 | 0.225\n4 | 30 | 60 | 1.8 | 1.475 | 0.325\n\n此时将残差作为样本的目标值训练$f_1(x)$，寻找回归树的最佳划分结点，遍历每个特征的每个可能取值。从年龄特征的5开始，到体重特征的70结束，分别计算方差，找到使损失函数最小的那个划分结点即为最佳划分结点。例如：以年龄7为划分结点，将小于7的样本划分为一类，大于等于7的样本划分为另一类。样本1为一组，样本2，3，4为一组，两组的方差分别为0，0.047，两组方差之和为0.047。所有可能划分情况如下表所示\n$$\\overline{x} = (-0.175+0.225+0.325)/3=0.125\\\\\n0.047 =[ (-0.175-\\overline{x})^2+(0.225-\\overline{x})^2+(0.325-\\overline{x})^2]/3\n$$\n\n划分点 | 小于划分点的样本 | 大于等于划分点的样本 | 总方差\n-|-|-|-\n年龄5 | / | 1，2，3，4 | 0.082\n年龄7 | 1 | 2，3，4 | 0.047\n年龄21 | 1，2 | 3，4 | 0.0125\n年龄30 | 1，2，3 | 4 | 0.062\n体重20 | / | 1，2，3，4 | 0.082\n体重30 | 1 | 2，3，4 | 0.047\n体重60 | 1，2 | 3，4 | 0.0125\n体重70 | 1，2，4 | 3 | 0.0867\n\n\n以上划分点的损失函数最小为0.0125，有两个划分点分别为年龄21和体重60，所以随机选一个作为划分点，这里我们选年龄21。\n此时还需要做一件事情，给这两个叶子结点分别赋一个参数，来拟合残差。\n$$c_{j1} =arg\\; \\underset{c}{min}\\sum\\limits_{x_i \\in R_{j1}} L(y_i,f_{0}(x_i) +c)$$\n\n这里其实和上面初始化学习器是一个道理，平方损失，求导，\n$$\\frac{\\partial L(y_i,f_0(x_i)+c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-f_0(x_i)-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i+f_0(x_i))$$\n令导数等于零$\\sum _{i=1}^N (c-y_i+f_0(x_i))=0$化简之后得到每个叶子结点的参数$c$，其实就是标签值的均值$c=\\overline{y_i-f_0(x_i)}$。\n根据上述划分结点：\n- 样本1，2为左叶子结点，$(x_1,x_2 \\in R_{11})$，所以$c_{11}=(−0.375−0.175)/2=−0.275。 $\n- 样本3，4为右叶子结点，$(x_3,x_4 \\in R_{11})$，所以$c_{21}=(0.225+0.325)/2=0.275。 $\n\n此时可更新强学习器 $$f_{1}(x) = f_{0}(x) + \\sum\\limits_{j=1}^{2}c_{j1}I(x \\in R_{j1})$$\n\n### 3、对迭代轮数m=2,3,4,5,…,M:\n循环迭代$M$次，$M$是人为控制的参数，迭代结束生成M棵树\n\n### 4、得到最后的强学习器：\n为了方别展示和理解，我们假设$Ｍ＝１$，根据上述结果得到强学习器：\n$$f(x) = f_M(x) =f_0(x) + \\sum\\limits_{m=1}^{M}\\sum\\limits_{j=1}^{J}c_{jm}I(x \\in R_{jm})$$\n\n![](GBDT/GBDT-19fece56.png)\n\n\n# GBDT分类算法\n## 二元GBDT分类算法\n### 假设条件\n- 类别1的概率为:$p_1=\\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}}$\n- 类别2的概率为:$p_2=1-p_2=\\frac{e^{f_2(x)}}{e^{f_1(x)}+e^{f_2(x)}}$\n\n$$\\begin{align*}\np_1 &= \\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}} = \\frac{1}{1+e^{f_2(x)/f_1(x)}}=\\frac{1}{1+e^{f(x)}}   \\\\\np_2 &= 1-p_1  =\\frac{e^{f(x)}}{1+e^{f(x)}}\n\\end{align*}$$\n\n### 损失函数化简\n对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：\n$$\\large L\\left(y,f(x)\\right)=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}$$\n其中$\\large p=\\frac{1}{1+e^{f(x)}}$\n$$\\begin{align*}\n\\large L\\left(y,f(x)\\right)&=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}\\\\\n &=-\\left \\{ ylog\\frac{e^{f(x)}}{1+e^{f(x)}} + (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=-\\left \\{ ylog\\frac{1}{1+e^{f(x)}} + ylog\\; e^{f(x)}+ (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=- \\left \\{ yf(x)-log\\left [ 1+e^{f(x)} \\right ] \\right \\}\n\\end{align*}$$\n\n### 算法简介\n\n![](GBDT/GBDT-42bbe544.png)\n### 实例\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:\n$y_i$ | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1\n\n#### 第一棵树\n##### 推导\n$$\\begin{align*}\nL\\left(y_i,c\\right)&=-\\left\\{y_ic-log\\left(1+e^{c}\\right)\\right\\} \\\\\n\\frac{\\partial L\\left(y_i,c\\right)}{\\partial c} &= \\frac{e^{c}}{1+e^{c}}-y=0 \\\\\n\\frac{e^{c}}{1+e^{c}}&=y \\\\\nc &= log \\frac{y}{1-y}=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)\n\\end{align*}$$\n##### 计算\n$$f_0(x)=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)=log\\left(\\frac{4}{6}\\right)=-0.4054$$\n\n#### 对迭代轮数m=1\n$$r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N$$\n\n$$r_{1,i}=y_1-\\frac{1}{1+e^{-f_{0}(x_1)}}=0-\\frac{1}{1+e^{-0.4054}}=-0.4$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$r_{1,i}$ | -0.4 | -0.4 | -0.4 | 0.6 | 0.6 | -0.4 | -0.4 | -0.4 | 0.6 | 0.6\n\n接着，我们需要以$r_{1,i}$为目标，拟合一颗树。\n\n划分点 | 小于等于划分点的样本 | 大于划分点的样本 | 总方差\n-|-|-|-\n1 | 1 | 2，3，4，5，6，7，8，9，10 | 0.2469\n2 | 1，2 | 3，4，5，6，7，8，9，10 | 0.25\n3 | 1，2，3 | 4，5，6，7，8，9，10 | 0.2449\n4 | 1，2，3，4 | 5，6，7，8，9，10 | 0.4375\n5 | 1，2，3，4，5 | 6，7，8，9，10 | 0.48\n6 | 1，2，3，4，5，6 | 7，8，9，10 | 0.4722\n7 | 1，2，3，4，5，6，7 | 8，9，10 | 0.4263\n8 | 1，2，3，4，5，6，7，8 | 9，10 | 0.1875\n9 | 1，2，3，4，5，6，7，8，9 | 10 | 0.2222\n10 | 1，2，3，4，5，6，7，8，9，10 | \\ | 0.24\n\n由此可知当切分点为8时，总方差最小。所以$R_{11}:x_i\\leqslant 8,R_{11}:x_i> 8$\n\n##### 输出$c_{m,j}$\n$$c_{m,j} =\\left. \\sum_{x_i\\in R_{m,j}} r_{m,i} \\middle / \\sum_{x_i\\in R_{m,j}} |r_{m,i}|(1-|r_{m,i}|) \\right. $$\n\n$$c_{1,1}=-0.625 \\;\\;\\;\\;\\;\\;\\; c_{1,2}=2.5$$\n\n$$f_{1,i}=\\sum_{j=1}^Jc_{jm}I(x \\in R_{jm})=\\left\\{\\begin{matrix}\n-0.4054-0.625=--1.0304\\\\\n-0.4054+2.5=2.0946\n\\end{matrix}\\right.$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$f_{1,i}(x_i)$ | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | -1.0304 | 2.0946 | 2.0946\n\n\n#### 对迭代轮数m=2\n\n其残差为\n$$$$r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N$$$$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n :-:| :-:| :-:| :-:| :-: |  :-:| :-: |  :-: |  :-: |  :-: |  :-:\n$f_{1,i}(x_i)$ | -0.3569  | -0.3569  | -0.3569  | 0.6431  | 0.6431  | -0.3569  | -0.3569  | -0.3569  | -7.1222  | -7.1222\n\n继续拟合第二可数\n\n#### 综上\n一共拟合$M$棵树\n\n\n## 多元GBDT分类算法\n\n![](GBDT/GBDT-b9b2986e.png)\n\n\n### 示例\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_i$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2\n$y_{i,0}$ | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0\n$y_{i,1}$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0\n$y_{i,2}$ | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1\n\n#### 根学习器\n首先进行初始化$f_{k0}(x_i)=0$，对所有的样本\n$$ \\begin{align*}\np_{m,k}(x)&=\\frac{e^{f_{m,k}(x)}}{\\sum_{l=1}^K e^{f_{m,l(x)}}}\\\\\np_{0,0}(x)&=\\frac{e^{f_{0,0}(x)}}{\\sum_{l=1}^K e^{f_{0,l(x)}}}=0.3333\n\\end{align*}$$\n#### 迭代轮数m=1\n##### 第一个类别$(y_i=0)$拟合第一棵树$(m=1)$\n\n$$\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}$$\n\n$x_i$|6|12|14|18|20|65|31|40|1|2|100|101|65|54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_{i,0}$ | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0\n$p_{0,0}$|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333|0.3333\n$r_{1,i,0}$|0.6667|0.6667|0.6667|0.6667|0.6667|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333|-0.3333\n\n- 选择切分点进行拟合\n计算完后可以发现，当选择31做为分裂点时，可以得到最小的$MSE，MSE=0.4879$\n\n划分点 | 小于等于划分点的样本 | 大于划分点的样本 | 总方差\n-|-|-|-\n1 | 1 | 2，6，12，14，18，20，31，40，54，65，65，100，101| 1.0036\n2 | 1，2 | 6，12，14，18，20，31，40，54，65，65，100，101 | 0.5063\n6 | 1，2，6 | 12，14，18，20，31，40，54，65，65，100，101 | 0.5149\n12 | 1，2，6，12 | 14，18，20，31，40，54，65，65，100，101 | 0.5222\n14 | 1，2，6，12，14 | 18，20，31，40，54，65，65，100，101 | 0.5270\n18 | 1，2，6，12，14，18 | 20，31，40，54，65，65，100，101 | 0.5270\n20 | 1，2，6，12，14，18，20 | 31，40，54，65，65，100，101 | 0.5175\n31 | 1，2，6，12，14，18，20，31 | 40，54，65，65，100，101 | 0.4879\n40 | 1，2，6，12，14，18，20，31，40 | 54，65，65，100，101 | 0.5163\n54 | 1，2，6，12，14，18，20，31，40，54 | 65，65，100，101 | 0.9012\n65 | 1，2，6，12，14，18，20，31，40，54，65，65 | 100，101 | 1.060\n100 | 1，14，18，20，31，40，54，65，65，100| 101 | 0.5045\n101 | 1，2，6，12，14，18，20，31，40，54，65，65，100，101| \\ | 0.5149\n\n- 计算$c_{m,j,l}$\n$$\\begin{align*}\nc_{mjl}&=\\frac{K-1}{K}\\frac{\\sum\\limits_{x_i \\in R_{mjl}}r_{mil}}{\\sum\\limits_{x_i \\in R_{mil}}|r_{mil}|(1-|r_{mil}|)}\\\\\nc_{110} &= 0.8751 \\\\\nc_{120} &= -0.9999\n\\end{align*}$$\n\n$$f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})$$\n\n\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$f_{m,k}(x_i)=f_{1,0}(x_i)$ | 1.1428 | 1.1428 | 1.1428 | 1.1428 | 1.1428 | -0.999 | -0.999 | -0.999 | 1.1428 | 1.1428 | -0.999 | -0.999 | -0.999 | -0.999\n\n##### 第二个类别（y_i=1)拟合第一颗树$(m=1)$\n$$\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}$$\n\n$x_i$|6|12|14|18|20|65|31|40|1|2|100|101|65|54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$y_{i,1}$ | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0\n$p_{0,1}$|0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333 | 0.3333\n$r_{1,i,1}$|-0.3333 | -0.3333 | -0.3333 | -0.3333 | -0.3333 | 0.6667 | 0.6667 | 0.6667 | 0.6667 | 0.6667 | -0.3333 | -0.3333 | -0.3333 | -0.3333\n\n以$r_{1,i,1}$拟合一颗回归树，（以6为分裂点）,可计算得到叶子结点\n$$c_{111}=2 \\;\\;\\;\\;\\;c_{121}=0.2499$$\n\n$$f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})$$\n\n$x_i$ | 6 | 12 | 14 | 18 | 20 | 65 | 31 | 40 | 1 | 2 | 100 | 101 | 65 | 54\n:-:|:-:|:-:|:-:|:-: | :-:|:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-:\n$f_{m,k}(x_i)=f_{1,1}(x_i)$ | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | -0.2499 | 2 | 2 | -0.2499 | -0.2499 | -0.2499 | -0.2499\n\n### 综上\n然后再拟合第三个类别（类别2）的第一颗树，过程也是重复上述步骤，所以这里就不再重复了。在拟合完所有类别的第一颗树后就开始拟合第二颗树。反复进行，直到训练了$M$轮。\n","slug":"GBDT","published":1,"updated":"2019-07-30T01:54:38.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iyb001nhomj0ya1z1v0","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"https://www.cnblogs.com/pinard/p/6140514.html\" target=\"_blank\" rel=\"noopener\">简介</a></h1><p>GBDT也是集成学习Boosting家族的成员,由梯度提升方法与回归树结合而成。<br>分类|损失函数<br>回归|$(y-\\hat y)^2$<br>分类|$p_K log_2 \\; p_K$</p>\n<a id=\"more\"></a>\n<h2 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a><a href=\"/2017/07/21/回归树\">回归树</a></h2><p>回归树生成算法<br><img src=\"/2017/10/20/GBDT/GBDT-f5523f89.png\" alt=\"\"></p>\n<h2 id=\"提升树\"><a href=\"#提升树\" class=\"headerlink\" title=\"提升树\"></a>提升树</h2><p>提升树可以表示为以下形式：这里我们约定 $T(x;Θ_m)$ 表示第 $m$ 棵决策树；$Θ_m$表示决策树的参数；$M$ 为树的个数。强分类器 $f_M(x)$ 可以由多个弱分类器 $T(x;Θ_m)$ 线性相加而成</p>\n<script type=\"math/tex; mode=display\">f_M (x)=\\sum_{m=1}^MT(x;Θ_m )</script><p>提升树的前向分步算法。第$m$步的模型可以写成</p>\n<script type=\"math/tex; mode=display\">f_m (x)=f_{m-1} (x)+ T(x;Θ_m )</script><p>然后得到损失函数</p>\n<script type=\"math/tex; mode=display\">L(f_m (x),y)=L(f_{m-1} (x)+ T(x;Θ_m ),y)</script><p>迭代的目的是构建 $T(x;Θ_m)$，使得本轮损失 $L(f_m(x),y)$ 最小。思想其实并不复杂，但是问题也很明显，对于不同的任务会有不同的损失函数，当损失函数是平方损失和指数损失函数时，每一步的优化还是简单的。但是对于一般损失函数而言，每一步的优化并不容易</p>\n<h3 id=\"提升树算法\"><a href=\"#提升树算法\" class=\"headerlink\" title=\"提升树算法\"></a>提升树算法</h3><p><img src=\"/2017/10/20/GBDT/GBDT-8717e980.png\" alt=\"\"></p>\n<h2 id=\"梯度提升树\"><a href=\"#梯度提升树\" class=\"headerlink\" title=\"梯度提升树\"></a>梯度提升树</h2><p><strong>采用泰勒展开式将上式中的残差展开，</strong></p>\n<h3 id=\"泰勒公式\"><a href=\"#泰勒公式\" class=\"headerlink\" title=\"泰勒公式\"></a><a href=\"/2017/08/14/微积分\">泰勒公式</a></h3><p>一元函数在点$x_k$处的泰勒展开式为：</p>\n<script type=\"math/tex; mode=display\">f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n</script><h3 id=\"拟合残差的近似\"><a href=\"#拟合残差的近似\" class=\"headerlink\" title=\"拟合残差的近似\"></a>拟合残差的近似</h3><p>梯度提升思想正是为了解决上面的问题。它的主要思想是先求$h_m$，再求$β_m$。观察式子</p>\n<script type=\"math/tex; mode=display\">\\sum _{i=1}^N = L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))</script><p>我们要最小化的式子由N部分相加而成，如果能够最小化每一部分，自然也就最小化了整个式子。考察其中任一部分，并将其进行泰勒一阶展开</p>\n<script type=\"math/tex; mode=display\">L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))=L(y_i,f_{m-1}(x_i))+\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} \\\\\nL(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))=\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><p>由于需要</p>\n<script type=\"math/tex; mode=display\">L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))<0\\Rightarrow \\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} <0</script><p>由于$β$是大于0的，则<script type=\"math/tex\">h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><br>这说明，我们已经成功地降低了在第$i$个样本点上的预测损失。同理，我们可以降低在每一个样本点上的预测损失。条件就是</p>\n<script type=\"math/tex; mode=display\">h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><p>这个条件其实告诉了我们如何去寻找基学习器$h_m$，用回归树拟合$h_m(x_i)$。我们已经有了$h_m$，下面优化求解$β$，很显然，这是一个一维搜索问题，如下：</p>\n<script type=\"math/tex; mode=display\">β_m=\\underset{β}{argmin}\\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+βh_m(x_i))</script><p>在上面的泰勒一阶展开时，有一个条件就是$βh_m(x_i)$要足够小，显然，执行一维搜索后得到的β会满足这个条件</p>\n<h1 id=\"GBDT算法\"><a href=\"#GBDT算法\" class=\"headerlink\" title=\"GBDT算法\"></a>GBDT算法</h1><p><img src=\"/2017/10/20/GBDT/GBDT-df9b76dd.png\" alt=\"\"></p>\n<p>以上算法将回归树和提升树的算法结合起来，在第5步中求解 $c_{m,j}$ ，如果损失函数为平方损失函数，则解法与前面的回归树一致，直接取均值即可。如果是其他损失函数，则需要具体进行求解。具体而言，就是取导数为零来解等式</p>\n<h1 id=\"GBDT回归算法\"><a href=\"#GBDT回归算法\" class=\"headerlink\" title=\"GBDT回归算法\"></a>GBDT回归算法</h1><p><img src=\"/2017/10/20/GBDT/GBDT-94935eb2.png\" alt=\"\"></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>年龄(岁)</th>\n<th>体重（kg）</th>\n<th>身高(m)(标签值)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>5</td>\n<td>20</td>\n<td>1.1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>7</td>\n<td>30</td>\n<td>1.3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>21</td>\n<td>70</td>\n<td>1.7</td>\n</tr>\n<tr>\n<td>4</td>\n<td>30</td>\n<td>60</td>\n<td>1.8</td>\n</tr>\n<tr>\n<td>5(要预测的)</td>\n<td>25</td>\n<td>65</td>\n<td>？</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>设损失函数为平方差函数</strong></p>\n<script type=\"math/tex; mode=display\">L(y_i,f(x_i))=\\left(\\frac{1}{2}\\right)*(y_i-f(x_i))^2</script><h3 id=\"1、初始化学习器-f-0-x\"><a href=\"#1、初始化学习器-f-0-x\" class=\"headerlink\" title=\"1、初始化学习器 $f_0(x)$\"></a>1、初始化学习器 $f_0(x)$</h3><script type=\"math/tex; mode=display\">f_0(x) =arg\\; \\underset{c}{min}\\sum\\limits_{i=1}^{N}L(y_i, c)=arg\\; \\underset{c}{min}\\sum _{i=1}^N(y_i-c)^2</script><p>由于此时只有根结点，样本１,２，３,４都在根结点，此时要找到使得平方损失函数最小的参数$c$，怎么求呢？平方损失显然是一个凸函数，直接求导，倒数等于零，得到$c$。</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(y_i,c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i)</script><p>令$\\sum _{i=1}^N (c-y_i)=0$，得$c=\\overline{y}$。<br>所以初始化时，$c$取值为所有训练样本标签值的均值。$c=(1.1+1.3+1.7+1.8)/4=1.475$，此时得到初始学习器 $f_0(x)$。</p>\n<script type=\"math/tex; mode=display\">f_0(x)=c=1.475</script><h3 id=\"2、对迭代轮数m-1\"><a href=\"#2、对迭代轮数m-1\" class=\"headerlink\" title=\"2、对迭代轮数m=1:\"></a>2、对迭代轮数m=1:</h3><p>计算负梯度——残差</p>\n<script type=\"math/tex; mode=display\">r_{i1} = -\\bigg[\\frac{\\partial L(y_i, f(x_i))}{\\partial f(x_i)}\\bigg]_{f(x) = f_{0} (x)}=-\\frac{\\partial \\sum _{i=1}^N(y_i- f_0(x_i))^2}{2\\partial f_0(x_i)}=\\sum _{i=1}^N(y_i- f_0(x_i))</script><p>说白了，就是残差（上面已经解释过了），在此例中，残差在下表列出：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编号</th>\n<th style=\"text-align:center\">年龄(岁)</th>\n<th style=\"text-align:center\">体重（kg）</th>\n<th style=\"text-align:center\">身高(m)(标签值)</th>\n<th style=\"text-align:center\">$f_0(x)$</th>\n<th style=\"text-align:center\">残差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">1.1</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">-0.375</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1.3</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">-0.175</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">70</td>\n<td style=\"text-align:center\">1.7</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">0.225</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">1.8</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">0.325</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>此时将残差作为样本的目标值训练$f_1(x)$，寻找回归树的最佳划分结点，遍历每个特征的每个可能取值。从年龄特征的5开始，到体重特征的70结束，分别计算方差，找到使损失函数最小的那个划分结点即为最佳划分结点。例如：以年龄7为划分结点，将小于7的样本划分为一类，大于等于7的样本划分为另一类。样本1为一组，样本2，3，4为一组，两组的方差分别为0，0.047，两组方差之和为0.047。所有可能划分情况如下表所示</p>\n<script type=\"math/tex; mode=display\">\\overline{x} = (-0.175+0.225+0.325)/3=0.125\\\\\n0.047 =[ (-0.175-\\overline{x})^2+(0.225-\\overline{x})^2+(0.325-\\overline{x})^2]/3</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于划分点的样本</th>\n<th>大于等于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>年龄5</td>\n<td>/</td>\n<td>1，2，3，4</td>\n<td>0.082</td>\n</tr>\n<tr>\n<td>年龄7</td>\n<td>1</td>\n<td>2，3，4</td>\n<td>0.047</td>\n</tr>\n<tr>\n<td>年龄21</td>\n<td>1，2</td>\n<td>3，4</td>\n<td>0.0125</td>\n</tr>\n<tr>\n<td>年龄30</td>\n<td>1，2，3</td>\n<td>4</td>\n<td>0.062</td>\n</tr>\n<tr>\n<td>体重20</td>\n<td>/</td>\n<td>1，2，3，4</td>\n<td>0.082</td>\n</tr>\n<tr>\n<td>体重30</td>\n<td>1</td>\n<td>2，3，4</td>\n<td>0.047</td>\n</tr>\n<tr>\n<td>体重60</td>\n<td>1，2</td>\n<td>3，4</td>\n<td>0.0125</td>\n</tr>\n<tr>\n<td>体重70</td>\n<td>1，2，4</td>\n<td>3</td>\n<td>0.0867</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>以上划分点的损失函数最小为0.0125，有两个划分点分别为年龄21和体重60，所以随机选一个作为划分点，这里我们选年龄21。<br>此时还需要做一件事情，给这两个叶子结点分别赋一个参数，来拟合残差。</p>\n<script type=\"math/tex; mode=display\">c_{j1} =arg\\; \\underset{c}{min}\\sum\\limits_{x_i \\in R_{j1}} L(y_i,f_{0}(x_i) +c)</script><p>这里其实和上面初始化学习器是一个道理，平方损失，求导，</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(y_i,f_0(x_i)+c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-f_0(x_i)-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i+f_0(x_i))</script><p>令导数等于零$\\sum _{i=1}^N (c-y_i+f_0(x_i))=0$化简之后得到每个叶子结点的参数$c$，其实就是标签值的均值$c=\\overline{y_i-f_0(x_i)}$。<br>根据上述划分结点：</p>\n<ul>\n<li>样本1，2为左叶子结点，$(x_1,x_2 \\in R_{11})$，所以$c_{11}=(−0.375−0.175)/2=−0.275。 $</li>\n<li>样本3，4为右叶子结点，$(x_3,x_4 \\in R_{11})$，所以$c_{21}=(0.225+0.325)/2=0.275。 $</li>\n</ul>\n<p>此时可更新强学习器 <script type=\"math/tex\">f_{1}(x) = f_{0}(x) + \\sum\\limits_{j=1}^{2}c_{j1}I(x \\in R_{j1})</script></p>\n<h3 id=\"3、对迭代轮数m-2-3-4-5-…-M\"><a href=\"#3、对迭代轮数m-2-3-4-5-…-M\" class=\"headerlink\" title=\"3、对迭代轮数m=2,3,4,5,…,M:\"></a>3、对迭代轮数m=2,3,4,5,…,M:</h3><p>循环迭代$M$次，$M$是人为控制的参数，迭代结束生成M棵树</p>\n<h3 id=\"4、得到最后的强学习器：\"><a href=\"#4、得到最后的强学习器：\" class=\"headerlink\" title=\"4、得到最后的强学习器：\"></a>4、得到最后的强学习器：</h3><p>为了方别展示和理解，我们假设$Ｍ＝１$，根据上述结果得到强学习器：</p>\n<script type=\"math/tex; mode=display\">f(x) = f_M(x) =f_0(x) + \\sum\\limits_{m=1}^{M}\\sum\\limits_{j=1}^{J}c_{jm}I(x \\in R_{jm})</script><p><img src=\"/2017/10/20/GBDT/GBDT-19fece56.png\" alt=\"\"></p>\n<h1 id=\"GBDT分类算法\"><a href=\"#GBDT分类算法\" class=\"headerlink\" title=\"GBDT分类算法\"></a>GBDT分类算法</h1><h2 id=\"二元GBDT分类算法\"><a href=\"#二元GBDT分类算法\" class=\"headerlink\" title=\"二元GBDT分类算法\"></a>二元GBDT分类算法</h2><h3 id=\"假设条件\"><a href=\"#假设条件\" class=\"headerlink\" title=\"假设条件\"></a>假设条件</h3><ul>\n<li>类别1的概率为:$p_1=\\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}}$</li>\n<li>类别2的概率为:$p_2=1-p_2=\\frac{e^{f_2(x)}}{e^{f_1(x)}+e^{f_2(x)}}$</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_1 &= \\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}} = \\frac{1}{1+e^{f_2(x)/f_1(x)}}=\\frac{1}{1+e^{f(x)}}   \\\\\np_2 &= 1-p_1  =\\frac{e^{f(x)}}{1+e^{f(x)}}\n\\end{align*}</script><h3 id=\"损失函数化简\"><a href=\"#损失函数化简\" class=\"headerlink\" title=\"损失函数化简\"></a>损失函数化简</h3><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：</p>\n<script type=\"math/tex; mode=display\">\\large L\\left(y,f(x)\\right)=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}</script><p>其中$\\large p=\\frac{1}{1+e^{f(x)}}$</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\large L\\left(y,f(x)\\right)&=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}\\\\\n &=-\\left \\{ ylog\\frac{e^{f(x)}}{1+e^{f(x)}} + (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=-\\left \\{ ylog\\frac{1}{1+e^{f(x)}} + ylog\\; e^{f(x)}+ (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=- \\left \\{ yf(x)-log\\left [ 1+e^{f(x)} \\right ] \\right \\}\n\\end{align*}</script><h3 id=\"算法简介\"><a href=\"#算法简介\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p><img src=\"/2017/10/20/GBDT/GBDT-42bbe544.png\" alt=\"\"></p>\n<h3 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_i$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"第一棵树\"><a href=\"#第一棵树\" class=\"headerlink\" title=\"第一棵树\"></a>第一棵树</h4><h5 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a>推导</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nL\\left(y_i,c\\right)&=-\\left\\{y_ic-log\\left(1+e^{c}\\right)\\right\\} \\\\\n\\frac{\\partial L\\left(y_i,c\\right)}{\\partial c} &= \\frac{e^{c}}{1+e^{c}}-y=0 \\\\\n\\frac{e^{c}}{1+e^{c}}&=y \\\\\nc &= log \\frac{y}{1-y}=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)\n\\end{align*}</script><h5 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h5><script type=\"math/tex; mode=display\">f_0(x)=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)=log\\left(\\frac{4}{6}\\right)=-0.4054</script><h4 id=\"对迭代轮数m-1\"><a href=\"#对迭代轮数m-1\" class=\"headerlink\" title=\"对迭代轮数m=1\"></a>对迭代轮数m=1</h4><script type=\"math/tex; mode=display\">r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N</script><script type=\"math/tex; mode=display\">r_{1,i}=y_1-\\frac{1}{1+e^{-f_{0}(x_1)}}=0-\\frac{1}{1+e^{-0.4054}}=-0.4</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$r_{1,i}$</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">0.6</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>接着，我们需要以$r_{1,i}$为目标，拟合一颗树。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于等于划分点的样本</th>\n<th>大于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2，3，4，5，6，7，8，9，10</td>\n<td>0.2469</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1，2</td>\n<td>3，4，5，6，7，8，9，10</td>\n<td>0.25</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1，2，3</td>\n<td>4，5，6，7，8，9，10</td>\n<td>0.2449</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1，2，3，4</td>\n<td>5，6，7，8，9，10</td>\n<td>0.4375</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1，2，3，4，5</td>\n<td>6，7，8，9，10</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1，2，3，4，5，6</td>\n<td>7，8，9，10</td>\n<td>0.4722</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1，2，3，4，5，6，7</td>\n<td>8，9，10</td>\n<td>0.4263</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1，2，3，4，5，6，7，8</td>\n<td>9，10</td>\n<td>0.1875</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1，2，3，4，5，6，7，8，9</td>\n<td>10</td>\n<td>0.2222</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1，2，3，4，5，6，7，8，9，10</td>\n<td>\\</td>\n<td>0.24</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>由此可知当切分点为8时，总方差最小。所以$R_{11}:x_i\\leqslant 8,R_{11}:x_i&gt; 8$</p>\n<h5 id=\"输出-c-m-j\"><a href=\"#输出-c-m-j\" class=\"headerlink\" title=\"输出$c_{m,j}$\"></a>输出$c_{m,j}$</h5><script type=\"math/tex; mode=display\">c_{m,j} =\\left. \\sum_{x_i\\in R_{m,j}} r_{m,i} \\middle / \\sum_{x_i\\in R_{m,j}} |r_{m,i}|(1-|r_{m,i}|) \\right.</script><script type=\"math/tex; mode=display\">c_{1,1}=-0.625 \\;\\;\\;\\;\\;\\;\\; c_{1,2}=2.5</script><script type=\"math/tex; mode=display\">f_{1,i}=\\sum_{j=1}^Jc_{jm}I(x \\in R_{jm})=\\left\\{\\begin{matrix}\n-0.4054-0.625=--1.0304\\\\\n-0.4054+2.5=2.0946\n\\end{matrix}\\right.</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{1,i}(x_i)$</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">2.0946</td>\n<td style=\"text-align:center\">2.0946</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"对迭代轮数m-2\"><a href=\"#对迭代轮数m-2\" class=\"headerlink\" title=\"对迭代轮数m=2\"></a>对迭代轮数m=2</h4><p>其残差为</p>\n<script type=\"math/tex; mode=display\">r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{1,i}(x_i)$</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">0.6431</td>\n<td style=\"text-align:center\">0.6431</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-7.1222</td>\n<td style=\"text-align:center\">-7.1222</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>继续拟合第二可数</p>\n<h4 id=\"综上\"><a href=\"#综上\" class=\"headerlink\" title=\"综上\"></a>综上</h4><p>一共拟合$M$棵树</p>\n<h2 id=\"多元GBDT分类算法\"><a href=\"#多元GBDT分类算法\" class=\"headerlink\" title=\"多元GBDT分类算法\"></a>多元GBDT分类算法</h2><p><img src=\"/2017/10/20/GBDT/GBDT-b9b2986e.png\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_i$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,0}$</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,1}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,2}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"根学习器\"><a href=\"#根学习器\" class=\"headerlink\" title=\"根学习器\"></a>根学习器</h4><p>首先进行初始化$f_{k0}(x_i)=0$，对所有的样本</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_{m,k}(x)&=\\frac{e^{f_{m,k}(x)}}{\\sum_{l=1}^K e^{f_{m,l(x)}}}\\\\\np_{0,0}(x)&=\\frac{e^{f_{0,0}(x)}}{\\sum_{l=1}^K e^{f_{0,l(x)}}}=0.3333\n\\end{align*}</script><h4 id=\"迭代轮数m-1\"><a href=\"#迭代轮数m-1\" class=\"headerlink\" title=\"迭代轮数m=1\"></a>迭代轮数m=1</h4><h5 id=\"第一个类别-y-i-0-拟合第一棵树-m-1\"><a href=\"#第一个类别-y-i-0-拟合第一棵树-m-1\" class=\"headerlink\" title=\"第一个类别$(y_i=0)$拟合第一棵树$(m=1)$\"></a>第一个类别$(y_i=0)$拟合第一棵树$(m=1)$</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_{i,0}$</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$p_{0,0}$</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$r_{1,i,0}$</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>选择切分点进行拟合<br>计算完后可以发现，当选择31做为分裂点时，可以得到最小的$MSE，MSE=0.4879$</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于等于划分点的样本</th>\n<th>大于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2，6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>1.0036</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1，2</td>\n<td>6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5063</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1，2，6</td>\n<td>12，14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5149</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1，2，6，12</td>\n<td>14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5222</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1，2，6，12，14</td>\n<td>18，20，31，40，54，65，65，100，101</td>\n<td>0.5270</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1，2，6，12，14，18</td>\n<td>20，31，40，54，65，65，100，101</td>\n<td>0.5270</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1，2，6，12，14，18，20</td>\n<td>31，40，54，65，65，100，101</td>\n<td>0.5175</td>\n</tr>\n<tr>\n<td>31</td>\n<td>1，2，6，12，14，18，20，31</td>\n<td>40，54，65，65，100，101</td>\n<td>0.4879</td>\n</tr>\n<tr>\n<td>40</td>\n<td>1，2，6，12，14，18，20，31，40</td>\n<td>54，65，65，100，101</td>\n<td>0.5163</td>\n</tr>\n<tr>\n<td>54</td>\n<td>1，2，6，12，14，18，20，31，40，54</td>\n<td>65，65，100，101</td>\n<td>0.9012</td>\n</tr>\n<tr>\n<td>65</td>\n<td>1，2，6，12，14，18，20，31，40，54，65，65</td>\n<td>100，101</td>\n<td>1.060</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1，14，18，20，31，40，54，65，65，100</td>\n<td>101</td>\n<td>0.5045</td>\n</tr>\n<tr>\n<td>101</td>\n<td>1，2，6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>\\</td>\n<td>0.5149</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>计算$c_{m,j,l}$<script type=\"math/tex; mode=display\">\\begin{align*}\nc_{mjl}&=\\frac{K-1}{K}\\frac{\\sum\\limits_{x_i \\in R_{mjl}}r_{mil}}{\\sum\\limits_{x_i \\in R_{mil}}|r_{mil}|(1-|r_{mil}|)}\\\\\nc_{110} &= 0.8751 \\\\\nc_{120} &= -0.9999\n\\end{align*}</script></li>\n</ul>\n<script type=\"math/tex; mode=display\">f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{m,k}(x_i)=f_{1,0}(x_i)$</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"第二个类别（y-i-1-拟合第一颗树-m-1\"><a href=\"#第二个类别（y-i-1-拟合第一颗树-m-1\" class=\"headerlink\" title=\"第二个类别（y_i=1)拟合第一颗树$(m=1)$\"></a>第二个类别（y_i=1)拟合第一颗树$(m=1)$</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_{i,1}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$p_{0,1}$</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$r_{1,i,1}$</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>以$r_{1,i,1}$拟合一颗回归树，（以6为分裂点）,可计算得到叶子结点</p>\n<script type=\"math/tex; mode=display\">c_{111}=2 \\;\\;\\;\\;\\;c_{121}=0.2499</script><script type=\"math/tex; mode=display\">f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{m,k}(x_i)=f_{1,1}(x_i)$</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"综上-1\"><a href=\"#综上-1\" class=\"headerlink\" title=\"综上\"></a>综上</h3><p>然后再拟合第三个类别（类别2）的第一颗树，过程也是重复上述步骤，所以这里就不再重复了。在拟合完所有类别的第一颗树后就开始拟合第二颗树。反复进行，直到训练了$M$轮。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"https://www.cnblogs.com/pinard/p/6140514.html\" target=\"_blank\" rel=\"noopener\">简介</a></h1><p>GBDT也是集成学习Boosting家族的成员,由梯度提升方法与回归树结合而成。<br>分类|损失函数<br>回归|$(y-\\hat y)^2$<br>分类|$p_K log_2 \\; p_K$</p>","more":"<h2 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a><a href=\"/2017/07/21/回归树\">回归树</a></h2><p>回归树生成算法<br><img src=\"/2017/10/20/GBDT/GBDT-f5523f89.png\" alt=\"\"></p>\n<h2 id=\"提升树\"><a href=\"#提升树\" class=\"headerlink\" title=\"提升树\"></a>提升树</h2><p>提升树可以表示为以下形式：这里我们约定 $T(x;Θ_m)$ 表示第 $m$ 棵决策树；$Θ_m$表示决策树的参数；$M$ 为树的个数。强分类器 $f_M(x)$ 可以由多个弱分类器 $T(x;Θ_m)$ 线性相加而成</p>\n<script type=\"math/tex; mode=display\">f_M (x)=\\sum_{m=1}^MT(x;Θ_m )</script><p>提升树的前向分步算法。第$m$步的模型可以写成</p>\n<script type=\"math/tex; mode=display\">f_m (x)=f_{m-1} (x)+ T(x;Θ_m )</script><p>然后得到损失函数</p>\n<script type=\"math/tex; mode=display\">L(f_m (x),y)=L(f_{m-1} (x)+ T(x;Θ_m ),y)</script><p>迭代的目的是构建 $T(x;Θ_m)$，使得本轮损失 $L(f_m(x),y)$ 最小。思想其实并不复杂，但是问题也很明显，对于不同的任务会有不同的损失函数，当损失函数是平方损失和指数损失函数时，每一步的优化还是简单的。但是对于一般损失函数而言，每一步的优化并不容易</p>\n<h3 id=\"提升树算法\"><a href=\"#提升树算法\" class=\"headerlink\" title=\"提升树算法\"></a>提升树算法</h3><p><img src=\"/2017/10/20/GBDT/GBDT-8717e980.png\" alt=\"\"></p>\n<h2 id=\"梯度提升树\"><a href=\"#梯度提升树\" class=\"headerlink\" title=\"梯度提升树\"></a>梯度提升树</h2><p><strong>采用泰勒展开式将上式中的残差展开，</strong></p>\n<h3 id=\"泰勒公式\"><a href=\"#泰勒公式\" class=\"headerlink\" title=\"泰勒公式\"></a><a href=\"/2017/08/14/微积分\">泰勒公式</a></h3><p>一元函数在点$x_k$处的泰勒展开式为：</p>\n<script type=\"math/tex; mode=display\">f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n</script><h3 id=\"拟合残差的近似\"><a href=\"#拟合残差的近似\" class=\"headerlink\" title=\"拟合残差的近似\"></a>拟合残差的近似</h3><p>梯度提升思想正是为了解决上面的问题。它的主要思想是先求$h_m$，再求$β_m$。观察式子</p>\n<script type=\"math/tex; mode=display\">\\sum _{i=1}^N = L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))</script><p>我们要最小化的式子由N部分相加而成，如果能够最小化每一部分，自然也就最小化了整个式子。考察其中任一部分，并将其进行泰勒一阶展开</p>\n<script type=\"math/tex; mode=display\">L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))=L(y_i,f_{m-1}(x_i))+\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} \\\\\nL(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))=\\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><p>由于需要</p>\n<script type=\"math/tex; mode=display\">L(y_i,f_{m-1}(x_i)+\\beta h_m(x_i))-L(y_i,f_{m-1}(x_i))<0\\Rightarrow \\beta h_m(x_i)\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)} <0</script><p>由于$β$是大于0的，则<script type=\"math/tex\">h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><br>这说明，我们已经成功地降低了在第$i$个样本点上的预测损失。同理，我们可以降低在每一个样本点上的预测损失。条件就是</p>\n<script type=\"math/tex; mode=display\">h_m(x_i)=-\\frac{\\partial L(y_i,f_{m-1}(x_i))}{\\partial f_{m-1}(x_i)}</script><p>这个条件其实告诉了我们如何去寻找基学习器$h_m$，用回归树拟合$h_m(x_i)$。我们已经有了$h_m$，下面优化求解$β$，很显然，这是一个一维搜索问题，如下：</p>\n<script type=\"math/tex; mode=display\">β_m=\\underset{β}{argmin}\\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+βh_m(x_i))</script><p>在上面的泰勒一阶展开时，有一个条件就是$βh_m(x_i)$要足够小，显然，执行一维搜索后得到的β会满足这个条件</p>\n<h1 id=\"GBDT算法\"><a href=\"#GBDT算法\" class=\"headerlink\" title=\"GBDT算法\"></a>GBDT算法</h1><p><img src=\"/2017/10/20/GBDT/GBDT-df9b76dd.png\" alt=\"\"></p>\n<p>以上算法将回归树和提升树的算法结合起来，在第5步中求解 $c_{m,j}$ ，如果损失函数为平方损失函数，则解法与前面的回归树一致，直接取均值即可。如果是其他损失函数，则需要具体进行求解。具体而言，就是取导数为零来解等式</p>\n<h1 id=\"GBDT回归算法\"><a href=\"#GBDT回归算法\" class=\"headerlink\" title=\"GBDT回归算法\"></a>GBDT回归算法</h1><p><img src=\"/2017/10/20/GBDT/GBDT-94935eb2.png\" alt=\"\"></p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>年龄(岁)</th>\n<th>体重（kg）</th>\n<th>身高(m)(标签值)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>5</td>\n<td>20</td>\n<td>1.1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>7</td>\n<td>30</td>\n<td>1.3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>21</td>\n<td>70</td>\n<td>1.7</td>\n</tr>\n<tr>\n<td>4</td>\n<td>30</td>\n<td>60</td>\n<td>1.8</td>\n</tr>\n<tr>\n<td>5(要预测的)</td>\n<td>25</td>\n<td>65</td>\n<td>？</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>设损失函数为平方差函数</strong></p>\n<script type=\"math/tex; mode=display\">L(y_i,f(x_i))=\\left(\\frac{1}{2}\\right)*(y_i-f(x_i))^2</script><h3 id=\"1、初始化学习器-f-0-x\"><a href=\"#1、初始化学习器-f-0-x\" class=\"headerlink\" title=\"1、初始化学习器 $f_0(x)$\"></a>1、初始化学习器 $f_0(x)$</h3><script type=\"math/tex; mode=display\">f_0(x) =arg\\; \\underset{c}{min}\\sum\\limits_{i=1}^{N}L(y_i, c)=arg\\; \\underset{c}{min}\\sum _{i=1}^N(y_i-c)^2</script><p>由于此时只有根结点，样本１,２，３,４都在根结点，此时要找到使得平方损失函数最小的参数$c$，怎么求呢？平方损失显然是一个凸函数，直接求导，倒数等于零，得到$c$。</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(y_i,c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i)</script><p>令$\\sum _{i=1}^N (c-y_i)=0$，得$c=\\overline{y}$。<br>所以初始化时，$c$取值为所有训练样本标签值的均值。$c=(1.1+1.3+1.7+1.8)/4=1.475$，此时得到初始学习器 $f_0(x)$。</p>\n<script type=\"math/tex; mode=display\">f_0(x)=c=1.475</script><h3 id=\"2、对迭代轮数m-1\"><a href=\"#2、对迭代轮数m-1\" class=\"headerlink\" title=\"2、对迭代轮数m=1:\"></a>2、对迭代轮数m=1:</h3><p>计算负梯度——残差</p>\n<script type=\"math/tex; mode=display\">r_{i1} = -\\bigg[\\frac{\\partial L(y_i, f(x_i))}{\\partial f(x_i)}\\bigg]_{f(x) = f_{0} (x)}=-\\frac{\\partial \\sum _{i=1}^N(y_i- f_0(x_i))^2}{2\\partial f_0(x_i)}=\\sum _{i=1}^N(y_i- f_0(x_i))</script><p>说白了，就是残差（上面已经解释过了），在此例中，残差在下表列出：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编号</th>\n<th style=\"text-align:center\">年龄(岁)</th>\n<th style=\"text-align:center\">体重（kg）</th>\n<th style=\"text-align:center\">身高(m)(标签值)</th>\n<th style=\"text-align:center\">$f_0(x)$</th>\n<th style=\"text-align:center\">残差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">1.1</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">-0.375</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1.3</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">-0.175</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">70</td>\n<td style=\"text-align:center\">1.7</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">0.225</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">1.8</td>\n<td style=\"text-align:center\">1.475</td>\n<td style=\"text-align:center\">0.325</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>此时将残差作为样本的目标值训练$f_1(x)$，寻找回归树的最佳划分结点，遍历每个特征的每个可能取值。从年龄特征的5开始，到体重特征的70结束，分别计算方差，找到使损失函数最小的那个划分结点即为最佳划分结点。例如：以年龄7为划分结点，将小于7的样本划分为一类，大于等于7的样本划分为另一类。样本1为一组，样本2，3，4为一组，两组的方差分别为0，0.047，两组方差之和为0.047。所有可能划分情况如下表所示</p>\n<script type=\"math/tex; mode=display\">\\overline{x} = (-0.175+0.225+0.325)/3=0.125\\\\\n0.047 =[ (-0.175-\\overline{x})^2+(0.225-\\overline{x})^2+(0.325-\\overline{x})^2]/3</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于划分点的样本</th>\n<th>大于等于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>年龄5</td>\n<td>/</td>\n<td>1，2，3，4</td>\n<td>0.082</td>\n</tr>\n<tr>\n<td>年龄7</td>\n<td>1</td>\n<td>2，3，4</td>\n<td>0.047</td>\n</tr>\n<tr>\n<td>年龄21</td>\n<td>1，2</td>\n<td>3，4</td>\n<td>0.0125</td>\n</tr>\n<tr>\n<td>年龄30</td>\n<td>1，2，3</td>\n<td>4</td>\n<td>0.062</td>\n</tr>\n<tr>\n<td>体重20</td>\n<td>/</td>\n<td>1，2，3，4</td>\n<td>0.082</td>\n</tr>\n<tr>\n<td>体重30</td>\n<td>1</td>\n<td>2，3，4</td>\n<td>0.047</td>\n</tr>\n<tr>\n<td>体重60</td>\n<td>1，2</td>\n<td>3，4</td>\n<td>0.0125</td>\n</tr>\n<tr>\n<td>体重70</td>\n<td>1，2，4</td>\n<td>3</td>\n<td>0.0867</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>以上划分点的损失函数最小为0.0125，有两个划分点分别为年龄21和体重60，所以随机选一个作为划分点，这里我们选年龄21。<br>此时还需要做一件事情，给这两个叶子结点分别赋一个参数，来拟合残差。</p>\n<script type=\"math/tex; mode=display\">c_{j1} =arg\\; \\underset{c}{min}\\sum\\limits_{x_i \\in R_{j1}} L(y_i,f_{0}(x_i) +c)</script><p>这里其实和上面初始化学习器是一个道理，平方损失，求导，</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial L(y_i,f_0(x_i)+c)}{\\partial c}=\\sum _{i=1}^N \\frac{\\partial (\\frac{1}{2}[y_i-f_0(x_i)-c]^2)}{\\partial c}=\\sum _{i=1}^N (c-y_i+f_0(x_i))</script><p>令导数等于零$\\sum _{i=1}^N (c-y_i+f_0(x_i))=0$化简之后得到每个叶子结点的参数$c$，其实就是标签值的均值$c=\\overline{y_i-f_0(x_i)}$。<br>根据上述划分结点：</p>\n<ul>\n<li>样本1，2为左叶子结点，$(x_1,x_2 \\in R_{11})$，所以$c_{11}=(−0.375−0.175)/2=−0.275。 $</li>\n<li>样本3，4为右叶子结点，$(x_3,x_4 \\in R_{11})$，所以$c_{21}=(0.225+0.325)/2=0.275。 $</li>\n</ul>\n<p>此时可更新强学习器 <script type=\"math/tex\">f_{1}(x) = f_{0}(x) + \\sum\\limits_{j=1}^{2}c_{j1}I(x \\in R_{j1})</script></p>\n<h3 id=\"3、对迭代轮数m-2-3-4-5-…-M\"><a href=\"#3、对迭代轮数m-2-3-4-5-…-M\" class=\"headerlink\" title=\"3、对迭代轮数m=2,3,4,5,…,M:\"></a>3、对迭代轮数m=2,3,4,5,…,M:</h3><p>循环迭代$M$次，$M$是人为控制的参数，迭代结束生成M棵树</p>\n<h3 id=\"4、得到最后的强学习器：\"><a href=\"#4、得到最后的强学习器：\" class=\"headerlink\" title=\"4、得到最后的强学习器：\"></a>4、得到最后的强学习器：</h3><p>为了方别展示和理解，我们假设$Ｍ＝１$，根据上述结果得到强学习器：</p>\n<script type=\"math/tex; mode=display\">f(x) = f_M(x) =f_0(x) + \\sum\\limits_{m=1}^{M}\\sum\\limits_{j=1}^{J}c_{jm}I(x \\in R_{jm})</script><p><img src=\"/2017/10/20/GBDT/GBDT-19fece56.png\" alt=\"\"></p>\n<h1 id=\"GBDT分类算法\"><a href=\"#GBDT分类算法\" class=\"headerlink\" title=\"GBDT分类算法\"></a>GBDT分类算法</h1><h2 id=\"二元GBDT分类算法\"><a href=\"#二元GBDT分类算法\" class=\"headerlink\" title=\"二元GBDT分类算法\"></a>二元GBDT分类算法</h2><h3 id=\"假设条件\"><a href=\"#假设条件\" class=\"headerlink\" title=\"假设条件\"></a>假设条件</h3><ul>\n<li>类别1的概率为:$p_1=\\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}}$</li>\n<li>类别2的概率为:$p_2=1-p_2=\\frac{e^{f_2(x)}}{e^{f_1(x)}+e^{f_2(x)}}$</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_1 &= \\frac{e^{f_1(x)}}{e^{f_1(x)}+e^{f_2(x)}} = \\frac{1}{1+e^{f_2(x)/f_1(x)}}=\\frac{1}{1+e^{f(x)}}   \\\\\np_2 &= 1-p_1  =\\frac{e^{f(x)}}{1+e^{f(x)}}\n\\end{align*}</script><h3 id=\"损失函数化简\"><a href=\"#损失函数化简\" class=\"headerlink\" title=\"损失函数化简\"></a>损失函数化简</h3><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：</p>\n<script type=\"math/tex; mode=display\">\\large L\\left(y,f(x)\\right)=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}</script><p>其中$\\large p=\\frac{1}{1+e^{f(x)}}$</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\large L\\left(y,f(x)\\right)&=-\\left\\{ylog\\;p+(1-y)log(1-p)\\right\\}\\\\\n &=-\\left \\{ ylog\\frac{e^{f(x)}}{1+e^{f(x)}} + (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=-\\left \\{ ylog\\frac{1}{1+e^{f(x)}} + ylog\\; e^{f(x)}+ (1-y)log\\frac{1}{1+e^{f(x)}} \\right \\} \\\\\n &=- \\left \\{ yf(x)-log\\left [ 1+e^{f(x)} \\right ] \\right \\}\n\\end{align*}</script><h3 id=\"算法简介\"><a href=\"#算法简介\" class=\"headerlink\" title=\"算法简介\"></a>算法简介</h3><p><img src=\"/2017/10/20/GBDT/GBDT-42bbe544.png\" alt=\"\"></p>\n<h3 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_i$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"第一棵树\"><a href=\"#第一棵树\" class=\"headerlink\" title=\"第一棵树\"></a>第一棵树</h4><h5 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a>推导</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nL\\left(y_i,c\\right)&=-\\left\\{y_ic-log\\left(1+e^{c}\\right)\\right\\} \\\\\n\\frac{\\partial L\\left(y_i,c\\right)}{\\partial c} &= \\frac{e^{c}}{1+e^{c}}-y=0 \\\\\n\\frac{e^{c}}{1+e^{c}}&=y \\\\\nc &= log \\frac{y}{1-y}=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)\n\\end{align*}</script><h5 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h5><script type=\"math/tex; mode=display\">f_0(x)=log\\left(\\frac{\\sum_{i=1}^N y_i}{\\sum_{i=1}^N(1-y_i)}\\right)=log\\left(\\frac{4}{6}\\right)=-0.4054</script><h4 id=\"对迭代轮数m-1\"><a href=\"#对迭代轮数m-1\" class=\"headerlink\" title=\"对迭代轮数m=1\"></a>对迭代轮数m=1</h4><script type=\"math/tex; mode=display\">r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N</script><script type=\"math/tex; mode=display\">r_{1,i}=y_1-\\frac{1}{1+e^{-f_{0}(x_1)}}=0-\\frac{1}{1+e^{-0.4054}}=-0.4</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$r_{1,i}$</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">-0.4</td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\">0.6</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>接着，我们需要以$r_{1,i}$为目标，拟合一颗树。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于等于划分点的样本</th>\n<th>大于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2，3，4，5，6，7，8，9，10</td>\n<td>0.2469</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1，2</td>\n<td>3，4，5，6，7，8，9，10</td>\n<td>0.25</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1，2，3</td>\n<td>4，5，6，7，8，9，10</td>\n<td>0.2449</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1，2，3，4</td>\n<td>5，6，7，8，9，10</td>\n<td>0.4375</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1，2，3，4，5</td>\n<td>6，7，8，9，10</td>\n<td>0.48</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1，2，3，4，5，6</td>\n<td>7，8，9，10</td>\n<td>0.4722</td>\n</tr>\n<tr>\n<td>7</td>\n<td>1，2，3，4，5，6，7</td>\n<td>8，9，10</td>\n<td>0.4263</td>\n</tr>\n<tr>\n<td>8</td>\n<td>1，2，3，4，5，6，7，8</td>\n<td>9，10</td>\n<td>0.1875</td>\n</tr>\n<tr>\n<td>9</td>\n<td>1，2，3，4，5，6，7，8，9</td>\n<td>10</td>\n<td>0.2222</td>\n</tr>\n<tr>\n<td>10</td>\n<td>1，2，3，4，5，6，7，8，9，10</td>\n<td>\\</td>\n<td>0.24</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>由此可知当切分点为8时，总方差最小。所以$R_{11}:x_i\\leqslant 8,R_{11}:x_i&gt; 8$</p>\n<h5 id=\"输出-c-m-j\"><a href=\"#输出-c-m-j\" class=\"headerlink\" title=\"输出$c_{m,j}$\"></a>输出$c_{m,j}$</h5><script type=\"math/tex; mode=display\">c_{m,j} =\\left. \\sum_{x_i\\in R_{m,j}} r_{m,i} \\middle / \\sum_{x_i\\in R_{m,j}} |r_{m,i}|(1-|r_{m,i}|) \\right.</script><script type=\"math/tex; mode=display\">c_{1,1}=-0.625 \\;\\;\\;\\;\\;\\;\\; c_{1,2}=2.5</script><script type=\"math/tex; mode=display\">f_{1,i}=\\sum_{j=1}^Jc_{jm}I(x \\in R_{jm})=\\left\\{\\begin{matrix}\n-0.4054-0.625=--1.0304\\\\\n-0.4054+2.5=2.0946\n\\end{matrix}\\right.</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{1,i}(x_i)$</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">-1.0304</td>\n<td style=\"text-align:center\">2.0946</td>\n<td style=\"text-align:center\">2.0946</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"对迭代轮数m-2\"><a href=\"#对迭代轮数m-2\" class=\"headerlink\" title=\"对迭代轮数m=2\"></a>对迭代轮数m=2</h4><p>其残差为</p>\n<script type=\"math/tex; mode=display\">r_{m,i} = -\\left[ \\frac{\\partial L(y_i,f(x_i))}{\\partial f(x_i)} \\right]_{f(x)=f_{m-1}(x)}=y_i-\\frac{1}{1+e^{\\left(-f_{m-1}(x_i)\\right)}} ~,~i=1,2,...,N</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{1,i}(x_i)$</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">0.6431</td>\n<td style=\"text-align:center\">0.6431</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-0.3569</td>\n<td style=\"text-align:center\">-7.1222</td>\n<td style=\"text-align:center\">-7.1222</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>继续拟合第二可数</p>\n<h4 id=\"综上\"><a href=\"#综上\" class=\"headerlink\" title=\"综上\"></a>综上</h4><p>一共拟合$M$棵树</p>\n<h2 id=\"多元GBDT分类算法\"><a href=\"#多元GBDT分类算法\" class=\"headerlink\" title=\"多元GBDT分类算法\"></a>多元GBDT分类算法</h2><p><img src=\"/2017/10/20/GBDT/GBDT-b9b2986e.png\" alt=\"\"></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_i$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,0}$</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,1}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$y_{i,2}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"根学习器\"><a href=\"#根学习器\" class=\"headerlink\" title=\"根学习器\"></a>根学习器</h4><p>首先进行初始化$f_{k0}(x_i)=0$，对所有的样本</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_{m,k}(x)&=\\frac{e^{f_{m,k}(x)}}{\\sum_{l=1}^K e^{f_{m,l(x)}}}\\\\\np_{0,0}(x)&=\\frac{e^{f_{0,0}(x)}}{\\sum_{l=1}^K e^{f_{0,l(x)}}}=0.3333\n\\end{align*}</script><h4 id=\"迭代轮数m-1\"><a href=\"#迭代轮数m-1\" class=\"headerlink\" title=\"迭代轮数m=1\"></a>迭代轮数m=1</h4><h5 id=\"第一个类别-y-i-0-拟合第一棵树-m-1\"><a href=\"#第一个类别-y-i-0-拟合第一棵树-m-1\" class=\"headerlink\" title=\"第一个类别$(y_i=0)$拟合第一棵树$(m=1)$\"></a>第一个类别$(y_i=0)$拟合第一棵树$(m=1)$</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_{i,0}$</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$p_{0,0}$</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$r_{1,i,0}$</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>选择切分点进行拟合<br>计算完后可以发现，当选择31做为分裂点时，可以得到最小的$MSE，MSE=0.4879$</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>划分点</th>\n<th>小于等于划分点的样本</th>\n<th>大于划分点的样本</th>\n<th>总方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2，6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>1.0036</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1，2</td>\n<td>6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5063</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1，2，6</td>\n<td>12，14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5149</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1，2，6，12</td>\n<td>14，18，20，31，40，54，65，65，100，101</td>\n<td>0.5222</td>\n</tr>\n<tr>\n<td>14</td>\n<td>1，2，6，12，14</td>\n<td>18，20，31，40，54，65，65，100，101</td>\n<td>0.5270</td>\n</tr>\n<tr>\n<td>18</td>\n<td>1，2，6，12，14，18</td>\n<td>20，31，40，54，65，65，100，101</td>\n<td>0.5270</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1，2，6，12，14，18，20</td>\n<td>31，40，54，65，65，100，101</td>\n<td>0.5175</td>\n</tr>\n<tr>\n<td>31</td>\n<td>1，2，6，12，14，18，20，31</td>\n<td>40，54，65，65，100，101</td>\n<td>0.4879</td>\n</tr>\n<tr>\n<td>40</td>\n<td>1，2，6，12，14，18，20，31，40</td>\n<td>54，65，65，100，101</td>\n<td>0.5163</td>\n</tr>\n<tr>\n<td>54</td>\n<td>1，2，6，12，14，18，20，31，40，54</td>\n<td>65，65，100，101</td>\n<td>0.9012</td>\n</tr>\n<tr>\n<td>65</td>\n<td>1，2，6，12，14，18，20，31，40，54，65，65</td>\n<td>100，101</td>\n<td>1.060</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1，14，18，20，31，40，54，65，65，100</td>\n<td>101</td>\n<td>0.5045</td>\n</tr>\n<tr>\n<td>101</td>\n<td>1，2，6，12，14，18，20，31，40，54，65，65，100，101</td>\n<td>\\</td>\n<td>0.5149</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>计算$c_{m,j,l}$<script type=\"math/tex; mode=display\">\\begin{align*}\nc_{mjl}&=\\frac{K-1}{K}\\frac{\\sum\\limits_{x_i \\in R_{mjl}}r_{mil}}{\\sum\\limits_{x_i \\in R_{mil}}|r_{mil}|(1-|r_{mil}|)}\\\\\nc_{110} &= 0.8751 \\\\\nc_{120} &= -0.9999\n\\end{align*}</script></li>\n</ul>\n<script type=\"math/tex; mode=display\">f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{m,k}(x_i)=f_{1,0}(x_i)$</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">1.1428</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n<td style=\"text-align:center\">-0.999</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h5 id=\"第二个类别（y-i-1-拟合第一颗树-m-1\"><a href=\"#第二个类别（y-i-1-拟合第一颗树-m-1\" class=\"headerlink\" title=\"第二个类别（y_i=1)拟合第一颗树$(m=1)$\"></a>第二个类别（y_i=1)拟合第一颗树$(m=1)$</h5><script type=\"math/tex; mode=display\">\\begin{align*}\nr_{m,i,k}=y_{i,k}-p_{m-1,k}\\\\\nr_{1,i,0}=y_{i,0}-p_{0,0}\n\\end{align*}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$y_{i,1}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$p_{0,1}$</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n<td style=\"text-align:center\">0.3333</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$r_{1,i,1}$</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">0.6667</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n<td style=\"text-align:center\">-0.3333</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>以$r_{1,i,1}$拟合一颗回归树，（以6为分裂点）,可计算得到叶子结点</p>\n<script type=\"math/tex; mode=display\">c_{111}=2 \\;\\;\\;\\;\\;c_{121}=0.2499</script><script type=\"math/tex; mode=display\">f_{mk}(x_i)=f_{m-1,k}(x_i)+\\sum_{x_i \\in R_{mjk}}c_{mjk}*I(x_i \\in R_{mjk})</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$x_i$</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">18</th>\n<th style=\"text-align:center\">20</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">31</th>\n<th style=\"text-align:center\">40</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">100</th>\n<th style=\"text-align:center\">101</th>\n<th style=\"text-align:center\">65</th>\n<th style=\"text-align:center\">54</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$f_{m,k}(x_i)=f_{1,1}(x_i)$</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n<td style=\"text-align:center\">-0.2499</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"综上-1\"><a href=\"#综上-1\" class=\"headerlink\" title=\"综上\"></a>综上</h3><p>然后再拟合第三个类别（类别2）的第一颗树，过程也是重复上述步骤，所以这里就不再重复了。在拟合完所有类别的第一颗树后就开始拟合第二颗树。反复进行，直到训练了$M$轮。</p>"},{"title":"HDFS","date":"2019-08-16T02:17:08.000Z","_content":"\n# HDFS框架\n\n![img](HDFS/2608446-66ac838fbd1c4c6d.webp)\n\n- 主从结构：\n  1. 主节点，只有一个  ： `namenode`\n  2. 从节点，有很多个  ：`datanodes`\n- `namenode`负责：\n     1. 接收用户请求操作\n     2.  维护文件信息系统的目录结构\n     3. 管理文件与`block`之间的关系，`block`与`datanade`之间的关系\n        注意：`namenode`归根结底要放在磁盘上的以保证数据的持久性，但是为了提高效率，一般在`hadoop`运行时时放在内存中的\n- `datanode`负责：\n        1. 存储文件\n           2. 文件被分成`block`存储字磁盘上\n           3. 为保证数据安全，文件会有多个副本\n\n# HDFS shell命令\n\n**命令格式：** `bin/hadoop fs <args> URI`\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`URI`：`scheme://authority/path`—HDFS文件系统\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`file://authority/path`—本地文件系统\n\n| 命令            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `cat`           | 使用方法：`hadoop fs -cat URI [URI …]`<br>**将路径指定文件的内容输出到`stdout,`成功返回0，失败返回-1。**<br>eg:`hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2`<br>&emsp;&nbsp;&nbsp;`hadoop fs -cat file:///file3 /user/hadoop/file4` |\n| `chgrp`         | 使用方法：`hadoop fs -chgrp [-R] GROUP URI [URI …]`<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; `-R`：递归改变文件的目录结构<br>**改变文件所属的组。** |\n| `chmod`         | 使用方法：`hadoop fs -chmod [-R] <MODE[,MODE]...  OCTALMODE> URI [URI …]`<br> &nbsp; &emsp; &emsp;&emsp;&emsp;`-R`：递归改变文件的目录结构<br/>**改变文件的权限。** |\n| `chown`         | 使用方法：`hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]`<br>&emsp;&emsp;&emsp;&emsp;&emsp;`-R`：递归改变文件的目录结构<br/>**改变文件的拥有者。** |\n| `copyFromLocal` | 使用方法：`hadoop fs -copyFromLocal <localsrc> URI`<br>**除了限定源路径是一个本地文件外，和[`put`](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#putlink)命令相似** |\n| `copyToLocal`   | 使用方法：`hadoop fs -copyToLocal [-ignorecrc] [-crc] URI <localdst>`<br>**除了限定目标路径是一个本地文件外，和[get](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#getlink)命令类似。** |\n| `cp`            | 使用方法：`hadoop fs -cp URI [URI …] <dest>`<br>**将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。成功返回0，失败返回-1。**<br>eg：`hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir` |\n| `du`            | 使用方法：`hadoop fs -du URI [URI …]`<br>**显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。成功返回0，失败返回-1。**<br>eg：`hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1` |\n| `dus`           | 使用方法：`hadoop fs -dus <args>`<br>**显示文件的大小。**    |\n| `expunge`       | 使用方法：`hadoop fs -expunge`<br>**清空回收站。**           |\n| `get`           | 使用方法：`hadoop fs -get [-ignorecrc] [-crc] <src> <localdst>`<br>**复制文件到本地文件系统。可用`-ignorecrc`选项复制`CRC`校验失败的文件。使用`-crc`选项复制文件以及CRC信息。**<br>eg：`hadoop fs -get /user/hadoop/file localfile`<br>&emsp;&emsp;`hadoop fs -get hdfs://host:port/user/hadoop/file localfile` |\n| `getmerge`      | 使用方法：`hadoop fs -getmerge <src> <localdst> [addnl]`<br>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。`addnl`是可选的，用于指定在每个文件结尾添加一个换行符。 |\n| `ls`            | 使用方法：`hadoop fs -ls <args>`<br>如果是文件，则按照如下格式返回文件信息：`文件名 <副本数> 文件大小 修改日期 修改时间 权限 用户ID 组ID`<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下`目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID`<br>成功返回0，失败返回-1。 |\n| `lsr`           | `ls`命令的递归版本。类似于Unix中的`ls -R`。                  |\n| `mkdir`         | 使用方法：`hadoop fs -mkdir <paths>`<br>**接受路径指定的`uri`作为参数，创建这些目录。其行为类似于`Unix`的`mkdir -p`，它会创建路径中的各级父目录。成功返回0，失败返回-1。**<br>eg：`hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2` |\n| `movefromLocal` | 使用方法：`dfs -moveFromLocal <src> <dst>`                   |\n| `mv`            | 使用方法：`hadoop fs -mv URI [URI …] <dest>`<br>**将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。**<br>eg：`hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2` |\n| `put`           | 使用方法：`hadoop fs -put <localsrc> ... <dst>`<br>**从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。成功返回0，失败返回-1。**<br>eg：`hadoop fs -put localfile /user/hadoop/hadoopfile` |\n| `rm`            | 使用方法：`hadoop fs -rm URI [URI …]`<br>**删除指定的文件。只删除非空目录和文件。请参考`rmr`命令了解递归删除。成功返回0，失败返回-1。**<br>eg：`hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir` |\n| `rmr`           | 使用方法：`hadoop fs -rmr URI [URI …]`<br>`delete`的递归版本。<br>`hadoop fs -rmr /user/hadoop/dir` |\n| `setrep`        | 使用方法：`hadoop fs -setrep [-R] <path>`<br>**改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。成功返回0，失败返回-1。**<br>`hadoop fs -setrep -w 3 -R /user/hadoop/dir1` |\n| `stat`          | 使用方法：`hadoop fs -stat URI [URI …]`<br>**返回指定路径的统计信息。**<br>`hadoop fs -stat path` |\n| `tail`          | 使用方法：`hadoop fs -tail [-f] URI`<br>**将文件尾部1K字节的内容输出到`stdout`。支持-f选项，行为和`Unix`中一致。成功返回0，失败返回-1。** |\n| `test`          | 使用方法：`hadoop fs -test -[ezd] URI`<br>&emsp;&emsp;&emsp;&emsp;&emsp;`-e` 检查文件是否存在。如果存在则返回`0`。<br/>&emsp;&emsp;&emsp;&emsp;&emsp;`-z` 检查文件是否是`0`字节。如果是则返回`0`。 <br/>&emsp;&emsp;&emsp;&emsp;&emsp;`-d `如果路径是个目录，则返回`1`，否则返回`0`。 |\n| `text`          | 使用方法：`hadoop fs -text <src>`<br>**将源文件输出为文本格式。允许的格式是`zip`和`TextRecordInputStream`。** |\n| `touchz`        | 使用方法：`hadoop fs -touchz URI [URI …]`<br>**创建一个0字节的空文件。成功返回0，失败返回-1。** |\n\n\n\n","source":"_posts/HDFS.md","raw":"---\ntitle: HDFS\ndate: 2019-08-16 10:17:08\ntags: [人工智能,分布式系统]\ncategories: Hadoop\npermalink: hadoop/HDFS.md\n---\n\n# HDFS框架\n\n![img](HDFS/2608446-66ac838fbd1c4c6d.webp)\n\n- 主从结构：\n  1. 主节点，只有一个  ： `namenode`\n  2. 从节点，有很多个  ：`datanodes`\n- `namenode`负责：\n     1. 接收用户请求操作\n     2.  维护文件信息系统的目录结构\n     3. 管理文件与`block`之间的关系，`block`与`datanade`之间的关系\n        注意：`namenode`归根结底要放在磁盘上的以保证数据的持久性，但是为了提高效率，一般在`hadoop`运行时时放在内存中的\n- `datanode`负责：\n        1. 存储文件\n           2. 文件被分成`block`存储字磁盘上\n           3. 为保证数据安全，文件会有多个副本\n\n# HDFS shell命令\n\n**命令格式：** `bin/hadoop fs <args> URI`\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`URI`：`scheme://authority/path`—HDFS文件系统\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`file://authority/path`—本地文件系统\n\n| 命令            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `cat`           | 使用方法：`hadoop fs -cat URI [URI …]`<br>**将路径指定文件的内容输出到`stdout,`成功返回0，失败返回-1。**<br>eg:`hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2`<br>&emsp;&nbsp;&nbsp;`hadoop fs -cat file:///file3 /user/hadoop/file4` |\n| `chgrp`         | 使用方法：`hadoop fs -chgrp [-R] GROUP URI [URI …]`<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; `-R`：递归改变文件的目录结构<br>**改变文件所属的组。** |\n| `chmod`         | 使用方法：`hadoop fs -chmod [-R] <MODE[,MODE]...  OCTALMODE> URI [URI …]`<br> &nbsp; &emsp; &emsp;&emsp;&emsp;`-R`：递归改变文件的目录结构<br/>**改变文件的权限。** |\n| `chown`         | 使用方法：`hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]`<br>&emsp;&emsp;&emsp;&emsp;&emsp;`-R`：递归改变文件的目录结构<br/>**改变文件的拥有者。** |\n| `copyFromLocal` | 使用方法：`hadoop fs -copyFromLocal <localsrc> URI`<br>**除了限定源路径是一个本地文件外，和[`put`](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#putlink)命令相似** |\n| `copyToLocal`   | 使用方法：`hadoop fs -copyToLocal [-ignorecrc] [-crc] URI <localdst>`<br>**除了限定目标路径是一个本地文件外，和[get](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#getlink)命令类似。** |\n| `cp`            | 使用方法：`hadoop fs -cp URI [URI …] <dest>`<br>**将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。成功返回0，失败返回-1。**<br>eg：`hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir` |\n| `du`            | 使用方法：`hadoop fs -du URI [URI …]`<br>**显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。成功返回0，失败返回-1。**<br>eg：`hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1` |\n| `dus`           | 使用方法：`hadoop fs -dus <args>`<br>**显示文件的大小。**    |\n| `expunge`       | 使用方法：`hadoop fs -expunge`<br>**清空回收站。**           |\n| `get`           | 使用方法：`hadoop fs -get [-ignorecrc] [-crc] <src> <localdst>`<br>**复制文件到本地文件系统。可用`-ignorecrc`选项复制`CRC`校验失败的文件。使用`-crc`选项复制文件以及CRC信息。**<br>eg：`hadoop fs -get /user/hadoop/file localfile`<br>&emsp;&emsp;`hadoop fs -get hdfs://host:port/user/hadoop/file localfile` |\n| `getmerge`      | 使用方法：`hadoop fs -getmerge <src> <localdst> [addnl]`<br>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。`addnl`是可选的，用于指定在每个文件结尾添加一个换行符。 |\n| `ls`            | 使用方法：`hadoop fs -ls <args>`<br>如果是文件，则按照如下格式返回文件信息：`文件名 <副本数> 文件大小 修改日期 修改时间 权限 用户ID 组ID`<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下`目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID`<br>成功返回0，失败返回-1。 |\n| `lsr`           | `ls`命令的递归版本。类似于Unix中的`ls -R`。                  |\n| `mkdir`         | 使用方法：`hadoop fs -mkdir <paths>`<br>**接受路径指定的`uri`作为参数，创建这些目录。其行为类似于`Unix`的`mkdir -p`，它会创建路径中的各级父目录。成功返回0，失败返回-1。**<br>eg：`hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2` |\n| `movefromLocal` | 使用方法：`dfs -moveFromLocal <src> <dst>`                   |\n| `mv`            | 使用方法：`hadoop fs -mv URI [URI …] <dest>`<br>**将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。**<br>eg：`hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2` |\n| `put`           | 使用方法：`hadoop fs -put <localsrc> ... <dst>`<br>**从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。成功返回0，失败返回-1。**<br>eg：`hadoop fs -put localfile /user/hadoop/hadoopfile` |\n| `rm`            | 使用方法：`hadoop fs -rm URI [URI …]`<br>**删除指定的文件。只删除非空目录和文件。请参考`rmr`命令了解递归删除。成功返回0，失败返回-1。**<br>eg：`hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir` |\n| `rmr`           | 使用方法：`hadoop fs -rmr URI [URI …]`<br>`delete`的递归版本。<br>`hadoop fs -rmr /user/hadoop/dir` |\n| `setrep`        | 使用方法：`hadoop fs -setrep [-R] <path>`<br>**改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。成功返回0，失败返回-1。**<br>`hadoop fs -setrep -w 3 -R /user/hadoop/dir1` |\n| `stat`          | 使用方法：`hadoop fs -stat URI [URI …]`<br>**返回指定路径的统计信息。**<br>`hadoop fs -stat path` |\n| `tail`          | 使用方法：`hadoop fs -tail [-f] URI`<br>**将文件尾部1K字节的内容输出到`stdout`。支持-f选项，行为和`Unix`中一致。成功返回0，失败返回-1。** |\n| `test`          | 使用方法：`hadoop fs -test -[ezd] URI`<br>&emsp;&emsp;&emsp;&emsp;&emsp;`-e` 检查文件是否存在。如果存在则返回`0`。<br/>&emsp;&emsp;&emsp;&emsp;&emsp;`-z` 检查文件是否是`0`字节。如果是则返回`0`。 <br/>&emsp;&emsp;&emsp;&emsp;&emsp;`-d `如果路径是个目录，则返回`1`，否则返回`0`。 |\n| `text`          | 使用方法：`hadoop fs -text <src>`<br>**将源文件输出为文本格式。允许的格式是`zip`和`TextRecordInputStream`。** |\n| `touchz`        | 使用方法：`hadoop fs -touchz URI [URI …]`<br>**创建一个0字节的空文件。成功返回0，失败返回-1。** |\n\n\n\n","slug":"hadoop/HDFS.md","published":1,"updated":"2019-08-16T06:49:59.153Z","_id":"cjzdr6iyi001qhomj07gym6f7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"HDFS框架\"><a href=\"#HDFS框架\" class=\"headerlink\" title=\"HDFS框架\"></a>HDFS框架</h1><p><img src=\"/2019/08/16/hadoop/HDFS.md/2608446-66ac838fbd1c4c6d.webp\" alt=\"img\"></p>\n<ul>\n<li>主从结构：<ol>\n<li>主节点，只有一个  ： <code>namenode</code></li>\n<li>从节点，有很多个  ：<code>datanodes</code></li>\n</ol>\n</li>\n<li><code>namenode</code>负责：<ol>\n<li>接收用户请求操作</li>\n<li>维护文件信息系统的目录结构</li>\n<li>管理文件与<code>block</code>之间的关系，<code>block</code>与<code>datanade</code>之间的关系<br>注意：<code>namenode</code>归根结底要放在磁盘上的以保证数据的持久性，但是为了提高效率，一般在<code>hadoop</code>运行时时放在内存中的</li>\n</ol>\n</li>\n<li><code>datanode</code>负责：<pre><code>  1. 存储文件\n     2. 文件被分成`block`存储字磁盘上\n     3. 为保证数据安全，文件会有多个副本\n</code></pre></li>\n</ul>\n<h1 id=\"HDFS-shell命令\"><a href=\"#HDFS-shell命令\" class=\"headerlink\" title=\"HDFS shell命令\"></a>HDFS shell命令</h1><p><strong>命令格式：</strong> <code>bin/hadoop fs &lt;args&gt; URI</code></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>URI</code>：<code>scheme://authority/path</code>—HDFS文件系统<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>file://authority/path</code>—本地文件系统</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cat</code></td>\n<td>使用方法：<code>hadoop fs -cat URI [URI …]</code><br><strong>将路径指定文件的内容输出到<code>stdout,</code>成功返回0，失败返回-1。</strong><br>eg:<code>hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2</code><br>&emsp;&nbsp;&nbsp;<code>hadoop fs -cat file:///file3 /user/hadoop/file4</code></td>\n</tr>\n<tr>\n<td><code>chgrp</code></td>\n<td>使用方法：<code>hadoop fs -chgrp [-R] GROUP URI [URI …]</code><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; <code>-R</code>：递归改变文件的目录结构<br><strong>改变文件所属的组。</strong></td>\n</tr>\n<tr>\n<td><code>chmod</code></td>\n<td>使用方法：<code>hadoop fs -chmod [-R] &lt;MODE[,MODE]...  OCTALMODE&gt; URI [URI …]</code><br> &nbsp; &emsp; &emsp;&emsp;&emsp;<code>-R</code>：递归改变文件的目录结构<br><strong>改变文件的权限。</strong></td>\n</tr>\n<tr>\n<td><code>chown</code></td>\n<td>使用方法：<code>hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-R</code>：递归改变文件的目录结构<br><strong>改变文件的拥有者。</strong></td>\n</tr>\n<tr>\n<td><code>copyFromLocal</code></td>\n<td>使用方法：<code>hadoop fs -copyFromLocal &lt;localsrc&gt; URI</code><br><strong>除了限定源路径是一个本地文件外，和<a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#putlink\" target=\"_blank\" rel=\"noopener\"><code>put</code></a>命令相似</strong></td>\n</tr>\n<tr>\n<td><code>copyToLocal</code></td>\n<td>使用方法：<code>hadoop fs -copyToLocal [-ignorecrc] [-crc] URI &lt;localdst&gt;</code><br><strong>除了限定目标路径是一个本地文件外，和<a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#getlink\" target=\"_blank\" rel=\"noopener\">get</a>命令类似。</strong></td>\n</tr>\n<tr>\n<td><code>cp</code></td>\n<td>使用方法：<code>hadoop fs -cp URI [URI …] &lt;dest&gt;</code><br><strong>将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir</code></td>\n</tr>\n<tr>\n<td><code>du</code></td>\n<td>使用方法：<code>hadoop fs -du URI [URI …]</code><br><strong>显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1</code></td>\n</tr>\n<tr>\n<td><code>dus</code></td>\n<td>使用方法：<code>hadoop fs -dus &lt;args&gt;</code><br><strong>显示文件的大小。</strong></td>\n</tr>\n<tr>\n<td><code>expunge</code></td>\n<td>使用方法：<code>hadoop fs -expunge</code><br><strong>清空回收站。</strong></td>\n</tr>\n<tr>\n<td><code>get</code></td>\n<td>使用方法：<code>hadoop fs -get [-ignorecrc] [-crc] &lt;src&gt; &lt;localdst&gt;</code><br><strong>复制文件到本地文件系统。可用<code>-ignorecrc</code>选项复制<code>CRC</code>校验失败的文件。使用<code>-crc</code>选项复制文件以及CRC信息。</strong><br>eg：<code>hadoop fs -get /user/hadoop/file localfile</code><br>&emsp;&emsp;<code>hadoop fs -get hdfs://host:port/user/hadoop/file localfile</code></td>\n</tr>\n<tr>\n<td><code>getmerge</code></td>\n<td>使用方法：<code>hadoop fs -getmerge &lt;src&gt; &lt;localdst&gt; [addnl]</code><br>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。<code>addnl</code>是可选的，用于指定在每个文件结尾添加一个换行符。</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>使用方法：<code>hadoop fs -ls &lt;args&gt;</code><br>如果是文件，则按照如下格式返回文件信息：<code>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID</code><br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下<code>目录名 &lt;dir&gt; 修改日期 修改时间 权限 用户ID 组ID</code><br>成功返回0，失败返回-1。</td>\n</tr>\n<tr>\n<td><code>lsr</code></td>\n<td><code>ls</code>命令的递归版本。类似于Unix中的<code>ls -R</code>。</td>\n</tr>\n<tr>\n<td><code>mkdir</code></td>\n<td>使用方法：<code>hadoop fs -mkdir &lt;paths&gt;</code><br><strong>接受路径指定的<code>uri</code>作为参数，创建这些目录。其行为类似于<code>Unix</code>的<code>mkdir -p</code>，它会创建路径中的各级父目录。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2</code></td>\n</tr>\n<tr>\n<td><code>movefromLocal</code></td>\n<td>使用方法：<code>dfs -moveFromLocal &lt;src&gt; &lt;dst&gt;</code></td>\n</tr>\n<tr>\n<td><code>mv</code></td>\n<td>使用方法：<code>hadoop fs -mv URI [URI …] &lt;dest&gt;</code><br><strong>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。</strong><br>eg：<code>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</code></td>\n</tr>\n<tr>\n<td><code>put</code></td>\n<td>使用方法：<code>hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;</code><br><strong>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -put localfile /user/hadoop/hadoopfile</code></td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>使用方法：<code>hadoop fs -rm URI [URI …]</code><br><strong>删除指定的文件。只删除非空目录和文件。请参考<code>rmr</code>命令了解递归删除。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</code></td>\n</tr>\n<tr>\n<td><code>rmr</code></td>\n<td>使用方法：<code>hadoop fs -rmr URI [URI …]</code><br><code>delete</code>的递归版本。<br><code>hadoop fs -rmr /user/hadoop/dir</code></td>\n</tr>\n<tr>\n<td><code>setrep</code></td>\n<td>使用方法：<code>hadoop fs -setrep [-R] &lt;path&gt;</code><br><strong>改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。成功返回0，失败返回-1。</strong><br><code>hadoop fs -setrep -w 3 -R /user/hadoop/dir1</code></td>\n</tr>\n<tr>\n<td><code>stat</code></td>\n<td>使用方法：<code>hadoop fs -stat URI [URI …]</code><br><strong>返回指定路径的统计信息。</strong><br><code>hadoop fs -stat path</code></td>\n</tr>\n<tr>\n<td><code>tail</code></td>\n<td>使用方法：<code>hadoop fs -tail [-f] URI</code><br><strong>将文件尾部1K字节的内容输出到<code>stdout</code>。支持-f选项，行为和<code>Unix</code>中一致。成功返回0，失败返回-1。</strong></td>\n</tr>\n<tr>\n<td><code>test</code></td>\n<td>使用方法：<code>hadoop fs -test -[ezd] URI</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-e</code> 检查文件是否存在。如果存在则返回<code>0</code>。<br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-z</code> 检查文件是否是<code>0</code>字节。如果是则返回<code>0</code>。 <br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-d</code>如果路径是个目录，则返回<code>1</code>，否则返回<code>0</code>。</td>\n</tr>\n<tr>\n<td><code>text</code></td>\n<td>使用方法：<code>hadoop fs -text &lt;src&gt;</code><br><strong>将源文件输出为文本格式。允许的格式是<code>zip</code>和<code>TextRecordInputStream</code>。</strong></td>\n</tr>\n<tr>\n<td><code>touchz</code></td>\n<td>使用方法：<code>hadoop fs -touchz URI [URI …]</code><br><strong>创建一个0字节的空文件。成功返回0，失败返回-1。</strong></td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HDFS框架\"><a href=\"#HDFS框架\" class=\"headerlink\" title=\"HDFS框架\"></a>HDFS框架</h1><p><img src=\"/2019/08/16/hadoop/HDFS.md/2608446-66ac838fbd1c4c6d.webp\" alt=\"img\"></p>\n<ul>\n<li>主从结构：<ol>\n<li>主节点，只有一个  ： <code>namenode</code></li>\n<li>从节点，有很多个  ：<code>datanodes</code></li>\n</ol>\n</li>\n<li><code>namenode</code>负责：<ol>\n<li>接收用户请求操作</li>\n<li>维护文件信息系统的目录结构</li>\n<li>管理文件与<code>block</code>之间的关系，<code>block</code>与<code>datanade</code>之间的关系<br>注意：<code>namenode</code>归根结底要放在磁盘上的以保证数据的持久性，但是为了提高效率，一般在<code>hadoop</code>运行时时放在内存中的</li>\n</ol>\n</li>\n<li><code>datanode</code>负责：<pre><code>  1. 存储文件\n     2. 文件被分成`block`存储字磁盘上\n     3. 为保证数据安全，文件会有多个副本\n</code></pre></li>\n</ul>\n<h1 id=\"HDFS-shell命令\"><a href=\"#HDFS-shell命令\" class=\"headerlink\" title=\"HDFS shell命令\"></a>HDFS shell命令</h1><p><strong>命令格式：</strong> <code>bin/hadoop fs &lt;args&gt; URI</code></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>URI</code>：<code>scheme://authority/path</code>—HDFS文件系统<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>file://authority/path</code>—本地文件系统</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cat</code></td>\n<td>使用方法：<code>hadoop fs -cat URI [URI …]</code><br><strong>将路径指定文件的内容输出到<code>stdout,</code>成功返回0，失败返回-1。</strong><br>eg:<code>hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2</code><br>&emsp;&nbsp;&nbsp;<code>hadoop fs -cat file:///file3 /user/hadoop/file4</code></td>\n</tr>\n<tr>\n<td><code>chgrp</code></td>\n<td>使用方法：<code>hadoop fs -chgrp [-R] GROUP URI [URI …]</code><br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; <code>-R</code>：递归改变文件的目录结构<br><strong>改变文件所属的组。</strong></td>\n</tr>\n<tr>\n<td><code>chmod</code></td>\n<td>使用方法：<code>hadoop fs -chmod [-R] &lt;MODE[,MODE]...  OCTALMODE&gt; URI [URI …]</code><br> &nbsp; &emsp; &emsp;&emsp;&emsp;<code>-R</code>：递归改变文件的目录结构<br><strong>改变文件的权限。</strong></td>\n</tr>\n<tr>\n<td><code>chown</code></td>\n<td>使用方法：<code>hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-R</code>：递归改变文件的目录结构<br><strong>改变文件的拥有者。</strong></td>\n</tr>\n<tr>\n<td><code>copyFromLocal</code></td>\n<td>使用方法：<code>hadoop fs -copyFromLocal &lt;localsrc&gt; URI</code><br><strong>除了限定源路径是一个本地文件外，和<a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#putlink\" target=\"_blank\" rel=\"noopener\"><code>put</code></a>命令相似</strong></td>\n</tr>\n<tr>\n<td><code>copyToLocal</code></td>\n<td>使用方法：<code>hadoop fs -copyToLocal [-ignorecrc] [-crc] URI &lt;localdst&gt;</code><br><strong>除了限定目标路径是一个本地文件外，和<a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#getlink\" target=\"_blank\" rel=\"noopener\">get</a>命令类似。</strong></td>\n</tr>\n<tr>\n<td><code>cp</code></td>\n<td>使用方法：<code>hadoop fs -cp URI [URI …] &lt;dest&gt;</code><br><strong>将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir</code></td>\n</tr>\n<tr>\n<td><code>du</code></td>\n<td>使用方法：<code>hadoop fs -du URI [URI …]</code><br><strong>显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1</code></td>\n</tr>\n<tr>\n<td><code>dus</code></td>\n<td>使用方法：<code>hadoop fs -dus &lt;args&gt;</code><br><strong>显示文件的大小。</strong></td>\n</tr>\n<tr>\n<td><code>expunge</code></td>\n<td>使用方法：<code>hadoop fs -expunge</code><br><strong>清空回收站。</strong></td>\n</tr>\n<tr>\n<td><code>get</code></td>\n<td>使用方法：<code>hadoop fs -get [-ignorecrc] [-crc] &lt;src&gt; &lt;localdst&gt;</code><br><strong>复制文件到本地文件系统。可用<code>-ignorecrc</code>选项复制<code>CRC</code>校验失败的文件。使用<code>-crc</code>选项复制文件以及CRC信息。</strong><br>eg：<code>hadoop fs -get /user/hadoop/file localfile</code><br>&emsp;&emsp;<code>hadoop fs -get hdfs://host:port/user/hadoop/file localfile</code></td>\n</tr>\n<tr>\n<td><code>getmerge</code></td>\n<td>使用方法：<code>hadoop fs -getmerge &lt;src&gt; &lt;localdst&gt; [addnl]</code><br>接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。<code>addnl</code>是可选的，用于指定在每个文件结尾添加一个换行符。</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>使用方法：<code>hadoop fs -ls &lt;args&gt;</code><br>如果是文件，则按照如下格式返回文件信息：<code>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID</code><br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下<code>目录名 &lt;dir&gt; 修改日期 修改时间 权限 用户ID 组ID</code><br>成功返回0，失败返回-1。</td>\n</tr>\n<tr>\n<td><code>lsr</code></td>\n<td><code>ls</code>命令的递归版本。类似于Unix中的<code>ls -R</code>。</td>\n</tr>\n<tr>\n<td><code>mkdir</code></td>\n<td>使用方法：<code>hadoop fs -mkdir &lt;paths&gt;</code><br><strong>接受路径指定的<code>uri</code>作为参数，创建这些目录。其行为类似于<code>Unix</code>的<code>mkdir -p</code>，它会创建路径中的各级父目录。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2</code></td>\n</tr>\n<tr>\n<td><code>movefromLocal</code></td>\n<td>使用方法：<code>dfs -moveFromLocal &lt;src&gt; &lt;dst&gt;</code></td>\n</tr>\n<tr>\n<td><code>mv</code></td>\n<td>使用方法：<code>hadoop fs -mv URI [URI …] &lt;dest&gt;</code><br><strong>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。</strong><br>eg：<code>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</code></td>\n</tr>\n<tr>\n<td><code>put</code></td>\n<td>使用方法：<code>hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;</code><br><strong>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -put localfile /user/hadoop/hadoopfile</code></td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>使用方法：<code>hadoop fs -rm URI [URI …]</code><br><strong>删除指定的文件。只删除非空目录和文件。请参考<code>rmr</code>命令了解递归删除。成功返回0，失败返回-1。</strong><br>eg：<code>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</code></td>\n</tr>\n<tr>\n<td><code>rmr</code></td>\n<td>使用方法：<code>hadoop fs -rmr URI [URI …]</code><br><code>delete</code>的递归版本。<br><code>hadoop fs -rmr /user/hadoop/dir</code></td>\n</tr>\n<tr>\n<td><code>setrep</code></td>\n<td>使用方法：<code>hadoop fs -setrep [-R] &lt;path&gt;</code><br><strong>改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。成功返回0，失败返回-1。</strong><br><code>hadoop fs -setrep -w 3 -R /user/hadoop/dir1</code></td>\n</tr>\n<tr>\n<td><code>stat</code></td>\n<td>使用方法：<code>hadoop fs -stat URI [URI …]</code><br><strong>返回指定路径的统计信息。</strong><br><code>hadoop fs -stat path</code></td>\n</tr>\n<tr>\n<td><code>tail</code></td>\n<td>使用方法：<code>hadoop fs -tail [-f] URI</code><br><strong>将文件尾部1K字节的内容输出到<code>stdout</code>。支持-f选项，行为和<code>Unix</code>中一致。成功返回0，失败返回-1。</strong></td>\n</tr>\n<tr>\n<td><code>test</code></td>\n<td>使用方法：<code>hadoop fs -test -[ezd] URI</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-e</code> 检查文件是否存在。如果存在则返回<code>0</code>。<br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-z</code> 检查文件是否是<code>0</code>字节。如果是则返回<code>0</code>。 <br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>-d</code>如果路径是个目录，则返回<code>1</code>，否则返回<code>0</code>。</td>\n</tr>\n<tr>\n<td><code>text</code></td>\n<td>使用方法：<code>hadoop fs -text &lt;src&gt;</code><br><strong>将源文件输出为文本格式。允许的格式是<code>zip</code>和<code>TextRecordInputStream</code>。</strong></td>\n</tr>\n<tr>\n<td><code>touchz</code></td>\n<td>使用方法：<code>hadoop fs -touchz URI [URI …]</code><br><strong>创建一个0字节的空文件。成功返回0，失败返回-1。</strong></td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"MapReduce","date":"2019-08-16T06:48:05.000Z","_content":"\n`Map/Reduce` 是一个分布式运算程序的编程框架，`Map/Reduce` 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 `hadoop` 集群上。每个`Map/Reduce`任务都被初始化为一个`Job`，每个`Job`又可以分为两种阶段：`map`阶段和`reduce`阶段。这两个阶段分别用两个函数表示，即`map`函数和`reduce`函数。一个`Map/Reduce`作业的输入和输出类型如下所示：\n\n`(input) <k1, v1> -> map-> <k2, v2> -> Shuff-> <k2, list[v2]> -> reduce -> <k3, v3> (output)`\n\n简单在于其编程模型只包含`map`和`reduce`两个过程，`map`的主要输入是一对`<key , value>`值，经过`map`计算后输出一对`<key , value>`值；然后将相同`key`合并，形成`<key , value集合>`；再将这个`<key , value集合>`输入`reduce`，经过计算输出零个或多个`<key , value>`对。\n\n![img](MapReduce/14019352-0c530b046636edd0.webp)\n\n# [原理](https://songlee24.github.io/2015/07/29/mapreduce-word-count/)\n\n![img](MapReduce/1089769-20180418222127341-658345249.png)\n\n系统中有两类主要的进程节点：`master`（单点），`worker`（多个）。其中，`worker`根据不同的计算任务，又分为`map worke`r（对应上图中的`Map phase`）、`reduce worker`（对应上图中的`Reduce phase`）。\n\n- `master`是系统的中心节点，负责为`worker`节点分配计算任务，同时监控`worker`节点的状态。如果某个`worker`计算太慢，或者宕机，`master`会将该`worker`进程负责的计算任务转移到其他进程。\n- `worker`包括`Map`与`Reduce`\n\n1. 首先将文件分割成`<key,value>`的键值对。`Map`通过 `RecordReader` 读取Input的`<key,value>`对，`map`根据用户自定义的任务，运行完毕后，输出另外一系列`<key,value>`，\n2. `Shuffle` 阶段需要从所有`map`主机上把相同的`key` 的 `key value`对组合在一起，（也就是这里省去的`Combine`阶段）。\n3. `Partitioner`组件会把 `key `放进一个 `hash`函数里，然后得到结果。如果两个 `key` 的哈希值 一样，他们的 `<key,value>`对就被放到同一个 `reduce` 函数里。我们也把分配到同一个 `reduce`函数里的` <key,value>`对叫做一个`reduce partition`。\n4. `reduce()` 函数以 `key` 及对应的 `value` 列表作为输入，按照用户自己的程序逻辑，经合并 `key` 相同的 `value` 值后，产 生另外一系列 `<key,value>` 对作为最终输出写入` HDFS`。\n\n# 应用\n\n","source":"_posts/MapReduce.md","raw":"---\ntitle: MapReduce\ndate: 2019-08-16 14:48:05\ntags: [人工智能,分布式系统]\ncategories: Hadoop\npermalink: hadoop/MapReduce.md\n---\n\n`Map/Reduce` 是一个分布式运算程序的编程框架，`Map/Reduce` 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 `hadoop` 集群上。每个`Map/Reduce`任务都被初始化为一个`Job`，每个`Job`又可以分为两种阶段：`map`阶段和`reduce`阶段。这两个阶段分别用两个函数表示，即`map`函数和`reduce`函数。一个`Map/Reduce`作业的输入和输出类型如下所示：\n\n`(input) <k1, v1> -> map-> <k2, v2> -> Shuff-> <k2, list[v2]> -> reduce -> <k3, v3> (output)`\n\n简单在于其编程模型只包含`map`和`reduce`两个过程，`map`的主要输入是一对`<key , value>`值，经过`map`计算后输出一对`<key , value>`值；然后将相同`key`合并，形成`<key , value集合>`；再将这个`<key , value集合>`输入`reduce`，经过计算输出零个或多个`<key , value>`对。\n\n![img](MapReduce/14019352-0c530b046636edd0.webp)\n\n# [原理](https://songlee24.github.io/2015/07/29/mapreduce-word-count/)\n\n![img](MapReduce/1089769-20180418222127341-658345249.png)\n\n系统中有两类主要的进程节点：`master`（单点），`worker`（多个）。其中，`worker`根据不同的计算任务，又分为`map worke`r（对应上图中的`Map phase`）、`reduce worker`（对应上图中的`Reduce phase`）。\n\n- `master`是系统的中心节点，负责为`worker`节点分配计算任务，同时监控`worker`节点的状态。如果某个`worker`计算太慢，或者宕机，`master`会将该`worker`进程负责的计算任务转移到其他进程。\n- `worker`包括`Map`与`Reduce`\n\n1. 首先将文件分割成`<key,value>`的键值对。`Map`通过 `RecordReader` 读取Input的`<key,value>`对，`map`根据用户自定义的任务，运行完毕后，输出另外一系列`<key,value>`，\n2. `Shuffle` 阶段需要从所有`map`主机上把相同的`key` 的 `key value`对组合在一起，（也就是这里省去的`Combine`阶段）。\n3. `Partitioner`组件会把 `key `放进一个 `hash`函数里，然后得到结果。如果两个 `key` 的哈希值 一样，他们的 `<key,value>`对就被放到同一个 `reduce` 函数里。我们也把分配到同一个 `reduce`函数里的` <key,value>`对叫做一个`reduce partition`。\n4. `reduce()` 函数以 `key` 及对应的 `value` 列表作为输入，按照用户自己的程序逻辑，经合并 `key` 相同的 `value` 值后，产 生另外一系列 `<key,value>` 对作为最终输出写入` HDFS`。\n\n# 应用\n\n","slug":"hadoop/MapReduce.md","published":1,"updated":"2019-08-16T12:48:17.221Z","_id":"cjzdr6iyk001uhomjuimlsg65","comments":1,"layout":"post","photos":[],"link":"","content":"<p><code>Map/Reduce</code> 是一个分布式运算程序的编程框架，<code>Map/Reduce</code> 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 <code>hadoop</code> 集群上。每个<code>Map/Reduce</code>任务都被初始化为一个<code>Job</code>，每个<code>Job</code>又可以分为两种阶段：<code>map</code>阶段和<code>reduce</code>阶段。这两个阶段分别用两个函数表示，即<code>map</code>函数和<code>reduce</code>函数。一个<code>Map/Reduce</code>作业的输入和输出类型如下所示：</p>\n<p><code>(input) &lt;k1, v1&gt; -&gt; map-&gt; &lt;k2, v2&gt; -&gt; Shuff-&gt; &lt;k2, list[v2]&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</code></p>\n<p>简单在于其编程模型只包含<code>map</code>和<code>reduce</code>两个过程，<code>map</code>的主要输入是一对<code>&lt;key , value&gt;</code>值，经过<code>map</code>计算后输出一对<code>&lt;key , value&gt;</code>值；然后将相同<code>key</code>合并，形成<code>&lt;key , value集合&gt;</code>；再将这个<code>&lt;key , value集合&gt;</code>输入<code>reduce</code>，经过计算输出零个或多个<code>&lt;key , value&gt;</code>对。</p>\n<p><img src=\"/2019/08/16/hadoop/MapReduce.md/14019352-0c530b046636edd0.webp\" alt=\"img\"></p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><a href=\"https://songlee24.github.io/2015/07/29/mapreduce-word-count/\" target=\"_blank\" rel=\"noopener\">原理</a></h1><p><img src=\"/2019/08/16/hadoop/MapReduce.md/1089769-20180418222127341-658345249.png\" alt=\"img\"></p>\n<p>系统中有两类主要的进程节点：<code>master</code>（单点），<code>worker</code>（多个）。其中，<code>worker</code>根据不同的计算任务，又分为<code>map worke</code>r（对应上图中的<code>Map phase</code>）、<code>reduce worker</code>（对应上图中的<code>Reduce phase</code>）。</p>\n<ul>\n<li><code>master</code>是系统的中心节点，负责为<code>worker</code>节点分配计算任务，同时监控<code>worker</code>节点的状态。如果某个<code>worker</code>计算太慢，或者宕机，<code>master</code>会将该<code>worker</code>进程负责的计算任务转移到其他进程。</li>\n<li><code>worker</code>包括<code>Map</code>与<code>Reduce</code></li>\n</ul>\n<ol>\n<li>首先将文件分割成<code>&lt;key,value&gt;</code>的键值对。<code>Map</code>通过 <code>RecordReader</code> 读取Input的<code>&lt;key,value&gt;</code>对，<code>map</code>根据用户自定义的任务，运行完毕后，输出另外一系列<code>&lt;key,value&gt;</code>，</li>\n<li><code>Shuffle</code> 阶段需要从所有<code>map</code>主机上把相同的<code>key</code> 的 <code>key value</code>对组合在一起，（也就是这里省去的<code>Combine</code>阶段）。</li>\n<li><code>Partitioner</code>组件会把 <code>key</code>放进一个 <code>hash</code>函数里，然后得到结果。如果两个 <code>key</code> 的哈希值 一样，他们的 <code>&lt;key,value&gt;</code>对就被放到同一个 <code>reduce</code> 函数里。我们也把分配到同一个 <code>reduce</code>函数里的<code>&lt;key,value&gt;</code>对叫做一个<code>reduce partition</code>。</li>\n<li><code>reduce()</code> 函数以 <code>key</code> 及对应的 <code>value</code> 列表作为输入，按照用户自己的程序逻辑，经合并 <code>key</code> 相同的 <code>value</code> 值后，产 生另外一系列 <code>&lt;key,value&gt;</code> 对作为最终输出写入<code>HDFS</code>。</li>\n</ol>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1>","site":{"data":{}},"excerpt":"","more":"<p><code>Map/Reduce</code> 是一个分布式运算程序的编程框架，<code>Map/Reduce</code> 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 <code>hadoop</code> 集群上。每个<code>Map/Reduce</code>任务都被初始化为一个<code>Job</code>，每个<code>Job</code>又可以分为两种阶段：<code>map</code>阶段和<code>reduce</code>阶段。这两个阶段分别用两个函数表示，即<code>map</code>函数和<code>reduce</code>函数。一个<code>Map/Reduce</code>作业的输入和输出类型如下所示：</p>\n<p><code>(input) &lt;k1, v1&gt; -&gt; map-&gt; &lt;k2, v2&gt; -&gt; Shuff-&gt; &lt;k2, list[v2]&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</code></p>\n<p>简单在于其编程模型只包含<code>map</code>和<code>reduce</code>两个过程，<code>map</code>的主要输入是一对<code>&lt;key , value&gt;</code>值，经过<code>map</code>计算后输出一对<code>&lt;key , value&gt;</code>值；然后将相同<code>key</code>合并，形成<code>&lt;key , value集合&gt;</code>；再将这个<code>&lt;key , value集合&gt;</code>输入<code>reduce</code>，经过计算输出零个或多个<code>&lt;key , value&gt;</code>对。</p>\n<p><img src=\"/2019/08/16/hadoop/MapReduce.md/14019352-0c530b046636edd0.webp\" alt=\"img\"></p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><a href=\"https://songlee24.github.io/2015/07/29/mapreduce-word-count/\" target=\"_blank\" rel=\"noopener\">原理</a></h1><p><img src=\"/2019/08/16/hadoop/MapReduce.md/1089769-20180418222127341-658345249.png\" alt=\"img\"></p>\n<p>系统中有两类主要的进程节点：<code>master</code>（单点），<code>worker</code>（多个）。其中，<code>worker</code>根据不同的计算任务，又分为<code>map worke</code>r（对应上图中的<code>Map phase</code>）、<code>reduce worker</code>（对应上图中的<code>Reduce phase</code>）。</p>\n<ul>\n<li><code>master</code>是系统的中心节点，负责为<code>worker</code>节点分配计算任务，同时监控<code>worker</code>节点的状态。如果某个<code>worker</code>计算太慢，或者宕机，<code>master</code>会将该<code>worker</code>进程负责的计算任务转移到其他进程。</li>\n<li><code>worker</code>包括<code>Map</code>与<code>Reduce</code></li>\n</ul>\n<ol>\n<li>首先将文件分割成<code>&lt;key,value&gt;</code>的键值对。<code>Map</code>通过 <code>RecordReader</code> 读取Input的<code>&lt;key,value&gt;</code>对，<code>map</code>根据用户自定义的任务，运行完毕后，输出另外一系列<code>&lt;key,value&gt;</code>，</li>\n<li><code>Shuffle</code> 阶段需要从所有<code>map</code>主机上把相同的<code>key</code> 的 <code>key value</code>对组合在一起，（也就是这里省去的<code>Combine</code>阶段）。</li>\n<li><code>Partitioner</code>组件会把 <code>key</code>放进一个 <code>hash</code>函数里，然后得到结果。如果两个 <code>key</code> 的哈希值 一样，他们的 <code>&lt;key,value&gt;</code>对就被放到同一个 <code>reduce</code> 函数里。我们也把分配到同一个 <code>reduce</code>函数里的<code>&lt;key,value&gt;</code>对叫做一个<code>reduce partition</code>。</li>\n<li><code>reduce()</code> 函数以 <code>key</code> 及对应的 <code>value</code> 列表作为输入，按照用户自己的程序逻辑，经合并 <code>key</code> 相同的 <code>value</code> 值后，产 生另外一系列 <code>&lt;key,value&gt;</code> 对作为最终输出写入<code>HDFS</code>。</li>\n</ol>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1>"},{"title":"LDA线性判别分析","date":"2018-08-13T08:10:58.000Z","_content":"\n**欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大**\n# LDA思想\nLDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。\n可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。\n<!--more-->\n- 同类的数据点尽可能的接近（within class）\n\n- 不同类的数据点尽可能的分开（between class）\n\n![](LDA线性判别分析/LDA线性判别分析-c7a32c02.png)\n\n上图中国提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。\n# 算法流程\n输入：数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,...,C_k\\}$，降维到的维度$d$。\n输出：降维后的样本集$D′$\n\n1. 计算类内散度矩阵$S_w$\n$X_j(j=1,2...k)$为第$j$类样本的集合;$\\mu_j(j=1,2...k)$为第$j$类样本的均值向量\n$$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$$\n\n1.  计算类间散度矩阵$S_b$\n$N_j(j=1,2...k)$为第$j$类样本的个数;$μ$为所有样本均值向量。\n$$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$$\n\n1.  计算矩阵$S^{−1}wS_b$\n1. 计算$S^{−1}wS_b$的最大的$d$个特征值和对应的$d$个特征向量($w_1,w_2,...w_d)$,得到投影矩阵\n1. 对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$\n1.  得到输出样本集$D'=\\{(z_1,y_1), (z_2,y_2), ...,((z_m,y_m))\\}$\n\n\n# [推导](http://www.cnblogs.com/pinard/p/6244265.html)\n**欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大**\n## 二分类\n假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{0,1\\}$。我们定义$N_j(j=0,1)$为第$j$类样本的个数，$X_j(j=0,1)$为第$j$类样本的集合，而$\\mu_j(j=0,1)$为第j类样本的均值向量，定义$\\Sigma_j(j=0,1)$为第$j$类样本的协方差矩阵（严格说是缺少分母部分的协方差矩阵）。\n\n$\\mu_j $的表达式为：\n$$\\mu _j = \\frac{1}{N_j}\\sum\\limits_{x \\in X_j}x\\;\\;(j=0,1)$$\n\n$Σ_j$的表达式为：\n$$\\Sigma_j = \\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T\\;\\;(j=0,1)$$\n\n由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量$w$,则对任意一个样本本$x_i$,它在直线$w$的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在直线$w$的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||_2^2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^TΣ_0w$和$w^TΣ_1w$尽可能的小，即最小化$w^TΣ_0w+w^TΣ_1w$。投影之后的协方差$WX(WX)^T$则$WXX^TW^T=WΣW^T$综上所述，我们的优化目标为：\n\n$$\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{||w^T\\mu_0-w^T\\mu_1||_2^2}{w^T\\Sigma_0w+w^T\\Sigma_1w} = \\frac{w^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^Tw}{w^T(\\Sigma_0+\\Sigma_1)w}$$\n\n\n\n我们一般定义类内散度矩阵 $S_w$ 为： $S_w = \\Sigma_0 + \\Sigma_1 = \\sum \\limits_{x \\in X\\_0}(x-\\mu_0)(x-\\mu_0)^T + \\sum \\limits_{x \\in X_1}(x-\\mu_1)(x-\\mu_1)^T$\n\n同时定义类间散度矩阵$S_b$为：$S_b = (\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T$\n\n这样我们的优化目标重写为：\n\n$$\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{w^TS_bw}{w^TS_ww}$$\n\n因为分子分母都是关于$w$的二次型，若$w$是一个解，则对任意常数$α$，$αw$也是一个解。因此解与w的长度无关，只与其方向有关。不妨令$w^TS_ww=1$，则最优化目标等价于\n\n$$\\begin{eqnarray}\n&\\min_w& -w^TS_bw\\\\\n&s.t.& w^TS_ww=1\n\\end{eqnarray}$$\n\n引入拉格朗日乘子，上式等价于\n\n$$\\begin{eqnarray}\n&\\min& c(w)=-w^TS_bw+\\lambda(w^TS_ww-1)\n\\end{eqnarray}$$\n\n求导得\n\n$$\\frac{dc}{dw}=-2S_bw+2\\lambda S_ww$$\n\n令其等于0，得\n\n$$S_bw=\\lambda S_ww$$\n如果$S_w$可逆，等式两边同乘$S_w^{-1}$有\n\n$$S_w^{-1}S_bw=\\lambda w$$\n\n可喜的发现$w$就是矩阵 $S_w^{-1}S_b$ 的特征向量，因此求解问题转化成求矩阵特征值问题上了，首先求出 $S_w^{-1}S_b$ 的特征值，然后取前 $K$ 个特征向量按列组成 w 矩阵即可\n## 多分类\n假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,...,C_k\\}$。我们定义$N_j(j=1,2...k)$为第$j$类样本的个数，$X_j(j=1,2...k)$为第$j$类样本的集合，而$\\mu_j(j=1,2...k)$为第$j$类样本的均值向量，定义$\\Sigma_j(j=1,2...k)$为第$j$类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。\n\n\n由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为$d$，对应的基向量为$(w_1,w_2,...w_d)$，基向量组成的矩阵为$W$, 它是一个$n×d$的矩阵。\n\n\n\n此时我们的优化目标应该可以变成为:$$\\frac{W^TS_bW}{W^TS_wW}$$\n\n\n\n其中类间散度$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$,$μ$为所有样本均值向量。\n\n类内散度$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$\n\n\n\n由于现在分子分母都是矩阵，要将矩阵变成实数，可以取矩阵的行列式或者矩阵的迹。其中，矩阵的行列式等于矩阵特征值之积，矩阵的迹等于矩阵特征值之和。所以优化目标可以转化为：\n\n常见的一个LDA多类优化目标函数定义为：\n\n$$\\max_W \\frac{tr(W^TS_bW)}{tr(W^TS_wW)}\\\\\n\nor\\\\\n\n\\max_W \\frac{|W^TS_bW|}{|W^TS_wW|}$$\n\n\n可以通过如下广义特征值求解： $$S_bW=\\lambda S_wW$$\n\n\n\n$W$的解则是$S_w^{-1}S_b$的$N-1$个最大广义特征值所对应的特征向量按列组成的矩阵。\n","source":"_posts/LDA线性判别分析.md","raw":"---\ntitle: LDA线性判别分析\ndate: 2018-08-13 16:10:58\ntags: [人工智能,特征工程,降维]\ncategories: 机器学习\n---\n\n**欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大**\n# LDA思想\nLDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。\n可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。\n<!--more-->\n- 同类的数据点尽可能的接近（within class）\n\n- 不同类的数据点尽可能的分开（between class）\n\n![](LDA线性判别分析/LDA线性判别分析-c7a32c02.png)\n\n上图中国提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。\n# 算法流程\n输入：数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,...,C_k\\}$，降维到的维度$d$。\n输出：降维后的样本集$D′$\n\n1. 计算类内散度矩阵$S_w$\n$X_j(j=1,2...k)$为第$j$类样本的集合;$\\mu_j(j=1,2...k)$为第$j$类样本的均值向量\n$$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$$\n\n1.  计算类间散度矩阵$S_b$\n$N_j(j=1,2...k)$为第$j$类样本的个数;$μ$为所有样本均值向量。\n$$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$$\n\n1.  计算矩阵$S^{−1}wS_b$\n1. 计算$S^{−1}wS_b$的最大的$d$个特征值和对应的$d$个特征向量($w_1,w_2,...w_d)$,得到投影矩阵\n1. 对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$\n1.  得到输出样本集$D'=\\{(z_1,y_1), (z_2,y_2), ...,((z_m,y_m))\\}$\n\n\n# [推导](http://www.cnblogs.com/pinard/p/6244265.html)\n**欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大**\n## 二分类\n假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{0,1\\}$。我们定义$N_j(j=0,1)$为第$j$类样本的个数，$X_j(j=0,1)$为第$j$类样本的集合，而$\\mu_j(j=0,1)$为第j类样本的均值向量，定义$\\Sigma_j(j=0,1)$为第$j$类样本的协方差矩阵（严格说是缺少分母部分的协方差矩阵）。\n\n$\\mu_j $的表达式为：\n$$\\mu _j = \\frac{1}{N_j}\\sum\\limits_{x \\in X_j}x\\;\\;(j=0,1)$$\n\n$Σ_j$的表达式为：\n$$\\Sigma_j = \\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T\\;\\;(j=0,1)$$\n\n由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量$w$,则对任意一个样本本$x_i$,它在直线$w$的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在直线$w$的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||_2^2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^TΣ_0w$和$w^TΣ_1w$尽可能的小，即最小化$w^TΣ_0w+w^TΣ_1w$。投影之后的协方差$WX(WX)^T$则$WXX^TW^T=WΣW^T$综上所述，我们的优化目标为：\n\n$$\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{||w^T\\mu_0-w^T\\mu_1||_2^2}{w^T\\Sigma_0w+w^T\\Sigma_1w} = \\frac{w^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^Tw}{w^T(\\Sigma_0+\\Sigma_1)w}$$\n\n\n\n我们一般定义类内散度矩阵 $S_w$ 为： $S_w = \\Sigma_0 + \\Sigma_1 = \\sum \\limits_{x \\in X\\_0}(x-\\mu_0)(x-\\mu_0)^T + \\sum \\limits_{x \\in X_1}(x-\\mu_1)(x-\\mu_1)^T$\n\n同时定义类间散度矩阵$S_b$为：$S_b = (\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T$\n\n这样我们的优化目标重写为：\n\n$$\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{w^TS_bw}{w^TS_ww}$$\n\n因为分子分母都是关于$w$的二次型，若$w$是一个解，则对任意常数$α$，$αw$也是一个解。因此解与w的长度无关，只与其方向有关。不妨令$w^TS_ww=1$，则最优化目标等价于\n\n$$\\begin{eqnarray}\n&\\min_w& -w^TS_bw\\\\\n&s.t.& w^TS_ww=1\n\\end{eqnarray}$$\n\n引入拉格朗日乘子，上式等价于\n\n$$\\begin{eqnarray}\n&\\min& c(w)=-w^TS_bw+\\lambda(w^TS_ww-1)\n\\end{eqnarray}$$\n\n求导得\n\n$$\\frac{dc}{dw}=-2S_bw+2\\lambda S_ww$$\n\n令其等于0，得\n\n$$S_bw=\\lambda S_ww$$\n如果$S_w$可逆，等式两边同乘$S_w^{-1}$有\n\n$$S_w^{-1}S_bw=\\lambda w$$\n\n可喜的发现$w$就是矩阵 $S_w^{-1}S_b$ 的特征向量，因此求解问题转化成求矩阵特征值问题上了，首先求出 $S_w^{-1}S_b$ 的特征值，然后取前 $K$ 个特征向量按列组成 w 矩阵即可\n## 多分类\n假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\\}$其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,...,C_k\\}$。我们定义$N_j(j=1,2...k)$为第$j$类样本的个数，$X_j(j=1,2...k)$为第$j$类样本的集合，而$\\mu_j(j=1,2...k)$为第$j$类样本的均值向量，定义$\\Sigma_j(j=1,2...k)$为第$j$类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。\n\n\n由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为$d$，对应的基向量为$(w_1,w_2,...w_d)$，基向量组成的矩阵为$W$, 它是一个$n×d$的矩阵。\n\n\n\n此时我们的优化目标应该可以变成为:$$\\frac{W^TS_bW}{W^TS_wW}$$\n\n\n\n其中类间散度$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$,$μ$为所有样本均值向量。\n\n类内散度$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$\n\n\n\n由于现在分子分母都是矩阵，要将矩阵变成实数，可以取矩阵的行列式或者矩阵的迹。其中，矩阵的行列式等于矩阵特征值之积，矩阵的迹等于矩阵特征值之和。所以优化目标可以转化为：\n\n常见的一个LDA多类优化目标函数定义为：\n\n$$\\max_W \\frac{tr(W^TS_bW)}{tr(W^TS_wW)}\\\\\n\nor\\\\\n\n\\max_W \\frac{|W^TS_bW|}{|W^TS_wW|}$$\n\n\n可以通过如下广义特征值求解： $$S_bW=\\lambda S_wW$$\n\n\n\n$W$的解则是$S_w^{-1}S_b$的$N-1$个最大广义特征值所对应的特征向量按列组成的矩阵。\n","slug":"LDA线性判别分析","published":1,"updated":"2019-07-30T01:54:38.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iym001yhomjxxpk2c9h","content":"<p><strong>欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大</strong></p>\n<h1 id=\"LDA思想\"><a href=\"#LDA思想\" class=\"headerlink\" title=\"LDA思想\"></a>LDA思想</h1><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。<br>可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。<br><a id=\"more\"></a></p>\n<ul>\n<li><p>同类的数据点尽可能的接近（within class）</p>\n</li>\n<li><p>不同类的数据点尽可能的分开（between class）</p>\n</li>\n</ul>\n<p><img src=\"/2018/08/13/LDA线性判别分析/LDA线性判别分析-c7a32c02.png\" alt=\"\"></p>\n<p>上图中国提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。</p>\n<h1 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h1><p>输入：数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,…,C_k\\}$，降维到的维度$d$。<br>输出：降维后的样本集$D′$</p>\n<ol>\n<li><p>计算类内散度矩阵$S_w$<br>$X_j(j=1,2…k)$为第$j$类样本的集合;$\\mu_j(j=1,2…k)$为第$j$类样本的均值向量</p>\n<script type=\"math/tex; mode=display\">S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T</script></li>\n<li><p>计算类间散度矩阵$S_b$<br>$N_j(j=1,2…k)$为第$j$类样本的个数;$μ$为所有样本均值向量。</p>\n<script type=\"math/tex; mode=display\">S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T</script></li>\n<li><p>计算矩阵$S^{−1}wS_b$</p>\n</li>\n<li>计算$S^{−1}wS_b$的最大的$d$个特征值和对应的$d$个特征向量($w_1,w_2,…w_d)$,得到投影矩阵</li>\n<li>对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$</li>\n<li>得到输出样本集$D’=\\{(z_1,y_1), (z_2,y_2), …,((z_m,y_m))\\}$</li>\n</ol>\n<h1 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a><a href=\"http://www.cnblogs.com/pinard/p/6244265.html\" target=\"_blank\" rel=\"noopener\">推导</a></h1><p><strong>欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大</strong></p>\n<h2 id=\"二分类\"><a href=\"#二分类\" class=\"headerlink\" title=\"二分类\"></a>二分类</h2><p>假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{0,1\\}$。我们定义$N_j(j=0,1)$为第$j$类样本的个数，$X_j(j=0,1)$为第$j$类样本的集合，而$\\mu_j(j=0,1)$为第j类样本的均值向量，定义$\\Sigma_j(j=0,1)$为第$j$类样本的协方差矩阵（严格说是缺少分母部分的协方差矩阵）。</p>\n<p>$\\mu_j $的表达式为：</p>\n<script type=\"math/tex; mode=display\">\\mu _j = \\frac{1}{N_j}\\sum\\limits_{x \\in X_j}x\\;\\;(j=0,1)</script><p>$Σ_j$的表达式为：</p>\n<script type=\"math/tex; mode=display\">\\Sigma_j = \\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T\\;\\;(j=0,1)</script><p>由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量$w$,则对任意一个样本本$x_i$,它在直线$w$的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在直线$w$的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||_2^2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^TΣ_0w$和$w^TΣ_1w$尽可能的小，即最小化$w^TΣ_0w+w^TΣ_1w$。投影之后的协方差$WX(WX)^T$则$WXX^TW^T=WΣW^T$综上所述，我们的优化目标为：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{||w^T\\mu_0-w^T\\mu_1||_2^2}{w^T\\Sigma_0w+w^T\\Sigma_1w} = \\frac{w^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^Tw}{w^T(\\Sigma_0+\\Sigma_1)w}</script><p>我们一般定义类内散度矩阵 $S_w$ 为： $S_w = \\Sigma_0 + \\Sigma_1 = \\sum \\limits_{x \\in X_0}(x-\\mu_0)(x-\\mu_0)^T + \\sum \\limits_{x \\in X_1}(x-\\mu_1)(x-\\mu_1)^T$</p>\n<p>同时定义类间散度矩阵$S_b$为：$S_b = (\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T$</p>\n<p>这样我们的优化目标重写为：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{w^TS_bw}{w^TS_ww}</script><p>因为分子分母都是关于$w$的二次型，若$w$是一个解，则对任意常数$α$，$αw$也是一个解。因此解与w的长度无关，只与其方向有关。不妨令$w^TS_ww=1$，则最优化目标等价于</p>\n<script type=\"math/tex; mode=display\">\\begin{eqnarray}\n&\\min_w& -w^TS_bw\\\\\n&s.t.& w^TS_ww=1\n\\end{eqnarray}</script><p>引入拉格朗日乘子，上式等价于</p>\n<script type=\"math/tex; mode=display\">\\begin{eqnarray}\n&\\min& c(w)=-w^TS_bw+\\lambda(w^TS_ww-1)\n\\end{eqnarray}</script><p>求导得</p>\n<script type=\"math/tex; mode=display\">\\frac{dc}{dw}=-2S_bw+2\\lambda S_ww</script><p>令其等于0，得</p>\n<script type=\"math/tex; mode=display\">S_bw=\\lambda S_ww</script><p>如果$S_w$可逆，等式两边同乘$S_w^{-1}$有</p>\n<script type=\"math/tex; mode=display\">S_w^{-1}S_bw=\\lambda w</script><p>可喜的发现$w$就是矩阵 $S_w^{-1}S_b$ 的特征向量，因此求解问题转化成求矩阵特征值问题上了，首先求出 $S_w^{-1}S_b$ 的特征值，然后取前 $K$ 个特征向量按列组成 w 矩阵即可</p>\n<h2 id=\"多分类\"><a href=\"#多分类\" class=\"headerlink\" title=\"多分类\"></a>多分类</h2><p>假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,…,C_k\\}$。我们定义$N_j(j=1,2…k)$为第$j$类样本的个数，$X_j(j=1,2…k)$为第$j$类样本的集合，而$\\mu_j(j=1,2…k)$为第$j$类样本的均值向量，定义$\\Sigma_j(j=1,2…k)$为第$j$类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。</p>\n<p>由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为$d$，对应的基向量为$(w_1,w_2,…w_d)$，基向量组成的矩阵为$W$, 它是一个$n×d$的矩阵。</p>\n<p>此时我们的优化目标应该可以变成为:<script type=\"math/tex\">\\frac{W^TS_bW}{W^TS_wW}</script></p>\n<p>其中类间散度$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$,$μ$为所有样本均值向量。</p>\n<p>类内散度$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$</p>\n<p>由于现在分子分母都是矩阵，要将矩阵变成实数，可以取矩阵的行列式或者矩阵的迹。其中，矩阵的行列式等于矩阵特征值之积，矩阵的迹等于矩阵特征值之和。所以优化目标可以转化为：</p>\n<p>常见的一个LDA多类优化目标函数定义为：</p>\n<script type=\"math/tex; mode=display\">\\max_W \\frac{tr(W^TS_bW)}{tr(W^TS_wW)}\\\\\n\nor\\\\\n\n\\max_W \\frac{|W^TS_bW|}{|W^TS_wW|}</script><p>可以通过如下广义特征值求解： <script type=\"math/tex\">S_bW=\\lambda S_wW</script></p>\n<p>$W$的解则是$S_w^{-1}S_b$的$N-1$个最大广义特征值所对应的特征向量按列组成的矩阵。</p>\n","site":{"data":{}},"excerpt":"<p><strong>欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大</strong></p>\n<h1 id=\"LDA思想\"><a href=\"#LDA思想\" class=\"headerlink\" title=\"LDA思想\"></a>LDA思想</h1><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。<br>可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。<br></p>","more":"<p></p>\n<ul>\n<li><p>同类的数据点尽可能的接近（within class）</p>\n</li>\n<li><p>不同类的数据点尽可能的分开（between class）</p>\n</li>\n</ul>\n<p><img src=\"/2018/08/13/LDA线性判别分析/LDA线性判别分析-c7a32c02.png\" alt=\"\"></p>\n<p>上图中国提供了两种投影方式，哪一种能更好的满足我们的标准呢？从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，当然在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。</p>\n<h1 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h1><p>输入：数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,…,C_k\\}$，降维到的维度$d$。<br>输出：降维后的样本集$D′$</p>\n<ol>\n<li><p>计算类内散度矩阵$S_w$<br>$X_j(j=1,2…k)$为第$j$类样本的集合;$\\mu_j(j=1,2…k)$为第$j$类样本的均值向量</p>\n<script type=\"math/tex; mode=display\">S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T</script></li>\n<li><p>计算类间散度矩阵$S_b$<br>$N_j(j=1,2…k)$为第$j$类样本的个数;$μ$为所有样本均值向量。</p>\n<script type=\"math/tex; mode=display\">S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T</script></li>\n<li><p>计算矩阵$S^{−1}wS_b$</p>\n</li>\n<li>计算$S^{−1}wS_b$的最大的$d$个特征值和对应的$d$个特征向量($w_1,w_2,…w_d)$,得到投影矩阵</li>\n<li>对样本集中的每一个样本特征$x_i$,转化为新的样本$z_i=W^Tx_i$</li>\n<li>得到输出样本集$D’=\\{(z_1,y_1), (z_2,y_2), …,((z_m,y_m))\\}$</li>\n</ol>\n<h1 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a><a href=\"http://www.cnblogs.com/pinard/p/6244265.html\" target=\"_blank\" rel=\"noopener\">推导</a></h1><p><strong>欲使同类样本的投影点尽可能接近，可以让同类样本的投影点的协方差尽可能小；而欲使异类样本的投影点尽可能远离，可以让异类样本的类中心之间的距离尽可能大</strong></p>\n<h2 id=\"二分类\"><a href=\"#二分类\" class=\"headerlink\" title=\"二分类\"></a>二分类</h2><p>假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$,其中任意样本$x_i$为$n$维向量，$y_i \\in \\{0,1\\}$。我们定义$N_j(j=0,1)$为第$j$类样本的个数，$X_j(j=0,1)$为第$j$类样本的集合，而$\\mu_j(j=0,1)$为第j类样本的均值向量，定义$\\Sigma_j(j=0,1)$为第$j$类样本的协方差矩阵（严格说是缺少分母部分的协方差矩阵）。</p>\n<p>$\\mu_j $的表达式为：</p>\n<script type=\"math/tex; mode=display\">\\mu _j = \\frac{1}{N_j}\\sum\\limits_{x \\in X_j}x\\;\\;(j=0,1)</script><p>$Σ_j$的表达式为：</p>\n<script type=\"math/tex; mode=display\">\\Sigma_j = \\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T\\;\\;(j=0,1)</script><p>由于是两类数据，因此我们只需要将数据投影到一条直线上即可。假设我们的投影直线是向量$w$,则对任意一个样本本$x_i$,它在直线$w$的投影为$w^Tx_i$,对于我们的两个类别的中心点$μ_0,μ_1$,在直线$w$的投影为$w^Tμ_0$和$w^Tμ_1$。由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||_2^2$,同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^TΣ_0w$和$w^TΣ_1w$尽可能的小，即最小化$w^TΣ_0w+w^TΣ_1w$。投影之后的协方差$WX(WX)^T$则$WXX^TW^T=WΣW^T$综上所述，我们的优化目标为：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{||w^T\\mu_0-w^T\\mu_1||_2^2}{w^T\\Sigma_0w+w^T\\Sigma_1w} = \\frac{w^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^Tw}{w^T(\\Sigma_0+\\Sigma_1)w}</script><p>我们一般定义类内散度矩阵 $S_w$ 为： $S_w = \\Sigma_0 + \\Sigma_1 = \\sum \\limits_{x \\in X_0}(x-\\mu_0)(x-\\mu_0)^T + \\sum \\limits_{x \\in X_1}(x-\\mu_1)(x-\\mu_1)^T$</p>\n<p>同时定义类间散度矩阵$S_b$为：$S_b = (\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T$</p>\n<p>这样我们的优化目标重写为：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{arg\\;max}_w\\;\\;J(w) = \\frac{w^TS_bw}{w^TS_ww}</script><p>因为分子分母都是关于$w$的二次型，若$w$是一个解，则对任意常数$α$，$αw$也是一个解。因此解与w的长度无关，只与其方向有关。不妨令$w^TS_ww=1$，则最优化目标等价于</p>\n<script type=\"math/tex; mode=display\">\\begin{eqnarray}\n&\\min_w& -w^TS_bw\\\\\n&s.t.& w^TS_ww=1\n\\end{eqnarray}</script><p>引入拉格朗日乘子，上式等价于</p>\n<script type=\"math/tex; mode=display\">\\begin{eqnarray}\n&\\min& c(w)=-w^TS_bw+\\lambda(w^TS_ww-1)\n\\end{eqnarray}</script><p>求导得</p>\n<script type=\"math/tex; mode=display\">\\frac{dc}{dw}=-2S_bw+2\\lambda S_ww</script><p>令其等于0，得</p>\n<script type=\"math/tex; mode=display\">S_bw=\\lambda S_ww</script><p>如果$S_w$可逆，等式两边同乘$S_w^{-1}$有</p>\n<script type=\"math/tex; mode=display\">S_w^{-1}S_bw=\\lambda w</script><p>可喜的发现$w$就是矩阵 $S_w^{-1}S_b$ 的特征向量，因此求解问题转化成求矩阵特征值问题上了，首先求出 $S_w^{-1}S_b$ 的特征值，然后取前 $K$ 个特征向量按列组成 w 矩阵即可</p>\n<h2 id=\"多分类\"><a href=\"#多分类\" class=\"headerlink\" title=\"多分类\"></a>多分类</h2><p>假设我们的数据集$D=\\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\\}$其中任意样本$x_i$为$n$维向量，$y_i \\in \\{C_1,C_2,…,C_k\\}$。我们定义$N_j(j=1,2…k)$为第$j$类样本的个数，$X_j(j=1,2…k)$为第$j$类样本的集合，而$\\mu_j(j=1,2…k)$为第$j$类样本的均值向量，定义$\\Sigma_j(j=1,2…k)$为第$j$类样本的协方差矩阵。在二类LDA里面定义的公式可以很容易的类推到多类LDA。</p>\n<p>由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为$d$，对应的基向量为$(w_1,w_2,…w_d)$，基向量组成的矩阵为$W$, 它是一个$n×d$的矩阵。</p>\n<p>此时我们的优化目标应该可以变成为:<script type=\"math/tex\">\\frac{W^TS_bW}{W^TS_wW}</script></p>\n<p>其中类间散度$S_b = \\sum\\limits_{j=1}^{k}N_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T$,$μ$为所有样本均值向量。</p>\n<p>类内散度$S_w = \\sum\\limits_{j=1}^{k}S_{wj} = \\sum\\limits_{j=1}^{k}\\sum\\limits_{x \\in X_j}(x-\\mu_j)(x-\\mu_j)^T$</p>\n<p>由于现在分子分母都是矩阵，要将矩阵变成实数，可以取矩阵的行列式或者矩阵的迹。其中，矩阵的行列式等于矩阵特征值之积，矩阵的迹等于矩阵特征值之和。所以优化目标可以转化为：</p>\n<p>常见的一个LDA多类优化目标函数定义为：</p>\n<script type=\"math/tex; mode=display\">\\max_W \\frac{tr(W^TS_bW)}{tr(W^TS_wW)}\\\\\n\nor\\\\\n\n\\max_W \\frac{|W^TS_bW|}{|W^TS_wW|}</script><p>可以通过如下广义特征值求解： <script type=\"math/tex\">S_bW=\\lambda S_wW</script></p>\n<p>$W$的解则是$S_w^{-1}S_b$的$N-1$个最大广义特征值所对应的特征向量按列组成的矩阵。</p>"},{"title":"PCA主成分分析","date":"2017-08-13T08:10:58.000Z","_content":"\n\n\n1 | 特征中心化。即每一维的数据都减去该维的均值。\n-|-\n2|计算协方差矩阵.协方差就是衡量两个变量相关性的变量\n3|计算协方差矩阵的特征值和特征向量\n4|选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集：样本乘以特征向量\n\n<!--more-->\n# PCA简介\nPCA的思想是将$n$维特征映射到$k$维空间上$k<n$，这$k$维特征是全新的正交特征，是重新构造出来的$k$维特征，而不是简单地从$n$维特征中去除其余$n−k$维特征。那么如何衡量投影向量的优劣呢？在数学上有三种方法衡量投影的优劣！PCA可以被定义为数据在低维线性空间上的正交投影。如下图所示，将3维空间中的数据映射到2维空间。\n- 映射的基本原则\n1. 使得投影数据的⽅差被最⼤化（Hotelling, 1933），即最大方差理论。即数据映射之后差异性最大，方法最大\n2. 使得平均投影代价最⼩的线性投影，即最小误差理论。平均投影代价是指数据点和它们的投影之间的平均平⽅距离\n\n![](PCA主成分分析/PCA主成分分析-dc898119.png)\n\n假设三维空间中有一系列点，这些点分布在一个过原点的斜面上，如果你用自然坐标系x,y,z这三个轴来表示这组数据的话，需要使用三个维度，而事实上，这些点的分布仅仅是在一个二维的平面上。我们所需要做得就是旋转x、y平面使其与数据点重合\n\n# PCA实现步骤\n\n1. 特征中心化。即每一维的数据都减去该维的均值。\n2. **计算协方差矩阵.**协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）PCA为什么使用协方差.md\n$$cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)$$\n\n3. 计算协方差矩阵的特征值和特征向量。\n4. 选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集。样本乘以特征向量\n\n# PCA实例\n现在假设有一组数据如下：\n\n![](PCA主成分分析/PCA主成分分析-79fd8d28.png)\n\n解决步骤：\n1、 分别求x和y的平均值，然后对于所有的样例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91。\n\n![](PCA主成分分析/PCA主成分分析-81a55a1f.png)\n\n2、 求特征[协方差矩阵](方差、协方差、协方差矩阵.md)，如果数据是3维，那么协方差矩阵是$$C = \\begin{pmatrix}\ncov(x,x) & cov(x,y) & cov(x,z)\\\\\ncov(y,x) & cov(y,y) & cov(y,z)\\\\\ncov(z,x) & cov(z,y) & cov(z,z)\n\\end{pmatrix}$$\n\n这里只有x和y，求解得$$cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)=\\bigl(\\begin{smallmatrix}\n0.5549 &0.5539 \\\\\n0.5539 &0.6449\n\\end{smallmatrix}\\bigr)$$对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。\n3、 求协方差的特征值和特征向量，得到$$eigenvalues = \\begin{pmatrix}\n0.0490833989\\\\\n1.28402771\n\\end{pmatrix}$$\n\n$$eigenvectors = \\begin{pmatrix}\n-0.735178656 & -0.677873399\\\\\n0.677873399 & -0.735178656\n\\end{pmatrix}$$\n\n4、 将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。\n5、 将样本点投影到选取的特征向量上\n[参考文献](https://blog.csdn.net/u013719780/article/details/78352262)\n","source":"_posts/PCA主成分分析.md","raw":"---\ntitle: PCA主成分分析\ndate: 2017-08-13 16:10:58\ntags: [人工智能,特征工程,降维]\ncategories: 机器学习\n---\n\n\n\n1 | 特征中心化。即每一维的数据都减去该维的均值。\n-|-\n2|计算协方差矩阵.协方差就是衡量两个变量相关性的变量\n3|计算协方差矩阵的特征值和特征向量\n4|选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集：样本乘以特征向量\n\n<!--more-->\n# PCA简介\nPCA的思想是将$n$维特征映射到$k$维空间上$k<n$，这$k$维特征是全新的正交特征，是重新构造出来的$k$维特征，而不是简单地从$n$维特征中去除其余$n−k$维特征。那么如何衡量投影向量的优劣呢？在数学上有三种方法衡量投影的优劣！PCA可以被定义为数据在低维线性空间上的正交投影。如下图所示，将3维空间中的数据映射到2维空间。\n- 映射的基本原则\n1. 使得投影数据的⽅差被最⼤化（Hotelling, 1933），即最大方差理论。即数据映射之后差异性最大，方法最大\n2. 使得平均投影代价最⼩的线性投影，即最小误差理论。平均投影代价是指数据点和它们的投影之间的平均平⽅距离\n\n![](PCA主成分分析/PCA主成分分析-dc898119.png)\n\n假设三维空间中有一系列点，这些点分布在一个过原点的斜面上，如果你用自然坐标系x,y,z这三个轴来表示这组数据的话，需要使用三个维度，而事实上，这些点的分布仅仅是在一个二维的平面上。我们所需要做得就是旋转x、y平面使其与数据点重合\n\n# PCA实现步骤\n\n1. 特征中心化。即每一维的数据都减去该维的均值。\n2. **计算协方差矩阵.**协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）PCA为什么使用协方差.md\n$$cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)$$\n\n3. 计算协方差矩阵的特征值和特征向量。\n4. 选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集。样本乘以特征向量\n\n# PCA实例\n现在假设有一组数据如下：\n\n![](PCA主成分分析/PCA主成分分析-79fd8d28.png)\n\n解决步骤：\n1、 分别求x和y的平均值，然后对于所有的样例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91。\n\n![](PCA主成分分析/PCA主成分分析-81a55a1f.png)\n\n2、 求特征[协方差矩阵](方差、协方差、协方差矩阵.md)，如果数据是3维，那么协方差矩阵是$$C = \\begin{pmatrix}\ncov(x,x) & cov(x,y) & cov(x,z)\\\\\ncov(y,x) & cov(y,y) & cov(y,z)\\\\\ncov(z,x) & cov(z,y) & cov(z,z)\n\\end{pmatrix}$$\n\n这里只有x和y，求解得$$cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)=\\bigl(\\begin{smallmatrix}\n0.5549 &0.5539 \\\\\n0.5539 &0.6449\n\\end{smallmatrix}\\bigr)$$对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。\n3、 求协方差的特征值和特征向量，得到$$eigenvalues = \\begin{pmatrix}\n0.0490833989\\\\\n1.28402771\n\\end{pmatrix}$$\n\n$$eigenvectors = \\begin{pmatrix}\n-0.735178656 & -0.677873399\\\\\n0.677873399 & -0.735178656\n\\end{pmatrix}$$\n\n4、 将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。\n5、 将样本点投影到选取的特征向量上\n[参考文献](https://blog.csdn.net/u013719780/article/details/78352262)\n","slug":"PCA主成分分析","published":1,"updated":"2019-07-30T01:54:38.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iyo0022homjxqw0kkj4","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>特征中心化。即每一维的数据都减去该维的均值。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>计算协方差矩阵.协方差就是衡量两个变量相关性的变量</td>\n</tr>\n<tr>\n<td>3</td>\n<td>计算协方差矩阵的特征值和特征向量</td>\n</tr>\n<tr>\n<td>4</td>\n<td>选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集：样本乘以特征向量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"PCA简介\"><a href=\"#PCA简介\" class=\"headerlink\" title=\"PCA简介\"></a>PCA简介</h1><p>PCA的思想是将$n$维特征映射到$k$维空间上$k&lt;n$，这$k$维特征是全新的正交特征，是重新构造出来的$k$维特征，而不是简单地从$n$维特征中去除其余$n−k$维特征。那么如何衡量投影向量的优劣呢？在数学上有三种方法衡量投影的优劣！PCA可以被定义为数据在低维线性空间上的正交投影。如下图所示，将3维空间中的数据映射到2维空间。</p>\n<ul>\n<li>映射的基本原则</li>\n</ul>\n<ol>\n<li>使得投影数据的⽅差被最⼤化（Hotelling, 1933），即最大方差理论。即数据映射之后差异性最大，方法最大</li>\n<li>使得平均投影代价最⼩的线性投影，即最小误差理论。平均投影代价是指数据点和它们的投影之间的平均平⽅距离</li>\n</ol>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-dc898119.png\" alt=\"\"></p>\n<p>假设三维空间中有一系列点，这些点分布在一个过原点的斜面上，如果你用自然坐标系x,y,z这三个轴来表示这组数据的话，需要使用三个维度，而事实上，这些点的分布仅仅是在一个二维的平面上。我们所需要做得就是旋转x、y平面使其与数据点重合</p>\n<h1 id=\"PCA实现步骤\"><a href=\"#PCA实现步骤\" class=\"headerlink\" title=\"PCA实现步骤\"></a>PCA实现步骤</h1><ol>\n<li>特征中心化。即每一维的数据都减去该维的均值。</li>\n<li><p><strong>计算协方差矩阵.</strong>协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）PCA为什么使用协方差.md</p>\n<script type=\"math/tex; mode=display\">cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)</script></li>\n<li><p>计算协方差矩阵的特征值和特征向量。</p>\n</li>\n<li>选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集。样本乘以特征向量</li>\n</ol>\n<h1 id=\"PCA实例\"><a href=\"#PCA实例\" class=\"headerlink\" title=\"PCA实例\"></a>PCA实例</h1><p>现在假设有一组数据如下：</p>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-79fd8d28.png\" alt=\"\"></p>\n<p>解决步骤：<br>1、 分别求x和y的平均值，然后对于所有的样例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91。</p>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-81a55a1f.png\" alt=\"\"></p>\n<p>2、 求特征<a href=\"方差、协方差、协方差矩阵.md\">协方差矩阵</a>，如果数据是3维，那么协方差矩阵是<script type=\"math/tex\">C = \\begin{pmatrix}\ncov(x,x) & cov(x,y) & cov(x,z)\\\\\ncov(y,x) & cov(y,y) & cov(y,z)\\\\\ncov(z,x) & cov(z,y) & cov(z,z)\n\\end{pmatrix}</script></p>\n<p>这里只有x和y，求解得<script type=\"math/tex\">cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)=\\bigl(\\begin{smallmatrix}\n0.5549 &0.5539 \\\\\n0.5539 &0.6449\n\\end{smallmatrix}\\bigr)</script>对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。<br>3、 求协方差的特征值和特征向量，得到<script type=\"math/tex\">eigenvalues = \\begin{pmatrix}\n0.0490833989\\\\\n1.28402771\n\\end{pmatrix}</script></p>\n<script type=\"math/tex; mode=display\">eigenvectors = \\begin{pmatrix}\n-0.735178656 & -0.677873399\\\\\n0.677873399 & -0.735178656\n\\end{pmatrix}</script><p>4、 将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。<br>5、 将样本点投影到选取的特征向量上<br><a href=\"https://blog.csdn.net/u013719780/article/details/78352262\" target=\"_blank\" rel=\"noopener\">参考文献</a></p>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>特征中心化。即每一维的数据都减去该维的均值。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>计算协方差矩阵.协方差就是衡量两个变量相关性的变量</td>\n</tr>\n<tr>\n<td>3</td>\n<td>计算协方差矩阵的特征值和特征向量</td>\n</tr>\n<tr>\n<td>4</td>\n<td>选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集：样本乘以特征向量</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"PCA简介\"><a href=\"#PCA简介\" class=\"headerlink\" title=\"PCA简介\"></a>PCA简介</h1><p>PCA的思想是将$n$维特征映射到$k$维空间上$k&lt;n$，这$k$维特征是全新的正交特征，是重新构造出来的$k$维特征，而不是简单地从$n$维特征中去除其余$n−k$维特征。那么如何衡量投影向量的优劣呢？在数学上有三种方法衡量投影的优劣！PCA可以被定义为数据在低维线性空间上的正交投影。如下图所示，将3维空间中的数据映射到2维空间。</p>\n<ul>\n<li>映射的基本原则</li>\n</ul>\n<ol>\n<li>使得投影数据的⽅差被最⼤化（Hotelling, 1933），即最大方差理论。即数据映射之后差异性最大，方法最大</li>\n<li>使得平均投影代价最⼩的线性投影，即最小误差理论。平均投影代价是指数据点和它们的投影之间的平均平⽅距离</li>\n</ol>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-dc898119.png\" alt=\"\"></p>\n<p>假设三维空间中有一系列点，这些点分布在一个过原点的斜面上，如果你用自然坐标系x,y,z这三个轴来表示这组数据的话，需要使用三个维度，而事实上，这些点的分布仅仅是在一个二维的平面上。我们所需要做得就是旋转x、y平面使其与数据点重合</p>\n<h1 id=\"PCA实现步骤\"><a href=\"#PCA实现步骤\" class=\"headerlink\" title=\"PCA实现步骤\"></a>PCA实现步骤</h1><ol>\n<li>特征中心化。即每一维的数据都减去该维的均值。</li>\n<li><p><strong>计算协方差矩阵.</strong>协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）PCA为什么使用协方差.md</p>\n<script type=\"math/tex; mode=display\">cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)</script></li>\n<li><p>计算协方差矩阵的特征值和特征向量。</p>\n</li>\n<li>选取从大到小依次选取若干个的特征值对应的特征向量，映射得到新的样本集。样本乘以特征向量</li>\n</ol>\n<h1 id=\"PCA实例\"><a href=\"#PCA实例\" class=\"headerlink\" title=\"PCA实例\"></a>PCA实例</h1><p>现在假设有一组数据如下：</p>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-79fd8d28.png\" alt=\"\"></p>\n<p>解决步骤：<br>1、 分别求x和y的平均值，然后对于所有的样例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91。</p>\n<p><img src=\"/2017/08/13/PCA主成分分析/PCA主成分分析-81a55a1f.png\" alt=\"\"></p>\n<p>2、 求特征<a href=\"方差、协方差、协方差矩阵.md\">协方差矩阵</a>，如果数据是3维，那么协方差矩阵是<script type=\"math/tex\">C = \\begin{pmatrix}\ncov(x,x) & cov(x,y) & cov(x,z)\\\\\ncov(y,x) & cov(y,y) & cov(y,z)\\\\\ncov(z,x) & cov(z,y) & cov(z,z)\n\\end{pmatrix}</script></p>\n<p>这里只有x和y，求解得<script type=\"math/tex\">cov=\\bigl(\\begin{smallmatrix}\ncov(x,x) & cov(x,y)\\\\\ncov(y,x) & cov(y,y)\n\\end{smallmatrix}\\bigr)=\\bigl(\\begin{smallmatrix}\n0.5549 &0.5539 \\\\\n0.5539 &0.6449\n\\end{smallmatrix}\\bigr)</script>对角线上分别是x和y的方差，非对角线上是协方差。协方差是衡量两个变量同时变化的变化程度。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果ｘ和ｙ是统计独立的，那么二者之间的协方差就是０；但是协方差是０，并不能说明ｘ和ｙ是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。<br>3、 求协方差的特征值和特征向量，得到<script type=\"math/tex\">eigenvalues = \\begin{pmatrix}\n0.0490833989\\\\\n1.28402771\n\\end{pmatrix}</script></p>\n<script type=\"math/tex; mode=display\">eigenvectors = \\begin{pmatrix}\n-0.735178656 & -0.677873399\\\\\n0.677873399 & -0.735178656\n\\end{pmatrix}</script><p>4、 将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。<br>5、 将样本点投影到选取的特征向量上<br><a href=\"https://blog.csdn.net/u013719780/article/details/78352262\" target=\"_blank\" rel=\"noopener\">参考文献</a></p>"},{"title":"SQL-spark","date":"2019-08-13T11:49:05.000Z","_content":"\n![æç«SQLæ¶æ](SQL-spark/spark_sql_architecture.jpg)\n\n# [getting started](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#dataset)\n\n## SparkSession\n\nSpark 中所有功能的入口是 `SparkSession` 类。要创建一个基本的` SparkSession` 对象, 只需要使用 `SparkSession.builder():`\n\n```scala\n// scala\nimport org.apache.spark.sql.SparkSession\n\nval spark = SparkSession\n  .builder()\n  .appName(\"Spark SQL basic example\")\n  .config(\"spark.some.config.option\", \"some-value\")\n  .getOrCreate()\n```\n\n```java\n// java\nimport org.apache.spark.sql.SparkSession;\n\nSparkSession spark = SparkSession\n  .builder()\n  .appName(\"Java Spark SQL basic example\")\n  .config(\"spark.some.config.option\", \"some-value\")\n  .getOrCreate();\n```\n\n```python\n# python\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .appName(\"Python Spark SQL basic example\") \\\n    .config(\"spark.some.config.option\", \"some-value\") \\\n    .getOrCreate()\n```\n\n## 创建 DataFrame\n\n应用程序可以使用 `SparkSession `从一个现有的 `RDD`，`Hive `表或 `Spark` 数据源创建 `DataFrame`。下面基于一个 `JSON` 文件的内容创建一个 `DataFrame`:\n\n```scala\nval df = spark.read.json(\"examples/src/main/resources/people.json\")           //scala\n\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nDataset<Row> df = spark.read().json(\"examples/src/main/resources/people.json\"); //java\n\ndf = spark.read.json(\"examples/src/main/resources/people.json\")               //python\n```\n\n##  DataFrame 操作\n\n`DataFrame`为 `Scala`,` Java`, `Python` 以及 `R` 语言中的结构化数据操作提供了一种领域特定语言。\n\n| scala                                   | java                                                 | python                                        |\n| --------------------------------------- | ---------------------------------------------------- | --------------------------------------------- |\n| `df.printSchema()`                      | `df.printSchema();`                                  | `df.printSchema()`                            |\n| `df.select(\"name\")`                     | `df.select(\"name\").show();`                          | `df.select(\"name\").show();`                   |\n| `df.select($\"name\", $\"age\" + 1).show()` | `df.select(col(\"name\"), col(\"age\").plus(1)).show();` | `df.select(df['name'], df['age'] + 1).show()` |\n| `df.filter($\"age\" > 21).show()`         | `df.filter(col(\"age\").gt(21)).show();`               | `df.filter(df['age'] > 21).show()`            |\n| `df.groupBy(\"age\").count().show()`      | `df.groupBy(\"age\").count().show()`                   | `df.groupBy(\"age\").count().show()`            |\n\n```scala\n/************************** scala*************************/\n\n// This import is needed to use the $-notation\nimport spark.implicits._\n// Print the schema in a tree format\ndf.printSchema()\n// root\n// |-- age: long (nullable = true)\n// |-- name: string (nullable = true)\n\n// Select only the \"name\" column\ndf.select(\"name\").show()\n// +-------+\n// |   name|\n// +-------+\n// |Michael|\n// |   Andy|\n// | Justin|\n// +-------+\n\n// Select everybody, but increment the age by 1\ndf.select($\"name\", $\"age\" + 1).show()\n// +-------+---------+\n// |   name|(age + 1)|\n// +-------+---------+\n// |Michael|     null|\n// |   Andy|       31|\n// | Justin|       20|\n// +-------+---------+\n\n// Select people older than 21\ndf.filter($\"age\" > 21).show()\n// +---+----+\n// |age|name|\n// +---+----+\n// | 30|Andy|\n// +---+----+\n\n// Count people by age\ndf.groupBy(\"age\").count().show()\n// +----+-----+\n// | age|count|\n// +----+-----+\n// |  19|    1|\n// |null|    1|\n// |  30|    1|\n// +----+-----+\n```\n\n```java\n/************************** java*************************/\n\n// col(\"...\") is preferable to df.col(\"...\")\nimport static org.apache.spark.sql.functions.col;\n\n// Print the schema in a tree format\ndf.printSchema();\n// root\n// |-- age: long (nullable = true)\n// |-- name: string (nullable = true)\n\n// Select only the \"name\" column\ndf.select(\"name\").show();\n// +-------+\n// |   name|\n// +-------+\n// |Michael|\n// |   Andy|\n// | Justin|\n// +-------+\n\n// Select everybody, but increment the age by 1\ndf.select(col(\"name\"), col(\"age\").plus(1)).show();\n// +-------+---------+\n// |   name|(age + 1)|\n// +-------+---------+\n// |Michael|     null|\n// |   Andy|       31|\n// | Justin|       20|\n// +-------+---------+\n\n// Select people older than 21\ndf.filter(col(\"age\").gt(21)).show();\n// +---+----+\n// |age|name|\n// +---+----+\n// | 30|Andy|\n// +---+----+\n\n// Count people by age\ndf.groupBy(\"age\").count().show();\n// +----+-----+\n// | age|count|\n// +----+-----+\n// |  19|    1|\n// |null|    1|\n// |  30|    1|\n// +----+-----+\n```\n\n```python\n#####################             python                ###################\n\n# spark, df are from the previous example\n# Print the schema in a tree format\ndf.printSchema()\n# root\n# |-- age: long (nullable = true)\n# |-- name: string (nullable = true)\n\n# Select only the \"name\" column\ndf.select(\"name\").show()\n# +-------+\n# |   name|\n# +-------+\n# |Michael|\n# |   Andy|\n# | Justin|\n# +-------+\n\n# Select everybody, but increment the age by 1\ndf.select(df['name'], df['age'] + 1).show()\n# +-------+---------+\n# |   name|(age + 1)|\n# +-------+---------+\n# |Michael|     null|\n# |   Andy|       31|\n# | Justin|       20|\n# +-------+---------+\n\n# Select people older than 21\ndf.filter(df['age'] > 21).show()\n# +---+----+\n# |age|name|\n# +---+----+\n# | 30|Andy|\n# +---+----+\n\n# Count people by age\ndf.groupBy(\"age\").count().show()\n# +----+-----+\n# | age|count|\n# +----+-----+\n# |  19|    1|\n# |null|    1|\n# |  30|    1|\n# +----+-----+\n```\n\n## SQL查询\n\n通过SQL访问数据库，返回一个DataFrame的类型\n\n```scala\n/***************************   scala   *********************************/\n\n// Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\")\nval sqlDF = spark.sql(\"SELECT * FROM people\")\nsqlDF.show()\n```\n\n```java\n/***************************   java   *********************************/\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\n\n// Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\");\nDataset<Row> sqlDF = spark.sql(\"SELECT * FROM people\");\nsqlDF.show();\n```\n\n```python\n#############################   python    ###############################\n\n# Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\")\nsqlDF = spark.sql(\"SELECT * FROM people\")\nsqlDF.show()\n```\n\n## 全局临时视图\n\nSpark SQL中的临时视图是**会话范围**的，如果创建它的会话终止，它将消失。如果您希望拥有一个在所有会话之间共享的临时视图并保持活动状态，直到Spark应用程序终止，您可以创建一个全局临时视图。\n\n```scala\n/*********************************  scala  *************************************/\n\n// Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\")\n\n// Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show()\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```java\n/*********************************  java  *************************************/\n\n// Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\");\n\n// Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show();\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```python\n###############################   python   ################################\n\n# Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\")\n\n# Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show()\n# +----+-------+\n# | age|   name|\n# +----+-------+\n# |null|Michael|\n# |  30|   Andy|\n# |  19| Justin|\n# +----+-------+\n```\n\n## 创建dataset\n\n`Dataset`是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个`Dataset`都有一个称为`DataFrame`的非类型化的视图，这个视图是行的数据集。上面的定义看起来和`RDD`的定义类似，`DataSet`和`RDD`主要的区别是：`DataSet`是特定域的对象集合；然而`RDD`是任何对象的集合。`DataSet`的`API`总是强类型的；而且可以利用这些模式进行优化，然而`RDD`却不行。`DataFrame`是特殊的`Dataset`，它在编译时不会对模式进行检测。在未来版本的Spark，`Dataset`将会替代`RDD`成为我们开发编程使用的`API`（**注意，`RDD`并不是会被取消，而是会作为底层的`API`提供给用户使用**）。\n\n```scala\n//   scala\n// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,\n// you can use custom classes that implement the Product interface\ncase class Person(name: String, age: Long)\n\n// Encoders are created for case classes\nval caseClassDS = Seq(Person(\"Andy\", 32)).toDS()\ncaseClassDS.show()\n// +----+---+\n// |name|age|\n// +----+---+\n// |Andy| 32|\n// +----+---+\n\n// Encoders for most common types are automatically provided by importing spark.implicits._\nval primitiveDS = Seq(1, 2, 3).toDS()\nprimitiveDS.map(_ + 1).collect() // Returns: Array(2, 3, 4)\n\n// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name\nval path = \"examples/src/main/resources/people.json\"\nval peopleDS = spark.read.json(path).as[Person]\npeopleDS.show()\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```java\n// java\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.io.Serializable;\n\nimport org.apache.spark.api.java.function.MapFunction;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.Encoder;\nimport org.apache.spark.sql.Encoders;\n\npublic static class Person implements Serializable {\n  private String name;\n  private int age;\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public int getAge() {\n    return age;\n  }\n\n  public void setAge(int age) {\n    this.age = age;\n  }\n}\n\n// Create an instance of a Bean class\nPerson person = new Person();\nperson.setName(\"Andy\");\nperson.setAge(32);\n\n// Encoders are created for Java beans\nEncoder<Person> personEncoder = Encoders.bean(Person.class);\nDataset<Person> javaBeanDS = spark.createDataset(\n  Collections.singletonList(person),\n  personEncoder\n);\njavaBeanDS.show();\n// +---+----+\n// |age|name|\n// +---+----+\n// | 32|Andy|\n// +---+----+\n\n// Encoders for most common types are provided in class Encoders\nEncoder<Integer> integerEncoder = Encoders.INT();\nDataset<Integer> primitiveDS = spark.createDataset(Arrays.asList(1, 2, 3), integerEncoder);\nDataset<Integer> transformedDS = primitiveDS.map(\n    (MapFunction<Integer, Integer>) value -> value + 1,\n    integerEncoder);\ntransformedDS.collect(); // Returns [2, 3, 4]\n\n// DataFrames can be converted to a Dataset by providing a class. Mapping based on name\nString path = \"examples/src/main/resources/people.json\";\nDataset<Person> peopleDS = spark.read().json(path).as(personEncoder);\npeopleDS.show();\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n## [与RDD互相转换](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd)？？？？？？\n\nSpark SQL 支持两种不同的方法将RDDs 转换成 Datasets.\n\n**??????????????????????????????????????????**\n\n## [聚合函数](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#id4)\n\nDataFrame可以使用聚合函数，例如count()、max()等\n\n### 自定义聚合函数\n\n使用`UserDefinedAggregateFunction a`自定义聚合函数。\n\n```scala\n\n```\n\n## \n\n","source":"_posts/SQL-spark.md","raw":"---\ntitle: SQL-spark\ndate: 2019-08-13 19:49:05\ntags: [人工智能,分布式系统,数据库]\ncategories: spark\npermalink: spark/SQL-spark.md\n---\n\n![æç«SQLæ¶æ](SQL-spark/spark_sql_architecture.jpg)\n\n# [getting started](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#dataset)\n\n## SparkSession\n\nSpark 中所有功能的入口是 `SparkSession` 类。要创建一个基本的` SparkSession` 对象, 只需要使用 `SparkSession.builder():`\n\n```scala\n// scala\nimport org.apache.spark.sql.SparkSession\n\nval spark = SparkSession\n  .builder()\n  .appName(\"Spark SQL basic example\")\n  .config(\"spark.some.config.option\", \"some-value\")\n  .getOrCreate()\n```\n\n```java\n// java\nimport org.apache.spark.sql.SparkSession;\n\nSparkSession spark = SparkSession\n  .builder()\n  .appName(\"Java Spark SQL basic example\")\n  .config(\"spark.some.config.option\", \"some-value\")\n  .getOrCreate();\n```\n\n```python\n# python\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .appName(\"Python Spark SQL basic example\") \\\n    .config(\"spark.some.config.option\", \"some-value\") \\\n    .getOrCreate()\n```\n\n## 创建 DataFrame\n\n应用程序可以使用 `SparkSession `从一个现有的 `RDD`，`Hive `表或 `Spark` 数据源创建 `DataFrame`。下面基于一个 `JSON` 文件的内容创建一个 `DataFrame`:\n\n```scala\nval df = spark.read.json(\"examples/src/main/resources/people.json\")           //scala\n\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nDataset<Row> df = spark.read().json(\"examples/src/main/resources/people.json\"); //java\n\ndf = spark.read.json(\"examples/src/main/resources/people.json\")               //python\n```\n\n##  DataFrame 操作\n\n`DataFrame`为 `Scala`,` Java`, `Python` 以及 `R` 语言中的结构化数据操作提供了一种领域特定语言。\n\n| scala                                   | java                                                 | python                                        |\n| --------------------------------------- | ---------------------------------------------------- | --------------------------------------------- |\n| `df.printSchema()`                      | `df.printSchema();`                                  | `df.printSchema()`                            |\n| `df.select(\"name\")`                     | `df.select(\"name\").show();`                          | `df.select(\"name\").show();`                   |\n| `df.select($\"name\", $\"age\" + 1).show()` | `df.select(col(\"name\"), col(\"age\").plus(1)).show();` | `df.select(df['name'], df['age'] + 1).show()` |\n| `df.filter($\"age\" > 21).show()`         | `df.filter(col(\"age\").gt(21)).show();`               | `df.filter(df['age'] > 21).show()`            |\n| `df.groupBy(\"age\").count().show()`      | `df.groupBy(\"age\").count().show()`                   | `df.groupBy(\"age\").count().show()`            |\n\n```scala\n/************************** scala*************************/\n\n// This import is needed to use the $-notation\nimport spark.implicits._\n// Print the schema in a tree format\ndf.printSchema()\n// root\n// |-- age: long (nullable = true)\n// |-- name: string (nullable = true)\n\n// Select only the \"name\" column\ndf.select(\"name\").show()\n// +-------+\n// |   name|\n// +-------+\n// |Michael|\n// |   Andy|\n// | Justin|\n// +-------+\n\n// Select everybody, but increment the age by 1\ndf.select($\"name\", $\"age\" + 1).show()\n// +-------+---------+\n// |   name|(age + 1)|\n// +-------+---------+\n// |Michael|     null|\n// |   Andy|       31|\n// | Justin|       20|\n// +-------+---------+\n\n// Select people older than 21\ndf.filter($\"age\" > 21).show()\n// +---+----+\n// |age|name|\n// +---+----+\n// | 30|Andy|\n// +---+----+\n\n// Count people by age\ndf.groupBy(\"age\").count().show()\n// +----+-----+\n// | age|count|\n// +----+-----+\n// |  19|    1|\n// |null|    1|\n// |  30|    1|\n// +----+-----+\n```\n\n```java\n/************************** java*************************/\n\n// col(\"...\") is preferable to df.col(\"...\")\nimport static org.apache.spark.sql.functions.col;\n\n// Print the schema in a tree format\ndf.printSchema();\n// root\n// |-- age: long (nullable = true)\n// |-- name: string (nullable = true)\n\n// Select only the \"name\" column\ndf.select(\"name\").show();\n// +-------+\n// |   name|\n// +-------+\n// |Michael|\n// |   Andy|\n// | Justin|\n// +-------+\n\n// Select everybody, but increment the age by 1\ndf.select(col(\"name\"), col(\"age\").plus(1)).show();\n// +-------+---------+\n// |   name|(age + 1)|\n// +-------+---------+\n// |Michael|     null|\n// |   Andy|       31|\n// | Justin|       20|\n// +-------+---------+\n\n// Select people older than 21\ndf.filter(col(\"age\").gt(21)).show();\n// +---+----+\n// |age|name|\n// +---+----+\n// | 30|Andy|\n// +---+----+\n\n// Count people by age\ndf.groupBy(\"age\").count().show();\n// +----+-----+\n// | age|count|\n// +----+-----+\n// |  19|    1|\n// |null|    1|\n// |  30|    1|\n// +----+-----+\n```\n\n```python\n#####################             python                ###################\n\n# spark, df are from the previous example\n# Print the schema in a tree format\ndf.printSchema()\n# root\n# |-- age: long (nullable = true)\n# |-- name: string (nullable = true)\n\n# Select only the \"name\" column\ndf.select(\"name\").show()\n# +-------+\n# |   name|\n# +-------+\n# |Michael|\n# |   Andy|\n# | Justin|\n# +-------+\n\n# Select everybody, but increment the age by 1\ndf.select(df['name'], df['age'] + 1).show()\n# +-------+---------+\n# |   name|(age + 1)|\n# +-------+---------+\n# |Michael|     null|\n# |   Andy|       31|\n# | Justin|       20|\n# +-------+---------+\n\n# Select people older than 21\ndf.filter(df['age'] > 21).show()\n# +---+----+\n# |age|name|\n# +---+----+\n# | 30|Andy|\n# +---+----+\n\n# Count people by age\ndf.groupBy(\"age\").count().show()\n# +----+-----+\n# | age|count|\n# +----+-----+\n# |  19|    1|\n# |null|    1|\n# |  30|    1|\n# +----+-----+\n```\n\n## SQL查询\n\n通过SQL访问数据库，返回一个DataFrame的类型\n\n```scala\n/***************************   scala   *********************************/\n\n// Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\")\nval sqlDF = spark.sql(\"SELECT * FROM people\")\nsqlDF.show()\n```\n\n```java\n/***************************   java   *********************************/\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\n\n// Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\");\nDataset<Row> sqlDF = spark.sql(\"SELECT * FROM people\");\nsqlDF.show();\n```\n\n```python\n#############################   python    ###############################\n\n# Register the DataFrame as a SQL temporary view\ndf.createOrReplaceTempView(\"people\")\nsqlDF = spark.sql(\"SELECT * FROM people\")\nsqlDF.show()\n```\n\n## 全局临时视图\n\nSpark SQL中的临时视图是**会话范围**的，如果创建它的会话终止，它将消失。如果您希望拥有一个在所有会话之间共享的临时视图并保持活动状态，直到Spark应用程序终止，您可以创建一个全局临时视图。\n\n```scala\n/*********************************  scala  *************************************/\n\n// Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\")\n\n// Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show()\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```java\n/*********************************  java  *************************************/\n\n// Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\");\n\n// Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show();\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```python\n###############################   python   ################################\n\n# Register the DataFrame as a global temporary view\ndf.createGlobalTempView(\"people\")\n\n# Global temporary view is tied to a system preserved database `global_temp`\nspark.sql(\"SELECT * FROM global_temp.people\").show()\n# +----+-------+\n# | age|   name|\n# +----+-------+\n# |null|Michael|\n# |  30|   Andy|\n# |  19| Justin|\n# +----+-------+\n```\n\n## 创建dataset\n\n`Dataset`是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个`Dataset`都有一个称为`DataFrame`的非类型化的视图，这个视图是行的数据集。上面的定义看起来和`RDD`的定义类似，`DataSet`和`RDD`主要的区别是：`DataSet`是特定域的对象集合；然而`RDD`是任何对象的集合。`DataSet`的`API`总是强类型的；而且可以利用这些模式进行优化，然而`RDD`却不行。`DataFrame`是特殊的`Dataset`，它在编译时不会对模式进行检测。在未来版本的Spark，`Dataset`将会替代`RDD`成为我们开发编程使用的`API`（**注意，`RDD`并不是会被取消，而是会作为底层的`API`提供给用户使用**）。\n\n```scala\n//   scala\n// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,\n// you can use custom classes that implement the Product interface\ncase class Person(name: String, age: Long)\n\n// Encoders are created for case classes\nval caseClassDS = Seq(Person(\"Andy\", 32)).toDS()\ncaseClassDS.show()\n// +----+---+\n// |name|age|\n// +----+---+\n// |Andy| 32|\n// +----+---+\n\n// Encoders for most common types are automatically provided by importing spark.implicits._\nval primitiveDS = Seq(1, 2, 3).toDS()\nprimitiveDS.map(_ + 1).collect() // Returns: Array(2, 3, 4)\n\n// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name\nval path = \"examples/src/main/resources/people.json\"\nval peopleDS = spark.read.json(path).as[Person]\npeopleDS.show()\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n```java\n// java\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.io.Serializable;\n\nimport org.apache.spark.api.java.function.MapFunction;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.Encoder;\nimport org.apache.spark.sql.Encoders;\n\npublic static class Person implements Serializable {\n  private String name;\n  private int age;\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public int getAge() {\n    return age;\n  }\n\n  public void setAge(int age) {\n    this.age = age;\n  }\n}\n\n// Create an instance of a Bean class\nPerson person = new Person();\nperson.setName(\"Andy\");\nperson.setAge(32);\n\n// Encoders are created for Java beans\nEncoder<Person> personEncoder = Encoders.bean(Person.class);\nDataset<Person> javaBeanDS = spark.createDataset(\n  Collections.singletonList(person),\n  personEncoder\n);\njavaBeanDS.show();\n// +---+----+\n// |age|name|\n// +---+----+\n// | 32|Andy|\n// +---+----+\n\n// Encoders for most common types are provided in class Encoders\nEncoder<Integer> integerEncoder = Encoders.INT();\nDataset<Integer> primitiveDS = spark.createDataset(Arrays.asList(1, 2, 3), integerEncoder);\nDataset<Integer> transformedDS = primitiveDS.map(\n    (MapFunction<Integer, Integer>) value -> value + 1,\n    integerEncoder);\ntransformedDS.collect(); // Returns [2, 3, 4]\n\n// DataFrames can be converted to a Dataset by providing a class. Mapping based on name\nString path = \"examples/src/main/resources/people.json\";\nDataset<Person> peopleDS = spark.read().json(path).as(personEncoder);\npeopleDS.show();\n// +----+-------+\n// | age|   name|\n// +----+-------+\n// |null|Michael|\n// |  30|   Andy|\n// |  19| Justin|\n// +----+-------+\n```\n\n## [与RDD互相转换](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd)？？？？？？\n\nSpark SQL 支持两种不同的方法将RDDs 转换成 Datasets.\n\n**??????????????????????????????????????????**\n\n## [聚合函数](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#id4)\n\nDataFrame可以使用聚合函数，例如count()、max()等\n\n### 自定义聚合函数\n\n使用`UserDefinedAggregateFunction a`自定义聚合函数。\n\n```scala\n\n```\n\n## \n\n","slug":"spark/SQL-spark.md","published":1,"updated":"2019-08-14T08:34:12.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iyq0024homjbsr0p8tr","content":"<p><img src=\"/2019/08/13/spark/SQL-spark.md/spark_sql_architecture.jpg\" alt=\"æç«SQLæ¶æ\"></p>\n<h1 id=\"getting-started\"><a href=\"#getting-started\" class=\"headerlink\" title=\"getting started\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#dataset\" target=\"_blank\" rel=\"noopener\">getting started</a></h1><h2 id=\"SparkSession\"><a href=\"#SparkSession\" class=\"headerlink\" title=\"SparkSession\"></a>SparkSession</h2><p>Spark 中所有功能的入口是 <code>SparkSession</code> 类。要创建一个基本的<code>SparkSession</code> 对象, 只需要使用 <code>SparkSession.builder():</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// scala</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">SparkSession</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> spark = <span class=\"type\">SparkSession</span></span><br><span class=\"line\">  .builder()</span><br><span class=\"line\">  .appName(<span class=\"string\">\"Spark SQL basic example\"</span>)</span><br><span class=\"line\">  .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>)</span><br><span class=\"line\">  .getOrCreate()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.SparkSession;</span><br><span class=\"line\"></span><br><span class=\"line\">SparkSession spark = SparkSession</span><br><span class=\"line\">  .builder()</span><br><span class=\"line\">  .appName(<span class=\"string\">\"Java Spark SQL basic example\"</span>)</span><br><span class=\"line\">  .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>)</span><br><span class=\"line\">  .getOrCreate();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyspark.sql <span class=\"keyword\">import</span> SparkSession</span><br><span class=\"line\"></span><br><span class=\"line\">spark = SparkSession \\</span><br><span class=\"line\">    .builder \\</span><br><span class=\"line\">    .appName(<span class=\"string\">\"Python Spark SQL basic example\"</span>) \\</span><br><span class=\"line\">    .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>) \\</span><br><span class=\"line\">    .getOrCreate()</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-DataFrame\"><a href=\"#创建-DataFrame\" class=\"headerlink\" title=\"创建 DataFrame\"></a>创建 DataFrame</h2><p>应用程序可以使用 <code>SparkSession</code>从一个现有的 <code>RDD</code>，<code>Hive</code>表或 <code>Spark</code> 数据源创建 <code>DataFrame</code>。下面基于一个 <code>JSON</code> 文件的内容创建一个 <code>DataFrame</code>:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> df = spark.read.json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>)           <span class=\"comment\">//scala</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">Dataset</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">Row</span>;</span><br><span class=\"line\"><span class=\"type\">Dataset</span>&lt;<span class=\"type\">Row</span>&gt; df = spark.read().json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>); <span class=\"comment\">//java</span></span><br><span class=\"line\"></span><br><span class=\"line\">df = spark.read.json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>)               <span class=\"comment\">//python</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"DataFrame-操作\"><a href=\"#DataFrame-操作\" class=\"headerlink\" title=\"DataFrame 操作\"></a>DataFrame 操作</h2><p><code>DataFrame</code>为 <code>Scala</code>,<code>Java</code>, <code>Python</code> 以及 <code>R</code> 语言中的结构化数据操作提供了一种领域特定语言。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>scala</th>\n<th>java</th>\n<th>python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>df.printSchema()</code></td>\n<td><code>df.printSchema();</code></td>\n<td><code>df.printSchema()</code></td>\n</tr>\n<tr>\n<td><code>df.select(&quot;name&quot;)</code></td>\n<td><code>df.select(&quot;name&quot;).show();</code></td>\n<td><code>df.select(&quot;name&quot;).show();</code></td>\n</tr>\n<tr>\n<td><code>df.select($&quot;name&quot;, $&quot;age&quot; + 1).show()</code></td>\n<td><code>df.select(col(&quot;name&quot;), col(&quot;age&quot;).plus(1)).show();</code></td>\n<td><code>df.select(df[&#39;name&#39;], df[&#39;age&#39;] + 1).show()</code></td>\n</tr>\n<tr>\n<td><code>df.filter($&quot;age&quot; &gt; 21).show()</code></td>\n<td><code>df.filter(col(&quot;age&quot;).gt(21)).show();</code></td>\n<td><code>df.filter(df[&#39;age&#39;] &gt; 21).show()</code></td>\n</tr>\n<tr>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/************************** scala*************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This import is needed to use the $-notation</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> spark.implicits._</span><br><span class=\"line\"><span class=\"comment\">// Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema()</span><br><span class=\"line\"><span class=\"comment\">// root</span></span><br><span class=\"line\"><span class=\"comment\">// |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\">// |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select($<span class=\"string\">\"name\"</span>, $<span class=\"string\">\"age\"</span> + <span class=\"number\">1</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select people older than 21</span></span><br><span class=\"line\">df.filter($<span class=\"string\">\"age\"</span> &gt; <span class=\"number\">21</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|count|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/************************** java*************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// col(\"...\") is preferable to df.col(\"...\")</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.spark.sql.functions.col;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema();</span><br><span class=\"line\"><span class=\"comment\">// root</span></span><br><span class=\"line\"><span class=\"comment\">// |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\">// |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show();</span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select(col(<span class=\"string\">\"name\"</span>), col(<span class=\"string\">\"age\"</span>).plus(<span class=\"number\">1</span>)).show();</span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select people older than 21</span></span><br><span class=\"line\">df.filter(col(<span class=\"string\">\"age\"</span>).gt(<span class=\"number\">21</span>)).show();</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|count|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#####################             python                ###################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># spark, df are from the previous example</span></span><br><span class=\"line\"><span class=\"comment\"># Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema()</span><br><span class=\"line\"><span class=\"comment\"># root</span></span><br><span class=\"line\"><span class=\"comment\"># |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\"># |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |   name|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |Michael|</span></span><br><span class=\"line\"><span class=\"comment\"># |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># | Justin|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select(df[<span class=\"string\">'name'</span>], df[<span class=\"string\">'age'</span>] + <span class=\"number\">1</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\"># |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\"># |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\"># |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\"># | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select people older than 21</span></span><br><span class=\"line\">df.filter(df[<span class=\"string\">'age'</span>] &gt; <span class=\"number\">21</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"><span class=\"comment\"># |age|name|</span></span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"><span class=\"comment\"># | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show()</span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\"># | age|count|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\"># |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SQL查询\"><a href=\"#SQL查询\" class=\"headerlink\" title=\"SQL查询\"></a>SQL查询</h2><p>通过SQL访问数据库，返回一个DataFrame的类型</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***************************   scala   *********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>)</span><br><span class=\"line\">sqlDF.show()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***************************   java   *********************************/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Dataset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Row;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>);</span><br><span class=\"line\">Dataset&lt;Row&gt; sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>);</span><br><span class=\"line\">sqlDF.show();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#############################   python    ###############################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\">sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>)</span><br><span class=\"line\">sqlDF.show()</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局临时视图\"><a href=\"#全局临时视图\" class=\"headerlink\" title=\"全局临时视图\"></a>全局临时视图</h2><p>Spark SQL中的临时视图是<strong>会话范围</strong>的，如果创建它的会话终止，它将消失。如果您希望拥有一个在所有会话之间共享的临时视图并保持活动状态，直到Spark应用程序终止，您可以创建一个全局临时视图。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********************************  scala  *************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********************************  java  *************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###############################   python   ################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\"># | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\"># |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建dataset\"><a href=\"#创建dataset\" class=\"headerlink\" title=\"创建dataset\"></a>创建dataset</h2><p><code>Dataset</code>是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个<code>Dataset</code>都有一个称为<code>DataFrame</code>的非类型化的视图，这个视图是行的数据集。上面的定义看起来和<code>RDD</code>的定义类似，<code>DataSet</code>和<code>RDD</code>主要的区别是：<code>DataSet</code>是特定域的对象集合；然而<code>RDD</code>是任何对象的集合。<code>DataSet</code>的<code>API</code>总是强类型的；而且可以利用这些模式进行优化，然而<code>RDD</code>却不行。<code>DataFrame</code>是特殊的<code>Dataset</code>，它在编译时不会对模式进行检测。在未来版本的Spark，<code>Dataset</code>将会替代<code>RDD</code>成为我们开发编程使用的<code>API</code>（<strong>注意，<code>RDD</code>并不是会被取消，而是会作为底层的<code>API</code>提供给用户使用</strong>）。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//   scala</span></span><br><span class=\"line\"><span class=\"comment\">// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,</span></span><br><span class=\"line\"><span class=\"comment\">// you can use custom classes that implement the Product interface</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">name: <span class=\"type\">String</span>, age: <span class=\"type\">Long</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">Encoders</span> <span class=\"title\">are</span> <span class=\"title\">created</span> <span class=\"title\">for</span> <span class=\"title\">case</span> <span class=\"title\">classes</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">caseClassDS</span> </span>= <span class=\"type\">Seq</span>(<span class=\"type\">Person</span>(<span class=\"string\">\"Andy\"</span>, <span class=\"number\">32</span>)).toDS()</span><br><span class=\"line\">caseClassDS.show()</span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"><span class=\"comment\">// |name|age|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"><span class=\"comment\">// |Andy| 32|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders for most common types are automatically provided by importing spark.implicits._</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> primitiveDS = <span class=\"type\">Seq</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>).toDS()</span><br><span class=\"line\">primitiveDS.map(_ + <span class=\"number\">1</span>).collect() <span class=\"comment\">// Returns: Array(2, 3, 4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> path = <span class=\"string\">\"examples/src/main/resources/people.json\"</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> peopleDS = spark.read.json(path).as[<span class=\"type\">Person</span>]</span><br><span class=\"line\">peopleDS.show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.api.java.function.MapFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Dataset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Row;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Encoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Encoders;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create an instance of a Bean class</span></span><br><span class=\"line\">Person person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.setName(<span class=\"string\">\"Andy\"</span>);</span><br><span class=\"line\">person.setAge(<span class=\"number\">32</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders are created for Java beans</span></span><br><span class=\"line\">Encoder&lt;Person&gt; personEncoder = Encoders.bean(Person.class);</span><br><span class=\"line\">Dataset&lt;Person&gt; javaBeanDS = spark.createDataset(</span><br><span class=\"line\">  Collections.singletonList(person),</span><br><span class=\"line\">  personEncoder</span><br><span class=\"line\">);</span><br><span class=\"line\">javaBeanDS.show();</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 32|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders for most common types are provided in class Encoders</span></span><br><span class=\"line\">Encoder&lt;Integer&gt; integerEncoder = Encoders.INT();</span><br><span class=\"line\">Dataset&lt;Integer&gt; primitiveDS = spark.createDataset(Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), integerEncoder);</span><br><span class=\"line\">Dataset&lt;Integer&gt; transformedDS = primitiveDS.map(</span><br><span class=\"line\">    (MapFunction&lt;Integer, Integer&gt;) value -&gt; value + <span class=\"number\">1</span>,</span><br><span class=\"line\">    integerEncoder);</span><br><span class=\"line\">transformedDS.collect(); <span class=\"comment\">// Returns [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DataFrames can be converted to a Dataset by providing a class. Mapping based on name</span></span><br><span class=\"line\">String path = <span class=\"string\">\"examples/src/main/resources/people.json\"</span>;</span><br><span class=\"line\">Dataset&lt;Person&gt; peopleDS = spark.read().json(path).as(personEncoder);</span><br><span class=\"line\">peopleDS.show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"与RDD互相转换？？？？？？\"><a href=\"#与RDD互相转换？？？？？？\" class=\"headerlink\" title=\"与RDD互相转换？？？？？？\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd\" target=\"_blank\" rel=\"noopener\">与RDD互相转换</a>？？？？？？</h2><p>Spark SQL 支持两种不同的方法将RDDs 转换成 Datasets.</p>\n<p><strong>??????????????????????????????????????????</strong></p>\n<h2 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#id4\" target=\"_blank\" rel=\"noopener\">聚合函数</a></h2><p>DataFrame可以使用聚合函数，例如count()、max()等</p>\n<h3 id=\"自定义聚合函数\"><a href=\"#自定义聚合函数\" class=\"headerlink\" title=\"自定义聚合函数\"></a>自定义聚合函数</h3><p>使用<code>UserDefinedAggregateFunction a</code>自定义聚合函数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/08/13/spark/SQL-spark.md/spark_sql_architecture.jpg\" alt=\"æç«SQLæ¶æ\"></p>\n<h1 id=\"getting-started\"><a href=\"#getting-started\" class=\"headerlink\" title=\"getting started\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#dataset\" target=\"_blank\" rel=\"noopener\">getting started</a></h1><h2 id=\"SparkSession\"><a href=\"#SparkSession\" class=\"headerlink\" title=\"SparkSession\"></a>SparkSession</h2><p>Spark 中所有功能的入口是 <code>SparkSession</code> 类。要创建一个基本的<code>SparkSession</code> 对象, 只需要使用 <code>SparkSession.builder():</code></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// scala</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">SparkSession</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> spark = <span class=\"type\">SparkSession</span></span><br><span class=\"line\">  .builder()</span><br><span class=\"line\">  .appName(<span class=\"string\">\"Spark SQL basic example\"</span>)</span><br><span class=\"line\">  .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>)</span><br><span class=\"line\">  .getOrCreate()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.SparkSession;</span><br><span class=\"line\"></span><br><span class=\"line\">SparkSession spark = SparkSession</span><br><span class=\"line\">  .builder()</span><br><span class=\"line\">  .appName(<span class=\"string\">\"Java Spark SQL basic example\"</span>)</span><br><span class=\"line\">  .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>)</span><br><span class=\"line\">  .getOrCreate();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pyspark.sql <span class=\"keyword\">import</span> SparkSession</span><br><span class=\"line\"></span><br><span class=\"line\">spark = SparkSession \\</span><br><span class=\"line\">    .builder \\</span><br><span class=\"line\">    .appName(<span class=\"string\">\"Python Spark SQL basic example\"</span>) \\</span><br><span class=\"line\">    .config(<span class=\"string\">\"spark.some.config.option\"</span>, <span class=\"string\">\"some-value\"</span>) \\</span><br><span class=\"line\">    .getOrCreate()</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-DataFrame\"><a href=\"#创建-DataFrame\" class=\"headerlink\" title=\"创建 DataFrame\"></a>创建 DataFrame</h2><p>应用程序可以使用 <code>SparkSession</code>从一个现有的 <code>RDD</code>，<code>Hive</code>表或 <code>Spark</code> 数据源创建 <code>DataFrame</code>。下面基于一个 <code>JSON</code> 文件的内容创建一个 <code>DataFrame</code>:</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> df = spark.read.json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>)           <span class=\"comment\">//scala</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">Dataset</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.<span class=\"type\">Row</span>;</span><br><span class=\"line\"><span class=\"type\">Dataset</span>&lt;<span class=\"type\">Row</span>&gt; df = spark.read().json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>); <span class=\"comment\">//java</span></span><br><span class=\"line\"></span><br><span class=\"line\">df = spark.read.json(<span class=\"string\">\"examples/src/main/resources/people.json\"</span>)               <span class=\"comment\">//python</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"DataFrame-操作\"><a href=\"#DataFrame-操作\" class=\"headerlink\" title=\"DataFrame 操作\"></a>DataFrame 操作</h2><p><code>DataFrame</code>为 <code>Scala</code>,<code>Java</code>, <code>Python</code> 以及 <code>R</code> 语言中的结构化数据操作提供了一种领域特定语言。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>scala</th>\n<th>java</th>\n<th>python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>df.printSchema()</code></td>\n<td><code>df.printSchema();</code></td>\n<td><code>df.printSchema()</code></td>\n</tr>\n<tr>\n<td><code>df.select(&quot;name&quot;)</code></td>\n<td><code>df.select(&quot;name&quot;).show();</code></td>\n<td><code>df.select(&quot;name&quot;).show();</code></td>\n</tr>\n<tr>\n<td><code>df.select($&quot;name&quot;, $&quot;age&quot; + 1).show()</code></td>\n<td><code>df.select(col(&quot;name&quot;), col(&quot;age&quot;).plus(1)).show();</code></td>\n<td><code>df.select(df[&#39;name&#39;], df[&#39;age&#39;] + 1).show()</code></td>\n</tr>\n<tr>\n<td><code>df.filter($&quot;age&quot; &gt; 21).show()</code></td>\n<td><code>df.filter(col(&quot;age&quot;).gt(21)).show();</code></td>\n<td><code>df.filter(df[&#39;age&#39;] &gt; 21).show()</code></td>\n</tr>\n<tr>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n<td><code>df.groupBy(&quot;age&quot;).count().show()</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/************************** scala*************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This import is needed to use the $-notation</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> spark.implicits._</span><br><span class=\"line\"><span class=\"comment\">// Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema()</span><br><span class=\"line\"><span class=\"comment\">// root</span></span><br><span class=\"line\"><span class=\"comment\">// |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\">// |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select($<span class=\"string\">\"name\"</span>, $<span class=\"string\">\"age\"</span> + <span class=\"number\">1</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select people older than 21</span></span><br><span class=\"line\">df.filter($<span class=\"string\">\"age\"</span> &gt; <span class=\"number\">21</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|count|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/************************** java*************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// col(\"...\") is preferable to df.col(\"...\")</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.apache.spark.sql.functions.col;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema();</span><br><span class=\"line\"><span class=\"comment\">// root</span></span><br><span class=\"line\"><span class=\"comment\">// |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\">// |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show();</span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select(col(<span class=\"string\">\"name\"</span>), col(<span class=\"string\">\"age\"</span>).plus(<span class=\"number\">1</span>)).show();</span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\">// |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\">// |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\">// | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\">// +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select people older than 21</span></span><br><span class=\"line\">df.filter(col(<span class=\"string\">\"age\"</span>).gt(<span class=\"number\">21</span>)).show();</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|count|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\">// |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-----+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#####################             python                ###################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># spark, df are from the previous example</span></span><br><span class=\"line\"><span class=\"comment\"># Print the schema in a tree format</span></span><br><span class=\"line\">df.printSchema()</span><br><span class=\"line\"><span class=\"comment\"># root</span></span><br><span class=\"line\"><span class=\"comment\"># |-- age: long (nullable = true)</span></span><br><span class=\"line\"><span class=\"comment\"># |-- name: string (nullable = true)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select only the \"name\" column</span></span><br><span class=\"line\">df.select(<span class=\"string\">\"name\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |   name|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |Michael|</span></span><br><span class=\"line\"><span class=\"comment\"># |   Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># | Justin|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select everybody, but increment the age by 1</span></span><br><span class=\"line\">df.select(df[<span class=\"string\">'name'</span>], df[<span class=\"string\">'age'</span>] + <span class=\"number\">1</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\"># |   name|(age + 1)|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"><span class=\"comment\"># |Michael|     null|</span></span><br><span class=\"line\"><span class=\"comment\"># |   Andy|       31|</span></span><br><span class=\"line\"><span class=\"comment\"># | Justin|       20|</span></span><br><span class=\"line\"><span class=\"comment\"># +-------+---------+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Select people older than 21</span></span><br><span class=\"line\">df.filter(df[<span class=\"string\">'age'</span>] &gt; <span class=\"number\">21</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"><span class=\"comment\"># |age|name|</span></span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"><span class=\"comment\"># | 30|Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Count people by age</span></span><br><span class=\"line\">df.groupBy(<span class=\"string\">\"age\"</span>).count().show()</span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\"># | age|count|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br><span class=\"line\"><span class=\"comment\"># |  19|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># |null|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># |  30|    1|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-----+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"SQL查询\"><a href=\"#SQL查询\" class=\"headerlink\" title=\"SQL查询\"></a>SQL查询</h2><p>通过SQL访问数据库，返回一个DataFrame的类型</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***************************   scala   *********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>)</span><br><span class=\"line\">sqlDF.show()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***************************   java   *********************************/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Dataset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Row;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>);</span><br><span class=\"line\">Dataset&lt;Row&gt; sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>);</span><br><span class=\"line\">sqlDF.show();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#############################   python    ###############################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the DataFrame as a SQL temporary view</span></span><br><span class=\"line\">df.createOrReplaceTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\">sqlDF = spark.sql(<span class=\"string\">\"SELECT * FROM people\"</span>)</span><br><span class=\"line\">sqlDF.show()</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局临时视图\"><a href=\"#全局临时视图\" class=\"headerlink\" title=\"全局临时视图\"></a>全局临时视图</h2><p>Spark SQL中的临时视图是<strong>会话范围</strong>的，如果创建它的会话终止，它将消失。如果您希望拥有一个在所有会话之间共享的临时视图并保持活动状态，直到Spark应用程序终止，您可以创建一个全局临时视图。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********************************  scala  *************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*********************************  java  *************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###############################   python   ################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the DataFrame as a global temporary view</span></span><br><span class=\"line\">df.createGlobalTempView(<span class=\"string\">\"people\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Global temporary view is tied to a system preserved database `global_temp`</span></span><br><span class=\"line\">spark.sql(<span class=\"string\">\"SELECT * FROM global_temp.people\"</span>).show()</span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\"># | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\"># |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\"># |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\"># |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\"># +----+-------+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建dataset\"><a href=\"#创建dataset\" class=\"headerlink\" title=\"创建dataset\"></a>创建dataset</h2><p><code>Dataset</code>是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个<code>Dataset</code>都有一个称为<code>DataFrame</code>的非类型化的视图，这个视图是行的数据集。上面的定义看起来和<code>RDD</code>的定义类似，<code>DataSet</code>和<code>RDD</code>主要的区别是：<code>DataSet</code>是特定域的对象集合；然而<code>RDD</code>是任何对象的集合。<code>DataSet</code>的<code>API</code>总是强类型的；而且可以利用这些模式进行优化，然而<code>RDD</code>却不行。<code>DataFrame</code>是特殊的<code>Dataset</code>，它在编译时不会对模式进行检测。在未来版本的Spark，<code>Dataset</code>将会替代<code>RDD</code>成为我们开发编程使用的<code>API</code>（<strong>注意，<code>RDD</code>并不是会被取消，而是会作为底层的<code>API</code>提供给用户使用</strong>）。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//   scala</span></span><br><span class=\"line\"><span class=\"comment\">// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,</span></span><br><span class=\"line\"><span class=\"comment\">// you can use custom classes that implement the Product interface</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">name: <span class=\"type\">String</span>, age: <span class=\"type\">Long</span></span>)</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">//</span> <span class=\"title\">Encoders</span> <span class=\"title\">are</span> <span class=\"title\">created</span> <span class=\"title\">for</span> <span class=\"title\">case</span> <span class=\"title\">classes</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">caseClassDS</span> </span>= <span class=\"type\">Seq</span>(<span class=\"type\">Person</span>(<span class=\"string\">\"Andy\"</span>, <span class=\"number\">32</span>)).toDS()</span><br><span class=\"line\">caseClassDS.show()</span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"><span class=\"comment\">// |name|age|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"><span class=\"comment\">// |Andy| 32|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+---+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders for most common types are automatically provided by importing spark.implicits._</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> primitiveDS = <span class=\"type\">Seq</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>).toDS()</span><br><span class=\"line\">primitiveDS.map(_ + <span class=\"number\">1</span>).collect() <span class=\"comment\">// Returns: Array(2, 3, 4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> path = <span class=\"string\">\"examples/src/main/resources/people.json\"</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> peopleDS = spark.read.json(path).as[<span class=\"type\">Person</span>]</span><br><span class=\"line\">peopleDS.show()</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.api.java.function.MapFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Dataset;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Row;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Encoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.spark.sql.Encoders;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create an instance of a Bean class</span></span><br><span class=\"line\">Person person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.setName(<span class=\"string\">\"Andy\"</span>);</span><br><span class=\"line\">person.setAge(<span class=\"number\">32</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders are created for Java beans</span></span><br><span class=\"line\">Encoder&lt;Person&gt; personEncoder = Encoders.bean(Person.class);</span><br><span class=\"line\">Dataset&lt;Person&gt; javaBeanDS = spark.createDataset(</span><br><span class=\"line\">  Collections.singletonList(person),</span><br><span class=\"line\">  personEncoder</span><br><span class=\"line\">);</span><br><span class=\"line\">javaBeanDS.show();</span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// |age|name|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"><span class=\"comment\">// | 32|Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// +---+----+</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Encoders for most common types are provided in class Encoders</span></span><br><span class=\"line\">Encoder&lt;Integer&gt; integerEncoder = Encoders.INT();</span><br><span class=\"line\">Dataset&lt;Integer&gt; primitiveDS = spark.createDataset(Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), integerEncoder);</span><br><span class=\"line\">Dataset&lt;Integer&gt; transformedDS = primitiveDS.map(</span><br><span class=\"line\">    (MapFunction&lt;Integer, Integer&gt;) value -&gt; value + <span class=\"number\">1</span>,</span><br><span class=\"line\">    integerEncoder);</span><br><span class=\"line\">transformedDS.collect(); <span class=\"comment\">// Returns [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DataFrames can be converted to a Dataset by providing a class. Mapping based on name</span></span><br><span class=\"line\">String path = <span class=\"string\">\"examples/src/main/resources/people.json\"</span>;</span><br><span class=\"line\">Dataset&lt;Person&gt; peopleDS = spark.read().json(path).as(personEncoder);</span><br><span class=\"line\">peopleDS.show();</span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// | age|   name|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br><span class=\"line\"><span class=\"comment\">// |null|Michael|</span></span><br><span class=\"line\"><span class=\"comment\">// |  30|   Andy|</span></span><br><span class=\"line\"><span class=\"comment\">// |  19| Justin|</span></span><br><span class=\"line\"><span class=\"comment\">// +----+-------+</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"与RDD互相转换？？？？？？\"><a href=\"#与RDD互相转换？？？？？？\" class=\"headerlink\" title=\"与RDD互相转换？？？？？？\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd\" target=\"_blank\" rel=\"noopener\">与RDD互相转换</a>？？？？？？</h2><p>Spark SQL 支持两种不同的方法将RDDs 转换成 Datasets.</p>\n<p><strong>??????????????????????????????????????????</strong></p>\n<h2 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#id4\" target=\"_blank\" rel=\"noopener\">聚合函数</a></h2><p>DataFrame可以使用聚合函数，例如count()、max()等</p>\n<h3 id=\"自定义聚合函数\"><a href=\"#自定义聚合函数\" class=\"headerlink\" title=\"自定义聚合函数\"></a>自定义聚合函数</h3><p>使用<code>UserDefinedAggregateFunction a</code>自定义聚合函数。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>"},{"title":"RDD-Spark","date":"2019-08-12T03:24:20.000Z","_content":"\n# Actions\n\n| 命令                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| `reduce(func)`             | 通过函数`func`聚集数据集中的所有元素。`func`函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行 |\n| `collect()`                | 在`Driver`的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用`filter`或者其它操作后，返回一个足够小的数据子集再使用，直接将整个`RDD`集Collect返回，很可能会让`Driver`程序OOM |\n| `count()`                  | 统计`RDD`中元素的个数                                        |\n| `take(n)`                  | 取`RDD`中的前`n`个元素。注意，这个操作目前并非在多个节点上，并行执行，而是`Driver`程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用） |\n| `first()`                  | 返回数据集的第一个元素（类似于`take(1)`  ）                  |\n| `reduce(func)`             | 按照指定规则聚合`RDD`中的元素                                |\n| `countByValue()`           | 统计出`RDD`中每个元素的个数                                  |\n| `countByKey()`             | 统计出`KV`格式的`RDD`中相同的K的个数                         |\n| `foreach(func)`            | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `foreachPartition(func)`   | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `saveAsTextFile(path)`     | 将数据集的元素，以t`extfile`的形式，保存到本地文件系统，`hdfs`或者任何其它`hadoop`支持的文件系统。Spark将会调用每个元素的`toString`方法，并将它转换为文件中的一行文本 |\n| `saveAsSequenceFile(path)` | 将数据集的元素，以`sequencefile`的格式，保存到指定的目录下，本地系统，`hdfs`或者任何其它`hadoop`支持的文件系统。`RDD`的元素必须由`key-value`对组成，并都实现了`Hadoop`的`Writable`接口，或隐式可以转换为`Writable`（Spark包括了基本类型的转换，例如`Int`，`Double`，`String`等等） |\n\n```scala\n//collect 把运行结果拉回到Driver端\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nval resultRDD = rdd.sortByKey()\nval list = resultRDD.collect()\nlist.foreach(println)\n\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nval resultRDD = rdd.sortByKey()\nval list = resultRDD.collect()\nlist.foreach(println)\n\n//take(n)：取RDD中的前n个元素\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.take(2).foreach(println)\n\n//first 相当于take(1)\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nprintln(rdd.first)\n\n// count 统计RDD中元素的个数\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nval num = rdd.count()\n\n// reduce 按照指定规则聚合RDD中的元素\nval numArr = Array(1,2,3,4,5)\nval rdd = sc.parallelize(numArr)\nval sum = rdd.reduce(_+_)\nprintln(sum)\n\n//countByValue 统计出RDD中每个元素的个数\nval rdd = sc.parallelize(Array(\n  \"Tom\",\"Jed\",\"Tom\",\n  \"Tom\",\"Jed\",\"Jed\",\n  \"Tom\",\"Tony\",\"Jed\"\n))\nval result = rdd.countByValue();\nresult.foreach(println)\n\n// countByKey 统计出KV格式的RDD中相同的K的个数\nval rdd = sc.parallelize(Array(\n  (\"销售部\",\"Tom\"), (\"销售部\",\"Jack\"),(\"销售部\",\"Bob\"),(\"销售部\",\"Terry\"),\n  (\"后勤部\",\"Jack\"),(\"后勤部\",\"Selina\"),(\"后勤部\",\"Hebe\"),\n  (\"人力部\",\"Ella\"),(\"人力部\",\"Harry\"),\n  (\"开发部\",\"Allen\")\n))\nval result = rdd.countByKey();\nresult.foreach(println)\n\n// foreach 遍历RDD中的元素\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.foreach(println)\n\n//foreachPartition 以分区为单位遍历RDD\nval rdd = sc.parallelize(1 to 6, 2)\nrdd.foreachPartition(x => {\n  println(\"data from a partition:\")\n  while(x.hasNext) {\n    println(x.next())\n  }\n})\n```\n\n# Transformations\n\n| 命令                                  | 说明                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| `filter(func)`                        | 返回一个新的数据集，由经过`func`函数后返回值为`true`的原元素组成 |\n| `map(func)`                           | 返回一个新的分布式数据集，由每个原元素经过`func`函数转换后组成 |\n| `flatMap(func)`                       | 类似于`map`，但是每一个输入元素，会被映射为0到多个输出元素（因此，`func`函数的返回值是一个`Seq`，而不是单一元素） |\n| `sample(withReplacement, frac, seed)` | 随机抽样<br>`withReplacement`：是否是放回式抽样<br>`frac`:：抽样的比例<br>`seed`：随机种子 |\n| `reduceByKey(func, [numTasks])`       | 在一个`(K,V)`对的数据集上使用，返回一个`(K,V)`对的数据集，`key`相同的值，都被使用指定的`reduce`函数聚合到一起。和`groupbykey`类似，任务的个数是可以通过第二个可选参数来配置的。 |\n| `groupByKey([numTasks])`              | 在一个由`（K,V）`对组成的数据集上调用，返回一个`(K，Seq[V])`对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入`numTask`可选参数，根据数据量设置不同数目的`Task` |\n| `sortByKey(func, [numTasks])`         | 按`key`值进行排序                                            |\n| `union(otherDataset)`                 | 返回一个新的数据集，由原数据集和参数联合而成                 |\n| `join(otherDataset, [numTasks])`      | 在类型为`(K,V)`和`(K,W)`类型的数据集上调用，返回一个`(K,(V,W))`对，每个key中的所有元素都在一起的数据集 |\n| `cartesian(otherDataset)`             | 笛卡尔积。但在数据集T和U上调用时，返回一个(T，U) 对的数据集，所有元素交互进行笛卡尔积。 |\n| `map(func)`                           | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `mapPartitions(func)`                 | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `mapPartitionsWithIndex`              | 与`mapPartitions`基本相同，只是在处理函数的参数是一个二元元组，元组的第一个元素是当前处理的分区的`index`，元组的第二个元素是当前处理的分区元素组成的`Iterator` |\n| `coalesce(n,shuffle)`                 | 改变RDD的分区数<br>n：新的分区数目<br>shuffle：false:不产生shuffle；true:产生shuffle，如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变 |\n| `repartition(n)`                      | 改变RDD分区数。`repartition(int n) = coalesce(int n, true)`  |\n| `partitionBy`                         | 通过自定义分区器改变RDD分区数                                |\n| `randomSplit(Array)`                  | 根据传入的 `Array`中每个元素的权重将`rdd`拆分成`Array.size`个`RDD`拆分后的`RDD`中元素数量由权重来决定， |\n| `groupWith(otherDataset, [numTasks])` | 在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup |\n\n## map和flatMap\n\n![img](RDD-Spark/15050362138086.jpg)\n\n## filter、sample、sortByKey、sortBy\n\n\n```scala\n//filter：过滤\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.filter(!_.contains(\"hello\")).foreach(println)\n\n/********** map和flatMap**************\n*map: 输入一条记录，输出一条记录\n*flatmap：输入一条记录，输出多头记录\n*************************************/\n\n//sample ：随机抽样\nval rdd = sc.makeRDD(Array(\n  \"hello1\",\"hello2\",\"hello3\",\"hello4\",\"hello5\",\"hello6\",\n  \"world1\",\"world2\",\"world3\",\"world4\"\n))\nrdd.sample(false, 0.3).foreach(println)\n\n//sortByKey：按key进行排序\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nrdd.sortByKey().foreach(println)\n\n//sortBy：自定义排序规则\nobject SortByOperator {\n  def main(args: Array[String]): Unit = {\n   val conf = new SparkConf().setAppName(\"TestSortBy\").setMaster(\"local\")\n    val sc = new SparkContext(conf)\n    val arr = Array(\n        Tuple3(190,100,\"Jed\"),\n        Tuple3(100,202,\"Tom\"),\n        Tuple3(90,111,\"Tony\")\n    )\n    val rdd = sc.parallelize(arr)\n    rdd.sortBy(_._1).foreach(println)   //按照190、100、90排序\n```\n\n## groupByKey和reduceByKey\n\n![img](RDD-Spark/15050363083877.jpg)\n\n## distinct：去掉重复数据\n\n![img](RDD-Spark/15050364198942.jpg)\n\n```scala\nval rdd = sc.makeRDD(Array(\n      \"hello\",\n      \"hello\",\n      \"hello\",\n      \"world\"\n))\nval distinctRDD = rdd\n      .map {(_,1)}\n      .reduceByKey(_+_)\n      .map(_._1)\ndistinctRDD.foreach {println}    //等价于：rdd.distinct().foreach {println}\n```\n\n## map和mapPartitions\n\n```scala\nval arr = Array(\"Tom\",\"Bob\",\"Tony\",\"Jerry\")\n//把4条数据分到两个分区中\nval rdd = sc.parallelize(arr,2)\n   \n/*\n * 模拟把RDD中的元素写入数据库的过程\n */\nrdd.map(x => {\n  println(\"创建数据库连接...\")\n  println(\"写入数据库...\")\n  println(\"关闭数据库连接...\")\n  println()\n}).count()\n结果：\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n```\n\n```scala\n/*\n * 将RDD中的数据写入到数据库中，绝大部分使用mapPartitions算子来实现\n */\nrdd.mapPartitions(x => {\n  println(\"创建数据库\")\n  val list = new ListBuffer[String]()\n  while(x.hasNext){\n    //写入数据库\n    list += x.next()+\":写入数据库\"\n  }\n  //执行SQL语句  批量插入\n  list.iterator\n})foreach(println)\n结果：\n创建数据库\nTom:写入数据库\nBob:写入数据库 \n创建数据库\nTony:写入数据库\nJerry:写入数据库\n```\n\n## mapPartitionsWithIndex\n\n```scala\nval dataArr = Array(\"Tom01\",\"Tom02\",\"Tom03\"\n                  ,\"Tom04\",\"Tom05\",\"Tom06\"\n                  ,\"Tom07\",\"Tom08\",\"Tom09\"\n                  ,\"Tom10\",\"Tom11\",\"Tom12\")\nval rdd = sc.parallelize(dataArr, 3);\nval result = rdd.mapPartitionsWithIndex((index,x) => {\n    val list = ListBuffer[String]()\n    while (x.hasNext) {\n      list += \"partition:\"+ index + \" content:\" + x.next\n    }\n    list.iterator\n})\nprintln(\"分区数量:\" + result.partitions.size)\nval resultArr = result.collect()\nfor(x <- resultArr){\n  println(x)\n}\n```\n\n## coalesce：改变RDD的分区数\n\n```scala\n/*\n * false:不产生shuffle\n * true:产生shuffle\n * 如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变\n * 增加分区会把原来的分区中的数据随机分配给设置的分区个数\n */\nval coalesceRdd = result.coalesce(6,true)\n   \nval results = coalesceRdd.mapPartitionsWithIndex((index,x) => {\n  val list = ListBuffer[String]()\n  while (x.hasNext) {\n      list += \"partition:\"+ index + \" content:[\" + x.next + \"]\"\n  }\n  list.iterator\n})\n   \nprintln(\"分区数量:\" + results.partitions.size)\nval resultArr = results.collect()\nfor(x <- resultArr){\n  println(x)\n}\n\n```\n\n![img](http://chant00.com/media/15050414638959.jpg)\n\n## randomSplit：拆分RDD\n\n```scala\n/**\n * randomSplit:\n *   根据传入的 Array中每个元素的权重将rdd拆分成Array.size个RDD\n *  拆分后的RDD中元素数量由权重来决定，数据量不大时不一定准确\n */\nval rdd = sc.parallelize(1 to 10)\nrdd.randomSplit(Array(0.1,0.2,0.3,0.4)).foreach(x => {println(x.count)})\n```\n\n## zip\n\n![img](RDD-Spark/15051361379636.jpg)\n\n","source":"_posts/RDD-Spark.md","raw":"---\ntitle: RDD-Spark\ndate: 2019-08-12 11:24:20\ntags: [人工智能,分布式系统]\ncategories: spark\npermalink: sparkL/RDD-Spark.md\n---\n\n# Actions\n\n| 命令                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| `reduce(func)`             | 通过函数`func`聚集数据集中的所有元素。`func`函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行 |\n| `collect()`                | 在`Driver`的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用`filter`或者其它操作后，返回一个足够小的数据子集再使用，直接将整个`RDD`集Collect返回，很可能会让`Driver`程序OOM |\n| `count()`                  | 统计`RDD`中元素的个数                                        |\n| `take(n)`                  | 取`RDD`中的前`n`个元素。注意，这个操作目前并非在多个节点上，并行执行，而是`Driver`程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用） |\n| `first()`                  | 返回数据集的第一个元素（类似于`take(1)`  ）                  |\n| `reduce(func)`             | 按照指定规则聚合`RDD`中的元素                                |\n| `countByValue()`           | 统计出`RDD`中每个元素的个数                                  |\n| `countByKey()`             | 统计出`KV`格式的`RDD`中相同的K的个数                         |\n| `foreach(func)`            | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `foreachPartition(func)`   | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `saveAsTextFile(path)`     | 将数据集的元素，以t`extfile`的形式，保存到本地文件系统，`hdfs`或者任何其它`hadoop`支持的文件系统。Spark将会调用每个元素的`toString`方法，并将它转换为文件中的一行文本 |\n| `saveAsSequenceFile(path)` | 将数据集的元素，以`sequencefile`的格式，保存到指定的目录下，本地系统，`hdfs`或者任何其它`hadoop`支持的文件系统。`RDD`的元素必须由`key-value`对组成，并都实现了`Hadoop`的`Writable`接口，或隐式可以转换为`Writable`（Spark包括了基本类型的转换，例如`Int`，`Double`，`String`等等） |\n\n```scala\n//collect 把运行结果拉回到Driver端\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nval resultRDD = rdd.sortByKey()\nval list = resultRDD.collect()\nlist.foreach(println)\n\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nval resultRDD = rdd.sortByKey()\nval list = resultRDD.collect()\nlist.foreach(println)\n\n//take(n)：取RDD中的前n个元素\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.take(2).foreach(println)\n\n//first 相当于take(1)\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nprintln(rdd.first)\n\n// count 统计RDD中元素的个数\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nval num = rdd.count()\n\n// reduce 按照指定规则聚合RDD中的元素\nval numArr = Array(1,2,3,4,5)\nval rdd = sc.parallelize(numArr)\nval sum = rdd.reduce(_+_)\nprintln(sum)\n\n//countByValue 统计出RDD中每个元素的个数\nval rdd = sc.parallelize(Array(\n  \"Tom\",\"Jed\",\"Tom\",\n  \"Tom\",\"Jed\",\"Jed\",\n  \"Tom\",\"Tony\",\"Jed\"\n))\nval result = rdd.countByValue();\nresult.foreach(println)\n\n// countByKey 统计出KV格式的RDD中相同的K的个数\nval rdd = sc.parallelize(Array(\n  (\"销售部\",\"Tom\"), (\"销售部\",\"Jack\"),(\"销售部\",\"Bob\"),(\"销售部\",\"Terry\"),\n  (\"后勤部\",\"Jack\"),(\"后勤部\",\"Selina\"),(\"后勤部\",\"Hebe\"),\n  (\"人力部\",\"Ella\"),(\"人力部\",\"Harry\"),\n  (\"开发部\",\"Allen\")\n))\nval result = rdd.countByKey();\nresult.foreach(println)\n\n// foreach 遍历RDD中的元素\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.foreach(println)\n\n//foreachPartition 以分区为单位遍历RDD\nval rdd = sc.parallelize(1 to 6, 2)\nrdd.foreachPartition(x => {\n  println(\"data from a partition:\")\n  while(x.hasNext) {\n    println(x.next())\n  }\n})\n```\n\n# Transformations\n\n| 命令                                  | 说明                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| `filter(func)`                        | 返回一个新的数据集，由经过`func`函数后返回值为`true`的原元素组成 |\n| `map(func)`                           | 返回一个新的分布式数据集，由每个原元素经过`func`函数转换后组成 |\n| `flatMap(func)`                       | 类似于`map`，但是每一个输入元素，会被映射为0到多个输出元素（因此，`func`函数的返回值是一个`Seq`，而不是单一元素） |\n| `sample(withReplacement, frac, seed)` | 随机抽样<br>`withReplacement`：是否是放回式抽样<br>`frac`:：抽样的比例<br>`seed`：随机种子 |\n| `reduceByKey(func, [numTasks])`       | 在一个`(K,V)`对的数据集上使用，返回一个`(K,V)`对的数据集，`key`相同的值，都被使用指定的`reduce`函数聚合到一起。和`groupbykey`类似，任务的个数是可以通过第二个可选参数来配置的。 |\n| `groupByKey([numTasks])`              | 在一个由`（K,V）`对组成的数据集上调用，返回一个`(K，Seq[V])`对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入`numTask`可选参数，根据数据量设置不同数目的`Task` |\n| `sortByKey(func, [numTasks])`         | 按`key`值进行排序                                            |\n| `union(otherDataset)`                 | 返回一个新的数据集，由原数据集和参数联合而成                 |\n| `join(otherDataset, [numTasks])`      | 在类型为`(K,V)`和`(K,W)`类型的数据集上调用，返回一个`(K,(V,W))`对，每个key中的所有元素都在一起的数据集 |\n| `cartesian(otherDataset)`             | 笛卡尔积。但在数据集T和U上调用时，返回一个(T，U) 对的数据集，所有元素交互进行笛卡尔积。 |\n| `map(func)`                           | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `mapPartitions(func)`                 | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `mapPartitionsWithIndex`              | 与`mapPartitions`基本相同，只是在处理函数的参数是一个二元元组，元组的第一个元素是当前处理的分区的`index`，元组的第二个元素是当前处理的分区元素组成的`Iterator` |\n| `coalesce(n,shuffle)`                 | 改变RDD的分区数<br>n：新的分区数目<br>shuffle：false:不产生shuffle；true:产生shuffle，如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变 |\n| `repartition(n)`                      | 改变RDD分区数。`repartition(int n) = coalesce(int n, true)`  |\n| `partitionBy`                         | 通过自定义分区器改变RDD分区数                                |\n| `randomSplit(Array)`                  | 根据传入的 `Array`中每个元素的权重将`rdd`拆分成`Array.size`个`RDD`拆分后的`RDD`中元素数量由权重来决定， |\n| `groupWith(otherDataset, [numTasks])` | 在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup |\n\n## map和flatMap\n\n![img](RDD-Spark/15050362138086.jpg)\n\n## filter、sample、sortByKey、sortBy\n\n\n```scala\n//filter：过滤\nval rdd = sc.makeRDD(Array(\"hello\",\"hello\",\"hello\",\"world\"))\nrdd.filter(!_.contains(\"hello\")).foreach(println)\n\n/********** map和flatMap**************\n*map: 输入一条记录，输出一条记录\n*flatmap：输入一条记录，输出多头记录\n*************************************/\n\n//sample ：随机抽样\nval rdd = sc.makeRDD(Array(\n  \"hello1\",\"hello2\",\"hello3\",\"hello4\",\"hello5\",\"hello6\",\n  \"world1\",\"world2\",\"world3\",\"world4\"\n))\nrdd.sample(false, 0.3).foreach(println)\n\n//sortByKey：按key进行排序\nval rdd = sc.makeRDD(Array(\n  (5,\"Tom\"),(10,\"Jed\"),(3,\"Tony\"),(2,\"Jack\")\n))\nrdd.sortByKey().foreach(println)\n\n//sortBy：自定义排序规则\nobject SortByOperator {\n  def main(args: Array[String]): Unit = {\n   val conf = new SparkConf().setAppName(\"TestSortBy\").setMaster(\"local\")\n    val sc = new SparkContext(conf)\n    val arr = Array(\n        Tuple3(190,100,\"Jed\"),\n        Tuple3(100,202,\"Tom\"),\n        Tuple3(90,111,\"Tony\")\n    )\n    val rdd = sc.parallelize(arr)\n    rdd.sortBy(_._1).foreach(println)   //按照190、100、90排序\n```\n\n## groupByKey和reduceByKey\n\n![img](RDD-Spark/15050363083877.jpg)\n\n## distinct：去掉重复数据\n\n![img](RDD-Spark/15050364198942.jpg)\n\n```scala\nval rdd = sc.makeRDD(Array(\n      \"hello\",\n      \"hello\",\n      \"hello\",\n      \"world\"\n))\nval distinctRDD = rdd\n      .map {(_,1)}\n      .reduceByKey(_+_)\n      .map(_._1)\ndistinctRDD.foreach {println}    //等价于：rdd.distinct().foreach {println}\n```\n\n## map和mapPartitions\n\n```scala\nval arr = Array(\"Tom\",\"Bob\",\"Tony\",\"Jerry\")\n//把4条数据分到两个分区中\nval rdd = sc.parallelize(arr,2)\n   \n/*\n * 模拟把RDD中的元素写入数据库的过程\n */\nrdd.map(x => {\n  println(\"创建数据库连接...\")\n  println(\"写入数据库...\")\n  println(\"关闭数据库连接...\")\n  println()\n}).count()\n结果：\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n创建数据库连接...\n写入数据库...\n关闭数据库连接...\n```\n\n```scala\n/*\n * 将RDD中的数据写入到数据库中，绝大部分使用mapPartitions算子来实现\n */\nrdd.mapPartitions(x => {\n  println(\"创建数据库\")\n  val list = new ListBuffer[String]()\n  while(x.hasNext){\n    //写入数据库\n    list += x.next()+\":写入数据库\"\n  }\n  //执行SQL语句  批量插入\n  list.iterator\n})foreach(println)\n结果：\n创建数据库\nTom:写入数据库\nBob:写入数据库 \n创建数据库\nTony:写入数据库\nJerry:写入数据库\n```\n\n## mapPartitionsWithIndex\n\n```scala\nval dataArr = Array(\"Tom01\",\"Tom02\",\"Tom03\"\n                  ,\"Tom04\",\"Tom05\",\"Tom06\"\n                  ,\"Tom07\",\"Tom08\",\"Tom09\"\n                  ,\"Tom10\",\"Tom11\",\"Tom12\")\nval rdd = sc.parallelize(dataArr, 3);\nval result = rdd.mapPartitionsWithIndex((index,x) => {\n    val list = ListBuffer[String]()\n    while (x.hasNext) {\n      list += \"partition:\"+ index + \" content:\" + x.next\n    }\n    list.iterator\n})\nprintln(\"分区数量:\" + result.partitions.size)\nval resultArr = result.collect()\nfor(x <- resultArr){\n  println(x)\n}\n```\n\n## coalesce：改变RDD的分区数\n\n```scala\n/*\n * false:不产生shuffle\n * true:产生shuffle\n * 如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变\n * 增加分区会把原来的分区中的数据随机分配给设置的分区个数\n */\nval coalesceRdd = result.coalesce(6,true)\n   \nval results = coalesceRdd.mapPartitionsWithIndex((index,x) => {\n  val list = ListBuffer[String]()\n  while (x.hasNext) {\n      list += \"partition:\"+ index + \" content:[\" + x.next + \"]\"\n  }\n  list.iterator\n})\n   \nprintln(\"分区数量:\" + results.partitions.size)\nval resultArr = results.collect()\nfor(x <- resultArr){\n  println(x)\n}\n\n```\n\n![img](http://chant00.com/media/15050414638959.jpg)\n\n## randomSplit：拆分RDD\n\n```scala\n/**\n * randomSplit:\n *   根据传入的 Array中每个元素的权重将rdd拆分成Array.size个RDD\n *  拆分后的RDD中元素数量由权重来决定，数据量不大时不一定准确\n */\nval rdd = sc.parallelize(1 to 10)\nrdd.randomSplit(Array(0.1,0.2,0.3,0.4)).foreach(x => {println(x.count)})\n```\n\n## zip\n\n![img](RDD-Spark/15051361379636.jpg)\n\n","slug":"sparkL/RDD-Spark.md","published":1,"updated":"2019-08-13T07:02:03.023Z","_id":"cjzdr6iyt0028homjd9kwomm6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>通过函数<code>func</code>聚集数据集中的所有元素。<code>func</code>函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行</td>\n</tr>\n<tr>\n<td><code>collect()</code></td>\n<td>在<code>Driver</code>的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用<code>filter</code>或者其它操作后，返回一个足够小的数据子集再使用，直接将整个<code>RDD</code>集Collect返回，很可能会让<code>Driver</code>程序OOM</td>\n</tr>\n<tr>\n<td><code>count()</code></td>\n<td>统计<code>RDD</code>中元素的个数</td>\n</tr>\n<tr>\n<td><code>take(n)</code></td>\n<td>取<code>RDD</code>中的前<code>n</code>个元素。注意，这个操作目前并非在多个节点上，并行执行，而是<code>Driver</code>程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用）</td>\n</tr>\n<tr>\n<td><code>first()</code></td>\n<td>返回数据集的第一个元素（类似于<code>take(1)</code>  ）</td>\n</tr>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>按照指定规则聚合<code>RDD</code>中的元素</td>\n</tr>\n<tr>\n<td><code>countByValue()</code></td>\n<td>统计出<code>RDD</code>中每个元素的个数</td>\n</tr>\n<tr>\n<td><code>countByKey()</code></td>\n<td>统计出<code>KV</code>格式的<code>RDD</code>中相同的K的个数</td>\n</tr>\n<tr>\n<td><code>foreach(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>foreachPartition(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>saveAsTextFile(path)</code></td>\n<td>将数据集的元素，以t<code>extfile</code>的形式，保存到本地文件系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。Spark将会调用每个元素的<code>toString</code>方法，并将它转换为文件中的一行文本</td>\n</tr>\n<tr>\n<td><code>saveAsSequenceFile(path)</code></td>\n<td>将数据集的元素，以<code>sequencefile</code>的格式，保存到指定的目录下，本地系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。<code>RDD</code>的元素必须由<code>key-value</code>对组成，并都实现了<code>Hadoop</code>的<code>Writable</code>接口，或隐式可以转换为<code>Writable</code>（Spark包括了基本类型的转换，例如<code>Int</code>，<code>Double</code>，<code>String</code>等等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//collect 把运行结果拉回到Driver端</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultRDD = rdd.sortByKey()</span><br><span class=\"line\"><span class=\"keyword\">val</span> list = resultRDD.collect()</span><br><span class=\"line\">list.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultRDD = rdd.sortByKey()</span><br><span class=\"line\"><span class=\"keyword\">val</span> list = resultRDD.collect()</span><br><span class=\"line\">list.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//take(n)：取RDD中的前n个元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.take(<span class=\"number\">2</span>).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//first 相当于take(1)</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">println(rdd.first)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// count 统计RDD中元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> num = rdd.count()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reduce 按照指定规则聚合RDD中的元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> numArr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(numArr)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sum = rdd.reduce(_+_)</span><br><span class=\"line\">println(sum)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//countByValue 统计出RDD中每个元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Jed\"</span>,<span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Jed\"</span>,<span class=\"string\">\"Jed\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Tony\"</span>,<span class=\"string\">\"Jed\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.countByValue();</span><br><span class=\"line\">result.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// countByKey 统计出KV格式的RDD中相同的K的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Tom\"</span>), (<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Jack\"</span>),(<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Bob\"</span>),(<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Terry\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Jack\"</span>),(<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Selina\"</span>),(<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Hebe\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"人力部\"</span>,<span class=\"string\">\"Ella\"</span>),(<span class=\"string\">\"人力部\"</span>,<span class=\"string\">\"Harry\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"开发部\"</span>,<span class=\"string\">\"Allen\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.countByKey();</span><br><span class=\"line\">result.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foreach 遍历RDD中的元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//foreachPartition 以分区为单位遍历RDD</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"number\">1</span> to <span class=\"number\">6</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">rdd.foreachPartition(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"data from a partition:\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x.hasNext) &#123;</span><br><span class=\"line\">    println(x.next())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>filter(func)</code></td>\n<td>返回一个新的数据集，由经过<code>func</code>函数后返回值为<code>true</code>的原元素组成</td>\n</tr>\n<tr>\n<td><code>map(func)</code></td>\n<td>返回一个新的分布式数据集，由每个原元素经过<code>func</code>函数转换后组成</td>\n</tr>\n<tr>\n<td><code>flatMap(func)</code></td>\n<td>类似于<code>map</code>，但是每一个输入元素，会被映射为0到多个输出元素（因此，<code>func</code>函数的返回值是一个<code>Seq</code>，而不是单一元素）</td>\n</tr>\n<tr>\n<td><code>sample(withReplacement, frac, seed)</code></td>\n<td>随机抽样<br><code>withReplacement</code>：是否是放回式抽样<br><code>frac</code>:：抽样的比例<br><code>seed</code>：随机种子</td>\n</tr>\n<tr>\n<td><code>reduceByKey(func, [numTasks])</code></td>\n<td>在一个<code>(K,V)</code>对的数据集上使用，返回一个<code>(K,V)</code>对的数据集，<code>key</code>相同的值，都被使用指定的<code>reduce</code>函数聚合到一起。和<code>groupbykey</code>类似，任务的个数是可以通过第二个可选参数来配置的。</td>\n</tr>\n<tr>\n<td><code>groupByKey([numTasks])</code></td>\n<td>在一个由<code>（K,V）</code>对组成的数据集上调用，返回一个<code>(K，Seq[V])</code>对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入<code>numTask</code>可选参数，根据数据量设置不同数目的<code>Task</code></td>\n</tr>\n<tr>\n<td><code>sortByKey(func, [numTasks])</code></td>\n<td>按<code>key</code>值进行排序</td>\n</tr>\n<tr>\n<td><code>union(otherDataset)</code></td>\n<td>返回一个新的数据集，由原数据集和参数联合而成</td>\n</tr>\n<tr>\n<td><code>join(otherDataset, [numTasks])</code></td>\n<td>在类型为<code>(K,V)</code>和<code>(K,W)</code>类型的数据集上调用，返回一个<code>(K,(V,W))</code>对，每个key中的所有元素都在一起的数据集</td>\n</tr>\n<tr>\n<td><code>cartesian(otherDataset)</code></td>\n<td>笛卡尔积。但在数据集T和U上调用时，返回一个(T，U) 对的数据集，所有元素交互进行笛卡尔积。</td>\n</tr>\n<tr>\n<td><code>map(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>mapPartitions(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>mapPartitionsWithIndex</code></td>\n<td>与<code>mapPartitions</code>基本相同，只是在处理函数的参数是一个二元元组，元组的第一个元素是当前处理的分区的<code>index</code>，元组的第二个元素是当前处理的分区元素组成的<code>Iterator</code></td>\n</tr>\n<tr>\n<td><code>coalesce(n,shuffle)</code></td>\n<td>改变RDD的分区数<br>n：新的分区数目<br>shuffle：false:不产生shuffle；true:产生shuffle，如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变</td>\n</tr>\n<tr>\n<td><code>repartition(n)</code></td>\n<td>改变RDD分区数。<code>repartition(int n) = coalesce(int n, true)</code></td>\n</tr>\n<tr>\n<td><code>partitionBy</code></td>\n<td>通过自定义分区器改变RDD分区数</td>\n</tr>\n<tr>\n<td><code>randomSplit(Array)</code></td>\n<td>根据传入的 <code>Array</code>中每个元素的权重将<code>rdd</code>拆分成<code>Array.size</code>个<code>RDD</code>拆分后的<code>RDD</code>中元素数量由权重来决定，</td>\n</tr>\n<tr>\n<td><code>groupWith(otherDataset, [numTasks])</code></td>\n<td>在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"map和flatMap\"><a href=\"#map和flatMap\" class=\"headerlink\" title=\"map和flatMap\"></a>map和flatMap</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050362138086.jpg\" alt=\"img\"></p>\n<h2 id=\"filter、sample、sortByKey、sortBy\"><a href=\"#filter、sample、sortByKey、sortBy\" class=\"headerlink\" title=\"filter、sample、sortByKey、sortBy\"></a>filter、sample、sortByKey、sortBy</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//filter：过滤</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.filter(!_.contains(<span class=\"string\">\"hello\"</span>)).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/********** map和flatMap**************</span></span><br><span class=\"line\"><span class=\"comment\">*map: 输入一条记录，输出一条记录</span></span><br><span class=\"line\"><span class=\"comment\">*flatmap：输入一条记录，输出多头记录</span></span><br><span class=\"line\"><span class=\"comment\">*************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sample ：随机抽样</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  <span class=\"string\">\"hello1\"</span>,<span class=\"string\">\"hello2\"</span>,<span class=\"string\">\"hello3\"</span>,<span class=\"string\">\"hello4\"</span>,<span class=\"string\">\"hello5\"</span>,<span class=\"string\">\"hello6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"world1\"</span>,<span class=\"string\">\"world2\"</span>,<span class=\"string\">\"world3\"</span>,<span class=\"string\">\"world4\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\">rdd.sample(<span class=\"literal\">false</span>, <span class=\"number\">0.3</span>).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sortByKey：按key进行排序</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\">rdd.sortByKey().foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sortBy：自定义排序规则</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SortByOperator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setAppName(<span class=\"string\">\"TestSortBy\"</span>).setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">190</span>,<span class=\"number\">100</span>,<span class=\"string\">\"Jed\"</span>),</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">100</span>,<span class=\"number\">202</span>,<span class=\"string\">\"Tom\"</span>),</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">90</span>,<span class=\"number\">111</span>,<span class=\"string\">\"Tony\"</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.parallelize(arr)</span><br><span class=\"line\">    rdd.sortBy(_._1).foreach(println)   <span class=\"comment\">//按照190、100、90排序</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"groupByKey和reduceByKey\"><a href=\"#groupByKey和reduceByKey\" class=\"headerlink\" title=\"groupByKey和reduceByKey\"></a>groupByKey和reduceByKey</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050363083877.jpg\" alt=\"img\"></p>\n<h2 id=\"distinct：去掉重复数据\"><a href=\"#distinct：去掉重复数据\" class=\"headerlink\" title=\"distinct：去掉重复数据\"></a>distinct：去掉重复数据</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050364198942.jpg\" alt=\"img\"></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"world\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> distinctRDD = rdd</span><br><span class=\"line\">      .map &#123;(_,<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">      .reduceByKey(_+_)</span><br><span class=\"line\">      .map(_._1)</span><br><span class=\"line\">distinctRDD.foreach &#123;println&#125;    <span class=\"comment\">//等价于：rdd.distinct().foreach &#123;println&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"map和mapPartitions\"><a href=\"#map和mapPartitions\" class=\"headerlink\" title=\"map和mapPartitions\"></a>map和mapPartitions</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Bob\"</span>,<span class=\"string\">\"Tony\"</span>,<span class=\"string\">\"Jerry\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//把4条数据分到两个分区中</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(arr,<span class=\"number\">2</span>)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 模拟把RDD中的元素写入数据库的过程</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">rdd.map(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"创建数据库连接...\"</span>)</span><br><span class=\"line\">  println(<span class=\"string\">\"写入数据库...\"</span>)</span><br><span class=\"line\">  println(<span class=\"string\">\"关闭数据库连接...\"</span>)</span><br><span class=\"line\">  println()</span><br><span class=\"line\">&#125;).count()</span><br><span class=\"line\">结果：</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 将RDD中的数据写入到数据库中，绝大部分使用mapPartitions算子来实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">rdd.mapPartitions(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"创建数据库\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> list = <span class=\"keyword\">new</span> <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x.hasNext)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//写入数据库</span></span><br><span class=\"line\">    list += x.next()+<span class=\"string\">\":写入数据库\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//执行SQL语句  批量插入</span></span><br><span class=\"line\">  list.iterator</span><br><span class=\"line\">&#125;)foreach(println)</span><br><span class=\"line\">结果：</span><br><span class=\"line\">创建数据库</span><br><span class=\"line\"><span class=\"type\">Tom</span>:写入数据库</span><br><span class=\"line\"><span class=\"type\">Bob</span>:写入数据库 </span><br><span class=\"line\">创建数据库</span><br><span class=\"line\"><span class=\"type\">Tony</span>:写入数据库</span><br><span class=\"line\"><span class=\"type\">Jerry</span>:写入数据库</span><br></pre></td></tr></table></figure>\n<h2 id=\"mapPartitionsWithIndex\"><a href=\"#mapPartitionsWithIndex\" class=\"headerlink\" title=\"mapPartitionsWithIndex\"></a>mapPartitionsWithIndex</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataArr = <span class=\"type\">Array</span>(<span class=\"string\">\"Tom01\"</span>,<span class=\"string\">\"Tom02\"</span>,<span class=\"string\">\"Tom03\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom04\"</span>,<span class=\"string\">\"Tom05\"</span>,<span class=\"string\">\"Tom06\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom07\"</span>,<span class=\"string\">\"Tom08\"</span>,<span class=\"string\">\"Tom09\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom10\"</span>,<span class=\"string\">\"Tom11\"</span>,<span class=\"string\">\"Tom12\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(dataArr, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.mapPartitionsWithIndex((index,x) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> list = <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x.hasNext) &#123;</span><br><span class=\"line\">      list += <span class=\"string\">\"partition:\"</span>+ index + <span class=\"string\">\" content:\"</span> + x.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.iterator</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">println(<span class=\"string\">\"分区数量:\"</span> + result.partitions.size)</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultArr = result.collect()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(x &lt;- resultArr)&#123;</span><br><span class=\"line\">  println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"coalesce：改变RDD的分区数\"><a href=\"#coalesce：改变RDD的分区数\" class=\"headerlink\" title=\"coalesce：改变RDD的分区数\"></a>coalesce：改变RDD的分区数</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * false:不产生shuffle</span></span><br><span class=\"line\"><span class=\"comment\"> * true:产生shuffle</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变</span></span><br><span class=\"line\"><span class=\"comment\"> * 增加分区会把原来的分区中的数据随机分配给设置的分区个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> coalesceRdd = result.coalesce(<span class=\"number\">6</span>,<span class=\"literal\">true</span>)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">val</span> results = coalesceRdd.mapPartitionsWithIndex((index,x) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> list = <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x.hasNext) &#123;</span><br><span class=\"line\">      list += <span class=\"string\">\"partition:\"</span>+ index + <span class=\"string\">\" content:[\"</span> + x.next + <span class=\"string\">\"]\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list.iterator</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">   </span><br><span class=\"line\">println(<span class=\"string\">\"分区数量:\"</span> + results.partitions.size)</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultArr = results.collect()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(x &lt;- resultArr)&#123;</span><br><span class=\"line\">  println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://chant00.com/media/15050414638959.jpg\" alt=\"img\"></p>\n<h2 id=\"randomSplit：拆分RDD\"><a href=\"#randomSplit：拆分RDD\" class=\"headerlink\" title=\"randomSplit：拆分RDD\"></a>randomSplit：拆分RDD</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * randomSplit:</span></span><br><span class=\"line\"><span class=\"comment\"> *   根据传入的 Array中每个元素的权重将rdd拆分成Array.size个RDD</span></span><br><span class=\"line\"><span class=\"comment\"> *  拆分后的RDD中元素数量由权重来决定，数据量不大时不一定准确</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"number\">1</span> to <span class=\"number\">10</span>)</span><br><span class=\"line\">rdd.randomSplit(<span class=\"type\">Array</span>(<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>)).foreach(x =&gt; &#123;println(x.count)&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15051361379636.jpg\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>通过函数<code>func</code>聚集数据集中的所有元素。<code>func</code>函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行</td>\n</tr>\n<tr>\n<td><code>collect()</code></td>\n<td>在<code>Driver</code>的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用<code>filter</code>或者其它操作后，返回一个足够小的数据子集再使用，直接将整个<code>RDD</code>集Collect返回，很可能会让<code>Driver</code>程序OOM</td>\n</tr>\n<tr>\n<td><code>count()</code></td>\n<td>统计<code>RDD</code>中元素的个数</td>\n</tr>\n<tr>\n<td><code>take(n)</code></td>\n<td>取<code>RDD</code>中的前<code>n</code>个元素。注意，这个操作目前并非在多个节点上，并行执行，而是<code>Driver</code>程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用）</td>\n</tr>\n<tr>\n<td><code>first()</code></td>\n<td>返回数据集的第一个元素（类似于<code>take(1)</code>  ）</td>\n</tr>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>按照指定规则聚合<code>RDD</code>中的元素</td>\n</tr>\n<tr>\n<td><code>countByValue()</code></td>\n<td>统计出<code>RDD</code>中每个元素的个数</td>\n</tr>\n<tr>\n<td><code>countByKey()</code></td>\n<td>统计出<code>KV</code>格式的<code>RDD</code>中相同的K的个数</td>\n</tr>\n<tr>\n<td><code>foreach(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>foreachPartition(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>saveAsTextFile(path)</code></td>\n<td>将数据集的元素，以t<code>extfile</code>的形式，保存到本地文件系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。Spark将会调用每个元素的<code>toString</code>方法，并将它转换为文件中的一行文本</td>\n</tr>\n<tr>\n<td><code>saveAsSequenceFile(path)</code></td>\n<td>将数据集的元素，以<code>sequencefile</code>的格式，保存到指定的目录下，本地系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。<code>RDD</code>的元素必须由<code>key-value</code>对组成，并都实现了<code>Hadoop</code>的<code>Writable</code>接口，或隐式可以转换为<code>Writable</code>（Spark包括了基本类型的转换，例如<code>Int</code>，<code>Double</code>，<code>String</code>等等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//collect 把运行结果拉回到Driver端</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultRDD = rdd.sortByKey()</span><br><span class=\"line\"><span class=\"keyword\">val</span> list = resultRDD.collect()</span><br><span class=\"line\">list.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultRDD = rdd.sortByKey()</span><br><span class=\"line\"><span class=\"keyword\">val</span> list = resultRDD.collect()</span><br><span class=\"line\">list.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//take(n)：取RDD中的前n个元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.take(<span class=\"number\">2</span>).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//first 相当于take(1)</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">println(rdd.first)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// count 统计RDD中元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">val</span> num = rdd.count()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reduce 按照指定规则聚合RDD中的元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> numArr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(numArr)</span><br><span class=\"line\"><span class=\"keyword\">val</span> sum = rdd.reduce(_+_)</span><br><span class=\"line\">println(sum)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//countByValue 统计出RDD中每个元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Jed\"</span>,<span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Jed\"</span>,<span class=\"string\">\"Jed\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Tony\"</span>,<span class=\"string\">\"Jed\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.countByValue();</span><br><span class=\"line\">result.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// countByKey 统计出KV格式的RDD中相同的K的个数</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Tom\"</span>), (<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Jack\"</span>),(<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Bob\"</span>),(<span class=\"string\">\"销售部\"</span>,<span class=\"string\">\"Terry\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Jack\"</span>),(<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Selina\"</span>),(<span class=\"string\">\"后勤部\"</span>,<span class=\"string\">\"Hebe\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"人力部\"</span>,<span class=\"string\">\"Ella\"</span>),(<span class=\"string\">\"人力部\"</span>,<span class=\"string\">\"Harry\"</span>),</span><br><span class=\"line\">  (<span class=\"string\">\"开发部\"</span>,<span class=\"string\">\"Allen\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.countByKey();</span><br><span class=\"line\">result.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// foreach 遍历RDD中的元素</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//foreachPartition 以分区为单位遍历RDD</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"number\">1</span> to <span class=\"number\">6</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">rdd.foreachPartition(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"data from a partition:\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x.hasNext) &#123;</span><br><span class=\"line\">    println(x.next())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h1 id=\"Transformations\"><a href=\"#Transformations\" class=\"headerlink\" title=\"Transformations\"></a>Transformations</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>filter(func)</code></td>\n<td>返回一个新的数据集，由经过<code>func</code>函数后返回值为<code>true</code>的原元素组成</td>\n</tr>\n<tr>\n<td><code>map(func)</code></td>\n<td>返回一个新的分布式数据集，由每个原元素经过<code>func</code>函数转换后组成</td>\n</tr>\n<tr>\n<td><code>flatMap(func)</code></td>\n<td>类似于<code>map</code>，但是每一个输入元素，会被映射为0到多个输出元素（因此，<code>func</code>函数的返回值是一个<code>Seq</code>，而不是单一元素）</td>\n</tr>\n<tr>\n<td><code>sample(withReplacement, frac, seed)</code></td>\n<td>随机抽样<br><code>withReplacement</code>：是否是放回式抽样<br><code>frac</code>:：抽样的比例<br><code>seed</code>：随机种子</td>\n</tr>\n<tr>\n<td><code>reduceByKey(func, [numTasks])</code></td>\n<td>在一个<code>(K,V)</code>对的数据集上使用，返回一个<code>(K,V)</code>对的数据集，<code>key</code>相同的值，都被使用指定的<code>reduce</code>函数聚合到一起。和<code>groupbykey</code>类似，任务的个数是可以通过第二个可选参数来配置的。</td>\n</tr>\n<tr>\n<td><code>groupByKey([numTasks])</code></td>\n<td>在一个由<code>（K,V）</code>对组成的数据集上调用，返回一个<code>(K，Seq[V])</code>对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入<code>numTask</code>可选参数，根据数据量设置不同数目的<code>Task</code></td>\n</tr>\n<tr>\n<td><code>sortByKey(func, [numTasks])</code></td>\n<td>按<code>key</code>值进行排序</td>\n</tr>\n<tr>\n<td><code>union(otherDataset)</code></td>\n<td>返回一个新的数据集，由原数据集和参数联合而成</td>\n</tr>\n<tr>\n<td><code>join(otherDataset, [numTasks])</code></td>\n<td>在类型为<code>(K,V)</code>和<code>(K,W)</code>类型的数据集上调用，返回一个<code>(K,(V,W))</code>对，每个key中的所有元素都在一起的数据集</td>\n</tr>\n<tr>\n<td><code>cartesian(otherDataset)</code></td>\n<td>笛卡尔积。但在数据集T和U上调用时，返回一个(T，U) 对的数据集，所有元素交互进行笛卡尔积。</td>\n</tr>\n<tr>\n<td><code>map(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>mapPartitions(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>mapPartitionsWithIndex</code></td>\n<td>与<code>mapPartitions</code>基本相同，只是在处理函数的参数是一个二元元组，元组的第一个元素是当前处理的分区的<code>index</code>，元组的第二个元素是当前处理的分区元素组成的<code>Iterator</code></td>\n</tr>\n<tr>\n<td><code>coalesce(n,shuffle)</code></td>\n<td>改变RDD的分区数<br>n：新的分区数目<br>shuffle：false:不产生shuffle；true:产生shuffle，如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变</td>\n</tr>\n<tr>\n<td><code>repartition(n)</code></td>\n<td>改变RDD分区数。<code>repartition(int n) = coalesce(int n, true)</code></td>\n</tr>\n<tr>\n<td><code>partitionBy</code></td>\n<td>通过自定义分区器改变RDD分区数</td>\n</tr>\n<tr>\n<td><code>randomSplit(Array)</code></td>\n<td>根据传入的 <code>Array</code>中每个元素的权重将<code>rdd</code>拆分成<code>Array.size</code>个<code>RDD</code>拆分后的<code>RDD</code>中元素数量由权重来决定，</td>\n</tr>\n<tr>\n<td><code>groupWith(otherDataset, [numTasks])</code></td>\n<td>在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"map和flatMap\"><a href=\"#map和flatMap\" class=\"headerlink\" title=\"map和flatMap\"></a>map和flatMap</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050362138086.jpg\" alt=\"img\"></p>\n<h2 id=\"filter、sample、sortByKey、sortBy\"><a href=\"#filter、sample、sortByKey、sortBy\" class=\"headerlink\" title=\"filter、sample、sortByKey、sortBy\"></a>filter、sample、sortByKey、sortBy</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//filter：过滤</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">rdd.filter(!_.contains(<span class=\"string\">\"hello\"</span>)).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/********** map和flatMap**************</span></span><br><span class=\"line\"><span class=\"comment\">*map: 输入一条记录，输出一条记录</span></span><br><span class=\"line\"><span class=\"comment\">*flatmap：输入一条记录，输出多头记录</span></span><br><span class=\"line\"><span class=\"comment\">*************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sample ：随机抽样</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  <span class=\"string\">\"hello1\"</span>,<span class=\"string\">\"hello2\"</span>,<span class=\"string\">\"hello3\"</span>,<span class=\"string\">\"hello4\"</span>,<span class=\"string\">\"hello5\"</span>,<span class=\"string\">\"hello6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"world1\"</span>,<span class=\"string\">\"world2\"</span>,<span class=\"string\">\"world3\"</span>,<span class=\"string\">\"world4\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\">rdd.sample(<span class=\"literal\">false</span>, <span class=\"number\">0.3</span>).foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sortByKey：按key进行排序</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">  (<span class=\"number\">5</span>,<span class=\"string\">\"Tom\"</span>),(<span class=\"number\">10</span>,<span class=\"string\">\"Jed\"</span>),(<span class=\"number\">3</span>,<span class=\"string\">\"Tony\"</span>),(<span class=\"number\">2</span>,<span class=\"string\">\"Jack\"</span>)</span><br><span class=\"line\">))</span><br><span class=\"line\">rdd.sortByKey().foreach(println)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sortBy：自定义排序规则</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">SortByOperator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]): <span class=\"type\">Unit</span> = &#123;</span><br><span class=\"line\">   <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setAppName(<span class=\"string\">\"TestSortBy\"</span>).setMaster(<span class=\"string\">\"local\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> sc = <span class=\"keyword\">new</span> <span class=\"type\">SparkContext</span>(conf)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">190</span>,<span class=\"number\">100</span>,<span class=\"string\">\"Jed\"</span>),</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">100</span>,<span class=\"number\">202</span>,<span class=\"string\">\"Tom\"</span>),</span><br><span class=\"line\">        <span class=\"type\">Tuple3</span>(<span class=\"number\">90</span>,<span class=\"number\">111</span>,<span class=\"string\">\"Tony\"</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">val</span> rdd = sc.parallelize(arr)</span><br><span class=\"line\">    rdd.sortBy(_._1).foreach(println)   <span class=\"comment\">//按照190、100、90排序</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"groupByKey和reduceByKey\"><a href=\"#groupByKey和reduceByKey\" class=\"headerlink\" title=\"groupByKey和reduceByKey\"></a>groupByKey和reduceByKey</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050363083877.jpg\" alt=\"img\"></p>\n<h2 id=\"distinct：去掉重复数据\"><a href=\"#distinct：去掉重复数据\" class=\"headerlink\" title=\"distinct：去掉重复数据\"></a>distinct：去掉重复数据</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15050364198942.jpg\" alt=\"img\"></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.makeRDD(<span class=\"type\">Array</span>(</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"world\"</span></span><br><span class=\"line\">))</span><br><span class=\"line\"><span class=\"keyword\">val</span> distinctRDD = rdd</span><br><span class=\"line\">      .map &#123;(_,<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">      .reduceByKey(_+_)</span><br><span class=\"line\">      .map(_._1)</span><br><span class=\"line\">distinctRDD.foreach &#123;println&#125;    <span class=\"comment\">//等价于：rdd.distinct().foreach &#123;println&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"map和mapPartitions\"><a href=\"#map和mapPartitions\" class=\"headerlink\" title=\"map和mapPartitions\"></a>map和mapPartitions</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"string\">\"Tom\"</span>,<span class=\"string\">\"Bob\"</span>,<span class=\"string\">\"Tony\"</span>,<span class=\"string\">\"Jerry\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//把4条数据分到两个分区中</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(arr,<span class=\"number\">2</span>)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 模拟把RDD中的元素写入数据库的过程</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">rdd.map(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"创建数据库连接...\"</span>)</span><br><span class=\"line\">  println(<span class=\"string\">\"写入数据库...\"</span>)</span><br><span class=\"line\">  println(<span class=\"string\">\"关闭数据库连接...\"</span>)</span><br><span class=\"line\">  println()</span><br><span class=\"line\">&#125;).count()</span><br><span class=\"line\">结果：</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br><span class=\"line\">创建数据库连接...</span><br><span class=\"line\">写入数据库...</span><br><span class=\"line\">关闭数据库连接...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 将RDD中的数据写入到数据库中，绝大部分使用mapPartitions算子来实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">rdd.mapPartitions(x =&gt; &#123;</span><br><span class=\"line\">  println(<span class=\"string\">\"创建数据库\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> list = <span class=\"keyword\">new</span> <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(x.hasNext)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//写入数据库</span></span><br><span class=\"line\">    list += x.next()+<span class=\"string\">\":写入数据库\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//执行SQL语句  批量插入</span></span><br><span class=\"line\">  list.iterator</span><br><span class=\"line\">&#125;)foreach(println)</span><br><span class=\"line\">结果：</span><br><span class=\"line\">创建数据库</span><br><span class=\"line\"><span class=\"type\">Tom</span>:写入数据库</span><br><span class=\"line\"><span class=\"type\">Bob</span>:写入数据库 </span><br><span class=\"line\">创建数据库</span><br><span class=\"line\"><span class=\"type\">Tony</span>:写入数据库</span><br><span class=\"line\"><span class=\"type\">Jerry</span>:写入数据库</span><br></pre></td></tr></table></figure>\n<h2 id=\"mapPartitionsWithIndex\"><a href=\"#mapPartitionsWithIndex\" class=\"headerlink\" title=\"mapPartitionsWithIndex\"></a>mapPartitionsWithIndex</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> dataArr = <span class=\"type\">Array</span>(<span class=\"string\">\"Tom01\"</span>,<span class=\"string\">\"Tom02\"</span>,<span class=\"string\">\"Tom03\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom04\"</span>,<span class=\"string\">\"Tom05\"</span>,<span class=\"string\">\"Tom06\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom07\"</span>,<span class=\"string\">\"Tom08\"</span>,<span class=\"string\">\"Tom09\"</span></span><br><span class=\"line\">                  ,<span class=\"string\">\"Tom10\"</span>,<span class=\"string\">\"Tom11\"</span>,<span class=\"string\">\"Tom12\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(dataArr, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">val</span> result = rdd.mapPartitionsWithIndex((index,x) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> list = <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x.hasNext) &#123;</span><br><span class=\"line\">      list += <span class=\"string\">\"partition:\"</span>+ index + <span class=\"string\">\" content:\"</span> + x.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.iterator</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">println(<span class=\"string\">\"分区数量:\"</span> + result.partitions.size)</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultArr = result.collect()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(x &lt;- resultArr)&#123;</span><br><span class=\"line\">  println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"coalesce：改变RDD的分区数\"><a href=\"#coalesce：改变RDD的分区数\" class=\"headerlink\" title=\"coalesce：改变RDD的分区数\"></a>coalesce：改变RDD的分区数</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * false:不产生shuffle</span></span><br><span class=\"line\"><span class=\"comment\"> * true:产生shuffle</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果重分区的数量大于原来的分区数量,必须设置为true,否则分区数不变</span></span><br><span class=\"line\"><span class=\"comment\"> * 增加分区会把原来的分区中的数据随机分配给设置的分区个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> coalesceRdd = result.coalesce(<span class=\"number\">6</span>,<span class=\"literal\">true</span>)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">val</span> results = coalesceRdd.mapPartitionsWithIndex((index,x) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> list = <span class=\"type\">ListBuffer</span>[<span class=\"type\">String</span>]()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (x.hasNext) &#123;</span><br><span class=\"line\">      list += <span class=\"string\">\"partition:\"</span>+ index + <span class=\"string\">\" content:[\"</span> + x.next + <span class=\"string\">\"]\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  list.iterator</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">   </span><br><span class=\"line\">println(<span class=\"string\">\"分区数量:\"</span> + results.partitions.size)</span><br><span class=\"line\"><span class=\"keyword\">val</span> resultArr = results.collect()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(x &lt;- resultArr)&#123;</span><br><span class=\"line\">  println(x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://chant00.com/media/15050414638959.jpg\" alt=\"img\"></p>\n<h2 id=\"randomSplit：拆分RDD\"><a href=\"#randomSplit：拆分RDD\" class=\"headerlink\" title=\"randomSplit：拆分RDD\"></a>randomSplit：拆分RDD</h2><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * randomSplit:</span></span><br><span class=\"line\"><span class=\"comment\"> *   根据传入的 Array中每个元素的权重将rdd拆分成Array.size个RDD</span></span><br><span class=\"line\"><span class=\"comment\"> *  拆分后的RDD中元素数量由权重来决定，数据量不大时不一定准确</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">val</span> rdd = sc.parallelize(<span class=\"number\">1</span> to <span class=\"number\">10</span>)</span><br><span class=\"line\">rdd.randomSplit(<span class=\"type\">Array</span>(<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>)).foreach(x =&gt; &#123;println(x.count)&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip\"></a>zip</h2><p><img src=\"/2019/08/12/sparkL/RDD-Spark.md/15051361379636.jpg\" alt=\"img\"></p>\n"},{"title":"SQL","date":"2019-07-31T11:24:57.000Z","_content":"\n# 名词解释\n\n| 名称             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 候选码（超级码） | 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。 |\n| 主码             | 当有多个候选码时，可以选定一个作为主码。                     |\n| 主属性           | 包含在任何一个候选码中的属性被称为主属性。                   |\n| 全码             | All-key关系模型的所有属性组组成该关系模式的候选码，称为全码。即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。 |\n| 外码             | 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称为这个属性组为R的外码或外键。s |\n| 实体完整性       | 关系主码中的属性值不能为空值。                               |\n\n<!--more-->\n\n# [关系运算](.\\关系运算-SQL.md) \n\n<table>\n  <tr>\n    <th colspan=\"2\">运算符</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">集合</td>\n    <td>∪</td>\n    <td>并-Union</td>\n    <td rowspan=\"3\">关系R和关系S具有相同的属性，且相应的属性来自同一个值域<br>`Select * from R Union Select * from S;`<br>`Select * from R Except Select * from S;`<br>`Select * from R Intersect Select * from S;`<br></td>\n  </tr>\n  <tr>\n    <td>-</td>\n    <td>差-Except</td>\n  </tr>\n  <tr>\n    <td>∩</td>\n    <td>交-Except</td>\n  </tr>\n  <tr>\n    <td>×</td>\n    <td>笛卡尔积</td>\n    <td>R: n个属性， k1个元组；S: m个属性， k2个元组<br>R×S：（n+m） 列元组的集合<br>行： k1×k2个元组<br>`Select * from R,S;`<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">关系</td>\n    <td>σ</td>\n    <td>选择</td>\n    <td>从关系R中选取符合条件的元组，<br>`SELECT R.学号，R.课程名, R.分数 from R WHERE 分数&gt;85`</td>\n  </tr>\n  <tr>\n    <td>π </td>\n    <td>投影</td>\n    <td>选取属性，选取的记过会删除重复的元组<br>`SELECT 品名，数量 FROM R;`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">连接</td>\n    <td>θ连接</td>\n    <td>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</td>\n  </tr>\n  <tr>\n    <td>自然连接</td>\n    <td>从两个关系的笛卡尔积中选取相同属性分量相等的元组</td>\n  </tr>\n  <tr>\n    <td>外连接</td>\n    <td>如果把悬浮元组也保存在结果关系中，而在其他属性，上填空值(Null)，就叫做外连接</td>\n  </tr>\n  <tr>\n    <td>÷ </td>\n    <td>除</td>\n    <td>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(x)与S(Y)组成的元组都在R(X,Y)中<br>`SELECT DISTINCT R.X FROM R  R1<br>WHERE NOT EXISTS <br>(\t<br>    SELECT S.Y FROM S <br>    WHERE NOT EXISTS <br>    (<br>        SELECT * FROM R R2 <br>        where R1.X=R2.X and R2.Y=S.Y<br>    )<br>)`</td>\n  </tr>\n</table>\n\n# [数据定义语言-DDL](DDL-SQL.md)\n\n| 命令   | 描述                                   |\n| ------ | -------------------------------------- |\n| CREATE | 创建新的表、视图或者其他数据库中的对象 |\n| ALTER  | 修改现存数据库对象，比如一张表         |\n| DROP   | 删除表、视图或者数据库中的其他对象     |\n\n# [数据操纵语言-DML](./DML-SQL.md)\n\n| 命令   | 描述                             |\n| ------ | -------------------------------- |\n| INSERT | 创建一条新记录                   |\n| UPDATE | 修改记录                         |\n| DELETE | 删除记录                         |\n| SELECT | 从一张或者多张表中检索特定的数据 |\n\n# [数据控制语言-DCL](./DCL-SQL.md)\n\n| 命令   | 描述               |\n| ------ | ------------------ |\n| GRANT  | 赋予用户特权       |\n| REVOKE | 收回赋予用户的特权 |\n\n\n\n","source":"_posts/SQL.md","raw":"---\ntitle: SQL\ndate: 2019-07-31 19:24:57\ntags: [数据库,编程语言]\ncategories: SQL\n---\n\n# 名词解释\n\n| 名称             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 候选码（超级码） | 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。 |\n| 主码             | 当有多个候选码时，可以选定一个作为主码。                     |\n| 主属性           | 包含在任何一个候选码中的属性被称为主属性。                   |\n| 全码             | All-key关系模型的所有属性组组成该关系模式的候选码，称为全码。即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。 |\n| 外码             | 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称为这个属性组为R的外码或外键。s |\n| 实体完整性       | 关系主码中的属性值不能为空值。                               |\n\n<!--more-->\n\n# [关系运算](.\\关系运算-SQL.md) \n\n<table>\n  <tr>\n    <th colspan=\"2\">运算符</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">集合</td>\n    <td>∪</td>\n    <td>并-Union</td>\n    <td rowspan=\"3\">关系R和关系S具有相同的属性，且相应的属性来自同一个值域<br>`Select * from R Union Select * from S;`<br>`Select * from R Except Select * from S;`<br>`Select * from R Intersect Select * from S;`<br></td>\n  </tr>\n  <tr>\n    <td>-</td>\n    <td>差-Except</td>\n  </tr>\n  <tr>\n    <td>∩</td>\n    <td>交-Except</td>\n  </tr>\n  <tr>\n    <td>×</td>\n    <td>笛卡尔积</td>\n    <td>R: n个属性， k1个元组；S: m个属性， k2个元组<br>R×S：（n+m） 列元组的集合<br>行： k1×k2个元组<br>`Select * from R,S;`<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">关系</td>\n    <td>σ</td>\n    <td>选择</td>\n    <td>从关系R中选取符合条件的元组，<br>`SELECT R.学号，R.课程名, R.分数 from R WHERE 分数&gt;85`</td>\n  </tr>\n  <tr>\n    <td>π </td>\n    <td>投影</td>\n    <td>选取属性，选取的记过会删除重复的元组<br>`SELECT 品名，数量 FROM R;`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">连接</td>\n    <td>θ连接</td>\n    <td>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</td>\n  </tr>\n  <tr>\n    <td>自然连接</td>\n    <td>从两个关系的笛卡尔积中选取相同属性分量相等的元组</td>\n  </tr>\n  <tr>\n    <td>外连接</td>\n    <td>如果把悬浮元组也保存在结果关系中，而在其他属性，上填空值(Null)，就叫做外连接</td>\n  </tr>\n  <tr>\n    <td>÷ </td>\n    <td>除</td>\n    <td>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(x)与S(Y)组成的元组都在R(X,Y)中<br>`SELECT DISTINCT R.X FROM R  R1<br>WHERE NOT EXISTS <br>(\t<br>    SELECT S.Y FROM S <br>    WHERE NOT EXISTS <br>    (<br>        SELECT * FROM R R2 <br>        where R1.X=R2.X and R2.Y=S.Y<br>    )<br>)`</td>\n  </tr>\n</table>\n\n# [数据定义语言-DDL](DDL-SQL.md)\n\n| 命令   | 描述                                   |\n| ------ | -------------------------------------- |\n| CREATE | 创建新的表、视图或者其他数据库中的对象 |\n| ALTER  | 修改现存数据库对象，比如一张表         |\n| DROP   | 删除表、视图或者数据库中的其他对象     |\n\n# [数据操纵语言-DML](./DML-SQL.md)\n\n| 命令   | 描述                             |\n| ------ | -------------------------------- |\n| INSERT | 创建一条新记录                   |\n| UPDATE | 修改记录                         |\n| DELETE | 删除记录                         |\n| SELECT | 从一张或者多张表中检索特定的数据 |\n\n# [数据控制语言-DCL](./DCL-SQL.md)\n\n| 命令   | 描述               |\n| ------ | ------------------ |\n| GRANT  | 赋予用户特权       |\n| REVOKE | 收回赋予用户的特权 |\n\n\n\n","slug":"SQL","published":1,"updated":"2019-08-13T10:40:28.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iyv002bhomj7ze2rg38","content":"<h1 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>候选码（超级码）</td>\n<td>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。</td>\n</tr>\n<tr>\n<td>主码</td>\n<td>当有多个候选码时，可以选定一个作为主码。</td>\n</tr>\n<tr>\n<td>主属性</td>\n<td>包含在任何一个候选码中的属性被称为主属性。</td>\n</tr>\n<tr>\n<td>全码</td>\n<td>All-key关系模型的所有属性组组成该关系模式的候选码，称为全码。即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。</td>\n</tr>\n<tr>\n<td>外码</td>\n<td>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称为这个属性组为R的外码或外键。s</td>\n</tr>\n<tr>\n<td>实体完整性</td>\n<td>关系主码中的属性值不能为空值。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"关系运算\"><a href=\"#关系运算\" class=\"headerlink\" title=\"关系运算\"></a><a href=\".\\关系运算-SQL.md\">关系运算</a></h1><table>\n  <tr>\n    <th colspan=\"2\">运算符</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">集合</td>\n    <td>∪</td>\n    <td>并-Union</td>\n    <td rowspan=\"3\">关系R和关系S具有相同的属性，且相应的属性来自同一个值域<br>`Select * from R Union Select * from S;`<br>`Select * from R Except Select * from S;`<br>`Select * from R Intersect Select * from S;`<br></td>\n  </tr>\n  <tr>\n    <td>-</td>\n    <td>差-Except</td>\n  </tr>\n  <tr>\n    <td>∩</td>\n    <td>交-Except</td>\n  </tr>\n  <tr>\n    <td>×</td>\n    <td>笛卡尔积</td>\n    <td>R: n个属性， k1个元组；S: m个属性， k2个元组<br>R×S：（n+m） 列元组的集合<br>行： k1×k2个元组<br>`Select * from R,S;`<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">关系</td>\n    <td>σ</td>\n    <td>选择</td>\n    <td>从关系R中选取符合条件的元组，<br>`SELECT R.学号，R.课程名, R.分数 from R WHERE 分数&gt;85`</td>\n  </tr>\n  <tr>\n    <td>π </td>\n    <td>投影</td>\n    <td>选取属性，选取的记过会删除重复的元组<br>`SELECT 品名，数量 FROM R;`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">连接</td>\n    <td>θ连接</td>\n    <td>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</td>\n  </tr>\n  <tr>\n    <td>自然连接</td>\n    <td>从两个关系的笛卡尔积中选取相同属性分量相等的元组</td>\n  </tr>\n  <tr>\n    <td>外连接</td>\n    <td>如果把悬浮元组也保存在结果关系中，而在其他属性，上填空值(Null)，就叫做外连接</td>\n  </tr>\n  <tr>\n    <td>÷ </td>\n    <td>除</td>\n    <td>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(x)与S(Y)组成的元组都在R(X,Y)中<br>`SELECT DISTINCT R.X FROM R  R1<br>WHERE NOT EXISTS <br>(    <br>    SELECT S.Y FROM S <br>    WHERE NOT EXISTS <br>    (<br>        SELECT * FROM R R2 <br>        where R1.X=R2.X and R2.Y=S.Y<br>    )<br>)`</td>\n  </tr>\n</table>\n\n<h1 id=\"数据定义语言-DDL\"><a href=\"#数据定义语言-DDL\" class=\"headerlink\" title=\"数据定义语言-DDL\"></a><a href=\"DDL-SQL.md\">数据定义语言-DDL</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CREATE</td>\n<td>创建新的表、视图或者其他数据库中的对象</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>修改现存数据库对象，比如一张表</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>删除表、视图或者数据库中的其他对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"数据操纵语言-DML\"><a href=\"#数据操纵语言-DML\" class=\"headerlink\" title=\"数据操纵语言-DML\"></a><a href=\"./DML-SQL.md\">数据操纵语言-DML</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INSERT</td>\n<td>创建一条新记录</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>修改记录</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除记录</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>从一张或者多张表中检索特定的数据</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"数据控制语言-DCL\"><a href=\"#数据控制语言-DCL\" class=\"headerlink\" title=\"数据控制语言-DCL\"></a><a href=\"./DCL-SQL.md\">数据控制语言-DCL</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GRANT</td>\n<td>赋予用户特权</td>\n</tr>\n<tr>\n<td>REVOKE</td>\n<td>收回赋予用户的特权</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<h1 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>候选码（超级码）</td>\n<td>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称为候选码。</td>\n</tr>\n<tr>\n<td>主码</td>\n<td>当有多个候选码时，可以选定一个作为主码。</td>\n</tr>\n<tr>\n<td>主属性</td>\n<td>包含在任何一个候选码中的属性被称为主属性。</td>\n</tr>\n<tr>\n<td>全码</td>\n<td>All-key关系模型的所有属性组组成该关系模式的候选码，称为全码。即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。</td>\n</tr>\n<tr>\n<td>外码</td>\n<td>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称为这个属性组为R的外码或外键。s</td>\n</tr>\n<tr>\n<td>实体完整性</td>\n<td>关系主码中的属性值不能为空值。</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"关系运算\"><a href=\"#关系运算\" class=\"headerlink\" title=\"关系运算\"></a><a href=\".\\关系运算-SQL.md\">关系运算</a></h1><table>\n  <tr>\n    <th colspan=\"2\">运算符</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">集合</td>\n    <td>∪</td>\n    <td>并-Union</td>\n    <td rowspan=\"3\">关系R和关系S具有相同的属性，且相应的属性来自同一个值域<br>`Select * from R Union Select * from S;`<br>`Select * from R Except Select * from S;`<br>`Select * from R Intersect Select * from S;`<br></td>\n  </tr>\n  <tr>\n    <td>-</td>\n    <td>差-Except</td>\n  </tr>\n  <tr>\n    <td>∩</td>\n    <td>交-Except</td>\n  </tr>\n  <tr>\n    <td>×</td>\n    <td>笛卡尔积</td>\n    <td>R: n个属性， k1个元组；S: m个属性， k2个元组<br>R×S：（n+m） 列元组的集合<br>行： k1×k2个元组<br>`Select * from R,S;`<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">关系</td>\n    <td>σ</td>\n    <td>选择</td>\n    <td>从关系R中选取符合条件的元组，<br>`SELECT R.学号，R.课程名, R.分数 from R WHERE 分数&gt;85`</td>\n  </tr>\n  <tr>\n    <td>π </td>\n    <td>投影</td>\n    <td>选取属性，选取的记过会删除重复的元组<br>`SELECT 品名，数量 FROM R;`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">连接</td>\n    <td>θ连接</td>\n    <td>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</td>\n  </tr>\n  <tr>\n    <td>自然连接</td>\n    <td>从两个关系的笛卡尔积中选取相同属性分量相等的元组</td>\n  </tr>\n  <tr>\n    <td>外连接</td>\n    <td>如果把悬浮元组也保存在结果关系中，而在其他属性，上填空值(Null)，就叫做外连接</td>\n  </tr>\n  <tr>\n    <td>÷ </td>\n    <td>除</td>\n    <td>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(x)与S(Y)组成的元组都在R(X,Y)中<br>`SELECT DISTINCT R.X FROM R  R1<br>WHERE NOT EXISTS <br>(    <br>    SELECT S.Y FROM S <br>    WHERE NOT EXISTS <br>    (<br>        SELECT * FROM R R2 <br>        where R1.X=R2.X and R2.Y=S.Y<br>    )<br>)`</td>\n  </tr>\n</table>\n\n<h1 id=\"数据定义语言-DDL\"><a href=\"#数据定义语言-DDL\" class=\"headerlink\" title=\"数据定义语言-DDL\"></a><a href=\"DDL-SQL.md\">数据定义语言-DDL</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CREATE</td>\n<td>创建新的表、视图或者其他数据库中的对象</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>修改现存数据库对象，比如一张表</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>删除表、视图或者数据库中的其他对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"数据操纵语言-DML\"><a href=\"#数据操纵语言-DML\" class=\"headerlink\" title=\"数据操纵语言-DML\"></a><a href=\"./DML-SQL.md\">数据操纵语言-DML</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>INSERT</td>\n<td>创建一条新记录</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>修改记录</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除记录</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>从一张或者多张表中检索特定的数据</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"数据控制语言-DCL\"><a href=\"#数据控制语言-DCL\" class=\"headerlink\" title=\"数据控制语言-DCL\"></a><a href=\"./DCL-SQL.md\">数据控制语言-DCL</a></h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GRANT</td>\n<td>赋予用户特权</td>\n</tr>\n<tr>\n<td>REVOKE</td>\n<td>收回赋予用户的特权</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"SVM支持向量机","date":"2017-10-18T15:22:09.000Z","_content":"# 简介\n支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。构建一个超平面将数据点分开,使所有数据距离超平面的距离最大。其中红色与蓝色的数据点成为**支持向量**\n\n![](SVM支持向量机/SVM支持向量机-7a61442f.png)\n\n<!--more-->\n## 知识体系结构\n- 学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；\n- 当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；\n- 当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。\n\n## [算法](https://blog.csdn.net/github_39261590/article/details/75009069)\n### 模型\n输入：是线性可分的 $m$ 个样本${(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),}$,其中 $x$ 为 $n$ 维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。\n\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n求得最优解,$w^{\\ast },b^{\\ast }$\n\n### 推导\n\n$$w^*\\cdot x+b^*=0$$\n分类决策函数为\n$$f(x)=sign(w^*\\cdot x+b^*)$$\n其他点$(x_0,y_0)$平面$w\\cdot x_i + b=0$的距离\n$$\\frac{|w\\cdot x_i + b|}{||w||_2^2}$$\n因为$y=\\pm 1$所以\n$$\\frac{y(w\\cdot x_i + b)}{||w||_2^2}$$\n假设$y(w\\cdot x_i + b)\\geqslant 1$则\n\n![](SVM支持向量机/SVM支持向量机-d7b11def.png)\n\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n\n# 线性可分支持向量机与硬间隔最大化\n## 概念\n- 线性可分支持量机的定义\n给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为\n$$w\\cdot x + b = 0$$\n以及相应的分类决策函数\n$$f(x)=sign(w\\cdot x + b )$$\n线性可分如下图所示：\n\n![](SVM支持向量机/SVM支持向量机-124d9ba6.png)\n\n- 支持向量\n距离超平面最近的数据点，如下图所示的圆圈处的数据点。\n- 硬间隔\n$$\\left\\{\\begin{matrix}\nw\\cdot x_{i}+b\\geqslant +1 &y_i=+1\\\\\nw\\cdot x_{i}+b\\leqslant -1 &y_i=-1\n\\end{matrix}\\right.$$\n硬间隔：两个异类支持向量到超平面的距离之和如下所示$$\\gamma =\\frac{2}{\\left \\| w \\right \\|}$$\n\n![硬间隔](SVM支持向量机/SVM支持向量机-92b2d31d.png)\n\n## 数学模型\nSVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n\n- 推导\n略\n\n## 怎么得到支持向量\n根据KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1)=0$，如果$α_i>0$则有$y_i(w\\cdot x_i+b)=1 $即点在支持向量上，否则如果$α_i=0$则有$y_i(w\\cdot x_i+b)≥1$，即样本在支持向量上或者已经被正确分类。\n\n## 算法\n输入：线性可分训练集$T={(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),}$,其中$x$为n维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。\n1. 构造约束优化问题\n$$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&\\alpha_i \\geq 0  \\; i=1,2,...m\n\\end{align*}$$\n2. 利用SMO算法求得求出上式最小时对应的$α$向量的值$α^∗$向量.\n2. 计算：\n$$w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i$$\n求b则稍微麻烦一点。注意到，对于任意支持向量$(x_s, y_s)$，都有\n$$y_s(w\\cdot x_s+b) = y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_ix_s+b) = 1$$\n假设我们有S个支持向量，则对应我们求出S个$b^{\\ast }$,理论上这些$b^{\\ast }$都可以作为最终的结果， 但是我们一般采用一种更健壮的办法，即求出所有支持向量所对应的$b_s^{\\ast }$，然后将其平均值作为最后的结果。\n\n\n\n\n\n\n# 线性支持向量机与软间隔最大化\n## 概念\n- 线性支持向量机\n训练数据集不是线性可分的。通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。这时需要修改硬间隔最大化，使其成为软间隔最大化。\n\n![](SVM支持向量机/SVM支持向量机-2b9c28f6.png)\n\n本来如果我们不考虑异常点，SVM的超平面应该是下图中的红色线所示，但是由于有一个蓝色的异常点，导致我们学习到的超平面是下图中的粗虚线所示，这样会严重影响我们的分类模型预测效果。\n- 软间隔\nSVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$ξ_i≥0$,使函数间隔加上松弛变量大于等于1，也就是说：\n$$y_i(w\\cdot  x_i +b) \\geq 1- \\xi_i$$\n\n## 数学模型\n对每个松弛变量$ξ_i$，支付一个代价$ξ_i$，这个就得到了我们的软间隔最大化的SVM学习条件。目标函数由原来的\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||^2 +C\\sum\\limits_{i=1}^{m}\\xi_i \\\\\ns.t. \\;  \\; \\;\\; &y_i(w\\cdot x_i + b)  \\geq 1 - \\xi_i \\;\\;(i =1,2,...m)\\\\\n&\\xi_i \\geq 0 \\;\\;(i =1,2,...m)\n\\end{align*}$$\nC>0称为惩罚参数，一般由应用问题决定，C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使$\\frac{1}{2}||w||^2$尽量小即间隔尽量大，同时使误分类点的个数尽量小，C是调和二者的系数。\n## 支持向量\n\n![](SVM支持向量机/SVM支持向量机-0ba6fdac.png)\n\n根据软间隔最大化时KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1+ξ_i^∗)=0$我们有\n1. 如果$α=0$,那么$y_i(w\\cdot x_i+b)−1≥0$,即样本在支持向量上或者已经被正确分类。如图中所有远离支持向量的点。\n1. 如果$0≤α≤C$,那么$ξ_i=0,y_i(w\\cdot x_i+b)−1=0$,即点在支持向量上。如图中在虚线支持向量上的点。\n1. 如果$α=C$，说明这是一个可能比较异常的点，需要检查此时$\\xi_i$\n 1. 如果$0≤ξ_i≤1$,那么点被正确分类，但是却在超平面和自己类别的支持向量之间。如图中的样本2和4.\n 2. 如果$ξ_i=1$,那么点在分离超平面上，无法被正确分类。\n 3. 如果$ξ_i>1$,那么点在超平面的另一侧，也就是说，这个点不能被正常分类。如图中的样本1和3\n\n## 算法\n输入：线性可分的$m$个样本$(x_1,y_1),(x_2,y_2),...,(x_m,y_m)$,,其中$x$为$n$维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }$和$b^{\\ast }$和分类决策函数。\n1. 选择一个惩罚系数C>0, 构造约束优化问题\n2. $$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha_i \\leqslant C \\; \\;\\;i=1,2,...m\n\\end{align*}$$\n1. 用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量.\n1. 计算$w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i$\n1. 找出所有的S个支持向量,即满足$0<α_s<C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s$. 所有的$b_s^∗$对应的平均值即为最终的$b^{\\ast } = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$\n1. 这样最终的分类超平面为：$w^∗\\cdot x+b^∗=0$，最终的分类决策函数为：\n2. $$f(x) = sign(w^{*} \\cdot x + b^{*})$$\n\n## 合页损失函数\n线性支持向量机还有另外一种解释如下：\n$$\\underbrace{ min}_{w, b}[1-y_i(w \\cdot x + b)]_{+} + \\lambda ||w||_2^2$$\n其中$L(y(w \\bullet x + b)) = [1-y_i(w \\bullet x + b)]_{+}$称为合页损失函数(hinge loss function)，下标+表示为：\n$$[z]_{+}= \\begin{cases} z & {z >0}\\\\ 0& {z\\leq 0} \\end{cases}$$\n也就是说，如果点被正确分类，且函数间隔大于1，损失是0，否则损失是$1−y(w∙x+b)$,如下图中的绿线。我们在下图还可以看出其他各种模型损失和函数间隔的关系：对于0-1损失函数，如果正确分类，损失是0，误分类损失1， 如下图黑线，可见0-1损失函数是不可导的。对于感知机模型，感知机的损失函数是$[-y_i(w \\cdot x + b)]_{+}$，这样当样本被正确分类时，损失是0，误分类时，损失是$-y_i(w \\cdot x + b)$，如下图紫线。对于逻辑回归之类和最大熵模型对应的对数损失，损失函数是$log[1+exp(−y(w\\cdot  x+b))]$, 如下图红线所示。\n\n![](SVM支持向量机/SVM支持向量机-18baeb56.png)\n\n# 非线性支持向量机与核函数\n## 概念\n- 非线性分类问题\n非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。如下图所示，无法用直线（线性模型）将正负实例正确分开，但可以用一条椭圆曲线（非线性模型）将它们正确分开。**用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。**\n\n![](SVM支持向量机/SVM支持向量机-51712dc0.png)\n\n- 核函数\n设$\\mathbb{X}$是输入空间（欧氏空间$\\mathbb{R}^{n}$的子集或离散集合），又设$\\mathbb{H}$为特征空间（希尔伯特空间），如果存在一个从$\\mathbb{X}$到$\\mathbb{H}$的映射\n$$\\Phi (x):\\mathbb{X}\\rightarrow \\mathbb{H}$$\n使得对所有$x,z\\in \\mathbb{X}$，函数$K(x,z)$满足条件\n$$K(x,z)=\\Phi (x)\\cdot \\Phi (z)$$\n则称$K(x,z)$为核函数，$\\Phi (x)$为映射函数，式中$\\Phi (x)\\cdot \\Phi (z)$为$\\Phi (x)$和$\\Phi (z)$的内积。\n\n![](SVM支持向量机/SVM支持向量机-f41dd70d.png)\n\n## 正定核函数\n一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$x_i \\in \\chi ， i=1,2,3...m$，$K(x_i,x_j)$对应的Gram矩阵$K = \\bigg[ K(x_i, x_j )\\bigg]$是半正定矩阵，则$K(x,z)$是正定核函数。　\n\n## 常用核函数\n- 线性核函数\n线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：\n$$K(x, z) = x \\cdot z$$\n也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n- 多项式核函数\n多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：\n$$K(x, z) = （\\gamma x \\cdot z  + r)^d$$\n其中，$γ,r,d$都需要自己调参定义。\n- 高斯核函数\n高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：\n$$K(x, z) = exp(-\\gamma||x-z||^2)$$\n其中，$γ$大于0，需要自己调参定义。\n- Sigmoid核函数\nSigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：\n$$K(x, z) = tanh（\\gamma x \\cdot z  + r)$$\n其中，$γ,r$都需要自己调参定义。\n\n## 算法\n输入：$m$个样本$(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),$,其中x为n维特征向量。y为二元输出，值为1，或者-1.\n输出：分离超平面的参数$w^∗$和$b^∗$和分类决策函数。\n算法过程如下：\n1. 选择适当的核函数$K(x,z)$和一个惩罚系数$C>0$, 构造约束优化问题\n$$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha _i\\leqslant C \\; i=1,2,...m\n\\end{align*}$$\n1. 用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量\n1. 得到$w^{\\ast } = \\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_i\\phi(x_i)$，此处可以不直接显式的计算$w^∗$。\n1. 找出所有的S个支持向量,即满足$0 < \\alpha_s < C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)$. 所有的$b_s^{\\ast }$对应的平均值即为最终的$b^{*} = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$\n\n这样最终的分类超平面为：$\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast } = 0$，最终的分类决策函数为：\n$$f(x) = sign(\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast })$$\n\n# SMO算法\n\n\n[支持向量机原理(一) 线性支持向量机](http://www.cnblogs.com/pinard/p/6097604.html)\n[支持向量机原理(二) 线性支持向量机的软间隔最大化模型](http://www.cnblogs.com/pinard/p/6100722.html)\n[支持向量机原理(三) 线性不可分支持向量机与核函数](http://www.cnblogs.com/pinard/p/6103615.html)\n[支持向量机原理(四) SMO算法原理](http://www.cnblogs.com/pinard/p/6111471.html)\n","source":"_posts/SVM支持向量机.md","raw":"---\ntitle: SVM支持向量机\ndate: 2017-10-18 23:22:09\ntags: [人工智能,线性分类器,模型]\ncategories: 机器学习\n---\n# 简介\n支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。构建一个超平面将数据点分开,使所有数据距离超平面的距离最大。其中红色与蓝色的数据点成为**支持向量**\n\n![](SVM支持向量机/SVM支持向量机-7a61442f.png)\n\n<!--more-->\n## 知识体系结构\n- 学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；\n- 当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；\n- 当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。\n\n## [算法](https://blog.csdn.net/github_39261590/article/details/75009069)\n### 模型\n输入：是线性可分的 $m$ 个样本${(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),}$,其中 $x$ 为 $n$ 维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。\n\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n求得最优解,$w^{\\ast },b^{\\ast }$\n\n### 推导\n\n$$w^*\\cdot x+b^*=0$$\n分类决策函数为\n$$f(x)=sign(w^*\\cdot x+b^*)$$\n其他点$(x_0,y_0)$平面$w\\cdot x_i + b=0$的距离\n$$\\frac{|w\\cdot x_i + b|}{||w||_2^2}$$\n因为$y=\\pm 1$所以\n$$\\frac{y(w\\cdot x_i + b)}{||w||_2^2}$$\n假设$y(w\\cdot x_i + b)\\geqslant 1$则\n\n![](SVM支持向量机/SVM支持向量机-d7b11def.png)\n\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n\n# 线性可分支持向量机与硬间隔最大化\n## 概念\n- 线性可分支持量机的定义\n给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为\n$$w\\cdot x + b = 0$$\n以及相应的分类决策函数\n$$f(x)=sign(w\\cdot x + b )$$\n线性可分如下图所示：\n\n![](SVM支持向量机/SVM支持向量机-124d9ba6.png)\n\n- 支持向量\n距离超平面最近的数据点，如下图所示的圆圈处的数据点。\n- 硬间隔\n$$\\left\\{\\begin{matrix}\nw\\cdot x_{i}+b\\geqslant +1 &y_i=+1\\\\\nw\\cdot x_{i}+b\\leqslant -1 &y_i=-1\n\\end{matrix}\\right.$$\n硬间隔：两个异类支持向量到超平面的距离之和如下所示$$\\gamma =\\frac{2}{\\left \\| w \\right \\|}$$\n\n![硬间隔](SVM支持向量机/SVM支持向量机-92b2d31d.png)\n\n## 数学模型\nSVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}$$\n\n- 推导\n略\n\n## 怎么得到支持向量\n根据KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1)=0$，如果$α_i>0$则有$y_i(w\\cdot x_i+b)=1 $即点在支持向量上，否则如果$α_i=0$则有$y_i(w\\cdot x_i+b)≥1$，即样本在支持向量上或者已经被正确分类。\n\n## 算法\n输入：线性可分训练集$T={(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),}$,其中$x$为n维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。\n1. 构造约束优化问题\n$$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&\\alpha_i \\geq 0  \\; i=1,2,...m\n\\end{align*}$$\n2. 利用SMO算法求得求出上式最小时对应的$α$向量的值$α^∗$向量.\n2. 计算：\n$$w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i$$\n求b则稍微麻烦一点。注意到，对于任意支持向量$(x_s, y_s)$，都有\n$$y_s(w\\cdot x_s+b) = y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_ix_s+b) = 1$$\n假设我们有S个支持向量，则对应我们求出S个$b^{\\ast }$,理论上这些$b^{\\ast }$都可以作为最终的结果， 但是我们一般采用一种更健壮的办法，即求出所有支持向量所对应的$b_s^{\\ast }$，然后将其平均值作为最后的结果。\n\n\n\n\n\n\n# 线性支持向量机与软间隔最大化\n## 概念\n- 线性支持向量机\n训练数据集不是线性可分的。通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。这时需要修改硬间隔最大化，使其成为软间隔最大化。\n\n![](SVM支持向量机/SVM支持向量机-2b9c28f6.png)\n\n本来如果我们不考虑异常点，SVM的超平面应该是下图中的红色线所示，但是由于有一个蓝色的异常点，导致我们学习到的超平面是下图中的粗虚线所示，这样会严重影响我们的分类模型预测效果。\n- 软间隔\nSVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$ξ_i≥0$,使函数间隔加上松弛变量大于等于1，也就是说：\n$$y_i(w\\cdot  x_i +b) \\geq 1- \\xi_i$$\n\n## 数学模型\n对每个松弛变量$ξ_i$，支付一个代价$ξ_i$，这个就得到了我们的软间隔最大化的SVM学习条件。目标函数由原来的\n$$\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||^2 +C\\sum\\limits_{i=1}^{m}\\xi_i \\\\\ns.t. \\;  \\; \\;\\; &y_i(w\\cdot x_i + b)  \\geq 1 - \\xi_i \\;\\;(i =1,2,...m)\\\\\n&\\xi_i \\geq 0 \\;\\;(i =1,2,...m)\n\\end{align*}$$\nC>0称为惩罚参数，一般由应用问题决定，C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使$\\frac{1}{2}||w||^2$尽量小即间隔尽量大，同时使误分类点的个数尽量小，C是调和二者的系数。\n## 支持向量\n\n![](SVM支持向量机/SVM支持向量机-0ba6fdac.png)\n\n根据软间隔最大化时KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1+ξ_i^∗)=0$我们有\n1. 如果$α=0$,那么$y_i(w\\cdot x_i+b)−1≥0$,即样本在支持向量上或者已经被正确分类。如图中所有远离支持向量的点。\n1. 如果$0≤α≤C$,那么$ξ_i=0,y_i(w\\cdot x_i+b)−1=0$,即点在支持向量上。如图中在虚线支持向量上的点。\n1. 如果$α=C$，说明这是一个可能比较异常的点，需要检查此时$\\xi_i$\n 1. 如果$0≤ξ_i≤1$,那么点被正确分类，但是却在超平面和自己类别的支持向量之间。如图中的样本2和4.\n 2. 如果$ξ_i=1$,那么点在分离超平面上，无法被正确分类。\n 3. 如果$ξ_i>1$,那么点在超平面的另一侧，也就是说，这个点不能被正常分类。如图中的样本1和3\n\n## 算法\n输入：线性可分的$m$个样本$(x_1,y_1),(x_2,y_2),...,(x_m,y_m)$,,其中$x$为$n$维特征向量。$y$为二元输出，值为1，或者-1.\n输出：是分离超平面的参数和$w^{\\ast }$和$b^{\\ast }$和分类决策函数。\n1. 选择一个惩罚系数C>0, 构造约束优化问题\n2. $$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha_i \\leqslant C \\; \\;\\;i=1,2,...m\n\\end{align*}$$\n1. 用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量.\n1. 计算$w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i$\n1. 找出所有的S个支持向量,即满足$0<α_s<C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s$. 所有的$b_s^∗$对应的平均值即为最终的$b^{\\ast } = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$\n1. 这样最终的分类超平面为：$w^∗\\cdot x+b^∗=0$，最终的分类决策函数为：\n2. $$f(x) = sign(w^{*} \\cdot x + b^{*})$$\n\n## 合页损失函数\n线性支持向量机还有另外一种解释如下：\n$$\\underbrace{ min}_{w, b}[1-y_i(w \\cdot x + b)]_{+} + \\lambda ||w||_2^2$$\n其中$L(y(w \\bullet x + b)) = [1-y_i(w \\bullet x + b)]_{+}$称为合页损失函数(hinge loss function)，下标+表示为：\n$$[z]_{+}= \\begin{cases} z & {z >0}\\\\ 0& {z\\leq 0} \\end{cases}$$\n也就是说，如果点被正确分类，且函数间隔大于1，损失是0，否则损失是$1−y(w∙x+b)$,如下图中的绿线。我们在下图还可以看出其他各种模型损失和函数间隔的关系：对于0-1损失函数，如果正确分类，损失是0，误分类损失1， 如下图黑线，可见0-1损失函数是不可导的。对于感知机模型，感知机的损失函数是$[-y_i(w \\cdot x + b)]_{+}$，这样当样本被正确分类时，损失是0，误分类时，损失是$-y_i(w \\cdot x + b)$，如下图紫线。对于逻辑回归之类和最大熵模型对应的对数损失，损失函数是$log[1+exp(−y(w\\cdot  x+b))]$, 如下图红线所示。\n\n![](SVM支持向量机/SVM支持向量机-18baeb56.png)\n\n# 非线性支持向量机与核函数\n## 概念\n- 非线性分类问题\n非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。如下图所示，无法用直线（线性模型）将正负实例正确分开，但可以用一条椭圆曲线（非线性模型）将它们正确分开。**用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。**\n\n![](SVM支持向量机/SVM支持向量机-51712dc0.png)\n\n- 核函数\n设$\\mathbb{X}$是输入空间（欧氏空间$\\mathbb{R}^{n}$的子集或离散集合），又设$\\mathbb{H}$为特征空间（希尔伯特空间），如果存在一个从$\\mathbb{X}$到$\\mathbb{H}$的映射\n$$\\Phi (x):\\mathbb{X}\\rightarrow \\mathbb{H}$$\n使得对所有$x,z\\in \\mathbb{X}$，函数$K(x,z)$满足条件\n$$K(x,z)=\\Phi (x)\\cdot \\Phi (z)$$\n则称$K(x,z)$为核函数，$\\Phi (x)$为映射函数，式中$\\Phi (x)\\cdot \\Phi (z)$为$\\Phi (x)$和$\\Phi (z)$的内积。\n\n![](SVM支持向量机/SVM支持向量机-f41dd70d.png)\n\n## 正定核函数\n一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$x_i \\in \\chi ， i=1,2,3...m$，$K(x_i,x_j)$对应的Gram矩阵$K = \\bigg[ K(x_i, x_j )\\bigg]$是半正定矩阵，则$K(x,z)$是正定核函数。　\n\n## 常用核函数\n- 线性核函数\n线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：\n$$K(x, z) = x \\cdot z$$\n也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n- 多项式核函数\n多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：\n$$K(x, z) = （\\gamma x \\cdot z  + r)^d$$\n其中，$γ,r,d$都需要自己调参定义。\n- 高斯核函数\n高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：\n$$K(x, z) = exp(-\\gamma||x-z||^2)$$\n其中，$γ$大于0，需要自己调参定义。\n- Sigmoid核函数\nSigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：\n$$K(x, z) = tanh（\\gamma x \\cdot z  + r)$$\n其中，$γ,r$都需要自己调参定义。\n\n## 算法\n输入：$m$个样本$(x_1,y_1), (x_2,y_2), ..., (x_m,y_m),$,其中x为n维特征向量。y为二元输出，值为1，或者-1.\n输出：分离超平面的参数$w^∗$和$b^∗$和分类决策函数。\n算法过程如下：\n1. 选择适当的核函数$K(x,z)$和一个惩罚系数$C>0$, 构造约束优化问题\n$$\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha _i\\leqslant C \\; i=1,2,...m\n\\end{align*}$$\n1. 用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量\n1. 得到$w^{\\ast } = \\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_i\\phi(x_i)$，此处可以不直接显式的计算$w^∗$。\n1. 找出所有的S个支持向量,即满足$0 < \\alpha_s < C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)$. 所有的$b_s^{\\ast }$对应的平均值即为最终的$b^{*} = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$\n\n这样最终的分类超平面为：$\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast } = 0$，最终的分类决策函数为：\n$$f(x) = sign(\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast })$$\n\n# SMO算法\n\n\n[支持向量机原理(一) 线性支持向量机](http://www.cnblogs.com/pinard/p/6097604.html)\n[支持向量机原理(二) 线性支持向量机的软间隔最大化模型](http://www.cnblogs.com/pinard/p/6100722.html)\n[支持向量机原理(三) 线性不可分支持向量机与核函数](http://www.cnblogs.com/pinard/p/6103615.html)\n[支持向量机原理(四) SMO算法原理](http://www.cnblogs.com/pinard/p/6111471.html)\n","slug":"SVM支持向量机","published":1,"updated":"2019-07-30T01:54:38.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iyx002ehomjtq12em8q","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。构建一个超平面将数据点分开,使所有数据距离超平面的距离最大。其中红色与蓝色的数据点成为<strong>支持向量</strong></p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-7a61442f.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"知识体系结构\"><a href=\"#知识体系结构\" class=\"headerlink\" title=\"知识体系结构\"></a>知识体系结构</h2><ul>\n<li>学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；</li>\n<li>当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；</li>\n<li>当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a><a href=\"https://blog.csdn.net/github_39261590/article/details/75009069\" target=\"_blank\" rel=\"noopener\">算法</a></h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><p>输入：是线性可分的 $m$ 个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中 $x$ 为 $n$ 维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><p>求得最优解,$w^{\\ast },b^{\\ast }$</p>\n<h3 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a>推导</h3><script type=\"math/tex; mode=display\">w^*\\cdot x+b^*=0</script><p>分类决策函数为</p>\n<script type=\"math/tex; mode=display\">f(x)=sign(w^*\\cdot x+b^*)</script><p>其他点$(x_0,y_0)$平面$w\\cdot x_i + b=0$的距离</p>\n<script type=\"math/tex; mode=display\">\\frac{|w\\cdot x_i + b|}{||w||_2^2}</script><p>因为$y=\\pm 1$所以</p>\n<script type=\"math/tex; mode=display\">\\frac{y(w\\cdot x_i + b)}{||w||_2^2}</script><p>假设$y(w\\cdot x_i + b)\\geqslant 1$则</p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-d7b11def.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><h1 id=\"线性可分支持向量机与硬间隔最大化\"><a href=\"#线性可分支持向量机与硬间隔最大化\" class=\"headerlink\" title=\"线性可分支持向量机与硬间隔最大化\"></a>线性可分支持向量机与硬间隔最大化</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>线性可分支持量机的定义<br>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<script type=\"math/tex; mode=display\">w\\cdot x + b = 0</script>以及相应的分类决策函数<script type=\"math/tex; mode=display\">f(x)=sign(w\\cdot x + b )</script>线性可分如下图所示：</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-124d9ba6.png\" alt=\"\"></p>\n<ul>\n<li>支持向量<br>距离超平面最近的数据点，如下图所示的圆圈处的数据点。</li>\n<li>硬间隔<script type=\"math/tex; mode=display\">\\left\\{\\begin{matrix}\nw\\cdot x_{i}+b\\geqslant +1 &y_i=+1\\\\\nw\\cdot x_{i}+b\\leqslant -1 &y_i=-1\n\\end{matrix}\\right.</script>硬间隔：两个异类支持向量到超平面的距离之和如下所示<script type=\"math/tex\">\\gamma =\\frac{2}{\\left \\| w \\right \\|}</script></li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-92b2d31d.png\" alt=\"硬间隔\"></p>\n<h2 id=\"数学模型\"><a href=\"#数学模型\" class=\"headerlink\" title=\"数学模型\"></a>数学模型</h2><p>SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><ul>\n<li>推导<br>略</li>\n</ul>\n<h2 id=\"怎么得到支持向量\"><a href=\"#怎么得到支持向量\" class=\"headerlink\" title=\"怎么得到支持向量\"></a>怎么得到支持向量</h2><p>根据KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1)=0$，如果$α_i&gt;0$则有$y_i(w\\cdot x_i+b)=1 $即点在支持向量上，否则如果$α_i=0$则有$y_i(w\\cdot x_i+b)≥1$，即样本在支持向量上或者已经被正确分类。</p>\n<h2 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：线性可分训练集$T={(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中$x$为n维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。</p>\n<ol>\n<li>构造约束优化问题<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&\\alpha_i \\geq 0  \\; i=1,2,...m\n\\end{align*}</script></li>\n<li>利用SMO算法求得求出上式最小时对应的$α$向量的值$α^∗$向量.</li>\n<li>计算：<script type=\"math/tex; mode=display\">w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i</script>求b则稍微麻烦一点。注意到，对于任意支持向量$(x_s, y_s)$，都有<script type=\"math/tex; mode=display\">y_s(w\\cdot x_s+b) = y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_ix_s+b) = 1</script>假设我们有S个支持向量，则对应我们求出S个$b^{\\ast }$,理论上这些$b^{\\ast }$都可以作为最终的结果， 但是我们一般采用一种更健壮的办法，即求出所有支持向量所对应的$b_s^{\\ast }$，然后将其平均值作为最后的结果。</li>\n</ol>\n<h1 id=\"线性支持向量机与软间隔最大化\"><a href=\"#线性支持向量机与软间隔最大化\" class=\"headerlink\" title=\"线性支持向量机与软间隔最大化\"></a>线性支持向量机与软间隔最大化</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>线性支持向量机<br>训练数据集不是线性可分的。通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。这时需要修改硬间隔最大化，使其成为软间隔最大化。</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-2b9c28f6.png\" alt=\"\"></p>\n<p>本来如果我们不考虑异常点，SVM的超平面应该是下图中的红色线所示，但是由于有一个蓝色的异常点，导致我们学习到的超平面是下图中的粗虚线所示，这样会严重影响我们的分类模型预测效果。</p>\n<ul>\n<li>软间隔<br>SVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$ξ_i≥0$,使函数间隔加上松弛变量大于等于1，也就是说：<script type=\"math/tex; mode=display\">y_i(w\\cdot  x_i +b) \\geq 1- \\xi_i</script></li>\n</ul>\n<h2 id=\"数学模型-1\"><a href=\"#数学模型-1\" class=\"headerlink\" title=\"数学模型\"></a>数学模型</h2><p>对每个松弛变量$ξ_i$，支付一个代价$ξ_i$，这个就得到了我们的软间隔最大化的SVM学习条件。目标函数由原来的</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||^2 +C\\sum\\limits_{i=1}^{m}\\xi_i \\\\\ns.t. \\;  \\; \\;\\; &y_i(w\\cdot x_i + b)  \\geq 1 - \\xi_i \\;\\;(i =1,2,...m)\\\\\n&\\xi_i \\geq 0 \\;\\;(i =1,2,...m)\n\\end{align*}</script><p>C&gt;0称为惩罚参数，一般由应用问题决定，C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使$\\frac{1}{2}||w||^2$尽量小即间隔尽量大，同时使误分类点的个数尽量小，C是调和二者的系数。</p>\n<h2 id=\"支持向量\"><a href=\"#支持向量\" class=\"headerlink\" title=\"支持向量\"></a>支持向量</h2><p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-0ba6fdac.png\" alt=\"\"></p>\n<p>根据软间隔最大化时KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1+ξ_i^∗)=0$我们有</p>\n<ol>\n<li>如果$α=0$,那么$y_i(w\\cdot x_i+b)−1≥0$,即样本在支持向量上或者已经被正确分类。如图中所有远离支持向量的点。</li>\n<li>如果$0≤α≤C$,那么$ξ_i=0,y_i(w\\cdot x_i+b)−1=0$,即点在支持向量上。如图中在虚线支持向量上的点。</li>\n<li>如果$α=C$，说明这是一个可能比较异常的点，需要检查此时$\\xi_i$<ol>\n<li>如果$0≤ξ_i≤1$,那么点被正确分类，但是却在超平面和自己类别的支持向量之间。如图中的样本2和4.</li>\n<li>如果$ξ_i=1$,那么点在分离超平面上，无法被正确分类。</li>\n<li>如果$ξ_i&gt;1$,那么点在超平面的另一侧，也就是说，这个点不能被正常分类。如图中的样本1和3</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"算法-2\"><a href=\"#算法-2\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：线性可分的$m$个样本$(x_1,y_1),(x_2,y_2),…,(x_m,y_m)$,,其中$x$为$n$维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }$和$b^{\\ast }$和分类决策函数。</p>\n<ol>\n<li>选择一个惩罚系数C&gt;0, 构造约束优化问题</li>\n<li><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha_i \\leqslant C \\; \\;\\;i=1,2,...m\n\\end{align*}</script></li>\n<li>用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量.</li>\n<li>计算$w^{<em>} = \\sum\\limits_{i=1}^{m}\\alpha_i^{</em>}y_ix_i$</li>\n<li>找出所有的S个支持向量,即满足$0&lt;α_s&lt;C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s$. 所有的$b_s^∗$对应的平均值即为最终的$b^{\\ast } = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$</li>\n<li>这样最终的分类超平面为：$w^∗\\cdot x+b^∗=0$，最终的分类决策函数为：</li>\n<li><script type=\"math/tex; mode=display\">f(x) = sign(w^{*} \\cdot x + b^{*})</script></li>\n</ol>\n<h2 id=\"合页损失函数\"><a href=\"#合页损失函数\" class=\"headerlink\" title=\"合页损失函数\"></a>合页损失函数</h2><p>线性支持向量机还有另外一种解释如下：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{ min}_{w, b}[1-y_i(w \\cdot x + b)]_{+} + \\lambda ||w||_2^2</script><p>其中$L(y(w \\bullet x + b)) = [1-y_i(w \\bullet x + b)]_{+}$称为合页损失函数(hinge loss function)，下标+表示为：</p>\n<script type=\"math/tex; mode=display\">[z]_{+}= \\begin{cases} z & {z >0}\\\\ 0& {z\\leq 0} \\end{cases}</script><p>也就是说，如果点被正确分类，且函数间隔大于1，损失是0，否则损失是$1−y(w∙x+b)$,如下图中的绿线。我们在下图还可以看出其他各种模型损失和函数间隔的关系：对于0-1损失函数，如果正确分类，损失是0，误分类损失1， 如下图黑线，可见0-1损失函数是不可导的。对于感知机模型，感知机的损失函数是$[-y_i(w \\cdot x + b)]_{+}$，这样当样本被正确分类时，损失是0，误分类时，损失是$-y_i(w \\cdot x + b)$，如下图紫线。对于逻辑回归之类和最大熵模型对应的对数损失，损失函数是$log[1+exp(−y(w\\cdot  x+b))]$, 如下图红线所示。</p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-18baeb56.png\" alt=\"\"></p>\n<h1 id=\"非线性支持向量机与核函数\"><a href=\"#非线性支持向量机与核函数\" class=\"headerlink\" title=\"非线性支持向量机与核函数\"></a>非线性支持向量机与核函数</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>非线性分类问题<br>非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。如下图所示，无法用直线（线性模型）将正负实例正确分开，但可以用一条椭圆曲线（非线性模型）将它们正确分开。<strong>用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。</strong></li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-51712dc0.png\" alt=\"\"></p>\n<ul>\n<li>核函数<br>设$\\mathbb{X}$是输入空间（欧氏空间$\\mathbb{R}^{n}$的子集或离散集合），又设$\\mathbb{H}$为特征空间（希尔伯特空间），如果存在一个从$\\mathbb{X}$到$\\mathbb{H}$的映射<script type=\"math/tex; mode=display\">\\Phi (x):\\mathbb{X}\\rightarrow \\mathbb{H}</script>使得对所有$x,z\\in \\mathbb{X}$，函数$K(x,z)$满足条件<script type=\"math/tex; mode=display\">K(x,z)=\\Phi (x)\\cdot \\Phi (z)</script>则称$K(x,z)$为核函数，$\\Phi (x)$为映射函数，式中$\\Phi (x)\\cdot \\Phi (z)$为$\\Phi (x)$和$\\Phi (z)$的内积。</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-f41dd70d.png\" alt=\"\"></p>\n<h2 id=\"正定核函数\"><a href=\"#正定核函数\" class=\"headerlink\" title=\"正定核函数\"></a>正定核函数</h2><p>一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$x_i \\in \\chi ， i=1,2,3…m$，$K(x_i,x_j)$对应的Gram矩阵$K = \\bigg[ K(x_i, x_j )\\bigg]$是半正定矩阵，则$K(x,z)$是正定核函数。　</p>\n<h2 id=\"常用核函数\"><a href=\"#常用核函数\" class=\"headerlink\" title=\"常用核函数\"></a>常用核函数</h2><ul>\n<li>线性核函数<br>线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = x \\cdot z</script>也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。</li>\n<li>多项式核函数<br>多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = （\\gamma x \\cdot z  + r)^d</script>其中，$γ,r,d$都需要自己调参定义。</li>\n<li>高斯核函数<br>高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：<script type=\"math/tex; mode=display\">K(x, z) = exp(-\\gamma||x-z||^2)</script>其中，$γ$大于0，需要自己调参定义。</li>\n<li>Sigmoid核函数<br>Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = tanh（\\gamma x \\cdot z  + r)</script>其中，$γ,r$都需要自己调参定义。</li>\n</ul>\n<h2 id=\"算法-3\"><a href=\"#算法-3\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：$m$个样本$(x_1,y_1), (x_2,y_2), …, (x_m,y_m),$,其中x为n维特征向量。y为二元输出，值为1，或者-1.<br>输出：分离超平面的参数$w^∗$和$b^∗$和分类决策函数。<br>算法过程如下：</p>\n<ol>\n<li>选择适当的核函数$K(x,z)$和一个惩罚系数$C&gt;0$, 构造约束优化问题<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha _i\\leqslant C \\; i=1,2,...m\n\\end{align*}</script></li>\n<li>用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量</li>\n<li>得到$w^{\\ast } = \\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_i\\phi(x_i)$，此处可以不直接显式的计算$w^∗$。</li>\n<li>找出所有的S个支持向量,即满足$0 &lt; \\alpha_s &lt; C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)$. 所有的$b_s^{\\ast }$对应的平均值即为最终的$b^{*} = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$</li>\n</ol>\n<p>这样最终的分类超平面为：$\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast } = 0$，最终的分类决策函数为：</p>\n<script type=\"math/tex; mode=display\">f(x) = sign(\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast })</script><h1 id=\"SMO算法\"><a href=\"#SMO算法\" class=\"headerlink\" title=\"SMO算法\"></a>SMO算法</h1><p><a href=\"http://www.cnblogs.com/pinard/p/6097604.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(一) 线性支持向量机</a><br><a href=\"http://www.cnblogs.com/pinard/p/6100722.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a><br><a href=\"http://www.cnblogs.com/pinard/p/6103615.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(三) 线性不可分支持向量机与核函数</a><br><a href=\"http://www.cnblogs.com/pinard/p/6111471.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(四) SMO算法原理</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>支持向量机（support vector machines，SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。构建一个超平面将数据点分开,使所有数据距离超平面的距离最大。其中红色与蓝色的数据点成为<strong>支持向量</strong></p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-7a61442f.png\" alt=\"\"></p>","more":"<h2 id=\"知识体系结构\"><a href=\"#知识体系结构\" class=\"headerlink\" title=\"知识体系结构\"></a>知识体系结构</h2><ul>\n<li>学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；</li>\n<li>当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；</li>\n<li>当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a><a href=\"https://blog.csdn.net/github_39261590/article/details/75009069\" target=\"_blank\" rel=\"noopener\">算法</a></h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><p>输入：是线性可分的 $m$ 个样本${(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中 $x$ 为 $n$ 维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><p>求得最优解,$w^{\\ast },b^{\\ast }$</p>\n<h3 id=\"推导\"><a href=\"#推导\" class=\"headerlink\" title=\"推导\"></a>推导</h3><script type=\"math/tex; mode=display\">w^*\\cdot x+b^*=0</script><p>分类决策函数为</p>\n<script type=\"math/tex; mode=display\">f(x)=sign(w^*\\cdot x+b^*)</script><p>其他点$(x_0,y_0)$平面$w\\cdot x_i + b=0$的距离</p>\n<script type=\"math/tex; mode=display\">\\frac{|w\\cdot x_i + b|}{||w||_2^2}</script><p>因为$y=\\pm 1$所以</p>\n<script type=\"math/tex; mode=display\">\\frac{y(w\\cdot x_i + b)}{||w||_2^2}</script><p>假设$y(w\\cdot x_i + b)\\geqslant 1$则</p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-d7b11def.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><h1 id=\"线性可分支持向量机与硬间隔最大化\"><a href=\"#线性可分支持向量机与硬间隔最大化\" class=\"headerlink\" title=\"线性可分支持向量机与硬间隔最大化\"></a>线性可分支持向量机与硬间隔最大化</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>线性可分支持量机的定义<br>给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为<script type=\"math/tex; mode=display\">w\\cdot x + b = 0</script>以及相应的分类决策函数<script type=\"math/tex; mode=display\">f(x)=sign(w\\cdot x + b )</script>线性可分如下图所示：</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-124d9ba6.png\" alt=\"\"></p>\n<ul>\n<li>支持向量<br>距离超平面最近的数据点，如下图所示的圆圈处的数据点。</li>\n<li>硬间隔<script type=\"math/tex; mode=display\">\\left\\{\\begin{matrix}\nw\\cdot x_{i}+b\\geqslant +1 &y_i=+1\\\\\nw\\cdot x_{i}+b\\leqslant -1 &y_i=-1\n\\end{matrix}\\right.</script>硬间隔：两个异类支持向量到超平面的距离之和如下所示<script type=\"math/tex\">\\gamma =\\frac{2}{\\left \\| w \\right \\|}</script></li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-92b2d31d.png\" alt=\"硬间隔\"></p>\n<h2 id=\"数学模型\"><a href=\"#数学模型\" class=\"headerlink\" title=\"数学模型\"></a>数学模型</h2><p>SVM的模型是让所有点到超平面的距离大于一定的距离，也就是所有的分类点要在各自类别的支持向量两边。用数学式子表示为：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||_2^2\\\\\ns.t\\;\\;\\;\\; & y_i(w\\cdot x_i + b)  \\geq 1 \\;\\;(i =1,2,...n)\n\\end{align*}</script><ul>\n<li>推导<br>略</li>\n</ul>\n<h2 id=\"怎么得到支持向量\"><a href=\"#怎么得到支持向量\" class=\"headerlink\" title=\"怎么得到支持向量\"></a>怎么得到支持向量</h2><p>根据KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1)=0$，如果$α_i&gt;0$则有$y_i(w\\cdot x_i+b)=1 $即点在支持向量上，否则如果$α_i=0$则有$y_i(w\\cdot x_i+b)≥1$，即样本在支持向量上或者已经被正确分类。</p>\n<h2 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：线性可分训练集$T={(x_1,y_1), (x_2,y_2), …, (x_m,y_m),}$,其中$x$为n维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }和b^{\\ast }$和分类决策函数。</p>\n<ol>\n<li>构造约束优化问题<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&\\alpha_i \\geq 0  \\; i=1,2,...m\n\\end{align*}</script></li>\n<li>利用SMO算法求得求出上式最小时对应的$α$向量的值$α^∗$向量.</li>\n<li>计算：<script type=\"math/tex; mode=display\">w^{*} = \\sum\\limits_{i=1}^{m}\\alpha_i^{*}y_ix_i</script>求b则稍微麻烦一点。注意到，对于任意支持向量$(x_s, y_s)$，都有<script type=\"math/tex; mode=display\">y_s(w\\cdot x_s+b) = y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_ix_s+b) = 1</script>假设我们有S个支持向量，则对应我们求出S个$b^{\\ast }$,理论上这些$b^{\\ast }$都可以作为最终的结果， 但是我们一般采用一种更健壮的办法，即求出所有支持向量所对应的$b_s^{\\ast }$，然后将其平均值作为最后的结果。</li>\n</ol>\n<h1 id=\"线性支持向量机与软间隔最大化\"><a href=\"#线性支持向量机与软间隔最大化\" class=\"headerlink\" title=\"线性支持向量机与软间隔最大化\"></a>线性支持向量机与软间隔最大化</h1><h2 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>线性支持向量机<br>训练数据集不是线性可分的。通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。这时需要修改硬间隔最大化，使其成为软间隔最大化。</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-2b9c28f6.png\" alt=\"\"></p>\n<p>本来如果我们不考虑异常点，SVM的超平面应该是下图中的红色线所示，但是由于有一个蓝色的异常点，导致我们学习到的超平面是下图中的粗虚线所示，这样会严重影响我们的分类模型预测效果。</p>\n<ul>\n<li>软间隔<br>SVM对训练集里面的每个样本$(x_i,y_i)$引入了一个松弛变量$ξ_i≥0$,使函数间隔加上松弛变量大于等于1，也就是说：<script type=\"math/tex; mode=display\">y_i(w\\cdot  x_i +b) \\geq 1- \\xi_i</script></li>\n</ul>\n<h2 id=\"数学模型-1\"><a href=\"#数学模型-1\" class=\"headerlink\" title=\"数学模型\"></a>数学模型</h2><p>对每个松弛变量$ξ_i$，支付一个代价$ξ_i$，这个就得到了我们的软间隔最大化的SVM学习条件。目标函数由原来的</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&min\\;\\; \\frac{1}{2}||w||^2 +C\\sum\\limits_{i=1}^{m}\\xi_i \\\\\ns.t. \\;  \\; \\;\\; &y_i(w\\cdot x_i + b)  \\geq 1 - \\xi_i \\;\\;(i =1,2,...m)\\\\\n&\\xi_i \\geq 0 \\;\\;(i =1,2,...m)\n\\end{align*}</script><p>C&gt;0称为惩罚参数，一般由应用问题决定，C值大时对误分类的惩罚增大，C值小时对误分类的惩罚减小。最小化目标函数包含两层含义：使$\\frac{1}{2}||w||^2$尽量小即间隔尽量大，同时使误分类点的个数尽量小，C是调和二者的系数。</p>\n<h2 id=\"支持向量\"><a href=\"#支持向量\" class=\"headerlink\" title=\"支持向量\"></a>支持向量</h2><p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-0ba6fdac.png\" alt=\"\"></p>\n<p>根据软间隔最大化时KKT条件中的对偶互补条件$α_i∗(y_i(w\\cdot x_i+b)−1+ξ_i^∗)=0$我们有</p>\n<ol>\n<li>如果$α=0$,那么$y_i(w\\cdot x_i+b)−1≥0$,即样本在支持向量上或者已经被正确分类。如图中所有远离支持向量的点。</li>\n<li>如果$0≤α≤C$,那么$ξ_i=0,y_i(w\\cdot x_i+b)−1=0$,即点在支持向量上。如图中在虚线支持向量上的点。</li>\n<li>如果$α=C$，说明这是一个可能比较异常的点，需要检查此时$\\xi_i$<ol>\n<li>如果$0≤ξ_i≤1$,那么点被正确分类，但是却在超平面和自己类别的支持向量之间。如图中的样本2和4.</li>\n<li>如果$ξ_i=1$,那么点在分离超平面上，无法被正确分类。</li>\n<li>如果$ξ_i&gt;1$,那么点在超平面的另一侧，也就是说，这个点不能被正常分类。如图中的样本1和3</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"算法-2\"><a href=\"#算法-2\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：线性可分的$m$个样本$(x_1,y_1),(x_2,y_2),…,(x_m,y_m)$,,其中$x$为$n$维特征向量。$y$为二元输出，值为1，或者-1.<br>输出：是分离超平面的参数和$w^{\\ast }$和$b^{\\ast }$和分类决策函数。</p>\n<ol>\n<li>选择一个惩罚系数C&gt;0, 构造约束优化问题</li>\n<li><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha_i \\leqslant C \\; \\;\\;i=1,2,...m\n\\end{align*}</script></li>\n<li>用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量.</li>\n<li>计算$w^{<em>} = \\sum\\limits_{i=1}^{m}\\alpha_i^{</em>}y_ix_i$</li>\n<li>找出所有的S个支持向量,即满足$0&lt;α_s&lt;C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_ix_i^Tx_s$. 所有的$b_s^∗$对应的平均值即为最终的$b^{\\ast } = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$</li>\n<li>这样最终的分类超平面为：$w^∗\\cdot x+b^∗=0$，最终的分类决策函数为：</li>\n<li><script type=\"math/tex; mode=display\">f(x) = sign(w^{*} \\cdot x + b^{*})</script></li>\n</ol>\n<h2 id=\"合页损失函数\"><a href=\"#合页损失函数\" class=\"headerlink\" title=\"合页损失函数\"></a>合页损失函数</h2><p>线性支持向量机还有另外一种解释如下：</p>\n<script type=\"math/tex; mode=display\">\\underbrace{ min}_{w, b}[1-y_i(w \\cdot x + b)]_{+} + \\lambda ||w||_2^2</script><p>其中$L(y(w \\bullet x + b)) = [1-y_i(w \\bullet x + b)]_{+}$称为合页损失函数(hinge loss function)，下标+表示为：</p>\n<script type=\"math/tex; mode=display\">[z]_{+}= \\begin{cases} z & {z >0}\\\\ 0& {z\\leq 0} \\end{cases}</script><p>也就是说，如果点被正确分类，且函数间隔大于1，损失是0，否则损失是$1−y(w∙x+b)$,如下图中的绿线。我们在下图还可以看出其他各种模型损失和函数间隔的关系：对于0-1损失函数，如果正确分类，损失是0，误分类损失1， 如下图黑线，可见0-1损失函数是不可导的。对于感知机模型，感知机的损失函数是$[-y_i(w \\cdot x + b)]_{+}$，这样当样本被正确分类时，损失是0，误分类时，损失是$-y_i(w \\cdot x + b)$，如下图紫线。对于逻辑回归之类和最大熵模型对应的对数损失，损失函数是$log[1+exp(−y(w\\cdot  x+b))]$, 如下图红线所示。</p>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-18baeb56.png\" alt=\"\"></p>\n<h1 id=\"非线性支持向量机与核函数\"><a href=\"#非线性支持向量机与核函数\" class=\"headerlink\" title=\"非线性支持向量机与核函数\"></a>非线性支持向量机与核函数</h1><h2 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h2><ul>\n<li>非线性分类问题<br>非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。如下图所示，无法用直线（线性模型）将正负实例正确分开，但可以用一条椭圆曲线（非线性模型）将它们正确分开。<strong>用线性分类方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间里用线性分类学习方法从训练数据中学习分类模型。</strong></li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-51712dc0.png\" alt=\"\"></p>\n<ul>\n<li>核函数<br>设$\\mathbb{X}$是输入空间（欧氏空间$\\mathbb{R}^{n}$的子集或离散集合），又设$\\mathbb{H}$为特征空间（希尔伯特空间），如果存在一个从$\\mathbb{X}$到$\\mathbb{H}$的映射<script type=\"math/tex; mode=display\">\\Phi (x):\\mathbb{X}\\rightarrow \\mathbb{H}</script>使得对所有$x,z\\in \\mathbb{X}$，函数$K(x,z)$满足条件<script type=\"math/tex; mode=display\">K(x,z)=\\Phi (x)\\cdot \\Phi (z)</script>则称$K(x,z)$为核函数，$\\Phi (x)$为映射函数，式中$\\Phi (x)\\cdot \\Phi (z)$为$\\Phi (x)$和$\\Phi (z)$的内积。</li>\n</ul>\n<p><img src=\"/2017/10/18/SVM支持向量机/SVM支持向量机-f41dd70d.png\" alt=\"\"></p>\n<h2 id=\"正定核函数\"><a href=\"#正定核函数\" class=\"headerlink\" title=\"正定核函数\"></a>正定核函数</h2><p>一个函数要想成为正定核函数，必须满足他里面任何点的集合形成的Gram矩阵是半正定的。也就是说,对于任意的$x_i \\in \\chi ， i=1,2,3…m$，$K(x_i,x_j)$对应的Gram矩阵$K = \\bigg[ K(x_i, x_j )\\bigg]$是半正定矩阵，则$K(x,z)$是正定核函数。　</p>\n<h2 id=\"常用核函数\"><a href=\"#常用核函数\" class=\"headerlink\" title=\"常用核函数\"></a>常用核函数</h2><ul>\n<li>线性核函数<br>线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = x \\cdot z</script>也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。</li>\n<li>多项式核函数<br>多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = （\\gamma x \\cdot z  + r)^d</script>其中，$γ,r,d$都需要自己调参定义。</li>\n<li>高斯核函数<br>高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：<script type=\"math/tex; mode=display\">K(x, z) = exp(-\\gamma||x-z||^2)</script>其中，$γ$大于0，需要自己调参定义。</li>\n<li>Sigmoid核函数<br>Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex; mode=display\">K(x, z) = tanh（\\gamma x \\cdot z  + r)</script>其中，$γ,r$都需要自己调参定义。</li>\n</ul>\n<h2 id=\"算法-3\"><a href=\"#算法-3\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>输入：$m$个样本$(x_1,y_1), (x_2,y_2), …, (x_m,y_m),$,其中x为n维特征向量。y为二元输出，值为1，或者-1.<br>输出：分离超平面的参数$w^∗$和$b^∗$和分类决策函数。<br>算法过程如下：</p>\n<ol>\n<li>选择适当的核函数$K(x,z)$和一个惩罚系数$C&gt;0$, 构造约束优化问题<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underbrace{min}_{\\alpha} \\;\\; \\frac{1}{2}\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{m}\\alpha_i\\alpha_jy_iy_j(x_i \\cdot x_j) -  \\sum\\limits_{i=1}^{m} \\alpha_i\\\\\ns.t\\;\\;\\;\\; & \\sum\\limits_{i=1}^{m}\\alpha_iy_i = 0\\\\\n&0\\leqslant \\alpha _i\\leqslant C \\; i=1,2,...m\n\\end{align*}</script></li>\n<li>用SMO算法求出上式最小时对应的$α$向量的值$α^∗$向量</li>\n<li>得到$w^{\\ast } = \\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_i\\phi(x_i)$，此处可以不直接显式的计算$w^∗$。</li>\n<li>找出所有的S个支持向量,即满足$0 &lt; \\alpha_s &lt; C$对应的样本$(x_s,y_s)$，通过 $y_s(\\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)+b) = 1$，计算出每个支持向量$(x_s,y_s)$对应的$b_s^{\\ast }$,计算出这些$b_s^{\\ast } = y_s - \\sum\\limits_{i=1}^{S}\\alpha_iy_iK(x_i,x_s)$. 所有的$b_s^{\\ast }$对应的平均值即为最终的$b^{*} = \\frac{1}{S}\\sum\\limits_{i=1}^{S}b_s^{\\ast }$</li>\n</ol>\n<p>这样最终的分类超平面为：$\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast } = 0$，最终的分类决策函数为：</p>\n<script type=\"math/tex; mode=display\">f(x) = sign(\\sum\\limits_{i=1}^{m}\\alpha_i^{\\ast }y_iK(x, x_i)+ b^{\\ast })</script><h1 id=\"SMO算法\"><a href=\"#SMO算法\" class=\"headerlink\" title=\"SMO算法\"></a>SMO算法</h1><p><a href=\"http://www.cnblogs.com/pinard/p/6097604.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(一) 线性支持向量机</a><br><a href=\"http://www.cnblogs.com/pinard/p/6100722.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(二) 线性支持向量机的软间隔最大化模型</a><br><a href=\"http://www.cnblogs.com/pinard/p/6103615.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(三) 线性不可分支持向量机与核函数</a><br><a href=\"http://www.cnblogs.com/pinard/p/6111471.html\" target=\"_blank\" rel=\"noopener\">支持向量机原理(四) SMO算法原理</a></p>"},{"title":"hadoop","date":"2019-08-14T11:20:28.000Z","_content":"\n![1565782138575](hadoop/1565782138575.png)\n\n`Apache Hadoop`软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它旨在从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于检测和处理应用层的故障，从而在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。`Hadoop`的命令众多，本文重点介绍`HDFS`与`MapReduce`\n\n<!--more-->\n\n<center>hadoop.tgn</center>\n<table>\n  <tr>\n    <th>类别</th>\n    <th>名称</th>\n    <th>说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">模块</td>\n    <td>Hadoop Common</td>\n    <td>支持其他Hadoop模块的常用实用程序。</td>\n  </tr>\n  <tr>\n    <td>Hadoop HDFS</td>\n    <td>一种分布式文件系统，可提供对应用程序数据的高吞吐量访问</td>\n  </tr>\n  <tr>\n    <td>Hadoop YARN</td>\n    <td>作业调度和集群资源管理的框架。</td>\n  </tr>\n  <tr>\n    <td>Hadoop MapReduce</td>\n    <td>基于YARN的系统，用于并行处理大型数据集</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/ozone/\">Hadoop Ozone</a></td>\n    <td><a href=\"https://hadoop.apache.org/ozone/\"><span style=\"font-weight:700\">Hadoop</span></a>的对象存储</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/submarine/\">Hadoop Submarine</a></td>\n    <td><a href=\"https://hadoop.apache.org/submarine/\"><span style=\"font-weight:700\">Hadoop</span></a>的机器学习引擎。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">数据库</td>\n    <td><a href=\"http://hive.apache.org/\">Apache Hive</a></td>\n    <td>是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://pig.apache.org/\">Apache Pig</a></td>\n    <td>是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hbase.apache.org/\">Apache HBase</a></td>\n    <td>是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cassandra.apache.org/\">Apache Cassandra</a></td>\n    <td>是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/hcatalog/\">Apache HCatalog</a></td>\n    <td>是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://avro.apache.org/\">Apache Avro</a></td>\n    <td>是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用。Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://sqoop.apache.org/\">Apache Sqoop</a></td>\n    <td>是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/chukwa/\">Apache Chukwa</a></td>\n    <td>是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合 Hadoop 处理的文件保存在 HDFS 中供 Hadoop 进行各种 MapReduce 操作。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">计算与模型</td>\n    <td><a href=\"http://mahout.apache.org/\">Apache Mahout</a></td>\n    <td>是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hama.apache.org/\">Apache Hama</a></td>\n    <td>是一个基于HDFS的BSP（Bulk Synchronous Parallel)并行计算框架, Hama可用于包括图、矩阵和网络算法在内的大规模、大数据计算。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://giraph.apache.org/\">Apache Giraph</a></td>\n    <td>是一个可伸缩的分布式迭代图处理系统， 基于Hadoop平台，灵感来自 BSP (bulk synchronous parallel) 和 Google 的 Pregel。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">框架</td>\n    <td><a href=\"http://flume.apache.org/\">Apache Flume</a></td>\n    <td>是一个分布的、可靠的、高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cloudera.github.io/hue/\">Cloudera Hue</a></td>\n    <td>是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce/YARN, HBase, Hive, Pig的web化操作和管理。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/ambari/\">Apache Ambari</a></td>\n    <td>是一种基于Web的工具，支持Hadoop集群的供应、管理和监控</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://zookeeper.apache.org/\">Apache Zookeeper</a><br></td>\n    <td>是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://bigtop.apache.org/\">Apache Bigtop</a></td>\n    <td>是一个对Hadoop及其周边生态进行打包，分发和测试的工具。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://oozie.apache.org/\">Apache Oozie</a></td>\n    <td>是一个工作流引擎服务器, 用于管理和协调运行在Hadoop平台上（HDFS、Pig和MapReduce）的任务。</td>\n  </tr>\n  <tr>\n    <td>辅助</td>\n    <td><a href=\"http://incubator.apache.org/crunch/\">Apache Crunch</a></td>\n    <td>是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据、执行聚合和排序记录等常见任务的模式库</td>\n  </tr>\n</table>\n\n# [HDFS](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html)\n\n`Hadoop`分布式文件系统(`HDFS`)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。`HDFS`是一个高度容错性的系统，适合部署在廉价的机器上。`HDFS`能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。`HDFS`放宽了一部分`POSIX`约束，来实现流式读取文件系统数据的目的。`HDFS`在最开始是作为`Apache Nutch`搜索引擎项目的基础架构而开发的。`HDFS`是`Apache Hadoop Core`项目的一部分。[`HDFS`使用指南]()\n\n# [Map/Reduce](./MapReduce.md)\n\n`Map/Reduce` 是一个分布式运算程序的编程框架，`Map/Reduce` 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 `hadoop` 集群上。每个`Map/Reduce`任务都被初始化为一个`Job`，每个`Job`又可以分为两种阶段：`map`阶段和`reduce`阶段。这两个阶段分别用两个函数表示，即`map`函数和`reduce`函数。一个`Map/Reduce`作业的输入和输出类型如下所示：\n\n`(input) <k1, v1> -> map -> <k2, v2> -> combine -> <k2, v2> -> reduce -> <k3, v3> (output)`\n\n![img](MapReduce/14019352-0c530b046636edd0.webp)\n\n# [Hive](./hive.md)","source":"_posts/hadoop.md","raw":"---\ntitle: hadoop\ndate: 2019-08-14 19:20:28\ntags: [人工智能,分布式系统]\ncategories: Hadoop\n---\n\n![1565782138575](hadoop/1565782138575.png)\n\n`Apache Hadoop`软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它旨在从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于检测和处理应用层的故障，从而在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。`Hadoop`的命令众多，本文重点介绍`HDFS`与`MapReduce`\n\n<!--more-->\n\n<center>hadoop.tgn</center>\n<table>\n  <tr>\n    <th>类别</th>\n    <th>名称</th>\n    <th>说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">模块</td>\n    <td>Hadoop Common</td>\n    <td>支持其他Hadoop模块的常用实用程序。</td>\n  </tr>\n  <tr>\n    <td>Hadoop HDFS</td>\n    <td>一种分布式文件系统，可提供对应用程序数据的高吞吐量访问</td>\n  </tr>\n  <tr>\n    <td>Hadoop YARN</td>\n    <td>作业调度和集群资源管理的框架。</td>\n  </tr>\n  <tr>\n    <td>Hadoop MapReduce</td>\n    <td>基于YARN的系统，用于并行处理大型数据集</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/ozone/\">Hadoop Ozone</a></td>\n    <td><a href=\"https://hadoop.apache.org/ozone/\"><span style=\"font-weight:700\">Hadoop</span></a>的对象存储</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/submarine/\">Hadoop Submarine</a></td>\n    <td><a href=\"https://hadoop.apache.org/submarine/\"><span style=\"font-weight:700\">Hadoop</span></a>的机器学习引擎。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">数据库</td>\n    <td><a href=\"http://hive.apache.org/\">Apache Hive</a></td>\n    <td>是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://pig.apache.org/\">Apache Pig</a></td>\n    <td>是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hbase.apache.org/\">Apache HBase</a></td>\n    <td>是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cassandra.apache.org/\">Apache Cassandra</a></td>\n    <td>是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/hcatalog/\">Apache HCatalog</a></td>\n    <td>是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://avro.apache.org/\">Apache Avro</a></td>\n    <td>是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用。Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://sqoop.apache.org/\">Apache Sqoop</a></td>\n    <td>是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/chukwa/\">Apache Chukwa</a></td>\n    <td>是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合 Hadoop 处理的文件保存在 HDFS 中供 Hadoop 进行各种 MapReduce 操作。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">计算与模型</td>\n    <td><a href=\"http://mahout.apache.org/\">Apache Mahout</a></td>\n    <td>是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hama.apache.org/\">Apache Hama</a></td>\n    <td>是一个基于HDFS的BSP（Bulk Synchronous Parallel)并行计算框架, Hama可用于包括图、矩阵和网络算法在内的大规模、大数据计算。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://giraph.apache.org/\">Apache Giraph</a></td>\n    <td>是一个可伸缩的分布式迭代图处理系统， 基于Hadoop平台，灵感来自 BSP (bulk synchronous parallel) 和 Google 的 Pregel。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">框架</td>\n    <td><a href=\"http://flume.apache.org/\">Apache Flume</a></td>\n    <td>是一个分布的、可靠的、高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cloudera.github.io/hue/\">Cloudera Hue</a></td>\n    <td>是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce/YARN, HBase, Hive, Pig的web化操作和管理。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/ambari/\">Apache Ambari</a></td>\n    <td>是一种基于Web的工具，支持Hadoop集群的供应、管理和监控</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://zookeeper.apache.org/\">Apache Zookeeper</a><br></td>\n    <td>是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://bigtop.apache.org/\">Apache Bigtop</a></td>\n    <td>是一个对Hadoop及其周边生态进行打包，分发和测试的工具。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://oozie.apache.org/\">Apache Oozie</a></td>\n    <td>是一个工作流引擎服务器, 用于管理和协调运行在Hadoop平台上（HDFS、Pig和MapReduce）的任务。</td>\n  </tr>\n  <tr>\n    <td>辅助</td>\n    <td><a href=\"http://incubator.apache.org/crunch/\">Apache Crunch</a></td>\n    <td>是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据、执行聚合和排序记录等常见任务的模式库</td>\n  </tr>\n</table>\n\n# [HDFS](https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html)\n\n`Hadoop`分布式文件系统(`HDFS`)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。`HDFS`是一个高度容错性的系统，适合部署在廉价的机器上。`HDFS`能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。`HDFS`放宽了一部分`POSIX`约束，来实现流式读取文件系统数据的目的。`HDFS`在最开始是作为`Apache Nutch`搜索引擎项目的基础架构而开发的。`HDFS`是`Apache Hadoop Core`项目的一部分。[`HDFS`使用指南]()\n\n# [Map/Reduce](./MapReduce.md)\n\n`Map/Reduce` 是一个分布式运算程序的编程框架，`Map/Reduce` 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 `hadoop` 集群上。每个`Map/Reduce`任务都被初始化为一个`Job`，每个`Job`又可以分为两种阶段：`map`阶段和`reduce`阶段。这两个阶段分别用两个函数表示，即`map`函数和`reduce`函数。一个`Map/Reduce`作业的输入和输出类型如下所示：\n\n`(input) <k1, v1> -> map -> <k2, v2> -> combine -> <k2, v2> -> reduce -> <k3, v3> (output)`\n\n![img](MapReduce/14019352-0c530b046636edd0.webp)\n\n# [Hive](./hive.md)","slug":"hadoop","published":1,"updated":"2019-08-16T12:40:15.299Z","_id":"cjzdr6iyy002ghomjbnm8yvqk","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/2019/08/14/hadoop/1565782138575.png\" alt=\"1565782138575\"></p>\n<p><code>Apache Hadoop</code>软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它旨在从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于检测和处理应用层的故障，从而在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。<code>Hadoop</code>的命令众多，本文重点介绍<code>HDFS</code>与<code>MapReduce</code></p>\n<a id=\"more\"></a>\n<p><center>hadoop.tgn</center></p>\n<table>\n  <tr>\n    <th>类别</th>\n    <th>名称</th>\n    <th>说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">模块</td>\n    <td>Hadoop Common</td>\n    <td>支持其他Hadoop模块的常用实用程序。</td>\n  </tr>\n  <tr>\n    <td>Hadoop HDFS</td>\n    <td>一种分布式文件系统，可提供对应用程序数据的高吞吐量访问</td>\n  </tr>\n  <tr>\n    <td>Hadoop YARN</td>\n    <td>作业调度和集群资源管理的框架。</td>\n  </tr>\n  <tr>\n    <td>Hadoop MapReduce</td>\n    <td>基于YARN的系统，用于并行处理大型数据集</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/ozone/\" target=\"_blank\" rel=\"noopener\">Hadoop Ozone</a></td>\n    <td><a href=\"https://hadoop.apache.org/ozone/\" target=\"_blank\" rel=\"noopener\"><span style=\"font-weight:700\">Hadoop</span></a>的对象存储</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/submarine/\" target=\"_blank\" rel=\"noopener\">Hadoop Submarine</a></td>\n    <td><a href=\"https://hadoop.apache.org/submarine/\" target=\"_blank\" rel=\"noopener\"><span style=\"font-weight:700\">Hadoop</span></a>的机器学习引擎。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">数据库</td>\n    <td><a href=\"http://hive.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Hive</a></td>\n    <td>是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://pig.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Pig</a></td>\n    <td>是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hbase.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache HBase</a></td>\n    <td>是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cassandra.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Cassandra</a></td>\n    <td>是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/hcatalog/\" target=\"_blank\" rel=\"noopener\">Apache HCatalog</a></td>\n    <td>是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://avro.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Avro</a></td>\n    <td>是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用。Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://sqoop.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Sqoop</a></td>\n    <td>是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/chukwa/\" target=\"_blank\" rel=\"noopener\">Apache Chukwa</a></td>\n    <td>是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合 Hadoop 处理的文件保存在 HDFS 中供 Hadoop 进行各种 MapReduce 操作。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">计算与模型</td>\n    <td><a href=\"http://mahout.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Mahout</a></td>\n    <td>是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hama.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Hama</a></td>\n    <td>是一个基于HDFS的BSP（Bulk Synchronous Parallel)并行计算框架, Hama可用于包括图、矩阵和网络算法在内的大规模、大数据计算。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://giraph.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Giraph</a></td>\n    <td>是一个可伸缩的分布式迭代图处理系统， 基于Hadoop平台，灵感来自 BSP (bulk synchronous parallel) 和 Google 的 Pregel。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">框架</td>\n    <td><a href=\"http://flume.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Flume</a></td>\n    <td>是一个分布的、可靠的、高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cloudera.github.io/hue/\" target=\"_blank\" rel=\"noopener\">Cloudera Hue</a></td>\n    <td>是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce/YARN, HBase, Hive, Pig的web化操作和管理。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/ambari/\" target=\"_blank\" rel=\"noopener\">Apache Ambari</a></td>\n    <td>是一种基于Web的工具，支持Hadoop集群的供应、管理和监控</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://zookeeper.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Zookeeper</a><br></td>\n    <td>是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://bigtop.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Bigtop</a></td>\n    <td>是一个对Hadoop及其周边生态进行打包，分发和测试的工具。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://oozie.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Oozie</a></td>\n    <td>是一个工作流引擎服务器, 用于管理和协调运行在Hadoop平台上（HDFS、Pig和MapReduce）的任务。</td>\n  </tr>\n  <tr>\n    <td>辅助</td>\n    <td><a href=\"http://incubator.apache.org/crunch/\" target=\"_blank\" rel=\"noopener\">Apache Crunch</a></td>\n    <td>是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据、执行聚合和排序记录等常见任务的模式库</td>\n  </tr>\n</table>\n\n<h1 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a><a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html\" target=\"_blank\" rel=\"noopener\">HDFS</a></h1><p><code>Hadoop</code>分布式文件系统(<code>HDFS</code>)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。<code>HDFS</code>是一个高度容错性的系统，适合部署在廉价的机器上。<code>HDFS</code>能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。<code>HDFS</code>放宽了一部分<code>POSIX</code>约束，来实现流式读取文件系统数据的目的。<code>HDFS</code>在最开始是作为<code>Apache Nutch</code>搜索引擎项目的基础架构而开发的。<code>HDFS</code>是<code>Apache Hadoop Core</code>项目的一部分。<a href=\"\"><code>HDFS</code>使用指南</a></p>\n<h1 id=\"Map-Reduce\"><a href=\"#Map-Reduce\" class=\"headerlink\" title=\"Map/Reduce\"></a><a href=\"./MapReduce.md\">Map/Reduce</a></h1><p><code>Map/Reduce</code> 是一个分布式运算程序的编程框架，<code>Map/Reduce</code> 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 <code>hadoop</code> 集群上。每个<code>Map/Reduce</code>任务都被初始化为一个<code>Job</code>，每个<code>Job</code>又可以分为两种阶段：<code>map</code>阶段和<code>reduce</code>阶段。这两个阶段分别用两个函数表示，即<code>map</code>函数和<code>reduce</code>函数。一个<code>Map/Reduce</code>作业的输入和输出类型如下所示：</p>\n<p><code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</code></p>\n<p><img src=\"/2019/08/14/hadoop/14019352-0c530b046636edd0.webp\" alt=\"img\"></p>\n<h1 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a><a href=\"./hive.md\">Hive</a></h1>","site":{"data":{}},"excerpt":"<p><img src=\"/2019/08/14/hadoop/1565782138575.png\" alt=\"1565782138575\"></p>\n<p><code>Apache Hadoop</code>软件库是一个框架，允许使用简单的编程模型跨计算机集群分布式处理大型数据集。它旨在从单个服务器扩展到数千台计算机，每台计算机都提供本地计算和存储。该库本身不是依靠硬件来提供高可用性，而是设计用于检测和处理应用层的故障，从而在计算机集群之上提供高可用性服务，每个计算机都可能容易出现故障。<code>Hadoop</code>的命令众多，本文重点介绍<code>HDFS</code>与<code>MapReduce</code></p>","more":"<p><center>hadoop.tgn</center></p>\n<table>\n  <tr>\n    <th>类别</th>\n    <th>名称</th>\n    <th>说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">模块</td>\n    <td>Hadoop Common</td>\n    <td>支持其他Hadoop模块的常用实用程序。</td>\n  </tr>\n  <tr>\n    <td>Hadoop HDFS</td>\n    <td>一种分布式文件系统，可提供对应用程序数据的高吞吐量访问</td>\n  </tr>\n  <tr>\n    <td>Hadoop YARN</td>\n    <td>作业调度和集群资源管理的框架。</td>\n  </tr>\n  <tr>\n    <td>Hadoop MapReduce</td>\n    <td>基于YARN的系统，用于并行处理大型数据集</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/ozone/\" target=\"_blank\" rel=\"noopener\">Hadoop Ozone</a></td>\n    <td><a href=\"https://hadoop.apache.org/ozone/\" target=\"_blank\" rel=\"noopener\"><span style=\"font-weight:700\">Hadoop</span></a>的对象存储</td>\n  </tr>\n  <tr>\n    <td><a href=\"https://hadoop.apache.org/submarine/\" target=\"_blank\" rel=\"noopener\">Hadoop Submarine</a></td>\n    <td><a href=\"https://hadoop.apache.org/submarine/\" target=\"_blank\" rel=\"noopener\"><span style=\"font-weight:700\">Hadoop</span></a>的机器学习引擎。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"8\">数据库</td>\n    <td><a href=\"http://hive.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Hive</a></td>\n    <td>是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://pig.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Pig</a></td>\n    <td>是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hbase.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache HBase</a></td>\n    <td>是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cassandra.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Cassandra</a></td>\n    <td>是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式的架构于一身</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/hcatalog/\" target=\"_blank\" rel=\"noopener\">Apache HCatalog</a></td>\n    <td>是基于Hadoop的数据表和存储管理，实现中央的元数据和模式管理，跨越Hadoop和RDBMS，利用Pig和Hive提供关系视图。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://avro.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Avro</a></td>\n    <td>是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用。Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://sqoop.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Sqoop</a></td>\n    <td>是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/chukwa/\" target=\"_blank\" rel=\"noopener\">Apache Chukwa</a></td>\n    <td>是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合 Hadoop 处理的文件保存在 HDFS 中供 Hadoop 进行各种 MapReduce 操作。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">计算与模型</td>\n    <td><a href=\"http://mahout.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Mahout</a></td>\n    <td>是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://hama.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Hama</a></td>\n    <td>是一个基于HDFS的BSP（Bulk Synchronous Parallel)并行计算框架, Hama可用于包括图、矩阵和网络算法在内的大规模、大数据计算。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://giraph.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Giraph</a></td>\n    <td>是一个可伸缩的分布式迭代图处理系统， 基于Hadoop平台，灵感来自 BSP (bulk synchronous parallel) 和 Google 的 Pregel。</td>\n  </tr>\n  <tr>\n    <td rowspan=\"6\">框架</td>\n    <td><a href=\"http://flume.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Flume</a></td>\n    <td>是一个分布的、可靠的、高可用的海量日志聚合的系统，可用于日志数据收集，日志数据处理，日志数据传输。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://cloudera.github.io/hue/\" target=\"_blank\" rel=\"noopener\">Cloudera Hue</a></td>\n    <td>是一个基于WEB的监控和管理系统，实现对HDFS，MapReduce/YARN, HBase, Hive, Pig的web化操作和管理。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://incubator.apache.org/ambari/\" target=\"_blank\" rel=\"noopener\">Apache Ambari</a></td>\n    <td>是一种基于Web的工具，支持Hadoop集群的供应、管理和监控</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://zookeeper.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Zookeeper</a><br></td>\n    <td>是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://bigtop.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Bigtop</a></td>\n    <td>是一个对Hadoop及其周边生态进行打包，分发和测试的工具。</td>\n  </tr>\n  <tr>\n    <td><a href=\"http://oozie.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Oozie</a></td>\n    <td>是一个工作流引擎服务器, 用于管理和协调运行在Hadoop平台上（HDFS、Pig和MapReduce）的任务。</td>\n  </tr>\n  <tr>\n    <td>辅助</td>\n    <td><a href=\"http://incubator.apache.org/crunch/\" target=\"_blank\" rel=\"noopener\">Apache Crunch</a></td>\n    <td>是基于Google的FlumeJava库编写的Java库，用于创建MapReduce程序。与Hive，Pig类似，Crunch提供了用于实现如连接数据、执行聚合和排序记录等常见任务的模式库</td>\n  </tr>\n</table>\n\n<h1 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a><a href=\"https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html\" target=\"_blank\" rel=\"noopener\">HDFS</a></h1><p><code>Hadoop</code>分布式文件系统(<code>HDFS</code>)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。<code>HDFS</code>是一个高度容错性的系统，适合部署在廉价的机器上。<code>HDFS</code>能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。<code>HDFS</code>放宽了一部分<code>POSIX</code>约束，来实现流式读取文件系统数据的目的。<code>HDFS</code>在最开始是作为<code>Apache Nutch</code>搜索引擎项目的基础架构而开发的。<code>HDFS</code>是<code>Apache Hadoop Core</code>项目的一部分。<a href=\"\"><code>HDFS</code>使用指南</a></p>\n<h1 id=\"Map-Reduce\"><a href=\"#Map-Reduce\" class=\"headerlink\" title=\"Map/Reduce\"></a><a href=\"./MapReduce.md\">Map/Reduce</a></h1><p><code>Map/Reduce</code> 是一个分布式运算程序的编程框架，<code>Map/Reduce</code> 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 <code>hadoop</code> 集群上。每个<code>Map/Reduce</code>任务都被初始化为一个<code>Job</code>，每个<code>Job</code>又可以分为两种阶段：<code>map</code>阶段和<code>reduce</code>阶段。这两个阶段分别用两个函数表示，即<code>map</code>函数和<code>reduce</code>函数。一个<code>Map/Reduce</code>作业的输入和输出类型如下所示：</p>\n<p><code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output)</code></p>\n<p><img src=\"/2019/08/14/hadoop/14019352-0c530b046636edd0.webp\" alt=\"img\"></p>\n<h1 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a><a href=\"./hive.md\">Hive</a></h1>"},{"title":"Hello World","date":"2017-08-13T03:11:19.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues\n\n<!-- more -->\n\n```\nnpm install hexo-renderer-kramed --save\n```\n# ceshi\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n$$lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|<\\epsilon)=1, i=1,...,n$$  ","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-08-13 11:11:19\ntags: testing\ncategories: 测试\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues\n\n<!-- more -->\n\n```\nnpm install hexo-renderer-kramed --save\n```\n# ceshi\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n$$lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|<\\epsilon)=1, i=1,...,n$$  ","slug":"hello-world","published":1,"updated":"2019-07-30T01:54:38.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iz1002khomj4sd61ldy","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on [GitHub](<a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo/issues</a></p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"ceshi\"><a href=\"#ceshi\" class=\"headerlink\" title=\"ceshi\"></a>ceshi</h1><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<script type=\"math/tex; mode=display\">lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|<\\epsilon)=1, i=1,...,n</script>","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on [GitHub](<a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo/issues</a></p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"ceshi\"><a href=\"#ceshi\" class=\"headerlink\" title=\"ceshi\"></a>ceshi</h1><h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<script type=\"math/tex; mode=display\">lim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|<\\epsilon)=1, i=1,...,n</script>"},{"title":"hive","date":"2019-08-13T03:42:07.000Z","_content":"\n# 查看表结构\n\n| 命令                                                         | 说明             |\n| ------------------------------------------------------------ | ---------------- |\n| `show tables like '*name*'`                                  | hive模糊搜索表   |\n| `desc formatted table_name`<br>`desc table_name`             | 查看表结构信息   |\n| `show partitions table_name`                                 | 查看分区信息     |\n| `select table_coulm from table_name where partition_name = '2014-02-25';` | 根据分区查询数据 |\n| `dfs -ls /user/hive/warehouse/table02;`                      | 查看hdfs文件信息 |\n\n","source":"_posts/hive.md","raw":"---\ntitle: hive\ndate: 2019-08-13 11:42:07\ntags: [数据库,编程语言]\ncategories: Hadoop\npermalink: HDFS/hive.md\n---\n\n# 查看表结构\n\n| 命令                                                         | 说明             |\n| ------------------------------------------------------------ | ---------------- |\n| `show tables like '*name*'`                                  | hive模糊搜索表   |\n| `desc formatted table_name`<br>`desc table_name`             | 查看表结构信息   |\n| `show partitions table_name`                                 | 查看分区信息     |\n| `select table_coulm from table_name where partition_name = '2014-02-25';` | 根据分区查询数据 |\n| `dfs -ls /user/hive/warehouse/table02;`                      | 查看hdfs文件信息 |\n\n","slug":"HDFS/hive.md","published":1,"updated":"2019-08-16T06:24:10.182Z","_id":"cjzdr6iz2002nhomjzi7eu01k","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"查看表结构\"><a href=\"#查看表结构\" class=\"headerlink\" title=\"查看表结构\"></a>查看表结构</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>show tables like &#39;*name*&#39;</code></td>\n<td>hive模糊搜索表</td>\n</tr>\n<tr>\n<td><code>desc formatted table_name</code><br><code>desc table_name</code></td>\n<td>查看表结构信息</td>\n</tr>\n<tr>\n<td><code>show partitions table_name</code></td>\n<td>查看分区信息</td>\n</tr>\n<tr>\n<td><code>select table_coulm from table_name where partition_name = &#39;2014-02-25&#39;;</code></td>\n<td>根据分区查询数据</td>\n</tr>\n<tr>\n<td><code>dfs -ls /user/hive/warehouse/table02;</code></td>\n<td>查看hdfs文件信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"查看表结构\"><a href=\"#查看表结构\" class=\"headerlink\" title=\"查看表结构\"></a>查看表结构</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>show tables like &#39;*name*&#39;</code></td>\n<td>hive模糊搜索表</td>\n</tr>\n<tr>\n<td><code>desc formatted table_name</code><br><code>desc table_name</code></td>\n<td>查看表结构信息</td>\n</tr>\n<tr>\n<td><code>show partitions table_name</code></td>\n<td>查看分区信息</td>\n</tr>\n<tr>\n<td><code>select table_coulm from table_name where partition_name = &#39;2014-02-25&#39;;</code></td>\n<td>根据分区查询数据</td>\n</tr>\n<tr>\n<td><code>dfs -ls /user/hive/warehouse/table02;</code></td>\n<td>查看hdfs文件信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"linux命令","date":"2019-07-30T02:59:16.000Z","_content":"\n# 文件基本属性\n\n## 文件属性说明\n\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。**因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。**\n\n<!--more-->\n\n## 查看文件属性\n\n```shell\nls -l\n```\n\n输出\n\n```shell\ndr-xr-xr-x   2 root root 4096 Dec 14  2012 bin\ndr-xr-xr-x   4 root root 4096 Apr 19  2012 boot\n```\n\n| 第一个字符                                                   | 属主                        | 属组                        | 其他用户                    |\n| ------------------------------------------------------------ | --------------------------- | --------------------------- | --------------------------- |\n| **d**   目录<br>**-**    文件<br>**l**    链接文档(link file)<br>**b**   装置文件里面的可供储存的接口设备(可随机存取装置)<br>**c**   装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 | r   读<br>w  写<br>x   执行 | r   读<br>w  写<br>x   执行 | r   读<br>w  写<br>x   执行 |\n\n## 更改文件属性\n\n<table>\n  <tr>\n    <th>功能</th>\n    <th colspan=\"5\">方法</th>\n  </tr>\n  <tr>\n    <td>更改文件属组</td>\n    <td colspan=\"5\">chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">更改文件属主</td>\n    <td colspan=\"5\">chown [–R] 属主名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown bin install.log`</td>\n  </tr>\n  <tr>\n    <td colspan=\"5\">chown [-R] 属主名：属组名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown root:root install.log`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">更改文件属性</td>\n    <td colspan=\"5\">Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</td>\n  </tr>\n  <tr>\n    <td>第一种方式</td>\n    <td colspan=\"4\">chmod [-R] xyz 文件或目录<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更<br>xyz : 就是刚刚提到的数字类型的权限属性<br><br>` chmod 777 test`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">第二种方式</td>\n    <td>u&nbsp;&nbsp;&nbsp;属主<br>g&nbsp;&nbsp;&nbsp;同组<br>o&nbsp;&nbsp;&nbsp;其他<br>a&nbsp;&nbsp;&nbsp;所有</td>\n    <td>+(加入)<br>-(除去)<br>=(设定)</td>\n    <td>r<br>w<br>x</td>\n    <td>文件或目录</td>\n  </tr>\n  <tr>\n    <td colspan=\"4\">`chmod u=rwx,g=rx,o=r&nbsp;&nbsp;test` </td>\n  </tr>\n</table>\n\n\n\n# 文件与目录管理\n\nLinux的目录结构为树状结构，最顶级的目录为根目录 /。其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。\n\n| 命令  | 说明                                                         |\n| ----- | ------------------------------------------------------------ |\n| ls    | **列出目录**<br>a: 全部的文件，连同隐藏文件（开头为.的文件）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用) |\n| cd    | **切换目录**<br># cd ~       # 表示回到自己的家目录，亦即是 /root 这个目录 |\n| pwd   | **显示目前的目录**<br>-P ：显示出确实的路径，而非使用连结 (link) 路径。 |\n| mkdir | **创建一个新的目录**<br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br/>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ |\n| rmdir | 删除一个空的目录<br>-p ：连同上一级『空的』目录也一起删除    |\n| cp    | **复制文件或目录**<br>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)<br/>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；<br/>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br/>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br/>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；<br/>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br/>-r：递归持续复制，用於目录的复制行为；(常用)<br/>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；<br/>-u：若 destination 比 source 旧才升级 destination ！ |\n| rm    | **移除文件或目录**<br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br/>-i ：互动模式，在删除前会询问使用者是否动作<br/>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ |\n| mv    | **移动文件与目录，或修改文件与目录的名称**<br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br/>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br/>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) |\n\n# 用户与用户组\n\n## 用户管理\n\n| 命令    | 说明                                                         |\n| ------- | ------------------------------------------------------------ |\n| useradd | **添加新的用户账号**    `useradd -s /bin/sh -g group –G adm,root gem`<br>`useradd 选项 用户名`<br>-c   comment 指定一段注释性描述。<br/>-d  目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br/>-g  用户组 指定用户所属的用户组。<br/>-G 用户组，用户组 指定用户所属的附加组。<br/>-s  Shell文件 指定用户的登录Shell。<br/>-u  用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 |\n| userdel | **删除帐号**   `userdel -r sam`<br>-r：把用户的主目录一起删除 |\n| usermod | 修改帐号   `usermod -s /bin/ksh -d /home/z –g developer sam`<br>`usermod 选项 用户名`<br>包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样 |\n| passwd  | 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。<br>`passwd 选项 用户名`<br>-l 锁定口令，即禁用账号。<br/>-u 口令解锁。<br/>-d 使账号无口令。<br/>-f 强迫用户下次登录时修改口令。 |\n\n## 用户组管理\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对**/etc/group**文件的更新\n\n| 命令     | 方法                                                         |\n| -------- | ------------------------------------------------------------ |\n| groupadd | **增加一个新的用户组**<br>-g GID 指定新用户组的组标识号（GID）。<br/>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 |\n| groupdel | 删除一个已有的用户组                                         |\n| groupmod | **修改用户组的属性**<br>-g GID 为用户组指定新的组标识号。<br/>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br/>-n新用户组 将用户组的名字改为新名字 |\n| newgrp   | **如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。**<br>```newgrp root``` |\n\n## 与用户账号有关的系统文件\n\n完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n\n### 伪用户\n\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示：\n\n```shell\n伪 用 户 含 义 \nbin 拥有可执行的用户命令文件 \nsys 拥有系统文件 \nadm 拥有帐户文件 \nuucp UUCP使用 \nlp lp或lpd子系统使用 \nnobody NFS使用\n```\n\n### 用户管理文件-/etc/passwd\n\n```shell\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\nroot:x:0:0:Superuser:/:\n```\n\n|    字段    | 说明                                                         |\n| :--------: | ------------------------------------------------------------ |\n|    口令    | 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux   系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 |\n| 用户标识号 | 系统内部用它来标识用户，一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等 |\n|  组标识号  | 记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。 |\n| 注释性描述 | 记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等， |\n|   主目录   | 用户的起始工作目录                                           |\n| 登陆shell  | 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell |\n\n### 用户管理文件-/etc/shadow\n\n由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n\n```shell\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志   root:Dnakfw28zf38w:8764:0:168:7:::\n```\n\n| 字段             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 登录名           | 与/etc/passwd文件中的登录名相一致的用户账号                  |\n| 口令             | 存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合   { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 |\n| 最后一次修改时间 | 从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO   Linux 中，这个时间起点是1970年1月1日。 |\n| 最小时间间隔     | 是两次修改口令之间所需的最小天数。                           |\n| 最大时间间隔     | 口令保持有效的最大天数。                                     |\n| 警告时间         | 从系统开始警告用户到用户密码正式失效之间的天数。             |\n| 不活动时间       | 用户没有登录活动但账号仍能保持有效的最大天数。               |\n| 失效时间         | 给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 |\n\n### 用户组管理文件-/etc/group\n\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n\n```shell\n组名:口令:组标识号:组内用户列表\nroot::0:root\n```\n\n| 字段         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| 组名         | 用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 |\n| 口令存       | 用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。 |\n| 组标识号     | 与用户标识号类似，也是一个整数，被系统内部用来标识组。       |\n| 组内用户列表 | 属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 |\n\n## 添加批量用户\n\n1. 先编辑一个文本用户文件。\n\n   每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：\n\n   ```txt\n   user001::600:100:user:/home/user001:/bin/bash\n   user002::601:100:user:/home/user002:/bin/bash\n   user003::602:100:user:/home/user003:/bin/bash\n   user004::603:100:user:/home/user004:/bin/bash\n   user005::604:100:user:/home/user005:/bin/bash\n   user006::605:100:user:/home/user006:/bin/bash\n   ```\n\n2. 以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户\n\n   ```shell\n   newusers < user.txt\n   ```\n\n3. 执行命令/usr/sbin/pwunconv\n\n   将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到 `/etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。\n\n   ```shell\n   pwunconv\n   ```\n\n4. 编辑每个用户的密码对照文件。\n\n   ```txt\n   user001:密码\n   user002:密码\n   user003:密码\n   user004:密码\n   user005:密码\n   user006:密码\n   ```\n\n5. 以root身份执行命令 `/usr/sbin/chpasswd`\n\n   创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。\n\n   ```shell\n   chpasswd < passwd.txt\n   ```\n\n6. 确定密码经编码写入/etc/passwd的密码栏后。\n\n   执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。\n\n   ```shell\n   pwconv\n   ```\n\n\n# yum 命令-包管理\n\n- yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件**包管理器**。\n\n- 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以**自动处理依赖性关系**，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\n- yum提供了**查找、安装、删除**某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n```shell\nyum [options] [command] [package ...]\n```\n\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">options</td>\n    <td>-h</td>\n    <td>帮助</td>\n  </tr>\n  <tr>\n    <td>-y</td>\n    <td>当安装过程提示选择全部为\"yes\"</td>\n  </tr>\n  <tr>\n    <td>-q</td>\n    <td>不显示安装的过程</td>\n  </tr>\n  <tr>\n    <td rowspan=\"11\">command</td>\n    <td>check-update</td>\n    <td>列出所有可更新的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>update</td>\n    <td>更新所有软件命令</td>\n  </tr>\n  <tr>\n    <td>update&lt;package_name&gt;</td>\n    <td>仅更新指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>install &lt;package_name&gt;</td>\n    <td>仅安装指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>list</td>\n    <td>列出所有可安裝的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>remove &lt;package_name&gt;</td>\n    <td>删除软件包命令</td>\n  </tr>\n  <tr>\n    <td>search <br>&lt;keyword&gt;</td>\n    <td>查找软件包命令</td>\n  </tr>\n  <tr>\n    <td>clean packages</td>\n    <td>清除缓存目录下的软件包</td>\n  </tr>\n  <tr>\n    <td>clean headers</td>\n    <td>清除缓存目录下的 headers</td>\n  </tr>\n  <tr>\n    <td>clean oldheaders</td>\n    <td>清除缓存目录下旧的 headers</td>\n  </tr>\n  <tr>\n    <td>clean/clean all</td>\n    <td>清除缓存目录下的软件包及旧的headers</td>\n  </tr>\n  <tr>\n    <td>package</td>\n    <td colspan=\"2\">操作的对象</td>\n  </tr>\n</table>\n\n\n\n# 命令大全\n\n| **1、文件管理**                                              |                                                              |                                                              |                                                              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [cat](http://www.runoob.com/linux/linux-comm-cat.html)       | [chattr](http://www.runoob.com/linux/linux-comm-chattr.html) | [chgrp](http://www.runoob.com/linux/linux-comm-chgrp.html)   | [chmod](http://www.runoob.com/linux/linux-comm-chmod.html)   |\n| [chown](http://www.runoob.com/linux/linux-comm-chown.html)   | [cksum](http://www.runoob.com/linux/linux-comm-cksum.html)   | [cmp](http://www.runoob.com/linux/linux-comm-cmp.html)       | [diff](http://www.runoob.com/linux/linux-comm-diff.html)     |\n| [diffstat](http://www.runoob.com/linux/linux-comm-diffstat.html) | [file](http://www.runoob.com/linux/linux-comm-file.html)     | [find](http://www.runoob.com/linux/linux-comm-find.html)     | [git](http://www.runoob.com/linux/linux-comm-git.html)       |\n| [gitview](http://www.runoob.com/linux/linux-comm-gitview.html) | [indent](http://www.runoob.com/linux/linux-comm-indent.html) | [cut](http://www.runoob.com/linux/linux-comm-cut.html)       | [ln](http://www.runoob.com/linux/linux-comm-ln.html)         |\n| [less](http://www.runoob.com/linux/linux-comm-less.html)     | [locate](http://www.runoob.com/linux/linux-comm-locate.html) | [lsattr](http://www.runoob.com/linux/linux-comm-lsattr.html) | [mattrib](http://www.runoob.com/linux/linux-comm-mattrib.html) |\n| [mc](http://www.runoob.com/linux/linux-comm-mc.html)         | [mdel](http://www.runoob.com/linux/linux-comm-mdel.html)     | [mdir](http://www.runoob.com/linux/linux-comm-mdir.html)     | [mktemp](http://www.runoob.com/linux/linux-comm-mktemp.html) |\n| [more](http://www.runoob.com/linux/linux-comm-more.html)     | [mmove](http://www.runoob.com/linux/linux-comm-mmove.html)   | [mread](http://www.runoob.com/linux/linux-comm-mread.html)   | [mren](http://www.runoob.com/linux/linux-comm-mren.html)     |\n| [mtools](http://www.runoob.com/linux/linux-comm-mtools.html) | [mtoolstest](http://www.runoob.com/linux/linux-comm-mtoolstest.html) | [mv](http://www.runoob.com/linux/linux-comm-mv.html)         | [od](http://www.runoob.com/linux/linux-comm-od.html)         |\n| [paste](http://www.runoob.com/linux/linux-comm-paste.html)   | [patch](http://www.runoob.com/linux/linux-comm-patch.html)   | [rcp](http://www.runoob.com/linux/linux-comm-rcp.html)       | [rm](http://www.runoob.com/linux/linux-comm-rm.html)         |\n| [slocate](http://www.runoob.com/linux/linux-comm-slocate.html) | [split](http://www.runoob.com/linux/linux-comm-split.html)   | [tee](http://www.runoob.com/linux/linux-comm-tee.html)       | [tmpwatch](http://www.runoob.com/linux/linux-comm-tmpwatch.html) |\n| [touch](http://www.runoob.com/linux/linux-comm-touch.html)   | [umask](http://www.runoob.com/linux/linux-comm-umask.html)   | [which](http://www.runoob.com/linux/linux-comm-which.html)   | [cp](http://www.runoob.com/linux/linux-comm-cp.html)         |\n| [whereis](http://www.runoob.com/linux/linux-comm-whereis.html) | [mcopy](http://www.runoob.com/linux/linux-comm-mcopy.html)   | [mshowfat](http://www.runoob.com/linux/linux-comm-mshowfat.html) | [rhmask](http://www.runoob.com/linux/linux-comm-rhmask.html) |\n| [scp](http://www.runoob.com/linux/linux-comm-scp.html)       | [awk](http://www.runoob.com/linux/linux-comm-awk.html)       | [read](http://www.runoob.com/linux/linux-comm-read.html)     | [updatedb](http://www.runoob.com/linux/linux-comm-updatedb.html) |\n| **2、文档编辑**                                              |                                                              |                                                              |                                                              |\n| [col](http://www.runoob.com/linux/linux-comm-col.html)       | [colrm](http://www.runoob.com/linux/linux-comm-colrm.html)   | [comm](http://www.runoob.com/linux/linux-comm-comm.html)     | [csplit](http://www.runoob.com/linux/linux-comm-csplit.html) |\n| [ed](http://www.runoob.com/linux/linux-comm-ed.html)         | [egrep](http://www.runoob.com/linux/linux-comm-egrep.html)   | [ex](http://www.runoob.com/linux/linux-comm-ex.html)         | [fgrep](http://www.runoob.com/linux/linux-comm-fgrep.html)   |\n| [fmt](http://www.runoob.com/linux/linux-comm-fmt.html)       | [fold](http://www.runoob.com/linux/linux-comm-fold.html)     | [grep](http://www.runoob.com/linux/linux-comm-grep.html)     | [ispell](http://www.runoob.com/linux/linux-comm-ispell.html) |\n| [jed](http://www.runoob.com/linux/linux-comm-jed.html)       | [joe](http://www.runoob.com/linux/linux-comm-joe.html)       | [join](http://www.runoob.com/linux/linux-comm-join.html)     | [look](http://www.runoob.com/linux/linux-comm-look.html)     |\n| [mtype](http://www.runoob.com/linux/linux-comm-mtype.html)   | [pico](http://www.runoob.com/linux/linux-comm-pico.html)     | [rgrep](http://www.runoob.com/linux/linux-comm-rgrep.html)   | [sed](http://www.runoob.com/linux/linux-comm-sed.html)       |\n| [sort](http://www.runoob.com/linux/linux-comm-sort.html)     | [spell](http://www.runoob.com/linux/linux-comm-spell.html)   | [tr](http://www.runoob.com/linux/linux-comm-tr.html)         | [expr](http://www.runoob.com/linux/linux-comm-expr.html)     |\n| [uniq](http://www.runoob.com/linux/linux-comm-uniq.html)     | [wc](http://www.runoob.com/linux/linux-comm-wc.html)         | [let](http://www.runoob.com/linux/linux-comm-let.html)       |                                                              |\n| **3、文件传输**                                              |                                                              |                                                              |                                                              |\n| [lprm](http://www.runoob.com/linux/linux-comm-lprm.html)     | [lpr](http://www.runoob.com/linux/linux-comm-lpr.html)       | [lpq](http://www.runoob.com/linux/linux-comm-lpq.html)       | [lpd](http://www.runoob.com/linux/linux-comm-lpd.html)       |\n| [bye](http://www.runoob.com/linux/linux-comm-bye.html)       | [ftp](http://www.runoob.com/linux/linux-comm-ftp.html)       | [uuto](http://www.runoob.com/linux/linux-comm-uuto.html)     | [uupick](http://www.runoob.com/linux/linux-comm-uupick.html) |\n| [uucp](http://www.runoob.com/linux/linux-comm-uucp.html)     | [uucico](http://www.runoob.com/linux/linux-comm-uucico.html) | [tftp](http://www.runoob.com/linux/linux-comm-tftp.html)     | [ncftp](http://www.runoob.com/linux/linux-comm-ncftp.html)   |\n| [ftpshut](http://www.runoob.com/linux/linux-comm-ftpshut.html) | [ftpwho](http://www.runoob.com/linux/linux-comm-ftpwho.html) | [ftpcount](http://www.runoob.com/linux/linux-comm-ftpcount.html) |                                                              |\n| **4、磁盘管理**                                              |                                                              |                                                              |                                                              |\n| [cd](http://www.runoob.com/linux/linux-comm-cd.html)         | [df](http://www.runoob.com/linux/linux-comm-df.html)         | [dirs](http://www.runoob.com/linux/linux-comm-dirs.html)     | [du](http://www.runoob.com/linux/linux-comm-du.html)         |\n| [edquota](http://www.runoob.com/linux/linux-comm-edquota.html) | [eject](http://www.runoob.com/linux/linux-comm-eject.html)   | [mcd](http://www.runoob.com/linux/linux-comm-mcd.html)       | [mdeltree](http://www.runoob.com/linux/linux-comm-mdeltree.html) |\n| [mdu](http://www.runoob.com/linux/linux-comm-mdu.html)       | [mkdir](http://www.runoob.com/linux/linux-comm-mkdir.html)   | [mlabel](http://www.runoob.com/linux/linux-comm-mlabel.html) | [mmd](http://www.runoob.com/linux/linux-comm-mmd.html)       |\n| [mrd](http://www.runoob.com/linux/linux-comm-mrd.html)       | [mzip](http://www.runoob.com/linux/linux-comm-mzip.html)     | [pwd](http://www.runoob.com/linux/linux-comm-pwd.html)       | [quota](http://www.runoob.com/linux/linux-comm-quota.html)   |\n| [mount](http://www.runoob.com/linux/linux-comm-mount.html)   | [mmount](http://www.runoob.com/linux/linux-comm-mmount.html) | [rmdir](http://www.runoob.com/linux/linux-comm-rmdir.html)   | [rmt](http://www.runoob.com/linux/linux-comm-rmt.html)       |\n| [stat](http://www.runoob.com/linux/linux-comm-stat.html)     | [tree](http://www.runoob.com/linux/linux-comm-tree.html)     | [umount](http://www.runoob.com/linux/linux-comm-umount.html) | [ls](http://www.runoob.com/linux/linux-comm-ls.html)         |\n| [quotacheck](http://www.runoob.com/linux/linux-comm-quotacheck.html) | [quotaoff](http://www.runoob.com/linux/linux-comm-quotaoff.html) | [lndir](http://www.runoob.com/linux/linux-comm-lndir.html)   | [repquota](http://www.runoob.com/linux/linux-comm-repquota.html) |\n| [quotaon](http://www.runoob.com/linux/linux-comm-quotaon.html) |                                                              |                                                              |                                                              |\n| **5、磁盘维护**                                              |                                                              |                                                              |                                                              |\n| [badblocks](http://www.runoob.com/linux/linux-comm-badblocks.html) | [cfdisk](http://www.runoob.com/linux/linux-comm-cfdisk.html) | [dd](http://www.runoob.com/linux/linux-comm-dd.html)         | [e2fsck](http://www.runoob.com/linux/linux-comm-e2fsck.html) |\n| [ext2ed](http://www.runoob.com/linux/linux-comm-ext2ed.html) | [fsck](http://www.runoob.com/linux/linux-comm-fsck.html)     | [fsck.minix](http://www.runoob.com/linux/linux-comm-fsck-minix.html) | [fsconf](http://www.runoob.com/linux/linux-comm-fsconf.html) |\n| [fdformat](http://www.runoob.com/linux/linux-comm-fdformat.html) | [hdparm](http://www.runoob.com/linux/linux-comm-hdparm.html) | [mformat](http://www.runoob.com/linux/linux-comm-mformat.html) | [mkbootdisk](http://www.runoob.com/linux/linux-comm-mkbootdisk.html) |\n| [mkdosfs](http://www.runoob.com/linux/linux-comm-mkdosfs.html) | [mke2fs](http://www.runoob.com/linux/linux-comm-mke2fs.html) | [mkfs.ext2](http://www.runoob.com/linux/linux-comm-mkfs-ext2.html) | [mkfs.msdos](http://www.runoob.com/linux/linux-comm-mkfs-msdos.html) |\n| [mkinitrd](http://www.runoob.com/linux/linux-comm-mkinitrd.html) | [mkisofs](http://www.runoob.com/linux/linux-comm-mkisofs.html) | [mkswap](http://www.runoob.com/linux/linux-comm-mkswap.html) | [mpartition](http://www.runoob.com/linux/linux-comm-mpartition.html) |\n| [swapon](http://www.runoob.com/linux/linux-comm-swapon.html) | [symlinks](http://www.runoob.com/linux/linux-comm-symlinks.html) | [sync](http://www.runoob.com/linux/linux-comm-sync.html)     | [mbadblocks](http://www.runoob.com/linux/linux-comm-mbadblocks.html) |\n| [mkfs.minix](http://www.runoob.com/linux/linux-comm-mkfs-minix.html) | [fsck.ext2](http://www.runoob.com/linux/linux-comm-fsck-ext2.html) | [fdisk](http://www.runoob.com/linux/linux-comm-fdisk.html)   | [losetup](http://www.runoob.com/linux/linux-comm-losetup.html) |\n| [mkfs](http://www.runoob.com/linux/linux-comm-mkfs.html)     | [sfdisk](http://www.runoob.com/linux/linux-comm-sfdisk.html) | [swapoff](http://www.runoob.com/linux/linux-comm-swapoff.html) |                                                              |\n| **6、网络通讯**                                              |                                                              |                                                              |                                                              |\n| [apachectl](http://www.runoob.com/linux/linux-comm-apachectl.html) | [arpwatch](http://www.runoob.com/linux/linux-comm-arpwatch.html) | [dip](http://www.runoob.com/linux/linux-comm-dip.html)       | [getty](http://www.runoob.com/linux/linux-comm-getty.html)   |\n| [mingetty](http://www.runoob.com/linux/linux-comm-mingetty.html) | [uux](http://www.runoob.com/linux/linux-comm-uux.html)       | [telnet](http://www.runoob.com/linux/linux-comm-telnet.html) | [uulog](http://www.runoob.com/linux/linux-comm-uulog.html)   |\n| [uustat](http://www.runoob.com/linux/linux-comm-uustat.html) | [ppp-off](http://www.runoob.com/linux/linux-comm-ppp-off.html) | [netconfig](http://www.runoob.com/linux/linux-comm-netconfig.html) | [nc](http://www.runoob.com/linux/linux-comm-nc.html)         |\n| [httpd](http://www.runoob.com/linux/linux-comm-httpd.html)   | [ifconfig](http://www.runoob.com/linux/linux-comm-ifconfig.html) | [minicom](http://www.runoob.com/linux/linux-comm-minicom.html) | [mesg](http://www.runoob.com/linux/linux-comm-mesg.html)     |\n| [dnsconf](http://www.runoob.com/linux/linux-comm-dnsconf.html) | [wall](http://www.runoob.com/linux/linux-comm-wall.html)     | [netstat](http://www.runoob.com/linux/linux-comm-netstat.html) | [ping](http://www.runoob.com/linux/linux-comm-ping.html)     |\n| [pppstats](http://www.runoob.com/linux/linux-comm-pppstats.html) | [samba](http://www.runoob.com/linux/linux-comm-samba.html)   | [setserial](http://www.runoob.com/linux/linux-comm-setserial.html) | [talk](http://www.runoob.com/linux/linux-comm-talk.html)     |\n| [traceroute](http://www.runoob.com/linux/linux-comm-traceroute.html) | [tty](http://www.runoob.com/linux/linux-comm-tty.html)       | [newaliases](http://www.runoob.com/linux/linux-comm-newaliases.html) | [uuname](http://www.runoob.com/linux/linux-comm-uuname.html) |\n| [netconf](http://www.runoob.com/linux/linux-comm-netconf.html) | [write](http://www.runoob.com/linux/linux-comm-write.html)   | [statserial](http://www.runoob.com/linux/linux-comm-statserial.html) | [efax](http://www.runoob.com/linux/linux-comm-efax.html)     |\n| [pppsetup](http://www.runoob.com/linux/linux-comm-pppsetup.html) | [tcpdump](http://www.runoob.com/linux/linux-comm-tcpdump.html) | [ytalk](http://www.runoob.com/linux/linux-comm-ytalk.html)   | [cu](http://www.runoob.com/linux/linux-comm-cu.html)         |\n| [smbd](http://www.runoob.com/linux/linux-comm-smbd.html)     | [testparm](http://www.runoob.com/linux/linux-comm-testparm.html) | [smbclient](http://www.runoob.com/linux/linux-comm-smbclient.html) | [shapecfg](http://www.runoob.com/linux/linux-comm-shapecfg.html) |\n| **7、系统管理**                                              |                                                              |                                                              |                                                              |\n| [adduser](http://www.runoob.com/linux/linux-comm-adduser.html) | [chfn](http://www.runoob.com/linux/linux-comm-chfn.html)     | [useradd](http://www.runoob.com/linux/linux-comm-useradd.html) | [date](http://www.runoob.com/linux/linux-comm-date.html)     |\n| [exit](http://www.runoob.com/linux/linux-comm-exit.html)     | [finger](http://www.runoob.com/linux/linux-comm-finger.html) | [fwhios](http://www.runoob.com/linux/linux-comm-fwhios.html) | [sleep](http://www.runoob.com/linux/linux-comm-sleep.html)   |\n| [suspend](http://www.runoob.com/linux/linux-comm-suspend.html) | [groupdel](http://www.runoob.com/linux/linux-comm-groupdel.html) | [groupmod](http://www.runoob.com/linux/linux-comm-groupmod.html) | [halt](http://www.runoob.com/linux/linux-comm-halt.html)     |\n| [kill](http://www.runoob.com/linux/linux-comm-kill.html)     | [last](http://www.runoob.com/linux/linux-comm-last.html)     | [lastb](http://www.runoob.com/linux/linux-comm-lastb.html)   | [login](http://www.runoob.com/linux/linux-comm-login.html)   |\n| [logname](http://www.runoob.com/linux/linux-comm-logname.html) | [logout](http://www.runoob.com/linux/linux-comm-logout.html) | [ps](http://www.runoob.com/linux/linux-comm-ps.html)         | [nice](http://www.runoob.com/linux/linux-comm-nice.html)     |\n| [procinfo](http://www.runoob.com/linux/linux-comm-procinfo.html) | [top](http://www.runoob.com/linux/linux-comm-top.html)       | [pstree](http://www.runoob.com/linux/linux-comm-pstree.html) | [reboot](http://www.runoob.com/linux/linux-comm-reboot.html) |\n| [rlogin](http://www.runoob.com/linux/linux-comm-rlogin.html) | [rsh](http://www.runoob.com/linux/linux-comm-rsh.html)       | [sliplogin](http://www.runoob.com/linux/linux-comm-sliplogin.html) | [screen](http://www.runoob.com/linux/linux-comm-screen.html) |\n| [shutdown](http://www.runoob.com/linux/linux-comm-shutdown.html) | [rwho](http://www.runoob.com/linux/linux-comm-rwho.html)     | [sudo](http://www.runoob.com/linux/linux-comm-sudo.html)     | [gitps](http://www.runoob.com/linux/linux-comm-gitps.html)   |\n| [swatch](http://www.runoob.com/linux/linux-comm-swatch.html) | [tload](http://www.runoob.com/linux/linux-comm-tload.html)   | [logrotate](http://www.runoob.com/linux/linux-comm-logrotate.html) | [uname](http://www.runoob.com/linux/linux-comm-uname.html)   |\n| [chsh](http://www.runoob.com/linux/linux-comm-chsh.html)     | [userconf](http://www.runoob.com/linux/linux-comm-userconf.html) | [userdel](http://www.runoob.com/linux/linux-comm-userdel.html) | [usermod](http://www.runoob.com/linux/linux-comm-usermod.html) |\n| [vlock](http://www.runoob.com/linux/linux-comm-vlock.html)   | [who](http://www.runoob.com/linux/linux-comm-who.html)       | [whoami](http://www.runoob.com/linux/linux-comm-whoami.html) | [whois](http://www.runoob.com/linux/linux-comm-whois.html)   |\n| [newgrp](http://www.runoob.com/linux/linux-comm-newgrp.html) | [renice](http://www.runoob.com/linux/linux-comm-renice.html) | [su](http://www.runoob.com/linux/linux-comm-su.html)         | [skill](http://www.runoob.com/linux/linux-comm-skill.html)   |\n| [w](http://www.runoob.com/linux/linux-comm-w.html)           | [id](http://www.runoob.com/linux/linux-comm-id.html)         | [free](http://www.runoob.com/linux/linux-comm-free.html)     |                                                              |\n| **8、系统设置**                                              |                                                              |                                                              |                                                              |\n| [reset](http://www.runoob.com/linux/linux-comm-reset.html)   | [clear](http://www.runoob.com/linux/linux-comm-clear.html)   | [alias](http://www.runoob.com/linux/linux-comm-alias.html)   | [dircolors](http://www.runoob.com/linux/linux-comm-dircolors.html) |\n| [aumix](http://www.runoob.com/linux/linux-comm-aumix.html)   | [bind](http://www.runoob.com/linux/linux-comm-bind.html)     | [chroot](http://www.runoob.com/linux/linux-comm-chroot.html) | [clock](http://www.runoob.com/linux/linux-comm-clock.html)   |\n| [crontab](http://www.runoob.com/linux/linux-comm-crontab.html) | [declare](http://www.runoob.com/linux/linux-comm-declare.html) | [depmod](http://www.runoob.com/linux/linux-comm-depmod.html) | [dmesg](http://www.runoob.com/linux/linux-comm-dmesg.html)   |\n| [enable](http://www.runoob.com/linux/linux-comm-enable.html) | [eval](http://www.runoob.com/linux/linux-comm-eval.html)     | [export](http://www.runoob.com/linux/linux-comm-export.html) | [pwunconv](http://www.runoob.com/linux/linux-comm-pwunconv.html) |\n| [grpconv](http://www.runoob.com/linux/linux-comm-grpconv.html) | [rpm](http://www.runoob.com/linux/linux-comm-rpm.html)       | [insmod](http://www.runoob.com/linux/linux-comm-insmod.html) | [kbdconfig](http://www.runoob.com/linux/linux-comm-kbdconfig.html) |\n| [lilo](http://www.runoob.com/linux/linux-comm-lilo.html)     | [liloconfig](http://www.runoob.com/linux/linux-comm-liloconfig.html) | [lsmod](http://www.runoob.com/linux/linux-comm-lsmod.html)   | [minfo](http://www.runoob.com/linux/linux-comm-minfo.html)   |\n| [set](http://www.runoob.com/linux/linux-comm-set.html)       | [modprobe](http://www.runoob.com/linux/linux-comm-modprobe.html) | [ntsysv](http://www.runoob.com/linux/linux-comm-ntsysv.html) | [mouseconfig](http://www.runoob.com/linux/linux-comm-mouseconfig.html) |\n| [passwd](http://www.runoob.com/linux/linux-comm-passwd.html) | [pwconv](http://www.runoob.com/linux/linux-comm-pwconv.html) | [rdate](http://www.runoob.com/linux/linux-comm-rdate.html)   | [resize](http://www.runoob.com/linux/linux-comm-resize.html) |\n| [rmmod](http://www.runoob.com/linux/linux-comm-rmmod.html)   | [grpunconv](http://www.runoob.com/linux/linux-comm-grpunconv.html) | [modinfo](http://www.runoob.com/linux/linux-comm-modinfo.html) | [time](http://www.runoob.com/linux/linux-comm-time.html)     |\n| [setup](http://www.runoob.com/linux/linux-comm-setup.html)   | [sndconfig](http://www.runoob.com/linux/linux-comm-sndconfig.html) | [setenv](http://www.runoob.com/linux/linux-comm-setenv.html) | [setconsole](http://www.runoob.com/linux/linux-comm-setconsole.html) |\n| [timeconfig](http://www.runoob.com/linux/linux-comm-timeconfig.html) | [ulimit](http://www.runoob.com/linux/linux-comm-ulimit.html) | [unset](http://www.runoob.com/linux/linux-comm-unset.html)   | [chkconfig](http://www.runoob.com/linux/linux-comm-chkconfig.html) |\n| [apmd](http://www.runoob.com/linux/linux-comm-apmd.html)     | [hwclock](http://www.runoob.com/linux/linux-comm-hwclock.html) | [mkkickstart](http://www.runoob.com/linux/linux-comm-mkkickstart.html) | [fbset](http://www.runoob.com/linux/linux-comm-fbset.html)   |\n| [unalias](http://www.runoob.com/linux/linux-comm-unalias.html) | [SVGATextMode](http://www.runoob.com/linux/linux-comm-svgatextmode.html) |                                                              |                                                              |\n| **9、备份压缩**                                              |                                                              |                                                              |                                                              |\n| [ar](http://www.runoob.com/linux/linux-comm-ar.html)         | [bunzip2](http://www.runoob.com/linux/linux-comm-bunzip2.html) | [bzip2](http://www.runoob.com/linux/linux-comm-bzip2.html)   | [bzip2recover](http://www.runoob.com/linux/linux-comm-bzip2recover.html) |\n| [gunzip](http://www.runoob.com/linux/linux-comm-gunzip.html) | [unarj](http://www.runoob.com/linux/linux-comm-unarj.html)   | [compress](http://www.runoob.com/linux/linux-comm-compress.html) | [cpio](http://www.runoob.com/linux/linux-comm-cpio.html)     |\n| [dump](http://www.runoob.com/linux/linux-comm-dump.html)     | [uuencode](http://www.runoob.com/linux/linux-comm-uuencode.html) | [gzexe](http://www.runoob.com/linux/linux-comm-gzexe.html)   | [gzip](http://www.runoob.com/linux/linux-comm-gzip.html)     |\n| [lha](http://www.runoob.com/linux/linux-comm-lha.html)       | [restore](http://www.runoob.com/linux/linux-comm-restore.html) | [tar](http://www.runoob.com/linux/linux-comm-tar.html)       | [uudecode](http://www.runoob.com/linux/linux-comm-uudecode.html) |\n| [unzip](http://www.runoob.com/linux/linux-comm-unzip.html)   | [zip](http://www.runoob.com/linux/linux-comm-zip.html)       | [zipinfo](http://www.runoob.com/linux/linux-comm-zipinfo.html) |                                                              |\n| **10、设备管理**                                             |                                                              |                                                              |                                                              |\n| [setleds](http://www.runoob.com/linux/linux-comm-setleds.html) | [loadkeys](http://www.runoob.com/linux/linux-comm-loadkeys.html) | [rdev](http://www.runoob.com/linux/linux-comm-rdev.html)     | [dumpkeys](http://www.runoob.com/linux/linux-comm-dumpkeys.html) |\n| [MAKEDEV](http://www.runoob.com/linux/linux-comm-makedev.html) |                                                              |                                                              |                                                              |","source":"_posts/linux命令.md","raw":"---\ntitle: linux命令\ndate: 2019-07-30 10:59:16\ntags: [操作系统，编程语言]\ncategories: linux\n---\n\n# 文件基本属性\n\n## 文件属性说明\n\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。**因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。**\n\n<!--more-->\n\n## 查看文件属性\n\n```shell\nls -l\n```\n\n输出\n\n```shell\ndr-xr-xr-x   2 root root 4096 Dec 14  2012 bin\ndr-xr-xr-x   4 root root 4096 Apr 19  2012 boot\n```\n\n| 第一个字符                                                   | 属主                        | 属组                        | 其他用户                    |\n| ------------------------------------------------------------ | --------------------------- | --------------------------- | --------------------------- |\n| **d**   目录<br>**-**    文件<br>**l**    链接文档(link file)<br>**b**   装置文件里面的可供储存的接口设备(可随机存取装置)<br>**c**   装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 | r   读<br>w  写<br>x   执行 | r   读<br>w  写<br>x   执行 | r   读<br>w  写<br>x   执行 |\n\n## 更改文件属性\n\n<table>\n  <tr>\n    <th>功能</th>\n    <th colspan=\"5\">方法</th>\n  </tr>\n  <tr>\n    <td>更改文件属组</td>\n    <td colspan=\"5\">chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">更改文件属主</td>\n    <td colspan=\"5\">chown [–R] 属主名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown bin install.log`</td>\n  </tr>\n  <tr>\n    <td colspan=\"5\">chown [-R] 属主名：属组名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown root:root install.log`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">更改文件属性</td>\n    <td colspan=\"5\">Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</td>\n  </tr>\n  <tr>\n    <td>第一种方式</td>\n    <td colspan=\"4\">chmod [-R] xyz 文件或目录<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更<br>xyz : 就是刚刚提到的数字类型的权限属性<br><br>` chmod 777 test`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">第二种方式</td>\n    <td>u&nbsp;&nbsp;&nbsp;属主<br>g&nbsp;&nbsp;&nbsp;同组<br>o&nbsp;&nbsp;&nbsp;其他<br>a&nbsp;&nbsp;&nbsp;所有</td>\n    <td>+(加入)<br>-(除去)<br>=(设定)</td>\n    <td>r<br>w<br>x</td>\n    <td>文件或目录</td>\n  </tr>\n  <tr>\n    <td colspan=\"4\">`chmod u=rwx,g=rx,o=r&nbsp;&nbsp;test` </td>\n  </tr>\n</table>\n\n\n\n# 文件与目录管理\n\nLinux的目录结构为树状结构，最顶级的目录为根目录 /。其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。\n\n| 命令  | 说明                                                         |\n| ----- | ------------------------------------------------------------ |\n| ls    | **列出目录**<br>a: 全部的文件，连同隐藏文件（开头为.的文件）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用) |\n| cd    | **切换目录**<br># cd ~       # 表示回到自己的家目录，亦即是 /root 这个目录 |\n| pwd   | **显示目前的目录**<br>-P ：显示出确实的路径，而非使用连结 (link) 路径。 |\n| mkdir | **创建一个新的目录**<br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br/>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ |\n| rmdir | 删除一个空的目录<br>-p ：连同上一级『空的』目录也一起删除    |\n| cp    | **复制文件或目录**<br>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)<br/>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；<br/>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br/>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br/>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；<br/>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br/>-r：递归持续复制，用於目录的复制行为；(常用)<br/>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；<br/>-u：若 destination 比 source 旧才升级 destination ！ |\n| rm    | **移除文件或目录**<br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br/>-i ：互动模式，在删除前会询问使用者是否动作<br/>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ |\n| mv    | **移动文件与目录，或修改文件与目录的名称**<br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br/>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br/>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) |\n\n# 用户与用户组\n\n## 用户管理\n\n| 命令    | 说明                                                         |\n| ------- | ------------------------------------------------------------ |\n| useradd | **添加新的用户账号**    `useradd -s /bin/sh -g group –G adm,root gem`<br>`useradd 选项 用户名`<br>-c   comment 指定一段注释性描述。<br/>-d  目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br/>-g  用户组 指定用户所属的用户组。<br/>-G 用户组，用户组 指定用户所属的附加组。<br/>-s  Shell文件 指定用户的登录Shell。<br/>-u  用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 |\n| userdel | **删除帐号**   `userdel -r sam`<br>-r：把用户的主目录一起删除 |\n| usermod | 修改帐号   `usermod -s /bin/ksh -d /home/z –g developer sam`<br>`usermod 选项 用户名`<br>包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样 |\n| passwd  | 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。<br>`passwd 选项 用户名`<br>-l 锁定口令，即禁用账号。<br/>-u 口令解锁。<br/>-d 使账号无口令。<br/>-f 强迫用户下次登录时修改口令。 |\n\n## 用户组管理\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对**/etc/group**文件的更新\n\n| 命令     | 方法                                                         |\n| -------- | ------------------------------------------------------------ |\n| groupadd | **增加一个新的用户组**<br>-g GID 指定新用户组的组标识号（GID）。<br/>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 |\n| groupdel | 删除一个已有的用户组                                         |\n| groupmod | **修改用户组的属性**<br>-g GID 为用户组指定新的组标识号。<br/>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br/>-n新用户组 将用户组的名字改为新名字 |\n| newgrp   | **如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。**<br>```newgrp root``` |\n\n## 与用户账号有关的系统文件\n\n完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n\n### 伪用户\n\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示：\n\n```shell\n伪 用 户 含 义 \nbin 拥有可执行的用户命令文件 \nsys 拥有系统文件 \nadm 拥有帐户文件 \nuucp UUCP使用 \nlp lp或lpd子系统使用 \nnobody NFS使用\n```\n\n### 用户管理文件-/etc/passwd\n\n```shell\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\nroot:x:0:0:Superuser:/:\n```\n\n|    字段    | 说明                                                         |\n| :--------: | ------------------------------------------------------------ |\n|    口令    | 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux   系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 |\n| 用户标识号 | 系统内部用它来标识用户，一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等 |\n|  组标识号  | 记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。 |\n| 注释性描述 | 记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等， |\n|   主目录   | 用户的起始工作目录                                           |\n| 登陆shell  | 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell |\n\n### 用户管理文件-/etc/shadow\n\n由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n\n```shell\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志   root:Dnakfw28zf38w:8764:0:168:7:::\n```\n\n| 字段             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 登录名           | 与/etc/passwd文件中的登录名相一致的用户账号                  |\n| 口令             | 存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合   { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 |\n| 最后一次修改时间 | 从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO   Linux 中，这个时间起点是1970年1月1日。 |\n| 最小时间间隔     | 是两次修改口令之间所需的最小天数。                           |\n| 最大时间间隔     | 口令保持有效的最大天数。                                     |\n| 警告时间         | 从系统开始警告用户到用户密码正式失效之间的天数。             |\n| 不活动时间       | 用户没有登录活动但账号仍能保持有效的最大天数。               |\n| 失效时间         | 给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 |\n\n### 用户组管理文件-/etc/group\n\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n\n```shell\n组名:口令:组标识号:组内用户列表\nroot::0:root\n```\n\n| 字段         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| 组名         | 用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 |\n| 口令存       | 用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。 |\n| 组标识号     | 与用户标识号类似，也是一个整数，被系统内部用来标识组。       |\n| 组内用户列表 | 属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 |\n\n## 添加批量用户\n\n1. 先编辑一个文本用户文件。\n\n   每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：\n\n   ```txt\n   user001::600:100:user:/home/user001:/bin/bash\n   user002::601:100:user:/home/user002:/bin/bash\n   user003::602:100:user:/home/user003:/bin/bash\n   user004::603:100:user:/home/user004:/bin/bash\n   user005::604:100:user:/home/user005:/bin/bash\n   user006::605:100:user:/home/user006:/bin/bash\n   ```\n\n2. 以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户\n\n   ```shell\n   newusers < user.txt\n   ```\n\n3. 执行命令/usr/sbin/pwunconv\n\n   将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到 `/etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。\n\n   ```shell\n   pwunconv\n   ```\n\n4. 编辑每个用户的密码对照文件。\n\n   ```txt\n   user001:密码\n   user002:密码\n   user003:密码\n   user004:密码\n   user005:密码\n   user006:密码\n   ```\n\n5. 以root身份执行命令 `/usr/sbin/chpasswd`\n\n   创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。\n\n   ```shell\n   chpasswd < passwd.txt\n   ```\n\n6. 确定密码经编码写入/etc/passwd的密码栏后。\n\n   执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。\n\n   ```shell\n   pwconv\n   ```\n\n\n# yum 命令-包管理\n\n- yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件**包管理器**。\n\n- 基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以**自动处理依赖性关系**，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\n- yum提供了**查找、安装、删除**某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n```shell\nyum [options] [command] [package ...]\n```\n\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">options</td>\n    <td>-h</td>\n    <td>帮助</td>\n  </tr>\n  <tr>\n    <td>-y</td>\n    <td>当安装过程提示选择全部为\"yes\"</td>\n  </tr>\n  <tr>\n    <td>-q</td>\n    <td>不显示安装的过程</td>\n  </tr>\n  <tr>\n    <td rowspan=\"11\">command</td>\n    <td>check-update</td>\n    <td>列出所有可更新的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>update</td>\n    <td>更新所有软件命令</td>\n  </tr>\n  <tr>\n    <td>update&lt;package_name&gt;</td>\n    <td>仅更新指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>install &lt;package_name&gt;</td>\n    <td>仅安装指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>list</td>\n    <td>列出所有可安裝的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>remove &lt;package_name&gt;</td>\n    <td>删除软件包命令</td>\n  </tr>\n  <tr>\n    <td>search <br>&lt;keyword&gt;</td>\n    <td>查找软件包命令</td>\n  </tr>\n  <tr>\n    <td>clean packages</td>\n    <td>清除缓存目录下的软件包</td>\n  </tr>\n  <tr>\n    <td>clean headers</td>\n    <td>清除缓存目录下的 headers</td>\n  </tr>\n  <tr>\n    <td>clean oldheaders</td>\n    <td>清除缓存目录下旧的 headers</td>\n  </tr>\n  <tr>\n    <td>clean/clean all</td>\n    <td>清除缓存目录下的软件包及旧的headers</td>\n  </tr>\n  <tr>\n    <td>package</td>\n    <td colspan=\"2\">操作的对象</td>\n  </tr>\n</table>\n\n\n\n# 命令大全\n\n| **1、文件管理**                                              |                                                              |                                                              |                                                              |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [cat](http://www.runoob.com/linux/linux-comm-cat.html)       | [chattr](http://www.runoob.com/linux/linux-comm-chattr.html) | [chgrp](http://www.runoob.com/linux/linux-comm-chgrp.html)   | [chmod](http://www.runoob.com/linux/linux-comm-chmod.html)   |\n| [chown](http://www.runoob.com/linux/linux-comm-chown.html)   | [cksum](http://www.runoob.com/linux/linux-comm-cksum.html)   | [cmp](http://www.runoob.com/linux/linux-comm-cmp.html)       | [diff](http://www.runoob.com/linux/linux-comm-diff.html)     |\n| [diffstat](http://www.runoob.com/linux/linux-comm-diffstat.html) | [file](http://www.runoob.com/linux/linux-comm-file.html)     | [find](http://www.runoob.com/linux/linux-comm-find.html)     | [git](http://www.runoob.com/linux/linux-comm-git.html)       |\n| [gitview](http://www.runoob.com/linux/linux-comm-gitview.html) | [indent](http://www.runoob.com/linux/linux-comm-indent.html) | [cut](http://www.runoob.com/linux/linux-comm-cut.html)       | [ln](http://www.runoob.com/linux/linux-comm-ln.html)         |\n| [less](http://www.runoob.com/linux/linux-comm-less.html)     | [locate](http://www.runoob.com/linux/linux-comm-locate.html) | [lsattr](http://www.runoob.com/linux/linux-comm-lsattr.html) | [mattrib](http://www.runoob.com/linux/linux-comm-mattrib.html) |\n| [mc](http://www.runoob.com/linux/linux-comm-mc.html)         | [mdel](http://www.runoob.com/linux/linux-comm-mdel.html)     | [mdir](http://www.runoob.com/linux/linux-comm-mdir.html)     | [mktemp](http://www.runoob.com/linux/linux-comm-mktemp.html) |\n| [more](http://www.runoob.com/linux/linux-comm-more.html)     | [mmove](http://www.runoob.com/linux/linux-comm-mmove.html)   | [mread](http://www.runoob.com/linux/linux-comm-mread.html)   | [mren](http://www.runoob.com/linux/linux-comm-mren.html)     |\n| [mtools](http://www.runoob.com/linux/linux-comm-mtools.html) | [mtoolstest](http://www.runoob.com/linux/linux-comm-mtoolstest.html) | [mv](http://www.runoob.com/linux/linux-comm-mv.html)         | [od](http://www.runoob.com/linux/linux-comm-od.html)         |\n| [paste](http://www.runoob.com/linux/linux-comm-paste.html)   | [patch](http://www.runoob.com/linux/linux-comm-patch.html)   | [rcp](http://www.runoob.com/linux/linux-comm-rcp.html)       | [rm](http://www.runoob.com/linux/linux-comm-rm.html)         |\n| [slocate](http://www.runoob.com/linux/linux-comm-slocate.html) | [split](http://www.runoob.com/linux/linux-comm-split.html)   | [tee](http://www.runoob.com/linux/linux-comm-tee.html)       | [tmpwatch](http://www.runoob.com/linux/linux-comm-tmpwatch.html) |\n| [touch](http://www.runoob.com/linux/linux-comm-touch.html)   | [umask](http://www.runoob.com/linux/linux-comm-umask.html)   | [which](http://www.runoob.com/linux/linux-comm-which.html)   | [cp](http://www.runoob.com/linux/linux-comm-cp.html)         |\n| [whereis](http://www.runoob.com/linux/linux-comm-whereis.html) | [mcopy](http://www.runoob.com/linux/linux-comm-mcopy.html)   | [mshowfat](http://www.runoob.com/linux/linux-comm-mshowfat.html) | [rhmask](http://www.runoob.com/linux/linux-comm-rhmask.html) |\n| [scp](http://www.runoob.com/linux/linux-comm-scp.html)       | [awk](http://www.runoob.com/linux/linux-comm-awk.html)       | [read](http://www.runoob.com/linux/linux-comm-read.html)     | [updatedb](http://www.runoob.com/linux/linux-comm-updatedb.html) |\n| **2、文档编辑**                                              |                                                              |                                                              |                                                              |\n| [col](http://www.runoob.com/linux/linux-comm-col.html)       | [colrm](http://www.runoob.com/linux/linux-comm-colrm.html)   | [comm](http://www.runoob.com/linux/linux-comm-comm.html)     | [csplit](http://www.runoob.com/linux/linux-comm-csplit.html) |\n| [ed](http://www.runoob.com/linux/linux-comm-ed.html)         | [egrep](http://www.runoob.com/linux/linux-comm-egrep.html)   | [ex](http://www.runoob.com/linux/linux-comm-ex.html)         | [fgrep](http://www.runoob.com/linux/linux-comm-fgrep.html)   |\n| [fmt](http://www.runoob.com/linux/linux-comm-fmt.html)       | [fold](http://www.runoob.com/linux/linux-comm-fold.html)     | [grep](http://www.runoob.com/linux/linux-comm-grep.html)     | [ispell](http://www.runoob.com/linux/linux-comm-ispell.html) |\n| [jed](http://www.runoob.com/linux/linux-comm-jed.html)       | [joe](http://www.runoob.com/linux/linux-comm-joe.html)       | [join](http://www.runoob.com/linux/linux-comm-join.html)     | [look](http://www.runoob.com/linux/linux-comm-look.html)     |\n| [mtype](http://www.runoob.com/linux/linux-comm-mtype.html)   | [pico](http://www.runoob.com/linux/linux-comm-pico.html)     | [rgrep](http://www.runoob.com/linux/linux-comm-rgrep.html)   | [sed](http://www.runoob.com/linux/linux-comm-sed.html)       |\n| [sort](http://www.runoob.com/linux/linux-comm-sort.html)     | [spell](http://www.runoob.com/linux/linux-comm-spell.html)   | [tr](http://www.runoob.com/linux/linux-comm-tr.html)         | [expr](http://www.runoob.com/linux/linux-comm-expr.html)     |\n| [uniq](http://www.runoob.com/linux/linux-comm-uniq.html)     | [wc](http://www.runoob.com/linux/linux-comm-wc.html)         | [let](http://www.runoob.com/linux/linux-comm-let.html)       |                                                              |\n| **3、文件传输**                                              |                                                              |                                                              |                                                              |\n| [lprm](http://www.runoob.com/linux/linux-comm-lprm.html)     | [lpr](http://www.runoob.com/linux/linux-comm-lpr.html)       | [lpq](http://www.runoob.com/linux/linux-comm-lpq.html)       | [lpd](http://www.runoob.com/linux/linux-comm-lpd.html)       |\n| [bye](http://www.runoob.com/linux/linux-comm-bye.html)       | [ftp](http://www.runoob.com/linux/linux-comm-ftp.html)       | [uuto](http://www.runoob.com/linux/linux-comm-uuto.html)     | [uupick](http://www.runoob.com/linux/linux-comm-uupick.html) |\n| [uucp](http://www.runoob.com/linux/linux-comm-uucp.html)     | [uucico](http://www.runoob.com/linux/linux-comm-uucico.html) | [tftp](http://www.runoob.com/linux/linux-comm-tftp.html)     | [ncftp](http://www.runoob.com/linux/linux-comm-ncftp.html)   |\n| [ftpshut](http://www.runoob.com/linux/linux-comm-ftpshut.html) | [ftpwho](http://www.runoob.com/linux/linux-comm-ftpwho.html) | [ftpcount](http://www.runoob.com/linux/linux-comm-ftpcount.html) |                                                              |\n| **4、磁盘管理**                                              |                                                              |                                                              |                                                              |\n| [cd](http://www.runoob.com/linux/linux-comm-cd.html)         | [df](http://www.runoob.com/linux/linux-comm-df.html)         | [dirs](http://www.runoob.com/linux/linux-comm-dirs.html)     | [du](http://www.runoob.com/linux/linux-comm-du.html)         |\n| [edquota](http://www.runoob.com/linux/linux-comm-edquota.html) | [eject](http://www.runoob.com/linux/linux-comm-eject.html)   | [mcd](http://www.runoob.com/linux/linux-comm-mcd.html)       | [mdeltree](http://www.runoob.com/linux/linux-comm-mdeltree.html) |\n| [mdu](http://www.runoob.com/linux/linux-comm-mdu.html)       | [mkdir](http://www.runoob.com/linux/linux-comm-mkdir.html)   | [mlabel](http://www.runoob.com/linux/linux-comm-mlabel.html) | [mmd](http://www.runoob.com/linux/linux-comm-mmd.html)       |\n| [mrd](http://www.runoob.com/linux/linux-comm-mrd.html)       | [mzip](http://www.runoob.com/linux/linux-comm-mzip.html)     | [pwd](http://www.runoob.com/linux/linux-comm-pwd.html)       | [quota](http://www.runoob.com/linux/linux-comm-quota.html)   |\n| [mount](http://www.runoob.com/linux/linux-comm-mount.html)   | [mmount](http://www.runoob.com/linux/linux-comm-mmount.html) | [rmdir](http://www.runoob.com/linux/linux-comm-rmdir.html)   | [rmt](http://www.runoob.com/linux/linux-comm-rmt.html)       |\n| [stat](http://www.runoob.com/linux/linux-comm-stat.html)     | [tree](http://www.runoob.com/linux/linux-comm-tree.html)     | [umount](http://www.runoob.com/linux/linux-comm-umount.html) | [ls](http://www.runoob.com/linux/linux-comm-ls.html)         |\n| [quotacheck](http://www.runoob.com/linux/linux-comm-quotacheck.html) | [quotaoff](http://www.runoob.com/linux/linux-comm-quotaoff.html) | [lndir](http://www.runoob.com/linux/linux-comm-lndir.html)   | [repquota](http://www.runoob.com/linux/linux-comm-repquota.html) |\n| [quotaon](http://www.runoob.com/linux/linux-comm-quotaon.html) |                                                              |                                                              |                                                              |\n| **5、磁盘维护**                                              |                                                              |                                                              |                                                              |\n| [badblocks](http://www.runoob.com/linux/linux-comm-badblocks.html) | [cfdisk](http://www.runoob.com/linux/linux-comm-cfdisk.html) | [dd](http://www.runoob.com/linux/linux-comm-dd.html)         | [e2fsck](http://www.runoob.com/linux/linux-comm-e2fsck.html) |\n| [ext2ed](http://www.runoob.com/linux/linux-comm-ext2ed.html) | [fsck](http://www.runoob.com/linux/linux-comm-fsck.html)     | [fsck.minix](http://www.runoob.com/linux/linux-comm-fsck-minix.html) | [fsconf](http://www.runoob.com/linux/linux-comm-fsconf.html) |\n| [fdformat](http://www.runoob.com/linux/linux-comm-fdformat.html) | [hdparm](http://www.runoob.com/linux/linux-comm-hdparm.html) | [mformat](http://www.runoob.com/linux/linux-comm-mformat.html) | [mkbootdisk](http://www.runoob.com/linux/linux-comm-mkbootdisk.html) |\n| [mkdosfs](http://www.runoob.com/linux/linux-comm-mkdosfs.html) | [mke2fs](http://www.runoob.com/linux/linux-comm-mke2fs.html) | [mkfs.ext2](http://www.runoob.com/linux/linux-comm-mkfs-ext2.html) | [mkfs.msdos](http://www.runoob.com/linux/linux-comm-mkfs-msdos.html) |\n| [mkinitrd](http://www.runoob.com/linux/linux-comm-mkinitrd.html) | [mkisofs](http://www.runoob.com/linux/linux-comm-mkisofs.html) | [mkswap](http://www.runoob.com/linux/linux-comm-mkswap.html) | [mpartition](http://www.runoob.com/linux/linux-comm-mpartition.html) |\n| [swapon](http://www.runoob.com/linux/linux-comm-swapon.html) | [symlinks](http://www.runoob.com/linux/linux-comm-symlinks.html) | [sync](http://www.runoob.com/linux/linux-comm-sync.html)     | [mbadblocks](http://www.runoob.com/linux/linux-comm-mbadblocks.html) |\n| [mkfs.minix](http://www.runoob.com/linux/linux-comm-mkfs-minix.html) | [fsck.ext2](http://www.runoob.com/linux/linux-comm-fsck-ext2.html) | [fdisk](http://www.runoob.com/linux/linux-comm-fdisk.html)   | [losetup](http://www.runoob.com/linux/linux-comm-losetup.html) |\n| [mkfs](http://www.runoob.com/linux/linux-comm-mkfs.html)     | [sfdisk](http://www.runoob.com/linux/linux-comm-sfdisk.html) | [swapoff](http://www.runoob.com/linux/linux-comm-swapoff.html) |                                                              |\n| **6、网络通讯**                                              |                                                              |                                                              |                                                              |\n| [apachectl](http://www.runoob.com/linux/linux-comm-apachectl.html) | [arpwatch](http://www.runoob.com/linux/linux-comm-arpwatch.html) | [dip](http://www.runoob.com/linux/linux-comm-dip.html)       | [getty](http://www.runoob.com/linux/linux-comm-getty.html)   |\n| [mingetty](http://www.runoob.com/linux/linux-comm-mingetty.html) | [uux](http://www.runoob.com/linux/linux-comm-uux.html)       | [telnet](http://www.runoob.com/linux/linux-comm-telnet.html) | [uulog](http://www.runoob.com/linux/linux-comm-uulog.html)   |\n| [uustat](http://www.runoob.com/linux/linux-comm-uustat.html) | [ppp-off](http://www.runoob.com/linux/linux-comm-ppp-off.html) | [netconfig](http://www.runoob.com/linux/linux-comm-netconfig.html) | [nc](http://www.runoob.com/linux/linux-comm-nc.html)         |\n| [httpd](http://www.runoob.com/linux/linux-comm-httpd.html)   | [ifconfig](http://www.runoob.com/linux/linux-comm-ifconfig.html) | [minicom](http://www.runoob.com/linux/linux-comm-minicom.html) | [mesg](http://www.runoob.com/linux/linux-comm-mesg.html)     |\n| [dnsconf](http://www.runoob.com/linux/linux-comm-dnsconf.html) | [wall](http://www.runoob.com/linux/linux-comm-wall.html)     | [netstat](http://www.runoob.com/linux/linux-comm-netstat.html) | [ping](http://www.runoob.com/linux/linux-comm-ping.html)     |\n| [pppstats](http://www.runoob.com/linux/linux-comm-pppstats.html) | [samba](http://www.runoob.com/linux/linux-comm-samba.html)   | [setserial](http://www.runoob.com/linux/linux-comm-setserial.html) | [talk](http://www.runoob.com/linux/linux-comm-talk.html)     |\n| [traceroute](http://www.runoob.com/linux/linux-comm-traceroute.html) | [tty](http://www.runoob.com/linux/linux-comm-tty.html)       | [newaliases](http://www.runoob.com/linux/linux-comm-newaliases.html) | [uuname](http://www.runoob.com/linux/linux-comm-uuname.html) |\n| [netconf](http://www.runoob.com/linux/linux-comm-netconf.html) | [write](http://www.runoob.com/linux/linux-comm-write.html)   | [statserial](http://www.runoob.com/linux/linux-comm-statserial.html) | [efax](http://www.runoob.com/linux/linux-comm-efax.html)     |\n| [pppsetup](http://www.runoob.com/linux/linux-comm-pppsetup.html) | [tcpdump](http://www.runoob.com/linux/linux-comm-tcpdump.html) | [ytalk](http://www.runoob.com/linux/linux-comm-ytalk.html)   | [cu](http://www.runoob.com/linux/linux-comm-cu.html)         |\n| [smbd](http://www.runoob.com/linux/linux-comm-smbd.html)     | [testparm](http://www.runoob.com/linux/linux-comm-testparm.html) | [smbclient](http://www.runoob.com/linux/linux-comm-smbclient.html) | [shapecfg](http://www.runoob.com/linux/linux-comm-shapecfg.html) |\n| **7、系统管理**                                              |                                                              |                                                              |                                                              |\n| [adduser](http://www.runoob.com/linux/linux-comm-adduser.html) | [chfn](http://www.runoob.com/linux/linux-comm-chfn.html)     | [useradd](http://www.runoob.com/linux/linux-comm-useradd.html) | [date](http://www.runoob.com/linux/linux-comm-date.html)     |\n| [exit](http://www.runoob.com/linux/linux-comm-exit.html)     | [finger](http://www.runoob.com/linux/linux-comm-finger.html) | [fwhios](http://www.runoob.com/linux/linux-comm-fwhios.html) | [sleep](http://www.runoob.com/linux/linux-comm-sleep.html)   |\n| [suspend](http://www.runoob.com/linux/linux-comm-suspend.html) | [groupdel](http://www.runoob.com/linux/linux-comm-groupdel.html) | [groupmod](http://www.runoob.com/linux/linux-comm-groupmod.html) | [halt](http://www.runoob.com/linux/linux-comm-halt.html)     |\n| [kill](http://www.runoob.com/linux/linux-comm-kill.html)     | [last](http://www.runoob.com/linux/linux-comm-last.html)     | [lastb](http://www.runoob.com/linux/linux-comm-lastb.html)   | [login](http://www.runoob.com/linux/linux-comm-login.html)   |\n| [logname](http://www.runoob.com/linux/linux-comm-logname.html) | [logout](http://www.runoob.com/linux/linux-comm-logout.html) | [ps](http://www.runoob.com/linux/linux-comm-ps.html)         | [nice](http://www.runoob.com/linux/linux-comm-nice.html)     |\n| [procinfo](http://www.runoob.com/linux/linux-comm-procinfo.html) | [top](http://www.runoob.com/linux/linux-comm-top.html)       | [pstree](http://www.runoob.com/linux/linux-comm-pstree.html) | [reboot](http://www.runoob.com/linux/linux-comm-reboot.html) |\n| [rlogin](http://www.runoob.com/linux/linux-comm-rlogin.html) | [rsh](http://www.runoob.com/linux/linux-comm-rsh.html)       | [sliplogin](http://www.runoob.com/linux/linux-comm-sliplogin.html) | [screen](http://www.runoob.com/linux/linux-comm-screen.html) |\n| [shutdown](http://www.runoob.com/linux/linux-comm-shutdown.html) | [rwho](http://www.runoob.com/linux/linux-comm-rwho.html)     | [sudo](http://www.runoob.com/linux/linux-comm-sudo.html)     | [gitps](http://www.runoob.com/linux/linux-comm-gitps.html)   |\n| [swatch](http://www.runoob.com/linux/linux-comm-swatch.html) | [tload](http://www.runoob.com/linux/linux-comm-tload.html)   | [logrotate](http://www.runoob.com/linux/linux-comm-logrotate.html) | [uname](http://www.runoob.com/linux/linux-comm-uname.html)   |\n| [chsh](http://www.runoob.com/linux/linux-comm-chsh.html)     | [userconf](http://www.runoob.com/linux/linux-comm-userconf.html) | [userdel](http://www.runoob.com/linux/linux-comm-userdel.html) | [usermod](http://www.runoob.com/linux/linux-comm-usermod.html) |\n| [vlock](http://www.runoob.com/linux/linux-comm-vlock.html)   | [who](http://www.runoob.com/linux/linux-comm-who.html)       | [whoami](http://www.runoob.com/linux/linux-comm-whoami.html) | [whois](http://www.runoob.com/linux/linux-comm-whois.html)   |\n| [newgrp](http://www.runoob.com/linux/linux-comm-newgrp.html) | [renice](http://www.runoob.com/linux/linux-comm-renice.html) | [su](http://www.runoob.com/linux/linux-comm-su.html)         | [skill](http://www.runoob.com/linux/linux-comm-skill.html)   |\n| [w](http://www.runoob.com/linux/linux-comm-w.html)           | [id](http://www.runoob.com/linux/linux-comm-id.html)         | [free](http://www.runoob.com/linux/linux-comm-free.html)     |                                                              |\n| **8、系统设置**                                              |                                                              |                                                              |                                                              |\n| [reset](http://www.runoob.com/linux/linux-comm-reset.html)   | [clear](http://www.runoob.com/linux/linux-comm-clear.html)   | [alias](http://www.runoob.com/linux/linux-comm-alias.html)   | [dircolors](http://www.runoob.com/linux/linux-comm-dircolors.html) |\n| [aumix](http://www.runoob.com/linux/linux-comm-aumix.html)   | [bind](http://www.runoob.com/linux/linux-comm-bind.html)     | [chroot](http://www.runoob.com/linux/linux-comm-chroot.html) | [clock](http://www.runoob.com/linux/linux-comm-clock.html)   |\n| [crontab](http://www.runoob.com/linux/linux-comm-crontab.html) | [declare](http://www.runoob.com/linux/linux-comm-declare.html) | [depmod](http://www.runoob.com/linux/linux-comm-depmod.html) | [dmesg](http://www.runoob.com/linux/linux-comm-dmesg.html)   |\n| [enable](http://www.runoob.com/linux/linux-comm-enable.html) | [eval](http://www.runoob.com/linux/linux-comm-eval.html)     | [export](http://www.runoob.com/linux/linux-comm-export.html) | [pwunconv](http://www.runoob.com/linux/linux-comm-pwunconv.html) |\n| [grpconv](http://www.runoob.com/linux/linux-comm-grpconv.html) | [rpm](http://www.runoob.com/linux/linux-comm-rpm.html)       | [insmod](http://www.runoob.com/linux/linux-comm-insmod.html) | [kbdconfig](http://www.runoob.com/linux/linux-comm-kbdconfig.html) |\n| [lilo](http://www.runoob.com/linux/linux-comm-lilo.html)     | [liloconfig](http://www.runoob.com/linux/linux-comm-liloconfig.html) | [lsmod](http://www.runoob.com/linux/linux-comm-lsmod.html)   | [minfo](http://www.runoob.com/linux/linux-comm-minfo.html)   |\n| [set](http://www.runoob.com/linux/linux-comm-set.html)       | [modprobe](http://www.runoob.com/linux/linux-comm-modprobe.html) | [ntsysv](http://www.runoob.com/linux/linux-comm-ntsysv.html) | [mouseconfig](http://www.runoob.com/linux/linux-comm-mouseconfig.html) |\n| [passwd](http://www.runoob.com/linux/linux-comm-passwd.html) | [pwconv](http://www.runoob.com/linux/linux-comm-pwconv.html) | [rdate](http://www.runoob.com/linux/linux-comm-rdate.html)   | [resize](http://www.runoob.com/linux/linux-comm-resize.html) |\n| [rmmod](http://www.runoob.com/linux/linux-comm-rmmod.html)   | [grpunconv](http://www.runoob.com/linux/linux-comm-grpunconv.html) | [modinfo](http://www.runoob.com/linux/linux-comm-modinfo.html) | [time](http://www.runoob.com/linux/linux-comm-time.html)     |\n| [setup](http://www.runoob.com/linux/linux-comm-setup.html)   | [sndconfig](http://www.runoob.com/linux/linux-comm-sndconfig.html) | [setenv](http://www.runoob.com/linux/linux-comm-setenv.html) | [setconsole](http://www.runoob.com/linux/linux-comm-setconsole.html) |\n| [timeconfig](http://www.runoob.com/linux/linux-comm-timeconfig.html) | [ulimit](http://www.runoob.com/linux/linux-comm-ulimit.html) | [unset](http://www.runoob.com/linux/linux-comm-unset.html)   | [chkconfig](http://www.runoob.com/linux/linux-comm-chkconfig.html) |\n| [apmd](http://www.runoob.com/linux/linux-comm-apmd.html)     | [hwclock](http://www.runoob.com/linux/linux-comm-hwclock.html) | [mkkickstart](http://www.runoob.com/linux/linux-comm-mkkickstart.html) | [fbset](http://www.runoob.com/linux/linux-comm-fbset.html)   |\n| [unalias](http://www.runoob.com/linux/linux-comm-unalias.html) | [SVGATextMode](http://www.runoob.com/linux/linux-comm-svgatextmode.html) |                                                              |                                                              |\n| **9、备份压缩**                                              |                                                              |                                                              |                                                              |\n| [ar](http://www.runoob.com/linux/linux-comm-ar.html)         | [bunzip2](http://www.runoob.com/linux/linux-comm-bunzip2.html) | [bzip2](http://www.runoob.com/linux/linux-comm-bzip2.html)   | [bzip2recover](http://www.runoob.com/linux/linux-comm-bzip2recover.html) |\n| [gunzip](http://www.runoob.com/linux/linux-comm-gunzip.html) | [unarj](http://www.runoob.com/linux/linux-comm-unarj.html)   | [compress](http://www.runoob.com/linux/linux-comm-compress.html) | [cpio](http://www.runoob.com/linux/linux-comm-cpio.html)     |\n| [dump](http://www.runoob.com/linux/linux-comm-dump.html)     | [uuencode](http://www.runoob.com/linux/linux-comm-uuencode.html) | [gzexe](http://www.runoob.com/linux/linux-comm-gzexe.html)   | [gzip](http://www.runoob.com/linux/linux-comm-gzip.html)     |\n| [lha](http://www.runoob.com/linux/linux-comm-lha.html)       | [restore](http://www.runoob.com/linux/linux-comm-restore.html) | [tar](http://www.runoob.com/linux/linux-comm-tar.html)       | [uudecode](http://www.runoob.com/linux/linux-comm-uudecode.html) |\n| [unzip](http://www.runoob.com/linux/linux-comm-unzip.html)   | [zip](http://www.runoob.com/linux/linux-comm-zip.html)       | [zipinfo](http://www.runoob.com/linux/linux-comm-zipinfo.html) |                                                              |\n| **10、设备管理**                                             |                                                              |                                                              |                                                              |\n| [setleds](http://www.runoob.com/linux/linux-comm-setleds.html) | [loadkeys](http://www.runoob.com/linux/linux-comm-loadkeys.html) | [rdev](http://www.runoob.com/linux/linux-comm-rdev.html)     | [dumpkeys](http://www.runoob.com/linux/linux-comm-dumpkeys.html) |\n| [MAKEDEV](http://www.runoob.com/linux/linux-comm-makedev.html) |                                                              |                                                              |                                                              |","slug":"linux命令","published":1,"updated":"2019-08-05T02:33:00.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iz5002shomjud74dujb","content":"<h1 id=\"文件基本属性\"><a href=\"#文件基本属性\" class=\"headerlink\" title=\"文件基本属性\"></a>文件基本属性</h1><h2 id=\"文件属性说明\"><a href=\"#文件属性说明\" class=\"headerlink\" title=\"文件属性说明\"></a>文件属性说明</h2><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。<strong>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"查看文件属性\"><a href=\"#查看文件属性\" class=\"headerlink\" title=\"查看文件属性\"></a>查看文件属性</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class=\"line\">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>第一个字符</th>\n<th>属主</th>\n<th>属组</th>\n<th>其他用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>d</strong>   目录<br><strong>-</strong>    文件<br><strong>l</strong>    链接文档(link file)<br><strong>b</strong>   装置文件里面的可供储存的接口设备(可随机存取装置)<br><strong>c</strong>   装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</td>\n<td>r   读<br>w  写<br>x   执行</td>\n<td>r   读<br>w  写<br>x   执行</td>\n<td>r   读<br>w  写<br>x   执行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"更改文件属性\"><a href=\"#更改文件属性\" class=\"headerlink\" title=\"更改文件属性\"></a>更改文件属性</h2><table>\n  <tr>\n    <th>功能</th>\n    <th colspan=\"5\">方法</th>\n  </tr>\n  <tr>\n    <td>更改文件属组</td>\n    <td colspan=\"5\">chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">更改文件属主</td>\n    <td colspan=\"5\">chown [–R] 属主名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown bin install.log`</td>\n  </tr>\n  <tr>\n    <td colspan=\"5\">chown [-R] 属主名：属组名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown root:root install.log`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">更改文件属性</td>\n    <td colspan=\"5\">Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</td>\n  </tr>\n  <tr>\n    <td>第一种方式</td>\n    <td colspan=\"4\">chmod [-R] xyz 文件或目录<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更<br>xyz : 就是刚刚提到的数字类型的权限属性<br><br>` chmod 777 test`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">第二种方式</td>\n    <td>u&nbsp;&nbsp;&nbsp;属主<br>g&nbsp;&nbsp;&nbsp;同组<br>o&nbsp;&nbsp;&nbsp;其他<br>a&nbsp;&nbsp;&nbsp;所有</td>\n    <td>+(加入)<br>-(除去)<br>=(设定)</td>\n    <td>r<br>w<br>x</td>\n    <td>文件或目录</td>\n  </tr>\n  <tr>\n    <td colspan=\"4\">`chmod u=rwx,g=rx,o=r&nbsp;&nbsp;test` </td>\n  </tr>\n</table>\n\n\n\n<h1 id=\"文件与目录管理\"><a href=\"#文件与目录管理\" class=\"headerlink\" title=\"文件与目录管理\"></a>文件与目录管理</h1><p>Linux的目录结构为树状结构，最顶级的目录为根目录 /。其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ls</td>\n<td><strong>列出目录</strong><br>a: 全部的文件，连同隐藏文件（开头为.的文件）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</td>\n</tr>\n<tr>\n<td>cd</td>\n<td><strong>切换目录</strong><br># cd ~       # 表示回到自己的家目录，亦即是 /root 这个目录</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td><strong>显示目前的目录</strong><br>-P ：显示出确实的路径，而非使用连结 (link) 路径。</td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td><strong>创建一个新的目录</strong><br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</td>\n</tr>\n<tr>\n<td>rmdir</td>\n<td>删除一个空的目录<br>-p ：连同上一级『空的』目录也一起删除</td>\n</tr>\n<tr>\n<td>cp</td>\n<td><strong>复制文件或目录</strong><br>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)<br>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；<br>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；<br>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br>-r：递归持续复制，用於目录的复制行为；(常用)<br>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；<br>-u：若 destination 比 source 旧才升级 destination ！</td>\n</tr>\n<tr>\n<td>rm</td>\n<td><strong>移除文件或目录</strong><br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</td>\n</tr>\n<tr>\n<td>mv</td>\n<td><strong>移动文件与目录，或修改文件与目录的名称</strong><br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"用户与用户组\"><a href=\"#用户与用户组\" class=\"headerlink\" title=\"用户与用户组\"></a>用户与用户组</h1><h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>useradd</td>\n<td><strong>添加新的用户账号</strong>    <code>useradd -s /bin/sh -g group –G adm,root gem</code><br><code>useradd 选项 用户名</code><br>-c   comment 指定一段注释性描述。<br>-d  目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g  用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s  Shell文件 指定用户的登录Shell。<br>-u  用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</td>\n</tr>\n<tr>\n<td>userdel</td>\n<td><strong>删除帐号</strong>   <code>userdel -r sam</code><br>-r：把用户的主目录一起删除</td>\n</tr>\n<tr>\n<td>usermod</td>\n<td>修改帐号   <code>usermod -s /bin/ksh -d /home/z –g developer sam</code><br><code>usermod 选项 用户名</code><br>包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样</td>\n</tr>\n<tr>\n<td>passwd</td>\n<td>用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。<br><code>passwd 选项 用户名</code><br>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令。<br>-f 强迫用户下次登录时修改口令。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"用户组管理\"><a href=\"#用户组管理\" class=\"headerlink\" title=\"用户组管理\"></a>用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<strong>/etc/group</strong>文件的更新</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>groupadd</td>\n<td><strong>增加一个新的用户组</strong><br>-g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</td>\n</tr>\n<tr>\n<td>groupdel</td>\n<td>删除一个已有的用户组</td>\n</tr>\n<tr>\n<td>groupmod</td>\n<td><strong>修改用户组的属性</strong><br>-g GID 为用户组指定新的组标识号。<br>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br>-n新用户组 将用户组的名字改为新名字</td>\n</tr>\n<tr>\n<td>newgrp</td>\n<td><strong>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</strong><br><figure class=\"highlight plain\"><figcaption><span>root``` |</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 与用户账号有关的系统文件</span><br><span class=\"line\"></span><br><span class=\"line\">完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</span><br><span class=\"line\"></span><br><span class=\"line\">### 伪用户</span><br><span class=\"line\"></span><br><span class=\"line\">这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示：</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">伪 用 户 含 义 </span><br><span class=\"line\">bin 拥有可执行的用户命令文件 </span><br><span class=\"line\">sys 拥有系统文件 </span><br><span class=\"line\">adm 拥有帐户文件 </span><br><span class=\"line\">uucp UUCP使用 </span><br><span class=\"line\">lp lp或lpd子系统使用 </span><br><span class=\"line\">nobody NFS使用</span><br></pre></td></tr></table></figure></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户管理文件-etc-passwd\"><a href=\"#用户管理文件-etc-passwd\" class=\"headerlink\" title=\"用户管理文件-/etc/passwd\"></a>用户管理文件-/etc/passwd</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br><span class=\"line\">root:x:0:0:Superuser:/:</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">口令</td>\n<td>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux   系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">用户标识号</td>\n<td>系统内部用它来标识用户，一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">组标识号</td>\n<td>记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">注释性描述</td>\n<td>记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等，</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主目录</td>\n<td>用户的起始工作目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">登陆shell</td>\n<td>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户管理文件-etc-shadow\"><a href=\"#用户管理文件-etc-shadow\" class=\"headerlink\" title=\"用户管理文件-/etc/shadow\"></a>用户管理文件-/etc/shadow</h3><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志   root:Dnakfw28zf38w:8764:0:168:7:::</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>登录名</td>\n<td>与/etc/passwd文件中的登录名相一致的用户账号</td>\n</tr>\n<tr>\n<td>口令</td>\n<td>存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合   { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</td>\n</tr>\n<tr>\n<td>最后一次修改时间</td>\n<td>从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO   Linux 中，这个时间起点是1970年1月1日。</td>\n</tr>\n<tr>\n<td>最小时间间隔</td>\n<td>是两次修改口令之间所需的最小天数。</td>\n</tr>\n<tr>\n<td>最大时间间隔</td>\n<td>口令保持有效的最大天数。</td>\n</tr>\n<tr>\n<td>警告时间</td>\n<td>从系统开始警告用户到用户密码正式失效之间的天数。</td>\n</tr>\n<tr>\n<td>不活动时间</td>\n<td>用户没有登录活动但账号仍能保持有效的最大天数。</td>\n</tr>\n<tr>\n<td>失效时间</td>\n<td>给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户组管理文件-etc-group\"><a href=\"#用户组管理文件-etc-group\" class=\"headerlink\" title=\"用户组管理文件-/etc/group\"></a>用户组管理文件-/etc/group</h3><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组名:口令:组标识号:组内用户列表</span><br><span class=\"line\">root::0:root</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组名</td>\n<td>用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</td>\n</tr>\n<tr>\n<td>口令存</td>\n<td>用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。</td>\n</tr>\n<tr>\n<td>组标识号</td>\n<td>与用户标识号类似，也是一个整数，被系统内部用来标识组。</td>\n</tr>\n<tr>\n<td>组内用户列表</td>\n<td>属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"添加批量用户\"><a href=\"#添加批量用户\" class=\"headerlink\" title=\"添加批量用户\"></a>添加批量用户</h2><ol>\n<li><p>先编辑一个文本用户文件。</p>\n<p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user001::600:100:user:/home/user001:/bin/bash</span><br><span class=\"line\">user002::601:100:user:/home/user002:/bin/bash</span><br><span class=\"line\">user003::602:100:user:/home/user003:/bin/bash</span><br><span class=\"line\">user004::603:100:user:/home/user004:/bin/bash</span><br><span class=\"line\">user005::604:100:user:/home/user005:/bin/bash</span><br><span class=\"line\">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newusers &lt; user.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令/usr/sbin/pwunconv</p>\n<p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwunconv</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑每个用户的密码对照文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user001:密码</span><br><span class=\"line\">user002:密码</span><br><span class=\"line\">user003:密码</span><br><span class=\"line\">user004:密码</span><br><span class=\"line\">user005:密码</span><br><span class=\"line\">user006:密码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以root身份执行命令 <code>/usr/sbin/chpasswd</code></p>\n<p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确定密码经编码写入/etc/passwd的密码栏后。</p>\n<p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwconv</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"yum-命令-包管理\"><a href=\"#yum-命令-包管理\" class=\"headerlink\" title=\"yum 命令-包管理\"></a>yum 命令-包管理</h1><ul>\n<li><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件<strong>包管理器</strong>。</p>\n</li>\n<li><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n</li>\n<li><p>yum提供了<strong>查找、安装、删除</strong>某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">options</td>\n    <td>-h</td>\n    <td>帮助</td>\n  </tr>\n  <tr>\n    <td>-y</td>\n    <td>当安装过程提示选择全部为\"yes\"</td>\n  </tr>\n  <tr>\n    <td>-q</td>\n    <td>不显示安装的过程</td>\n  </tr>\n  <tr>\n    <td rowspan=\"11\">command</td>\n    <td>check-update</td>\n    <td>列出所有可更新的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>update</td>\n    <td>更新所有软件命令</td>\n  </tr>\n  <tr>\n    <td>update&lt;package_name&gt;</td>\n    <td>仅更新指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>install &lt;package_name&gt;</td>\n    <td>仅安装指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>list</td>\n    <td>列出所有可安裝的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>remove &lt;package_name&gt;</td>\n    <td>删除软件包命令</td>\n  </tr>\n  <tr>\n    <td>search <br>&lt;keyword&gt;</td>\n    <td>查找软件包命令</td>\n  </tr>\n  <tr>\n    <td>clean packages</td>\n    <td>清除缓存目录下的软件包</td>\n  </tr>\n  <tr>\n    <td>clean headers</td>\n    <td>清除缓存目录下的 headers</td>\n  </tr>\n  <tr>\n    <td>clean oldheaders</td>\n    <td>清除缓存目录下旧的 headers</td>\n  </tr>\n  <tr>\n    <td>clean/clean all</td>\n    <td>清除缓存目录下的软件包及旧的headers</td>\n  </tr>\n  <tr>\n    <td>package</td>\n    <td colspan=\"2\">操作的对象</td>\n  </tr>\n</table>\n\n\n\n<h1 id=\"命令大全\"><a href=\"#命令大全\" class=\"headerlink\" title=\"命令大全\"></a>命令大全</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>1、文件管理</strong></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cat.html\" target=\"_blank\" rel=\"noopener\">cat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chattr.html\" target=\"_blank\" rel=\"noopener\">chattr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chgrp.html\" target=\"_blank\" rel=\"noopener\">chgrp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chmod.html\" target=\"_blank\" rel=\"noopener\">chmod</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chown.html\" target=\"_blank\" rel=\"noopener\">chown</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cksum.html\" target=\"_blank\" rel=\"noopener\">cksum</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cmp.html\" target=\"_blank\" rel=\"noopener\">cmp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-diff.html\" target=\"_blank\" rel=\"noopener\">diff</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-diffstat.html\" target=\"_blank\" rel=\"noopener\">diffstat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-file.html\" target=\"_blank\" rel=\"noopener\">file</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-find.html\" target=\"_blank\" rel=\"noopener\">find</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-git.html\" target=\"_blank\" rel=\"noopener\">git</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gitview.html\" target=\"_blank\" rel=\"noopener\">gitview</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-indent.html\" target=\"_blank\" rel=\"noopener\">indent</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cut.html\" target=\"_blank\" rel=\"noopener\">cut</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ln.html\" target=\"_blank\" rel=\"noopener\">ln</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-less.html\" target=\"_blank\" rel=\"noopener\">less</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-locate.html\" target=\"_blank\" rel=\"noopener\">locate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lsattr.html\" target=\"_blank\" rel=\"noopener\">lsattr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mattrib.html\" target=\"_blank\" rel=\"noopener\">mattrib</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mc.html\" target=\"_blank\" rel=\"noopener\">mc</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdel.html\" target=\"_blank\" rel=\"noopener\">mdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdir.html\" target=\"_blank\" rel=\"noopener\">mdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mktemp.html\" target=\"_blank\" rel=\"noopener\">mktemp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-more.html\" target=\"_blank\" rel=\"noopener\">more</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmove.html\" target=\"_blank\" rel=\"noopener\">mmove</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mread.html\" target=\"_blank\" rel=\"noopener\">mread</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mren.html\" target=\"_blank\" rel=\"noopener\">mren</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtools.html\" target=\"_blank\" rel=\"noopener\">mtools</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtoolstest.html\" target=\"_blank\" rel=\"noopener\">mtoolstest</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mv.html\" target=\"_blank\" rel=\"noopener\">mv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-od.html\" target=\"_blank\" rel=\"noopener\">od</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-paste.html\" target=\"_blank\" rel=\"noopener\">paste</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-patch.html\" target=\"_blank\" rel=\"noopener\">patch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rcp.html\" target=\"_blank\" rel=\"noopener\">rcp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rm.html\" target=\"_blank\" rel=\"noopener\">rm</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-slocate.html\" target=\"_blank\" rel=\"noopener\">slocate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-split.html\" target=\"_blank\" rel=\"noopener\">split</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tee.html\" target=\"_blank\" rel=\"noopener\">tee</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tmpwatch.html\" target=\"_blank\" rel=\"noopener\">tmpwatch</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-touch.html\" target=\"_blank\" rel=\"noopener\">touch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-umask.html\" target=\"_blank\" rel=\"noopener\">umask</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-which.html\" target=\"_blank\" rel=\"noopener\">which</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cp.html\" target=\"_blank\" rel=\"noopener\">cp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whereis.html\" target=\"_blank\" rel=\"noopener\">whereis</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mcopy.html\" target=\"_blank\" rel=\"noopener\">mcopy</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mshowfat.html\" target=\"_blank\" rel=\"noopener\">mshowfat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rhmask.html\" target=\"_blank\" rel=\"noopener\">rhmask</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-scp.html\" target=\"_blank\" rel=\"noopener\">scp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">awk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-read.html\" target=\"_blank\" rel=\"noopener\">read</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-updatedb.html\" target=\"_blank\" rel=\"noopener\">updatedb</a></td>\n</tr>\n<tr>\n<td><strong>2、文档编辑</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-col.html\" target=\"_blank\" rel=\"noopener\">col</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-colrm.html\" target=\"_blank\" rel=\"noopener\">colrm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-comm.html\" target=\"_blank\" rel=\"noopener\">comm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-csplit.html\" target=\"_blank\" rel=\"noopener\">csplit</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ed.html\" target=\"_blank\" rel=\"noopener\">ed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-egrep.html\" target=\"_blank\" rel=\"noopener\">egrep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ex.html\" target=\"_blank\" rel=\"noopener\">ex</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fgrep.html\" target=\"_blank\" rel=\"noopener\">fgrep</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fmt.html\" target=\"_blank\" rel=\"noopener\">fmt</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fold.html\" target=\"_blank\" rel=\"noopener\">fold</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grep.html\" target=\"_blank\" rel=\"noopener\">grep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ispell.html\" target=\"_blank\" rel=\"noopener\">ispell</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-jed.html\" target=\"_blank\" rel=\"noopener\">jed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-joe.html\" target=\"_blank\" rel=\"noopener\">joe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-join.html\" target=\"_blank\" rel=\"noopener\">join</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-look.html\" target=\"_blank\" rel=\"noopener\">look</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtype.html\" target=\"_blank\" rel=\"noopener\">mtype</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pico.html\" target=\"_blank\" rel=\"noopener\">pico</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rgrep.html\" target=\"_blank\" rel=\"noopener\">rgrep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sed.html\" target=\"_blank\" rel=\"noopener\">sed</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sort.html\" target=\"_blank\" rel=\"noopener\">sort</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-spell.html\" target=\"_blank\" rel=\"noopener\">spell</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tr.html\" target=\"_blank\" rel=\"noopener\">tr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-expr.html\" target=\"_blank\" rel=\"noopener\">expr</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uniq.html\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-wc.html\" target=\"_blank\" rel=\"noopener\">wc</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-let.html\" target=\"_blank\" rel=\"noopener\">let</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>3、文件传输</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lprm.html\" target=\"_blank\" rel=\"noopener\">lprm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpr.html\" target=\"_blank\" rel=\"noopener\">lpr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpq.html\" target=\"_blank\" rel=\"noopener\">lpq</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpd.html\" target=\"_blank\" rel=\"noopener\">lpd</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bye.html\" target=\"_blank\" rel=\"noopener\">bye</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftp.html\" target=\"_blank\" rel=\"noopener\">ftp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuto.html\" target=\"_blank\" rel=\"noopener\">uuto</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uupick.html\" target=\"_blank\" rel=\"noopener\">uupick</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uucp.html\" target=\"_blank\" rel=\"noopener\">uucp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uucico.html\" target=\"_blank\" rel=\"noopener\">uucico</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tftp.html\" target=\"_blank\" rel=\"noopener\">tftp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ncftp.html\" target=\"_blank\" rel=\"noopener\">ncftp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpshut.html\" target=\"_blank\" rel=\"noopener\">ftpshut</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpwho.html\" target=\"_blank\" rel=\"noopener\">ftpwho</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpcount.html\" target=\"_blank\" rel=\"noopener\">ftpcount</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>4、磁盘管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cd.html\" target=\"_blank\" rel=\"noopener\">cd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-df.html\" target=\"_blank\" rel=\"noopener\">df</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dirs.html\" target=\"_blank\" rel=\"noopener\">dirs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-du.html\" target=\"_blank\" rel=\"noopener\">du</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-edquota.html\" target=\"_blank\" rel=\"noopener\">edquota</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-eject.html\" target=\"_blank\" rel=\"noopener\">eject</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mcd.html\" target=\"_blank\" rel=\"noopener\">mcd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdeltree.html\" target=\"_blank\" rel=\"noopener\">mdeltree</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdu.html\" target=\"_blank\" rel=\"noopener\">mdu</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkdir.html\" target=\"_blank\" rel=\"noopener\">mkdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mlabel.html\" target=\"_blank\" rel=\"noopener\">mlabel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmd.html\" target=\"_blank\" rel=\"noopener\">mmd</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mrd.html\" target=\"_blank\" rel=\"noopener\">mrd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mzip.html\" target=\"_blank\" rel=\"noopener\">mzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwd.html\" target=\"_blank\" rel=\"noopener\">pwd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quota.html\" target=\"_blank\" rel=\"noopener\">quota</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mount.html\" target=\"_blank\" rel=\"noopener\">mount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmount.html\" target=\"_blank\" rel=\"noopener\">mmount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmdir.html\" target=\"_blank\" rel=\"noopener\">rmdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmt.html\" target=\"_blank\" rel=\"noopener\">rmt</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-stat.html\" target=\"_blank\" rel=\"noopener\">stat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tree.html\" target=\"_blank\" rel=\"noopener\">tree</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-umount.html\" target=\"_blank\" rel=\"noopener\">umount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ls.html\" target=\"_blank\" rel=\"noopener\">ls</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotacheck.html\" target=\"_blank\" rel=\"noopener\">quotacheck</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotaoff.html\" target=\"_blank\" rel=\"noopener\">quotaoff</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lndir.html\" target=\"_blank\" rel=\"noopener\">lndir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-repquota.html\" target=\"_blank\" rel=\"noopener\">repquota</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotaon.html\" target=\"_blank\" rel=\"noopener\">quotaon</a></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>5、磁盘维护</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-badblocks.html\" target=\"_blank\" rel=\"noopener\">badblocks</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cfdisk.html\" target=\"_blank\" rel=\"noopener\">cfdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dd.html\" target=\"_blank\" rel=\"noopener\">dd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-e2fsck.html\" target=\"_blank\" rel=\"noopener\">e2fsck</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ext2ed.html\" target=\"_blank\" rel=\"noopener\">ext2ed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck.html\" target=\"_blank\" rel=\"noopener\">fsck</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck-minix.html\" target=\"_blank\" rel=\"noopener\">fsck.minix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsconf.html\" target=\"_blank\" rel=\"noopener\">fsconf</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fdformat.html\" target=\"_blank\" rel=\"noopener\">fdformat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-hdparm.html\" target=\"_blank\" rel=\"noopener\">hdparm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mformat.html\" target=\"_blank\" rel=\"noopener\">mformat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkbootdisk.html\" target=\"_blank\" rel=\"noopener\">mkbootdisk</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkdosfs.html\" target=\"_blank\" rel=\"noopener\">mkdosfs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mke2fs.html\" target=\"_blank\" rel=\"noopener\">mke2fs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-ext2.html\" target=\"_blank\" rel=\"noopener\">mkfs.ext2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-msdos.html\" target=\"_blank\" rel=\"noopener\">mkfs.msdos</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkinitrd.html\" target=\"_blank\" rel=\"noopener\">mkinitrd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkisofs.html\" target=\"_blank\" rel=\"noopener\">mkisofs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkswap.html\" target=\"_blank\" rel=\"noopener\">mkswap</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mpartition.html\" target=\"_blank\" rel=\"noopener\">mpartition</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swapon.html\" target=\"_blank\" rel=\"noopener\">swapon</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-symlinks.html\" target=\"_blank\" rel=\"noopener\">symlinks</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sync.html\" target=\"_blank\" rel=\"noopener\">sync</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mbadblocks.html\" target=\"_blank\" rel=\"noopener\">mbadblocks</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-minix.html\" target=\"_blank\" rel=\"noopener\">mkfs.minix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck-ext2.html\" target=\"_blank\" rel=\"noopener\">fsck.ext2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fdisk.html\" target=\"_blank\" rel=\"noopener\">fdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-losetup.html\" target=\"_blank\" rel=\"noopener\">losetup</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs.html\" target=\"_blank\" rel=\"noopener\">mkfs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sfdisk.html\" target=\"_blank\" rel=\"noopener\">sfdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swapoff.html\" target=\"_blank\" rel=\"noopener\">swapoff</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>6、网络通讯</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-apachectl.html\" target=\"_blank\" rel=\"noopener\">apachectl</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-arpwatch.html\" target=\"_blank\" rel=\"noopener\">arpwatch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dip.html\" target=\"_blank\" rel=\"noopener\">dip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-getty.html\" target=\"_blank\" rel=\"noopener\">getty</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mingetty.html\" target=\"_blank\" rel=\"noopener\">mingetty</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uux.html\" target=\"_blank\" rel=\"noopener\">uux</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-telnet.html\" target=\"_blank\" rel=\"noopener\">telnet</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uulog.html\" target=\"_blank\" rel=\"noopener\">uulog</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uustat.html\" target=\"_blank\" rel=\"noopener\">uustat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ppp-off.html\" target=\"_blank\" rel=\"noopener\">ppp-off</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netconfig.html\" target=\"_blank\" rel=\"noopener\">netconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-nc.html\" target=\"_blank\" rel=\"noopener\">nc</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-httpd.html\" target=\"_blank\" rel=\"noopener\">httpd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ifconfig.html\" target=\"_blank\" rel=\"noopener\">ifconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-minicom.html\" target=\"_blank\" rel=\"noopener\">minicom</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mesg.html\" target=\"_blank\" rel=\"noopener\">mesg</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dnsconf.html\" target=\"_blank\" rel=\"noopener\">dnsconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-wall.html\" target=\"_blank\" rel=\"noopener\">wall</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netstat.html\" target=\"_blank\" rel=\"noopener\">netstat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ping.html\" target=\"_blank\" rel=\"noopener\">ping</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pppstats.html\" target=\"_blank\" rel=\"noopener\">pppstats</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-samba.html\" target=\"_blank\" rel=\"noopener\">samba</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setserial.html\" target=\"_blank\" rel=\"noopener\">setserial</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-talk.html\" target=\"_blank\" rel=\"noopener\">talk</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-traceroute.html\" target=\"_blank\" rel=\"noopener\">traceroute</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tty.html\" target=\"_blank\" rel=\"noopener\">tty</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-newaliases.html\" target=\"_blank\" rel=\"noopener\">newaliases</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuname.html\" target=\"_blank\" rel=\"noopener\">uuname</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netconf.html\" target=\"_blank\" rel=\"noopener\">netconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-write.html\" target=\"_blank\" rel=\"noopener\">write</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-statserial.html\" target=\"_blank\" rel=\"noopener\">statserial</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-efax.html\" target=\"_blank\" rel=\"noopener\">efax</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pppsetup.html\" target=\"_blank\" rel=\"noopener\">pppsetup</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tcpdump.html\" target=\"_blank\" rel=\"noopener\">tcpdump</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ytalk.html\" target=\"_blank\" rel=\"noopener\">ytalk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cu.html\" target=\"_blank\" rel=\"noopener\">cu</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-smbd.html\" target=\"_blank\" rel=\"noopener\">smbd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-testparm.html\" target=\"_blank\" rel=\"noopener\">testparm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-smbclient.html\" target=\"_blank\" rel=\"noopener\">smbclient</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-shapecfg.html\" target=\"_blank\" rel=\"noopener\">shapecfg</a></td>\n</tr>\n<tr>\n<td><strong>7、系统管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-adduser.html\" target=\"_blank\" rel=\"noopener\">adduser</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chfn.html\" target=\"_blank\" rel=\"noopener\">chfn</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-useradd.html\" target=\"_blank\" rel=\"noopener\">useradd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-date.html\" target=\"_blank\" rel=\"noopener\">date</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-exit.html\" target=\"_blank\" rel=\"noopener\">exit</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-finger.html\" target=\"_blank\" rel=\"noopener\">finger</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fwhios.html\" target=\"_blank\" rel=\"noopener\">fwhios</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sleep.html\" target=\"_blank\" rel=\"noopener\">sleep</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-suspend.html\" target=\"_blank\" rel=\"noopener\">suspend</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-groupdel.html\" target=\"_blank\" rel=\"noopener\">groupdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-groupmod.html\" target=\"_blank\" rel=\"noopener\">groupmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-halt.html\" target=\"_blank\" rel=\"noopener\">halt</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-kill.html\" target=\"_blank\" rel=\"noopener\">kill</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-last.html\" target=\"_blank\" rel=\"noopener\">last</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lastb.html\" target=\"_blank\" rel=\"noopener\">lastb</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-login.html\" target=\"_blank\" rel=\"noopener\">login</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logname.html\" target=\"_blank\" rel=\"noopener\">logname</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logout.html\" target=\"_blank\" rel=\"noopener\">logout</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ps.html\" target=\"_blank\" rel=\"noopener\">ps</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-nice.html\" target=\"_blank\" rel=\"noopener\">nice</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-procinfo.html\" target=\"_blank\" rel=\"noopener\">procinfo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-top.html\" target=\"_blank\" rel=\"noopener\">top</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pstree.html\" target=\"_blank\" rel=\"noopener\">pstree</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-reboot.html\" target=\"_blank\" rel=\"noopener\">reboot</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rlogin.html\" target=\"_blank\" rel=\"noopener\">rlogin</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rsh.html\" target=\"_blank\" rel=\"noopener\">rsh</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sliplogin.html\" target=\"_blank\" rel=\"noopener\">sliplogin</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-screen.html\" target=\"_blank\" rel=\"noopener\">screen</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-shutdown.html\" target=\"_blank\" rel=\"noopener\">shutdown</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rwho.html\" target=\"_blank\" rel=\"noopener\">rwho</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sudo.html\" target=\"_blank\" rel=\"noopener\">sudo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gitps.html\" target=\"_blank\" rel=\"noopener\">gitps</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swatch.html\" target=\"_blank\" rel=\"noopener\">swatch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tload.html\" target=\"_blank\" rel=\"noopener\">tload</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logrotate.html\" target=\"_blank\" rel=\"noopener\">logrotate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uname.html\" target=\"_blank\" rel=\"noopener\">uname</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chsh.html\" target=\"_blank\" rel=\"noopener\">chsh</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-userconf.html\" target=\"_blank\" rel=\"noopener\">userconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-userdel.html\" target=\"_blank\" rel=\"noopener\">userdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-usermod.html\" target=\"_blank\" rel=\"noopener\">usermod</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-vlock.html\" target=\"_blank\" rel=\"noopener\">vlock</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-who.html\" target=\"_blank\" rel=\"noopener\">who</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whoami.html\" target=\"_blank\" rel=\"noopener\">whoami</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whois.html\" target=\"_blank\" rel=\"noopener\">whois</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-newgrp.html\" target=\"_blank\" rel=\"noopener\">newgrp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-renice.html\" target=\"_blank\" rel=\"noopener\">renice</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-su.html\" target=\"_blank\" rel=\"noopener\">su</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-skill.html\" target=\"_blank\" rel=\"noopener\">skill</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-w.html\" target=\"_blank\" rel=\"noopener\">w</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-id.html\" target=\"_blank\" rel=\"noopener\">id</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-free.html\" target=\"_blank\" rel=\"noopener\">free</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>8、系统设置</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-reset.html\" target=\"_blank\" rel=\"noopener\">reset</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-clear.html\" target=\"_blank\" rel=\"noopener\">clear</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-alias.html\" target=\"_blank\" rel=\"noopener\">alias</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dircolors.html\" target=\"_blank\" rel=\"noopener\">dircolors</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-aumix.html\" target=\"_blank\" rel=\"noopener\">aumix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bind.html\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chroot.html\" target=\"_blank\" rel=\"noopener\">chroot</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-clock.html\" target=\"_blank\" rel=\"noopener\">clock</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-crontab.html\" target=\"_blank\" rel=\"noopener\">crontab</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-declare.html\" target=\"_blank\" rel=\"noopener\">declare</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-depmod.html\" target=\"_blank\" rel=\"noopener\">depmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dmesg.html\" target=\"_blank\" rel=\"noopener\">dmesg</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-enable.html\" target=\"_blank\" rel=\"noopener\">enable</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-eval.html\" target=\"_blank\" rel=\"noopener\">eval</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-export.html\" target=\"_blank\" rel=\"noopener\">export</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwunconv.html\" target=\"_blank\" rel=\"noopener\">pwunconv</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grpconv.html\" target=\"_blank\" rel=\"noopener\">grpconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rpm.html\" target=\"_blank\" rel=\"noopener\">rpm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-insmod.html\" target=\"_blank\" rel=\"noopener\">insmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-kbdconfig.html\" target=\"_blank\" rel=\"noopener\">kbdconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lilo.html\" target=\"_blank\" rel=\"noopener\">lilo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-liloconfig.html\" target=\"_blank\" rel=\"noopener\">liloconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lsmod.html\" target=\"_blank\" rel=\"noopener\">lsmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-minfo.html\" target=\"_blank\" rel=\"noopener\">minfo</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-set.html\" target=\"_blank\" rel=\"noopener\">set</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-modprobe.html\" target=\"_blank\" rel=\"noopener\">modprobe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ntsysv.html\" target=\"_blank\" rel=\"noopener\">ntsysv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mouseconfig.html\" target=\"_blank\" rel=\"noopener\">mouseconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-passwd.html\" target=\"_blank\" rel=\"noopener\">passwd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwconv.html\" target=\"_blank\" rel=\"noopener\">pwconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rdate.html\" target=\"_blank\" rel=\"noopener\">rdate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-resize.html\" target=\"_blank\" rel=\"noopener\">resize</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmmod.html\" target=\"_blank\" rel=\"noopener\">rmmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grpunconv.html\" target=\"_blank\" rel=\"noopener\">grpunconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-modinfo.html\" target=\"_blank\" rel=\"noopener\">modinfo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-time.html\" target=\"_blank\" rel=\"noopener\">time</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setup.html\" target=\"_blank\" rel=\"noopener\">setup</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sndconfig.html\" target=\"_blank\" rel=\"noopener\">sndconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setenv.html\" target=\"_blank\" rel=\"noopener\">setenv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setconsole.html\" target=\"_blank\" rel=\"noopener\">setconsole</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-timeconfig.html\" target=\"_blank\" rel=\"noopener\">timeconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ulimit.html\" target=\"_blank\" rel=\"noopener\">ulimit</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unset.html\" target=\"_blank\" rel=\"noopener\">unset</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chkconfig.html\" target=\"_blank\" rel=\"noopener\">chkconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-apmd.html\" target=\"_blank\" rel=\"noopener\">apmd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-hwclock.html\" target=\"_blank\" rel=\"noopener\">hwclock</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkkickstart.html\" target=\"_blank\" rel=\"noopener\">mkkickstart</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fbset.html\" target=\"_blank\" rel=\"noopener\">fbset</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unalias.html\" target=\"_blank\" rel=\"noopener\">unalias</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-svgatextmode.html\" target=\"_blank\" rel=\"noopener\">SVGATextMode</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>9、备份压缩</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ar.html\" target=\"_blank\" rel=\"noopener\">ar</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bunzip2.html\" target=\"_blank\" rel=\"noopener\">bunzip2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bzip2.html\" target=\"_blank\" rel=\"noopener\">bzip2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bzip2recover.html\" target=\"_blank\" rel=\"noopener\">bzip2recover</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gunzip.html\" target=\"_blank\" rel=\"noopener\">gunzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unarj.html\" target=\"_blank\" rel=\"noopener\">unarj</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-compress.html\" target=\"_blank\" rel=\"noopener\">compress</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cpio.html\" target=\"_blank\" rel=\"noopener\">cpio</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dump.html\" target=\"_blank\" rel=\"noopener\">dump</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuencode.html\" target=\"_blank\" rel=\"noopener\">uuencode</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gzexe.html\" target=\"_blank\" rel=\"noopener\">gzexe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gzip.html\" target=\"_blank\" rel=\"noopener\">gzip</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lha.html\" target=\"_blank\" rel=\"noopener\">lha</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-restore.html\" target=\"_blank\" rel=\"noopener\">restore</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tar.html\" target=\"_blank\" rel=\"noopener\">tar</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uudecode.html\" target=\"_blank\" rel=\"noopener\">uudecode</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unzip.html\" target=\"_blank\" rel=\"noopener\">unzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-zipinfo.html\" target=\"_blank\" rel=\"noopener\">zipinfo</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>10、设备管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setleds.html\" target=\"_blank\" rel=\"noopener\">setleds</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-loadkeys.html\" target=\"_blank\" rel=\"noopener\">loadkeys</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rdev.html\" target=\"_blank\" rel=\"noopener\">rdev</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dumpkeys.html\" target=\"_blank\" rel=\"noopener\">dumpkeys</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-makedev.html\" target=\"_blank\" rel=\"noopener\">MAKEDEV</a></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<h1 id=\"文件基本属性\"><a href=\"#文件基本属性\" class=\"headerlink\" title=\"文件基本属性\"></a>文件基本属性</h1><h2 id=\"文件属性说明\"><a href=\"#文件属性说明\" class=\"headerlink\" title=\"文件属性说明\"></a>文件属性说明</h2><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。<strong>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</strong></p>","more":"<h2 id=\"查看文件属性\"><a href=\"#查看文件属性\" class=\"headerlink\" title=\"查看文件属性\"></a>查看文件属性</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class=\"line\">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>第一个字符</th>\n<th>属主</th>\n<th>属组</th>\n<th>其他用户</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>d</strong>   目录<br><strong>-</strong>    文件<br><strong>l</strong>    链接文档(link file)<br><strong>b</strong>   装置文件里面的可供储存的接口设备(可随机存取装置)<br><strong>c</strong>   装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</td>\n<td>r   读<br>w  写<br>x   执行</td>\n<td>r   读<br>w  写<br>x   执行</td>\n<td>r   读<br>w  写<br>x   执行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"更改文件属性\"><a href=\"#更改文件属性\" class=\"headerlink\" title=\"更改文件属性\"></a>更改文件属性</h2><table>\n  <tr>\n    <th>功能</th>\n    <th colspan=\"5\">方法</th>\n  </tr>\n  <tr>\n    <td>更改文件属组</td>\n    <td colspan=\"5\">chgrp [-R] 属组名 文件名<br>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。<br></td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">更改文件属主</td>\n    <td colspan=\"5\">chown [–R] 属主名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown bin install.log`</td>\n  </tr>\n  <tr>\n    <td colspan=\"5\">chown [-R] 属主名：属组名 文件名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`chown root:root install.log`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">更改文件属性</td>\n    <td colspan=\"5\">Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</td>\n  </tr>\n  <tr>\n    <td>第一种方式</td>\n    <td colspan=\"4\">chmod [-R] xyz 文件或目录<br>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更<br>xyz : 就是刚刚提到的数字类型的权限属性<br><br>` chmod 777 test`</td>\n  </tr>\n  <tr>\n    <td rowspan=\"2\">第二种方式</td>\n    <td>u&nbsp;&nbsp;&nbsp;属主<br>g&nbsp;&nbsp;&nbsp;同组<br>o&nbsp;&nbsp;&nbsp;其他<br>a&nbsp;&nbsp;&nbsp;所有</td>\n    <td>+(加入)<br>-(除去)<br>=(设定)</td>\n    <td>r<br>w<br>x</td>\n    <td>文件或目录</td>\n  </tr>\n  <tr>\n    <td colspan=\"4\">`chmod u=rwx,g=rx,o=r&nbsp;&nbsp;test` </td>\n  </tr>\n</table>\n\n\n\n<h1 id=\"文件与目录管理\"><a href=\"#文件与目录管理\" class=\"headerlink\" title=\"文件与目录管理\"></a>文件与目录管理</h1><p>Linux的目录结构为树状结构，最顶级的目录为根目录 /。其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ls</td>\n<td><strong>列出目录</strong><br>a: 全部的文件，连同隐藏文件（开头为.的文件）<br>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)<br>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</td>\n</tr>\n<tr>\n<td>cd</td>\n<td><strong>切换目录</strong><br># cd ~       # 表示回到自己的家目录，亦即是 /root 这个目录</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td><strong>显示目前的目录</strong><br>-P ：显示出确实的路径，而非使用连结 (link) 路径。</td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td><strong>创建一个新的目录</strong><br>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～<br>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</td>\n</tr>\n<tr>\n<td>rmdir</td>\n<td>删除一个空的目录<br>-p ：连同上一级『空的』目录也一起删除</td>\n</tr>\n<tr>\n<td>cp</td>\n<td><strong>复制文件或目录</strong><br>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)<br>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；<br>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；<br>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)<br>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；<br>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；<br>-r：递归持续复制，用於目录的复制行为；(常用)<br>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；<br>-u：若 destination 比 source 旧才升级 destination ！</td>\n</tr>\n<tr>\n<td>rm</td>\n<td><strong>移除文件或目录</strong><br>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；<br>-i ：互动模式，在删除前会询问使用者是否动作<br>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</td>\n</tr>\n<tr>\n<td>mv</td>\n<td><strong>移动文件与目录，或修改文件与目录的名称</strong><br>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；<br>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！<br>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"用户与用户组\"><a href=\"#用户与用户组\" class=\"headerlink\" title=\"用户与用户组\"></a>用户与用户组</h1><h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>useradd</td>\n<td><strong>添加新的用户账号</strong>    <code>useradd -s /bin/sh -g group –G adm,root gem</code><br><code>useradd 选项 用户名</code><br>-c   comment 指定一段注释性描述。<br>-d  目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g  用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s  Shell文件 指定用户的登录Shell。<br>-u  用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</td>\n</tr>\n<tr>\n<td>userdel</td>\n<td><strong>删除帐号</strong>   <code>userdel -r sam</code><br>-r：把用户的主目录一起删除</td>\n</tr>\n<tr>\n<td>usermod</td>\n<td>修改帐号   <code>usermod -s /bin/ksh -d /home/z –g developer sam</code><br><code>usermod 选项 用户名</code><br>包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样</td>\n</tr>\n<tr>\n<td>passwd</td>\n<td>用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。<br><code>passwd 选项 用户名</code><br>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令。<br>-f 强迫用户下次登录时修改口令。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"用户组管理\"><a href=\"#用户组管理\" class=\"headerlink\" title=\"用户组管理\"></a>用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<strong>/etc/group</strong>文件的更新</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>groupadd</td>\n<td><strong>增加一个新的用户组</strong><br>-g GID 指定新用户组的组标识号（GID）。<br>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</td>\n</tr>\n<tr>\n<td>groupdel</td>\n<td>删除一个已有的用户组</td>\n</tr>\n<tr>\n<td>groupmod</td>\n<td><strong>修改用户组的属性</strong><br>-g GID 为用户组指定新的组标识号。<br>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。<br>-n新用户组 将用户组的名字改为新名字</td>\n</tr>\n<tr>\n<td>newgrp</td>\n<td><strong>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</strong><br><figure class=\"highlight plain\"><figcaption><span>root``` |</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 与用户账号有关的系统文件</span><br><span class=\"line\"></span><br><span class=\"line\">完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</span><br><span class=\"line\"></span><br><span class=\"line\">### 伪用户</span><br><span class=\"line\"></span><br><span class=\"line\">这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示：</span><br><span class=\"line\"></span><br><span class=\"line\">```shell</span><br><span class=\"line\">伪 用 户 含 义 </span><br><span class=\"line\">bin 拥有可执行的用户命令文件 </span><br><span class=\"line\">sys 拥有系统文件 </span><br><span class=\"line\">adm 拥有帐户文件 </span><br><span class=\"line\">uucp UUCP使用 </span><br><span class=\"line\">lp lp或lpd子系统使用 </span><br><span class=\"line\">nobody NFS使用</span><br></pre></td></tr></table></figure></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户管理文件-etc-passwd\"><a href=\"#用户管理文件-etc-passwd\" class=\"headerlink\" title=\"用户管理文件-/etc/passwd\"></a>用户管理文件-/etc/passwd</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br><span class=\"line\">root:x:0:0:Superuser:/:</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">口令</td>\n<td>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux   系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">用户标识号</td>\n<td>系统内部用它来标识用户，一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">组标识号</td>\n<td>记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">注释性描述</td>\n<td>记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等，</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主目录</td>\n<td>用户的起始工作目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">登陆shell</td>\n<td>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户管理文件-etc-shadow\"><a href=\"#用户管理文件-etc-shadow\" class=\"headerlink\" title=\"用户管理文件-/etc/shadow\"></a>用户管理文件-/etc/shadow</h3><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志   root:Dnakfw28zf38w:8764:0:168:7:::</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>登录名</td>\n<td>与/etc/passwd文件中的登录名相一致的用户账号</td>\n</tr>\n<tr>\n<td>口令</td>\n<td>存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合   { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</td>\n</tr>\n<tr>\n<td>最后一次修改时间</td>\n<td>从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO   Linux 中，这个时间起点是1970年1月1日。</td>\n</tr>\n<tr>\n<td>最小时间间隔</td>\n<td>是两次修改口令之间所需的最小天数。</td>\n</tr>\n<tr>\n<td>最大时间间隔</td>\n<td>口令保持有效的最大天数。</td>\n</tr>\n<tr>\n<td>警告时间</td>\n<td>从系统开始警告用户到用户密码正式失效之间的天数。</td>\n</tr>\n<tr>\n<td>不活动时间</td>\n<td>用户没有登录活动但账号仍能保持有效的最大天数。</td>\n</tr>\n<tr>\n<td>失效时间</td>\n<td>给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"用户组管理文件-etc-group\"><a href=\"#用户组管理文件-etc-group\" class=\"headerlink\" title=\"用户组管理文件-/etc/group\"></a>用户组管理文件-/etc/group</h3><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组名:口令:组标识号:组内用户列表</span><br><span class=\"line\">root::0:root</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>组名</td>\n<td>用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</td>\n</tr>\n<tr>\n<td>口令存</td>\n<td>用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。</td>\n</tr>\n<tr>\n<td>组标识号</td>\n<td>与用户标识号类似，也是一个整数，被系统内部用来标识组。</td>\n</tr>\n<tr>\n<td>组内用户列表</td>\n<td>属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"添加批量用户\"><a href=\"#添加批量用户\" class=\"headerlink\" title=\"添加批量用户\"></a>添加批量用户</h2><ol>\n<li><p>先编辑一个文本用户文件。</p>\n<p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user001::600:100:user:/home/user001:/bin/bash</span><br><span class=\"line\">user002::601:100:user:/home/user002:/bin/bash</span><br><span class=\"line\">user003::602:100:user:/home/user003:/bin/bash</span><br><span class=\"line\">user004::603:100:user:/home/user004:/bin/bash</span><br><span class=\"line\">user005::604:100:user:/home/user005:/bin/bash</span><br><span class=\"line\">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newusers &lt; user.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令/usr/sbin/pwunconv</p>\n<p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwunconv</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑每个用户的密码对照文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user001:密码</span><br><span class=\"line\">user002:密码</span><br><span class=\"line\">user003:密码</span><br><span class=\"line\">user004:密码</span><br><span class=\"line\">user005:密码</span><br><span class=\"line\">user006:密码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以root身份执行命令 <code>/usr/sbin/chpasswd</code></p>\n<p>创建用户密码，<code>chpasswd</code> 会将经过 <code>/usr/bin/passwd</code> 命令编码过的密码写入 <code>/etc/passwd</code> 的密码栏。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确定密码经编码写入/etc/passwd的密码栏后。</p>\n<p>执行命令 <code>/usr/sbin/pwconv</code> 将密码编码为 <code>shadow password</code>，并将结果写入 <code>/etc/shadow</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwconv</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"yum-命令-包管理\"><a href=\"#yum-命令-包管理\" class=\"headerlink\" title=\"yum 命令-包管理\"></a>yum 命令-包管理</h1><ul>\n<li><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件<strong>包管理器</strong>。</p>\n</li>\n<li><p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n</li>\n<li><p>yum提供了<strong>查找、安装、删除</strong>某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure>\n<table>\n  <tr>\n    <th>参数</th>\n    <th colspan=\"2\">说明</th>\n  </tr>\n  <tr>\n    <td rowspan=\"3\">options</td>\n    <td>-h</td>\n    <td>帮助</td>\n  </tr>\n  <tr>\n    <td>-y</td>\n    <td>当安装过程提示选择全部为\"yes\"</td>\n  </tr>\n  <tr>\n    <td>-q</td>\n    <td>不显示安装的过程</td>\n  </tr>\n  <tr>\n    <td rowspan=\"11\">command</td>\n    <td>check-update</td>\n    <td>列出所有可更新的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>update</td>\n    <td>更新所有软件命令</td>\n  </tr>\n  <tr>\n    <td>update&lt;package_name&gt;</td>\n    <td>仅更新指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>install &lt;package_name&gt;</td>\n    <td>仅安装指定的软件命令</td>\n  </tr>\n  <tr>\n    <td>list</td>\n    <td>列出所有可安裝的软件清单命令</td>\n  </tr>\n  <tr>\n    <td>remove &lt;package_name&gt;</td>\n    <td>删除软件包命令</td>\n  </tr>\n  <tr>\n    <td>search <br>&lt;keyword&gt;</td>\n    <td>查找软件包命令</td>\n  </tr>\n  <tr>\n    <td>clean packages</td>\n    <td>清除缓存目录下的软件包</td>\n  </tr>\n  <tr>\n    <td>clean headers</td>\n    <td>清除缓存目录下的 headers</td>\n  </tr>\n  <tr>\n    <td>clean oldheaders</td>\n    <td>清除缓存目录下旧的 headers</td>\n  </tr>\n  <tr>\n    <td>clean/clean all</td>\n    <td>清除缓存目录下的软件包及旧的headers</td>\n  </tr>\n  <tr>\n    <td>package</td>\n    <td colspan=\"2\">操作的对象</td>\n  </tr>\n</table>\n\n\n\n<h1 id=\"命令大全\"><a href=\"#命令大全\" class=\"headerlink\" title=\"命令大全\"></a>命令大全</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>1、文件管理</strong></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cat.html\" target=\"_blank\" rel=\"noopener\">cat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chattr.html\" target=\"_blank\" rel=\"noopener\">chattr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chgrp.html\" target=\"_blank\" rel=\"noopener\">chgrp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chmod.html\" target=\"_blank\" rel=\"noopener\">chmod</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chown.html\" target=\"_blank\" rel=\"noopener\">chown</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cksum.html\" target=\"_blank\" rel=\"noopener\">cksum</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cmp.html\" target=\"_blank\" rel=\"noopener\">cmp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-diff.html\" target=\"_blank\" rel=\"noopener\">diff</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-diffstat.html\" target=\"_blank\" rel=\"noopener\">diffstat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-file.html\" target=\"_blank\" rel=\"noopener\">file</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-find.html\" target=\"_blank\" rel=\"noopener\">find</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-git.html\" target=\"_blank\" rel=\"noopener\">git</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gitview.html\" target=\"_blank\" rel=\"noopener\">gitview</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-indent.html\" target=\"_blank\" rel=\"noopener\">indent</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cut.html\" target=\"_blank\" rel=\"noopener\">cut</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ln.html\" target=\"_blank\" rel=\"noopener\">ln</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-less.html\" target=\"_blank\" rel=\"noopener\">less</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-locate.html\" target=\"_blank\" rel=\"noopener\">locate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lsattr.html\" target=\"_blank\" rel=\"noopener\">lsattr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mattrib.html\" target=\"_blank\" rel=\"noopener\">mattrib</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mc.html\" target=\"_blank\" rel=\"noopener\">mc</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdel.html\" target=\"_blank\" rel=\"noopener\">mdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdir.html\" target=\"_blank\" rel=\"noopener\">mdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mktemp.html\" target=\"_blank\" rel=\"noopener\">mktemp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-more.html\" target=\"_blank\" rel=\"noopener\">more</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmove.html\" target=\"_blank\" rel=\"noopener\">mmove</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mread.html\" target=\"_blank\" rel=\"noopener\">mread</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mren.html\" target=\"_blank\" rel=\"noopener\">mren</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtools.html\" target=\"_blank\" rel=\"noopener\">mtools</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtoolstest.html\" target=\"_blank\" rel=\"noopener\">mtoolstest</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mv.html\" target=\"_blank\" rel=\"noopener\">mv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-od.html\" target=\"_blank\" rel=\"noopener\">od</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-paste.html\" target=\"_blank\" rel=\"noopener\">paste</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-patch.html\" target=\"_blank\" rel=\"noopener\">patch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rcp.html\" target=\"_blank\" rel=\"noopener\">rcp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rm.html\" target=\"_blank\" rel=\"noopener\">rm</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-slocate.html\" target=\"_blank\" rel=\"noopener\">slocate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-split.html\" target=\"_blank\" rel=\"noopener\">split</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tee.html\" target=\"_blank\" rel=\"noopener\">tee</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tmpwatch.html\" target=\"_blank\" rel=\"noopener\">tmpwatch</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-touch.html\" target=\"_blank\" rel=\"noopener\">touch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-umask.html\" target=\"_blank\" rel=\"noopener\">umask</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-which.html\" target=\"_blank\" rel=\"noopener\">which</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cp.html\" target=\"_blank\" rel=\"noopener\">cp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whereis.html\" target=\"_blank\" rel=\"noopener\">whereis</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mcopy.html\" target=\"_blank\" rel=\"noopener\">mcopy</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mshowfat.html\" target=\"_blank\" rel=\"noopener\">mshowfat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rhmask.html\" target=\"_blank\" rel=\"noopener\">rhmask</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-scp.html\" target=\"_blank\" rel=\"noopener\">scp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-awk.html\" target=\"_blank\" rel=\"noopener\">awk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-read.html\" target=\"_blank\" rel=\"noopener\">read</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-updatedb.html\" target=\"_blank\" rel=\"noopener\">updatedb</a></td>\n</tr>\n<tr>\n<td><strong>2、文档编辑</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-col.html\" target=\"_blank\" rel=\"noopener\">col</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-colrm.html\" target=\"_blank\" rel=\"noopener\">colrm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-comm.html\" target=\"_blank\" rel=\"noopener\">comm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-csplit.html\" target=\"_blank\" rel=\"noopener\">csplit</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ed.html\" target=\"_blank\" rel=\"noopener\">ed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-egrep.html\" target=\"_blank\" rel=\"noopener\">egrep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ex.html\" target=\"_blank\" rel=\"noopener\">ex</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fgrep.html\" target=\"_blank\" rel=\"noopener\">fgrep</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fmt.html\" target=\"_blank\" rel=\"noopener\">fmt</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fold.html\" target=\"_blank\" rel=\"noopener\">fold</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grep.html\" target=\"_blank\" rel=\"noopener\">grep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ispell.html\" target=\"_blank\" rel=\"noopener\">ispell</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-jed.html\" target=\"_blank\" rel=\"noopener\">jed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-joe.html\" target=\"_blank\" rel=\"noopener\">joe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-join.html\" target=\"_blank\" rel=\"noopener\">join</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-look.html\" target=\"_blank\" rel=\"noopener\">look</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mtype.html\" target=\"_blank\" rel=\"noopener\">mtype</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pico.html\" target=\"_blank\" rel=\"noopener\">pico</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rgrep.html\" target=\"_blank\" rel=\"noopener\">rgrep</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sed.html\" target=\"_blank\" rel=\"noopener\">sed</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sort.html\" target=\"_blank\" rel=\"noopener\">sort</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-spell.html\" target=\"_blank\" rel=\"noopener\">spell</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tr.html\" target=\"_blank\" rel=\"noopener\">tr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-expr.html\" target=\"_blank\" rel=\"noopener\">expr</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uniq.html\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-wc.html\" target=\"_blank\" rel=\"noopener\">wc</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-let.html\" target=\"_blank\" rel=\"noopener\">let</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>3、文件传输</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lprm.html\" target=\"_blank\" rel=\"noopener\">lprm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpr.html\" target=\"_blank\" rel=\"noopener\">lpr</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpq.html\" target=\"_blank\" rel=\"noopener\">lpq</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lpd.html\" target=\"_blank\" rel=\"noopener\">lpd</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bye.html\" target=\"_blank\" rel=\"noopener\">bye</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftp.html\" target=\"_blank\" rel=\"noopener\">ftp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuto.html\" target=\"_blank\" rel=\"noopener\">uuto</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uupick.html\" target=\"_blank\" rel=\"noopener\">uupick</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uucp.html\" target=\"_blank\" rel=\"noopener\">uucp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uucico.html\" target=\"_blank\" rel=\"noopener\">uucico</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tftp.html\" target=\"_blank\" rel=\"noopener\">tftp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ncftp.html\" target=\"_blank\" rel=\"noopener\">ncftp</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpshut.html\" target=\"_blank\" rel=\"noopener\">ftpshut</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpwho.html\" target=\"_blank\" rel=\"noopener\">ftpwho</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ftpcount.html\" target=\"_blank\" rel=\"noopener\">ftpcount</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>4、磁盘管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cd.html\" target=\"_blank\" rel=\"noopener\">cd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-df.html\" target=\"_blank\" rel=\"noopener\">df</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dirs.html\" target=\"_blank\" rel=\"noopener\">dirs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-du.html\" target=\"_blank\" rel=\"noopener\">du</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-edquota.html\" target=\"_blank\" rel=\"noopener\">edquota</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-eject.html\" target=\"_blank\" rel=\"noopener\">eject</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mcd.html\" target=\"_blank\" rel=\"noopener\">mcd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdeltree.html\" target=\"_blank\" rel=\"noopener\">mdeltree</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mdu.html\" target=\"_blank\" rel=\"noopener\">mdu</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkdir.html\" target=\"_blank\" rel=\"noopener\">mkdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mlabel.html\" target=\"_blank\" rel=\"noopener\">mlabel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmd.html\" target=\"_blank\" rel=\"noopener\">mmd</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mrd.html\" target=\"_blank\" rel=\"noopener\">mrd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mzip.html\" target=\"_blank\" rel=\"noopener\">mzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwd.html\" target=\"_blank\" rel=\"noopener\">pwd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quota.html\" target=\"_blank\" rel=\"noopener\">quota</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mount.html\" target=\"_blank\" rel=\"noopener\">mount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mmount.html\" target=\"_blank\" rel=\"noopener\">mmount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmdir.html\" target=\"_blank\" rel=\"noopener\">rmdir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmt.html\" target=\"_blank\" rel=\"noopener\">rmt</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-stat.html\" target=\"_blank\" rel=\"noopener\">stat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tree.html\" target=\"_blank\" rel=\"noopener\">tree</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-umount.html\" target=\"_blank\" rel=\"noopener\">umount</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ls.html\" target=\"_blank\" rel=\"noopener\">ls</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotacheck.html\" target=\"_blank\" rel=\"noopener\">quotacheck</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotaoff.html\" target=\"_blank\" rel=\"noopener\">quotaoff</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lndir.html\" target=\"_blank\" rel=\"noopener\">lndir</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-repquota.html\" target=\"_blank\" rel=\"noopener\">repquota</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-quotaon.html\" target=\"_blank\" rel=\"noopener\">quotaon</a></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>5、磁盘维护</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-badblocks.html\" target=\"_blank\" rel=\"noopener\">badblocks</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cfdisk.html\" target=\"_blank\" rel=\"noopener\">cfdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dd.html\" target=\"_blank\" rel=\"noopener\">dd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-e2fsck.html\" target=\"_blank\" rel=\"noopener\">e2fsck</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ext2ed.html\" target=\"_blank\" rel=\"noopener\">ext2ed</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck.html\" target=\"_blank\" rel=\"noopener\">fsck</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck-minix.html\" target=\"_blank\" rel=\"noopener\">fsck.minix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsconf.html\" target=\"_blank\" rel=\"noopener\">fsconf</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fdformat.html\" target=\"_blank\" rel=\"noopener\">fdformat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-hdparm.html\" target=\"_blank\" rel=\"noopener\">hdparm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mformat.html\" target=\"_blank\" rel=\"noopener\">mformat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkbootdisk.html\" target=\"_blank\" rel=\"noopener\">mkbootdisk</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkdosfs.html\" target=\"_blank\" rel=\"noopener\">mkdosfs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mke2fs.html\" target=\"_blank\" rel=\"noopener\">mke2fs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-ext2.html\" target=\"_blank\" rel=\"noopener\">mkfs.ext2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-msdos.html\" target=\"_blank\" rel=\"noopener\">mkfs.msdos</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkinitrd.html\" target=\"_blank\" rel=\"noopener\">mkinitrd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkisofs.html\" target=\"_blank\" rel=\"noopener\">mkisofs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkswap.html\" target=\"_blank\" rel=\"noopener\">mkswap</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mpartition.html\" target=\"_blank\" rel=\"noopener\">mpartition</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swapon.html\" target=\"_blank\" rel=\"noopener\">swapon</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-symlinks.html\" target=\"_blank\" rel=\"noopener\">symlinks</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sync.html\" target=\"_blank\" rel=\"noopener\">sync</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mbadblocks.html\" target=\"_blank\" rel=\"noopener\">mbadblocks</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs-minix.html\" target=\"_blank\" rel=\"noopener\">mkfs.minix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fsck-ext2.html\" target=\"_blank\" rel=\"noopener\">fsck.ext2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fdisk.html\" target=\"_blank\" rel=\"noopener\">fdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-losetup.html\" target=\"_blank\" rel=\"noopener\">losetup</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkfs.html\" target=\"_blank\" rel=\"noopener\">mkfs</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sfdisk.html\" target=\"_blank\" rel=\"noopener\">sfdisk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swapoff.html\" target=\"_blank\" rel=\"noopener\">swapoff</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>6、网络通讯</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-apachectl.html\" target=\"_blank\" rel=\"noopener\">apachectl</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-arpwatch.html\" target=\"_blank\" rel=\"noopener\">arpwatch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dip.html\" target=\"_blank\" rel=\"noopener\">dip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-getty.html\" target=\"_blank\" rel=\"noopener\">getty</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mingetty.html\" target=\"_blank\" rel=\"noopener\">mingetty</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uux.html\" target=\"_blank\" rel=\"noopener\">uux</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-telnet.html\" target=\"_blank\" rel=\"noopener\">telnet</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uulog.html\" target=\"_blank\" rel=\"noopener\">uulog</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uustat.html\" target=\"_blank\" rel=\"noopener\">uustat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ppp-off.html\" target=\"_blank\" rel=\"noopener\">ppp-off</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netconfig.html\" target=\"_blank\" rel=\"noopener\">netconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-nc.html\" target=\"_blank\" rel=\"noopener\">nc</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-httpd.html\" target=\"_blank\" rel=\"noopener\">httpd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ifconfig.html\" target=\"_blank\" rel=\"noopener\">ifconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-minicom.html\" target=\"_blank\" rel=\"noopener\">minicom</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mesg.html\" target=\"_blank\" rel=\"noopener\">mesg</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dnsconf.html\" target=\"_blank\" rel=\"noopener\">dnsconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-wall.html\" target=\"_blank\" rel=\"noopener\">wall</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netstat.html\" target=\"_blank\" rel=\"noopener\">netstat</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ping.html\" target=\"_blank\" rel=\"noopener\">ping</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pppstats.html\" target=\"_blank\" rel=\"noopener\">pppstats</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-samba.html\" target=\"_blank\" rel=\"noopener\">samba</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setserial.html\" target=\"_blank\" rel=\"noopener\">setserial</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-talk.html\" target=\"_blank\" rel=\"noopener\">talk</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-traceroute.html\" target=\"_blank\" rel=\"noopener\">traceroute</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tty.html\" target=\"_blank\" rel=\"noopener\">tty</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-newaliases.html\" target=\"_blank\" rel=\"noopener\">newaliases</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuname.html\" target=\"_blank\" rel=\"noopener\">uuname</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-netconf.html\" target=\"_blank\" rel=\"noopener\">netconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-write.html\" target=\"_blank\" rel=\"noopener\">write</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-statserial.html\" target=\"_blank\" rel=\"noopener\">statserial</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-efax.html\" target=\"_blank\" rel=\"noopener\">efax</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pppsetup.html\" target=\"_blank\" rel=\"noopener\">pppsetup</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tcpdump.html\" target=\"_blank\" rel=\"noopener\">tcpdump</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ytalk.html\" target=\"_blank\" rel=\"noopener\">ytalk</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cu.html\" target=\"_blank\" rel=\"noopener\">cu</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-smbd.html\" target=\"_blank\" rel=\"noopener\">smbd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-testparm.html\" target=\"_blank\" rel=\"noopener\">testparm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-smbclient.html\" target=\"_blank\" rel=\"noopener\">smbclient</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-shapecfg.html\" target=\"_blank\" rel=\"noopener\">shapecfg</a></td>\n</tr>\n<tr>\n<td><strong>7、系统管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-adduser.html\" target=\"_blank\" rel=\"noopener\">adduser</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chfn.html\" target=\"_blank\" rel=\"noopener\">chfn</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-useradd.html\" target=\"_blank\" rel=\"noopener\">useradd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-date.html\" target=\"_blank\" rel=\"noopener\">date</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-exit.html\" target=\"_blank\" rel=\"noopener\">exit</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-finger.html\" target=\"_blank\" rel=\"noopener\">finger</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fwhios.html\" target=\"_blank\" rel=\"noopener\">fwhios</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sleep.html\" target=\"_blank\" rel=\"noopener\">sleep</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-suspend.html\" target=\"_blank\" rel=\"noopener\">suspend</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-groupdel.html\" target=\"_blank\" rel=\"noopener\">groupdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-groupmod.html\" target=\"_blank\" rel=\"noopener\">groupmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-halt.html\" target=\"_blank\" rel=\"noopener\">halt</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-kill.html\" target=\"_blank\" rel=\"noopener\">kill</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-last.html\" target=\"_blank\" rel=\"noopener\">last</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lastb.html\" target=\"_blank\" rel=\"noopener\">lastb</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-login.html\" target=\"_blank\" rel=\"noopener\">login</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logname.html\" target=\"_blank\" rel=\"noopener\">logname</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logout.html\" target=\"_blank\" rel=\"noopener\">logout</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ps.html\" target=\"_blank\" rel=\"noopener\">ps</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-nice.html\" target=\"_blank\" rel=\"noopener\">nice</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-procinfo.html\" target=\"_blank\" rel=\"noopener\">procinfo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-top.html\" target=\"_blank\" rel=\"noopener\">top</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pstree.html\" target=\"_blank\" rel=\"noopener\">pstree</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-reboot.html\" target=\"_blank\" rel=\"noopener\">reboot</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rlogin.html\" target=\"_blank\" rel=\"noopener\">rlogin</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rsh.html\" target=\"_blank\" rel=\"noopener\">rsh</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sliplogin.html\" target=\"_blank\" rel=\"noopener\">sliplogin</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-screen.html\" target=\"_blank\" rel=\"noopener\">screen</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-shutdown.html\" target=\"_blank\" rel=\"noopener\">shutdown</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rwho.html\" target=\"_blank\" rel=\"noopener\">rwho</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sudo.html\" target=\"_blank\" rel=\"noopener\">sudo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gitps.html\" target=\"_blank\" rel=\"noopener\">gitps</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-swatch.html\" target=\"_blank\" rel=\"noopener\">swatch</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tload.html\" target=\"_blank\" rel=\"noopener\">tload</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-logrotate.html\" target=\"_blank\" rel=\"noopener\">logrotate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uname.html\" target=\"_blank\" rel=\"noopener\">uname</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chsh.html\" target=\"_blank\" rel=\"noopener\">chsh</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-userconf.html\" target=\"_blank\" rel=\"noopener\">userconf</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-userdel.html\" target=\"_blank\" rel=\"noopener\">userdel</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-usermod.html\" target=\"_blank\" rel=\"noopener\">usermod</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-vlock.html\" target=\"_blank\" rel=\"noopener\">vlock</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-who.html\" target=\"_blank\" rel=\"noopener\">who</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whoami.html\" target=\"_blank\" rel=\"noopener\">whoami</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-whois.html\" target=\"_blank\" rel=\"noopener\">whois</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-newgrp.html\" target=\"_blank\" rel=\"noopener\">newgrp</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-renice.html\" target=\"_blank\" rel=\"noopener\">renice</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-su.html\" target=\"_blank\" rel=\"noopener\">su</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-skill.html\" target=\"_blank\" rel=\"noopener\">skill</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-w.html\" target=\"_blank\" rel=\"noopener\">w</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-id.html\" target=\"_blank\" rel=\"noopener\">id</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-free.html\" target=\"_blank\" rel=\"noopener\">free</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>8、系统设置</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-reset.html\" target=\"_blank\" rel=\"noopener\">reset</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-clear.html\" target=\"_blank\" rel=\"noopener\">clear</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-alias.html\" target=\"_blank\" rel=\"noopener\">alias</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dircolors.html\" target=\"_blank\" rel=\"noopener\">dircolors</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-aumix.html\" target=\"_blank\" rel=\"noopener\">aumix</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bind.html\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chroot.html\" target=\"_blank\" rel=\"noopener\">chroot</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-clock.html\" target=\"_blank\" rel=\"noopener\">clock</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-crontab.html\" target=\"_blank\" rel=\"noopener\">crontab</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-declare.html\" target=\"_blank\" rel=\"noopener\">declare</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-depmod.html\" target=\"_blank\" rel=\"noopener\">depmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dmesg.html\" target=\"_blank\" rel=\"noopener\">dmesg</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-enable.html\" target=\"_blank\" rel=\"noopener\">enable</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-eval.html\" target=\"_blank\" rel=\"noopener\">eval</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-export.html\" target=\"_blank\" rel=\"noopener\">export</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwunconv.html\" target=\"_blank\" rel=\"noopener\">pwunconv</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grpconv.html\" target=\"_blank\" rel=\"noopener\">grpconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rpm.html\" target=\"_blank\" rel=\"noopener\">rpm</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-insmod.html\" target=\"_blank\" rel=\"noopener\">insmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-kbdconfig.html\" target=\"_blank\" rel=\"noopener\">kbdconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lilo.html\" target=\"_blank\" rel=\"noopener\">lilo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-liloconfig.html\" target=\"_blank\" rel=\"noopener\">liloconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lsmod.html\" target=\"_blank\" rel=\"noopener\">lsmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-minfo.html\" target=\"_blank\" rel=\"noopener\">minfo</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-set.html\" target=\"_blank\" rel=\"noopener\">set</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-modprobe.html\" target=\"_blank\" rel=\"noopener\">modprobe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ntsysv.html\" target=\"_blank\" rel=\"noopener\">ntsysv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mouseconfig.html\" target=\"_blank\" rel=\"noopener\">mouseconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-passwd.html\" target=\"_blank\" rel=\"noopener\">passwd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-pwconv.html\" target=\"_blank\" rel=\"noopener\">pwconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rdate.html\" target=\"_blank\" rel=\"noopener\">rdate</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-resize.html\" target=\"_blank\" rel=\"noopener\">resize</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rmmod.html\" target=\"_blank\" rel=\"noopener\">rmmod</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-grpunconv.html\" target=\"_blank\" rel=\"noopener\">grpunconv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-modinfo.html\" target=\"_blank\" rel=\"noopener\">modinfo</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-time.html\" target=\"_blank\" rel=\"noopener\">time</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setup.html\" target=\"_blank\" rel=\"noopener\">setup</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-sndconfig.html\" target=\"_blank\" rel=\"noopener\">sndconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setenv.html\" target=\"_blank\" rel=\"noopener\">setenv</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setconsole.html\" target=\"_blank\" rel=\"noopener\">setconsole</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-timeconfig.html\" target=\"_blank\" rel=\"noopener\">timeconfig</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ulimit.html\" target=\"_blank\" rel=\"noopener\">ulimit</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unset.html\" target=\"_blank\" rel=\"noopener\">unset</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-chkconfig.html\" target=\"_blank\" rel=\"noopener\">chkconfig</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-apmd.html\" target=\"_blank\" rel=\"noopener\">apmd</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-hwclock.html\" target=\"_blank\" rel=\"noopener\">hwclock</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-mkkickstart.html\" target=\"_blank\" rel=\"noopener\">mkkickstart</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-fbset.html\" target=\"_blank\" rel=\"noopener\">fbset</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unalias.html\" target=\"_blank\" rel=\"noopener\">unalias</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-svgatextmode.html\" target=\"_blank\" rel=\"noopener\">SVGATextMode</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>9、备份压缩</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-ar.html\" target=\"_blank\" rel=\"noopener\">ar</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bunzip2.html\" target=\"_blank\" rel=\"noopener\">bunzip2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bzip2.html\" target=\"_blank\" rel=\"noopener\">bzip2</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-bzip2recover.html\" target=\"_blank\" rel=\"noopener\">bzip2recover</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gunzip.html\" target=\"_blank\" rel=\"noopener\">gunzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unarj.html\" target=\"_blank\" rel=\"noopener\">unarj</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-compress.html\" target=\"_blank\" rel=\"noopener\">compress</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-cpio.html\" target=\"_blank\" rel=\"noopener\">cpio</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dump.html\" target=\"_blank\" rel=\"noopener\">dump</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uuencode.html\" target=\"_blank\" rel=\"noopener\">uuencode</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gzexe.html\" target=\"_blank\" rel=\"noopener\">gzexe</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-gzip.html\" target=\"_blank\" rel=\"noopener\">gzip</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-lha.html\" target=\"_blank\" rel=\"noopener\">lha</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-restore.html\" target=\"_blank\" rel=\"noopener\">restore</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-tar.html\" target=\"_blank\" rel=\"noopener\">tar</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-uudecode.html\" target=\"_blank\" rel=\"noopener\">uudecode</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-unzip.html\" target=\"_blank\" rel=\"noopener\">unzip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-zipinfo.html\" target=\"_blank\" rel=\"noopener\">zipinfo</a></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>10、设备管理</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-setleds.html\" target=\"_blank\" rel=\"noopener\">setleds</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-loadkeys.html\" target=\"_blank\" rel=\"noopener\">loadkeys</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-rdev.html\" target=\"_blank\" rel=\"noopener\">rdev</a></td>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-dumpkeys.html\" target=\"_blank\" rel=\"noopener\">dumpkeys</a></td>\n</tr>\n<tr>\n<td><a href=\"http://www.runoob.com/linux/linux-comm-makedev.html\" target=\"_blank\" rel=\"noopener\">MAKEDEV</a></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"python","date":"2019-08-15T06:27:07.000Z","_content":"\n\n\n\n\n# [matplotlib](https://matplotlib.org/index.html)\n\nhttps://serverpoolauth.ops.ctripcorp.com\n\n","source":"_posts/python.md","raw":"---\ntitle: python\ndate: 2019-08-15 14:27:07\ntags:\n---\n\n\n\n\n\n# [matplotlib](https://matplotlib.org/index.html)\n\nhttps://serverpoolauth.ops.ctripcorp.com\n\n","slug":"python","published":1,"updated":"2019-08-15T08:58:10.683Z","_id":"cjzdr6iz6002vhomjnaa24snl","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"matplotlib\"><a href=\"#matplotlib\" class=\"headerlink\" title=\"matplotlib\"></a><a href=\"https://matplotlib.org/index.html\" target=\"_blank\" rel=\"noopener\">matplotlib</a></h1><p><a href=\"https://serverpoolauth.ops.ctripcorp.com\" target=\"_blank\" rel=\"noopener\">https://serverpoolauth.ops.ctripcorp.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"matplotlib\"><a href=\"#matplotlib\" class=\"headerlink\" title=\"matplotlib\"></a><a href=\"https://matplotlib.org/index.html\" target=\"_blank\" rel=\"noopener\">matplotlib</a></h1><p><a href=\"https://serverpoolauth.ops.ctripcorp.com\" target=\"_blank\" rel=\"noopener\">https://serverpoolauth.ops.ctripcorp.com</a></p>\n"},{"title":"linux子系统-win10","date":"2019-08-05T09:29:40.000Z","_content":"\n# Windows10安装Ubuntu子系统\n\n## 一、启用或关闭Windows功能\n\n![1565005612829](linux子系统-win10/1565005612829.png)\n\n<!--more-->\n\n## 二、开启开发模式\n\n“设置 - 更新和安全 - 针对开发人员”设置页面，选中“开发人员模式”。\n\n![tempsnip](linux子系统-win10/tempsnip.png)\n\n## 三、安装 Linux 子系统\n\n打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本\n\n![Windows10å®è£Linuxå­ç³»ç»Ubuntu](linux子系统-win10/20171212111834391.jpg)\n\n## 四、一个好看的cmd\n\n[zsh](https://link.zhihu.com/?target=http%3A//www.zsh.org/)（Z Shell）是一个功能强大的交互式shell脚本命令解释器。它不仅支持bash，还提供一些强大和高效的功能，例如更好的**自动补全**和**纠错**。貌似很好用\n\n```shell\nsudo apt-get install zsh     #安装oh-my-zsh首先需要安装zsh\nzsh --version                #查看版本号\n\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"        #使用curl安装oh-my-zsh\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"   #使用wget安装oh-my-zsh\n```\n\n在`vim ~/.bash_profile`中启用zsh，编辑文件，在末尾添加：\n\n```shell\nexec zsh\nsource .zshrc\n```\n\n## 五、安装配置Cmder命令行终端\n\n访问[cmder.net](https://cmder.net/)，下载mini版本即可\n\n1. 修改启动参数\n\n   修改启动参数填入`bash -cur_console:p`，这样我们直接打开cmder后就可以进入到linux系统了\n\n   ![img](linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg)\n\n2. 将cmder添加进win10的右键菜单\n\n   1. 右键点击我的电脑--属性--高级系统设置--环境变量--系统变量，**点击新建，变量名设置为：**CMDER_HOME，变量值直接粘贴刚才拷贝的地址，\n\n   2. 然后点击系统变量中的path，点击新建，输入%CMDER_HOME%\n      ![tempsnip](linux子系统-win10/tempsnip-1565012471202.png)\n   3. 使用管理员权限打开cmder终端运行`Cmder.exe /REGISTER ALL`\n\n# 文件夹互相访问\n\n## win10访问ubuntu\n\n```shell\nC:\\Users\\xxx\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\xxx\n```\n\n\n\n## ubuntu访问win10\n\n```shell\n/mnt/c/Users    # 进入win10的c盘的Users\n```\n\n### 可以建立一个win10的快捷方式\n\n```shell\nln -s /mnt/c/Users/xxx ~/win10    建立链接\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/linux子系统-win10.md","raw":"---\ntitle: linux子系统-win10\ndate: 2019-08-05 17:29:40\ntags: [操作系统,开发环境]\ncategories: linux\n---\n\n# Windows10安装Ubuntu子系统\n\n## 一、启用或关闭Windows功能\n\n![1565005612829](linux子系统-win10/1565005612829.png)\n\n<!--more-->\n\n## 二、开启开发模式\n\n“设置 - 更新和安全 - 针对开发人员”设置页面，选中“开发人员模式”。\n\n![tempsnip](linux子系统-win10/tempsnip.png)\n\n## 三、安装 Linux 子系统\n\n打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本\n\n![Windows10å®è£Linuxå­ç³»ç»Ubuntu](linux子系统-win10/20171212111834391.jpg)\n\n## 四、一个好看的cmd\n\n[zsh](https://link.zhihu.com/?target=http%3A//www.zsh.org/)（Z Shell）是一个功能强大的交互式shell脚本命令解释器。它不仅支持bash，还提供一些强大和高效的功能，例如更好的**自动补全**和**纠错**。貌似很好用\n\n```shell\nsudo apt-get install zsh     #安装oh-my-zsh首先需要安装zsh\nzsh --version                #查看版本号\n\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"        #使用curl安装oh-my-zsh\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"   #使用wget安装oh-my-zsh\n```\n\n在`vim ~/.bash_profile`中启用zsh，编辑文件，在末尾添加：\n\n```shell\nexec zsh\nsource .zshrc\n```\n\n## 五、安装配置Cmder命令行终端\n\n访问[cmder.net](https://cmder.net/)，下载mini版本即可\n\n1. 修改启动参数\n\n   修改启动参数填入`bash -cur_console:p`，这样我们直接打开cmder后就可以进入到linux系统了\n\n   ![img](linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg)\n\n2. 将cmder添加进win10的右键菜单\n\n   1. 右键点击我的电脑--属性--高级系统设置--环境变量--系统变量，**点击新建，变量名设置为：**CMDER_HOME，变量值直接粘贴刚才拷贝的地址，\n\n   2. 然后点击系统变量中的path，点击新建，输入%CMDER_HOME%\n      ![tempsnip](linux子系统-win10/tempsnip-1565012471202.png)\n   3. 使用管理员权限打开cmder终端运行`Cmder.exe /REGISTER ALL`\n\n# 文件夹互相访问\n\n## win10访问ubuntu\n\n```shell\nC:\\Users\\xxx\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\xxx\n```\n\n\n\n## ubuntu访问win10\n\n```shell\n/mnt/c/Users    # 进入win10的c盘的Users\n```\n\n### 可以建立一个win10的快捷方式\n\n```shell\nln -s /mnt/c/Users/xxx ~/win10    建立链接\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"linux子系统-win10","published":1,"updated":"2019-08-06T01:52:57.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iz90030homjablgi8p8","content":"<h1 id=\"Windows10安装Ubuntu子系统\"><a href=\"#Windows10安装Ubuntu子系统\" class=\"headerlink\" title=\"Windows10安装Ubuntu子系统\"></a>Windows10安装Ubuntu子系统</h1><h2 id=\"一、启用或关闭Windows功能\"><a href=\"#一、启用或关闭Windows功能\" class=\"headerlink\" title=\"一、启用或关闭Windows功能\"></a>一、启用或关闭Windows功能</h2><p><img src=\"/2019/08/05/linux子系统-win10/1565005612829.png\" alt=\"1565005612829\"></p>\n<a id=\"more\"></a>\n<h2 id=\"二、开启开发模式\"><a href=\"#二、开启开发模式\" class=\"headerlink\" title=\"二、开启开发模式\"></a>二、开启开发模式</h2><p>“设置 - 更新和安全 - 针对开发人员”设置页面，选中“开发人员模式”。</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/tempsnip.png\" alt=\"tempsnip\"></p>\n<h2 id=\"三、安装-Linux-子系统\"><a href=\"#三、安装-Linux-子系统\" class=\"headerlink\" title=\"三、安装 Linux 子系统\"></a>三、安装 Linux 子系统</h2><p>打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/20171212111834391.jpg\" alt=\"Windows10å®è£Linuxå­ç³»ç»Ubuntu\"></p>\n<h2 id=\"四、一个好看的cmd\"><a href=\"#四、一个好看的cmd\" class=\"headerlink\" title=\"四、一个好看的cmd\"></a>四、一个好看的cmd</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.zsh.org/\" target=\"_blank\" rel=\"noopener\">zsh</a>（Z Shell）是一个功能强大的交互式shell脚本命令解释器。它不仅支持bash，还提供一些强大和高效的功能，例如更好的<strong>自动补全</strong>和<strong>纠错</strong>。貌似很好用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install zsh     #安装oh-my-zsh首先需要安装zsh</span><br><span class=\"line\">zsh --version                #查看版本号</span><br><span class=\"line\"></span><br><span class=\"line\">sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"        #使用curl安装oh-my-zsh</span><br><span class=\"line\">sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"   #使用wget安装oh-my-zsh</span><br></pre></td></tr></table></figure>\n<p>在<code>vim ~/.bash_profile</code>中启用zsh，编辑文件，在末尾添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec zsh</span><br><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、安装配置Cmder命令行终端\"><a href=\"#五、安装配置Cmder命令行终端\" class=\"headerlink\" title=\"五、安装配置Cmder命令行终端\"></a>五、安装配置Cmder命令行终端</h2><p>访问<a href=\"https://cmder.net/\" target=\"_blank\" rel=\"noopener\">cmder.net</a>，下载mini版本即可</p>\n<ol>\n<li><p>修改启动参数</p>\n<p>修改启动参数填入<code>bash -cur_console:p</code>，这样我们直接打开cmder后就可以进入到linux系统了</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg\" alt=\"img\"></p>\n</li>\n<li><p>将cmder添加进win10的右键菜单</p>\n<ol>\n<li><p>右键点击我的电脑—属性—高级系统设置—环境变量—系统变量，<strong>点击新建，变量名设置为：</strong>CMDER_HOME，变量值直接粘贴刚才拷贝的地址，</p>\n</li>\n<li><p>然后点击系统变量中的path，点击新建，输入%CMDER_HOME%<br><img src=\"/2019/08/05/linux子系统-win10/tempsnip-1565012471202.png\" alt=\"tempsnip\"></p>\n</li>\n<li>使用管理员权限打开cmder终端运行<code>Cmder.exe /REGISTER ALL</code></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"文件夹互相访问\"><a href=\"#文件夹互相访问\" class=\"headerlink\" title=\"文件夹互相访问\"></a>文件夹互相访问</h1><h2 id=\"win10访问ubuntu\"><a href=\"#win10访问ubuntu\" class=\"headerlink\" title=\"win10访问ubuntu\"></a>win10访问ubuntu</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\xxx\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\xxx</span><br></pre></td></tr></table></figure>\n<h2 id=\"ubuntu访问win10\"><a href=\"#ubuntu访问win10\" class=\"headerlink\" title=\"ubuntu访问win10\"></a>ubuntu访问win10</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/mnt/c/Users    # 进入win10的c盘的Users</span><br></pre></td></tr></table></figure>\n<h3 id=\"可以建立一个win10的快捷方式\"><a href=\"#可以建立一个win10的快捷方式\" class=\"headerlink\" title=\"可以建立一个win10的快捷方式\"></a>可以建立一个win10的快捷方式</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /mnt/c/Users/xxx ~/win10    建立链接</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"Windows10安装Ubuntu子系统\"><a href=\"#Windows10安装Ubuntu子系统\" class=\"headerlink\" title=\"Windows10安装Ubuntu子系统\"></a>Windows10安装Ubuntu子系统</h1><h2 id=\"一、启用或关闭Windows功能\"><a href=\"#一、启用或关闭Windows功能\" class=\"headerlink\" title=\"一、启用或关闭Windows功能\"></a>一、启用或关闭Windows功能</h2><p><img src=\"/2019/08/05/linux子系统-win10/1565005612829.png\" alt=\"1565005612829\"></p>","more":"<h2 id=\"二、开启开发模式\"><a href=\"#二、开启开发模式\" class=\"headerlink\" title=\"二、开启开发模式\"></a>二、开启开发模式</h2><p>“设置 - 更新和安全 - 针对开发人员”设置页面，选中“开发人员模式”。</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/tempsnip.png\" alt=\"tempsnip\"></p>\n<h2 id=\"三、安装-Linux-子系统\"><a href=\"#三、安装-Linux-子系统\" class=\"headerlink\" title=\"三、安装 Linux 子系统\"></a>三、安装 Linux 子系统</h2><p>打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/20171212111834391.jpg\" alt=\"Windows10å®è£Linuxå­ç³»ç»Ubuntu\"></p>\n<h2 id=\"四、一个好看的cmd\"><a href=\"#四、一个好看的cmd\" class=\"headerlink\" title=\"四、一个好看的cmd\"></a>四、一个好看的cmd</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.zsh.org/\" target=\"_blank\" rel=\"noopener\">zsh</a>（Z Shell）是一个功能强大的交互式shell脚本命令解释器。它不仅支持bash，还提供一些强大和高效的功能，例如更好的<strong>自动补全</strong>和<strong>纠错</strong>。貌似很好用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install zsh     #安装oh-my-zsh首先需要安装zsh</span><br><span class=\"line\">zsh --version                #查看版本号</span><br><span class=\"line\"></span><br><span class=\"line\">sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"        #使用curl安装oh-my-zsh</span><br><span class=\"line\">sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"   #使用wget安装oh-my-zsh</span><br></pre></td></tr></table></figure>\n<p>在<code>vim ~/.bash_profile</code>中启用zsh，编辑文件，在末尾添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec zsh</span><br><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、安装配置Cmder命令行终端\"><a href=\"#五、安装配置Cmder命令行终端\" class=\"headerlink\" title=\"五、安装配置Cmder命令行终端\"></a>五、安装配置Cmder命令行终端</h2><p>访问<a href=\"https://cmder.net/\" target=\"_blank\" rel=\"noopener\">cmder.net</a>，下载mini版本即可</p>\n<ol>\n<li><p>修改启动参数</p>\n<p>修改启动参数填入<code>bash -cur_console:p</code>，这样我们直接打开cmder后就可以进入到linux系统了</p>\n<p><img src=\"/2019/08/05/linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg\" alt=\"img\"></p>\n</li>\n<li><p>将cmder添加进win10的右键菜单</p>\n<ol>\n<li><p>右键点击我的电脑—属性—高级系统设置—环境变量—系统变量，<strong>点击新建，变量名设置为：</strong>CMDER_HOME，变量值直接粘贴刚才拷贝的地址，</p>\n</li>\n<li><p>然后点击系统变量中的path，点击新建，输入%CMDER_HOME%<br><img src=\"/2019/08/05/linux子系统-win10/tempsnip-1565012471202.png\" alt=\"tempsnip\"></p>\n</li>\n<li>使用管理员权限打开cmder终端运行<code>Cmder.exe /REGISTER ALL</code></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"文件夹互相访问\"><a href=\"#文件夹互相访问\" class=\"headerlink\" title=\"文件夹互相访问\"></a>文件夹互相访问</h1><h2 id=\"win10访问ubuntu\"><a href=\"#win10访问ubuntu\" class=\"headerlink\" title=\"win10访问ubuntu\"></a>win10访问ubuntu</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\xxx\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\rootfs\\home\\xxx</span><br></pre></td></tr></table></figure>\n<h2 id=\"ubuntu访问win10\"><a href=\"#ubuntu访问win10\" class=\"headerlink\" title=\"ubuntu访问win10\"></a>ubuntu访问win10</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/mnt/c/Users    # 进入win10的c盘的Users</span><br></pre></td></tr></table></figure>\n<h3 id=\"可以建立一个win10的快捷方式\"><a href=\"#可以建立一个win10的快捷方式\" class=\"headerlink\" title=\"可以建立一个win10的快捷方式\"></a>可以建立一个win10的快捷方式</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /mnt/c/Users/xxx ~/win10    建立链接</span><br></pre></td></tr></table></figure>"},{"title":"shell","date":"2019-07-30T02:29:25.000Z","_content":"\n\n\nShell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。\n\n# 运行脚本\n\n运行 Shell 脚本有两种方法：**1、作为可执行程序**；**2、作为解释器参数**\n\n## 1、作为可执行程序\n\n```shell\nchmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n```\n\n## 2、作为解释器参数\n\n```shell\n/bin/sh test.sh\n/bin/php test.php\n```\n\n<!--more-->\n\n# 变量\n\n## 变量名 \n\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n## 使用变量\n\n```shell\nyour_name=\"qinjx\"\necho ${your_name}\n```\n\n## 只读变量\n\n使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n\n```shell\n#!/bin/bash\nmyUrl=\"http://www.google.com\"\nreadonly myUrl\n```\n\n## 删除变量\n\n使用 unset 命令可以删除变量，变量被删除后不能再次使用。unset 命令不能删除只读变量。\n\n```shell\nunset variable_name\n```\n\n## 变量类型\n\n- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n# Shell 字符串\n\n| 符号     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| ‘-单引号 | 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； |\n| “-双引号 | 双引号里可以有变量，双引号里可以添加转义字符                 |\n\n\n\n## 拼接字符\n\n```shell\nyour_name=\"runoob\"\n# 使用双引号拼接\ngreeting=\"hello, \"$your_name\" !\"\ngreeting_1=\"hello, ${your_name} !\"\necho $greeting  $greeting_1\n# 使用单引号拼接\ngreeting_2='hello, '$your_name' !'\ngreeting_3='hello, ${your_name} !'\necho $greeting_2  $greeting_3\n```\n\n输出\n\n```shell\nhello, runoob ! hello, runoob !\nhello, runoob ! hello, ${your_name} !\n```\n\n## 获取字符串长度\n\n```shell\nstring=\"abcd\"\necho ${#string} #输出 4\n```\n\n## 提取子字符串\n\n```shell\nstring=\"runoob is a great site\"\necho ${string:1:4} # 输出 unoo\n```\n\n## 查找子字符串\n\n```shell\nstring=\"runoob is a great site\"\necho `expr index \"$string\" io`  # 输出 4\n```\n\n# 数组\n\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n\n```shell\narray_name=(value0 value1 value2 value3)  #定义数组\n\n#### 读取数据\nvaluen=${array_name[n]}    #读取单个元素\necho ${array_name[@]}      #读取所有元素\n\n#### 数组长度\nlength=${#array_name[@]}   #取得数组所有元素的个数\nlengthn=${#array_name[n]}  #取得数组单个元素的长度\n```\n\n# 传递参数\n\n我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $n       | n代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推 |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数。 <br>如\"\\$\\*\"用「\"」括起来的情况、以\"\\$1 ​\\$2 … $n\"的形式输出所有参数。 |\n| $@       | 与\\$*相同，但是使用时加引号，并在引号中返回每个参数。<br> 如\"​\\$@\"用「\"」括起来的情况、以\"​\\$1\" \"​\\$2\" … \"$n\" 的形式输出所有参数。 |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n**注意**：\\$* 与 \\$@ 区别：\n\n- 相同点：都是引用所有参数。\n\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n\n  ```shell\n  #!/bin/bash\n  # author:菜鸟教程\n  # url:www.runoob.com\n  \n  echo \"-- \\$* 演示 ---\"\n  for i in \"$*\"; do\n      echo $i\n  done\n  \n  echo \"-- \\$@ 演示 ---\"\n  for i in \"$@\"; do\n      echo $i\n  done\n  ```\n\n  输出\n\n  ```shell\n  $ chmod +x test.sh \n  $ ./test.sh 1 2 3\n  -- $* 演示 ---\n  1 2 3\n  -- $@ 演示 ---\n  1\n  2\n  3\n  ```\n\n  \n\n# 运算符\n\n| 运算符 | 说明                                                  | 举例                                      |\n| ------ | ----------------------------------------------------- | ----------------------------------------- |\n| %      | 取余                                                  | `expr $b % $a` 结果为 0。                 |\n| =      | 赋值                                                  | `a=$b` 将把变量 b 的值赋给 a。            |\n| ==     | 相等。用于比较两个数字，相同则返回 true。             | `[$a == $b]` 返回 false。                 |\n| !=     | 不相等。用于比较两个数字，不相同则返回 true。         | `[$a != $b ]`返回 true。                  |\n| -eq    | 检测两个数是否相等，相等返回 true。                   | `[$a -eq $b]` 返回 false。                |\n| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[$a -ne $b]` 返回 true。                 |\n| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[$a -gt $b]` 返回 false。                |\n| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[$a -lt $b]` 返回 true。                 |\n| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[$a -ge $b]` 返回 false。                |\n| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[$a -le $b]` 返回 true。                 |\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。   | `[!false]` 返回 true。                    |\n| -o     | 或运算，有一个表达式为 true 则返回 true。             | `[$a -lt 20 -o $b -gt 100]` 返回 true。   |\n| -a     | 与运算，两个表达式都为 true 才返回 true。             | `[$a -lt 20 -a $b -gt 100] `返回 false。  |\n| &&     | 逻辑的 AND                                            | `[[$a -lt 100 && $b -gt 100]]` 返回 false |\n| &#124;&#124; | 逻辑的 OR                                             | `[[\\$a -lt 100` &#124;&#124; `$b -gt 100 ]] `返回 true |\n\n```shell\na=10\nb=20\n\nif [[ $a -lt 100 && $b -gt 100 ]]\nthen\n   echo \"返回 true\"\nelse\n   echo \"返回 false\"\nfi\n```\n\n\n\n## 字符串运算符\n\n| 运算符 | 说明                                      | 举例                       |\n| :----- | :---------------------------------------- | :------------------------- |\n| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。   |\n| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ 、$a != $b ] 返回 true。 |\n| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。     |\n| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n \"$a\" ] 返回 true。    |\n| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。         |\n\n## 文件测试运算符\n\n| 操作符  | 说明                                                         | 举例                      |\n| :-----: | :----------------------------------------------------------- | :------------------------ |\n| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |\n| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |\n| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |\n| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |\n| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |\n| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |\n| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |\n| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |\n| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |\n| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |\n| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |\n| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |\n| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |\n\n# echo命令\n\n| 说明                  | 输入                                                         | 输出                         |\n| --------------------- | ------------------------------------------------------------ | ---------------------------- |\n| 显示普通字符串        | echo \"It is a test\"                                          | echo It is a test            |\n| 显示转义字符          | echo \"\\\"It is a test\\\"\"                                      | \"It is a test\"               |\n| 显示变量              | echo \"$name It is a test\"                                    | ok It is a test              |\n| 显示换行              | echo -e \"OK! \\n\" # -e 开启转义<br>echo \"It is a test\"        | OK!<br><br>OK!  It is a test |\n| 显示不换行            | echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行<br>echo \"It is a test\" | OK! It is a test             |\n| 显示结果定向至文件    | echo \"It is a test\" > myfile                                 |                              |\n| 原样输出字符串-单引号 | echo '$name\\\\\"'                                              | $name\\\"                      |\n| 显示命令执行结果      | echo \\`date\\`                                                | Thu Jul 24 10:08:46 CST 2014 |\n\n\n\n# printf\n\n```shell\nprintf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  \nprintf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 \nprintf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 \nprintf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 \n```\n\n- %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。\n- %-4.2f 指格式化为小数，其中.2指保留2位小数。\n\n# 转义字符\n\n| 序列  | 说明                                                         |\n| :---- | :----------------------------------------------------------- |\n| \\a    | 警告字符，通常为ASCII的BEL字符                               |\n| \\b    | 后退                                                         |\n| \\c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |\n| \\f    | 换页（formfeed）                                             |\n| \\n    | 换行                                                         |\n| \\r    | 回车（Carriage return）                                      |\n| \\t    | 水平制表符                                                   |\n| \\v    | 垂直制表符                                                   |\n| \\\\    | 一个字面上的反斜杠字符                                       |\n| \\ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             |\n| \\0ddd | 表示1到3位的八进制值字符                                     |\n\n# 流程控制\n\n## if else\n\n```shell\nif condition\nthen\n    command1 \n    command2\n    ...\n    commandN \nfi\n```\n\n## if else-if else\n\n```shell\nif condition1\nthen\n    command1\nelif condition2 \nthen \n    command2\nelse\n    commandN\nfi\n```\n\n## for循环\n\n```shell\nfor var in item1 item2 ... itemN\ndo\n    command1\n    command2\n    ...\n    commandN\ndone\n\n```\n\n## while 语句\n\n```shell\nwhile condition\ndo\n    command\ndone\n\n```\n\n## until 循环\n\nuntil 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。\n\n```shell\nuntil condition\ndo\n    command\ndone\n\n```\n\n## case语句\n\n```shell\ncase 值 in\n模式1)\n    command1\n    command2\n    ...\n    commandN\n    ;;\n模式2）\n    command1\n    command2\n    ...\n    commandN\n    ;;\nesac\n\n```\n\n## break\n\n跳出所有的循环\n\n## continue\n\n跳出当前循环\n\n# 函数\n\n```shell\n#!/bin/bash\n# author:菜鸟教程\n# url:www.runoob.com\n\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n```\n\n输出结果：\n\n```shell\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n```\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数                       |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n# Shell 输入/输出重定向\n\n| 命令            | 说明                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| command > file  | 将输出重定向到 file。任何file内的已经存在的内容将被新内容替代 |\n| command < file  | 将输入重定向到 file。本来需要从键盘获取输入的命令会转移到文件读取内容。 |\n| command >> file | 将输出以追加的方式重定向到 file。                            |\n| n > file        | 将文件描述符为 n 的文件重定向到 file。                       |\n| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。将新内容添加在文件末尾 |\n| n >& m          | 将输出文件 m 和 n 合并。                                     |\n| n <& m          | 将输入文件 m 和 n 合并。                                     |\n| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。           |\n\n## 重定向深入讲解\n\n- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n\n- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n\n- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n  \n\n```shell\n command >> file 2>&1  #将 stdout 和 stderr 合并后重定向到 file\n\n```\n\n# Shell 文件包含\n\n和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n\n```shell\n. filename   # 注意点号(.)和文件名中间有一空格\n\n或\n\nsource filename\n```\n\n# 日期\n\n| 命令                                | 说明                  |\n| ----------------------------------- | --------------------- |\n| `date +%Y%m%d`<br>`$(date +%Y%m%d)` | 获取今天日期          |\n| `date -d -2day +%Y%m%d`             | 获取前天日期（2天前） |\n| `date -d 2day +%Y%m%d`              | 获取后天日期（2天后） |\n\n| 命令  | 说明                          | 命令  | 说明                                   |\n| ----- | ----------------------------- | ----- | -------------------------------------- |\n| `%H`  | 小时（00..23）                | `%I ` | 小时（01..12）                         |\n| `%k ` | 小时（0..23）                 | `%l ` | 小时（1..12）                          |\n| `%M`  | 分（00..59）                  | `%p`  | 显示出AM或PM                           |\n| `%r ` | 时间(hh:mm:ss AM或PM)，12小时 | `%s ` | 从1970年1月1日00:00:00到目前经历的秒数 |\n| `%S` | 秒（00..59）                  |` %T `  | 时间（24小时制）（hh:mm:ss）      |\n| `%X ` | 显示时间的格式（％H:％M:％S） | `%Z `  | 时区 日期域                                |\n| `%a`  | 星期几的简称（ Sun..Sat）                  | `%A`   | 星期几的全称（ Sunday..Saturday）          |\n| `%b`  | 月的简称（Jan..Dec）                       | `%B`   | 月的全称（January..December）              |\n| `%c ` | 日期和时间（ Mon Nov 8 14:12:46 CST 1999） | `%d`   | 一个月的第几天（01..31）                   |\n| `%D`  | 日期（mm／dd／yy）                         | `%h`   | 和%b选项相同 |\n| `%j`  | 一年的第几天（001..366） | `%m` | 月（01..12） |\n| `%w` | 一个星期的第几天（0代表星期天） | `%W` | 一年的第几个星期（00..53，星期一为第一天） |\n| `%x` | 显示日期的格式（mm/dd/yy）                 | `%y`   | 年的最后两个数字（ 1999则是99）            |\n| `%Y`  | 年（例如：1970，1996等） |       |                                        |\n\n","source":"_posts/shell.md","raw":"---\ntitle: shell\ndate: 2019-07-30 10:29:25\ntags: [操作系统,编程语言]\ncategories: linux\n---\n\n\n\nShell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。\n\n# 运行脚本\n\n运行 Shell 脚本有两种方法：**1、作为可执行程序**；**2、作为解释器参数**\n\n## 1、作为可执行程序\n\n```shell\nchmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n```\n\n## 2、作为解释器参数\n\n```shell\n/bin/sh test.sh\n/bin/php test.php\n```\n\n<!--more-->\n\n# 变量\n\n## 变量名 \n\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n## 使用变量\n\n```shell\nyour_name=\"qinjx\"\necho ${your_name}\n```\n\n## 只读变量\n\n使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n\n```shell\n#!/bin/bash\nmyUrl=\"http://www.google.com\"\nreadonly myUrl\n```\n\n## 删除变量\n\n使用 unset 命令可以删除变量，变量被删除后不能再次使用。unset 命令不能删除只读变量。\n\n```shell\nunset variable_name\n```\n\n## 变量类型\n\n- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n# Shell 字符串\n\n| 符号     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| ‘-单引号 | 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； |\n| “-双引号 | 双引号里可以有变量，双引号里可以添加转义字符                 |\n\n\n\n## 拼接字符\n\n```shell\nyour_name=\"runoob\"\n# 使用双引号拼接\ngreeting=\"hello, \"$your_name\" !\"\ngreeting_1=\"hello, ${your_name} !\"\necho $greeting  $greeting_1\n# 使用单引号拼接\ngreeting_2='hello, '$your_name' !'\ngreeting_3='hello, ${your_name} !'\necho $greeting_2  $greeting_3\n```\n\n输出\n\n```shell\nhello, runoob ! hello, runoob !\nhello, runoob ! hello, ${your_name} !\n```\n\n## 获取字符串长度\n\n```shell\nstring=\"abcd\"\necho ${#string} #输出 4\n```\n\n## 提取子字符串\n\n```shell\nstring=\"runoob is a great site\"\necho ${string:1:4} # 输出 unoo\n```\n\n## 查找子字符串\n\n```shell\nstring=\"runoob is a great site\"\necho `expr index \"$string\" io`  # 输出 4\n```\n\n# 数组\n\nbash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n\n```shell\narray_name=(value0 value1 value2 value3)  #定义数组\n\n#### 读取数据\nvaluen=${array_name[n]}    #读取单个元素\necho ${array_name[@]}      #读取所有元素\n\n#### 数组长度\nlength=${#array_name[@]}   #取得数组所有元素的个数\nlengthn=${#array_name[n]}  #取得数组单个元素的长度\n```\n\n# 传递参数\n\n我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $n       | n代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推 |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数。 <br>如\"\\$\\*\"用「\"」括起来的情况、以\"\\$1 ​\\$2 … $n\"的形式输出所有参数。 |\n| $@       | 与\\$*相同，但是使用时加引号，并在引号中返回每个参数。<br> 如\"​\\$@\"用「\"」括起来的情况、以\"​\\$1\" \"​\\$2\" … \"$n\" 的形式输出所有参数。 |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n**注意**：\\$* 与 \\$@ 区别：\n\n- 相同点：都是引用所有参数。\n\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n\n  ```shell\n  #!/bin/bash\n  # author:菜鸟教程\n  # url:www.runoob.com\n  \n  echo \"-- \\$* 演示 ---\"\n  for i in \"$*\"; do\n      echo $i\n  done\n  \n  echo \"-- \\$@ 演示 ---\"\n  for i in \"$@\"; do\n      echo $i\n  done\n  ```\n\n  输出\n\n  ```shell\n  $ chmod +x test.sh \n  $ ./test.sh 1 2 3\n  -- $* 演示 ---\n  1 2 3\n  -- $@ 演示 ---\n  1\n  2\n  3\n  ```\n\n  \n\n# 运算符\n\n| 运算符 | 说明                                                  | 举例                                      |\n| ------ | ----------------------------------------------------- | ----------------------------------------- |\n| %      | 取余                                                  | `expr $b % $a` 结果为 0。                 |\n| =      | 赋值                                                  | `a=$b` 将把变量 b 的值赋给 a。            |\n| ==     | 相等。用于比较两个数字，相同则返回 true。             | `[$a == $b]` 返回 false。                 |\n| !=     | 不相等。用于比较两个数字，不相同则返回 true。         | `[$a != $b ]`返回 true。                  |\n| -eq    | 检测两个数是否相等，相等返回 true。                   | `[$a -eq $b]` 返回 false。                |\n| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[$a -ne $b]` 返回 true。                 |\n| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[$a -gt $b]` 返回 false。                |\n| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[$a -lt $b]` 返回 true。                 |\n| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[$a -ge $b]` 返回 false。                |\n| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[$a -le $b]` 返回 true。                 |\n| !      | 非运算，表达式为 true 则返回 false，否则返回 true。   | `[!false]` 返回 true。                    |\n| -o     | 或运算，有一个表达式为 true 则返回 true。             | `[$a -lt 20 -o $b -gt 100]` 返回 true。   |\n| -a     | 与运算，两个表达式都为 true 才返回 true。             | `[$a -lt 20 -a $b -gt 100] `返回 false。  |\n| &&     | 逻辑的 AND                                            | `[[$a -lt 100 && $b -gt 100]]` 返回 false |\n| &#124;&#124; | 逻辑的 OR                                             | `[[\\$a -lt 100` &#124;&#124; `$b -gt 100 ]] `返回 true |\n\n```shell\na=10\nb=20\n\nif [[ $a -lt 100 && $b -gt 100 ]]\nthen\n   echo \"返回 true\"\nelse\n   echo \"返回 false\"\nfi\n```\n\n\n\n## 字符串运算符\n\n| 运算符 | 说明                                      | 举例                       |\n| :----- | :---------------------------------------- | :------------------------- |\n| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。   |\n| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ 、$a != $b ] 返回 true。 |\n| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。     |\n| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n \"$a\" ] 返回 true。    |\n| $      | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。         |\n\n## 文件测试运算符\n\n| 操作符  | 说明                                                         | 举例                      |\n| :-----: | :----------------------------------------------------------- | :------------------------ |\n| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |\n| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |\n| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |\n| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |\n| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |\n| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |\n| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |\n| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |\n| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |\n| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |\n| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |\n| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |\n| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |\n\n# echo命令\n\n| 说明                  | 输入                                                         | 输出                         |\n| --------------------- | ------------------------------------------------------------ | ---------------------------- |\n| 显示普通字符串        | echo \"It is a test\"                                          | echo It is a test            |\n| 显示转义字符          | echo \"\\\"It is a test\\\"\"                                      | \"It is a test\"               |\n| 显示变量              | echo \"$name It is a test\"                                    | ok It is a test              |\n| 显示换行              | echo -e \"OK! \\n\" # -e 开启转义<br>echo \"It is a test\"        | OK!<br><br>OK!  It is a test |\n| 显示不换行            | echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行<br>echo \"It is a test\" | OK! It is a test             |\n| 显示结果定向至文件    | echo \"It is a test\" > myfile                                 |                              |\n| 原样输出字符串-单引号 | echo '$name\\\\\"'                                              | $name\\\"                      |\n| 显示命令执行结果      | echo \\`date\\`                                                | Thu Jul 24 10:08:46 CST 2014 |\n\n\n\n# printf\n\n```shell\nprintf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  \nprintf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 \nprintf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 \nprintf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 \n```\n\n- %-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。\n- %-4.2f 指格式化为小数，其中.2指保留2位小数。\n\n# 转义字符\n\n| 序列  | 说明                                                         |\n| :---- | :----------------------------------------------------------- |\n| \\a    | 警告字符，通常为ASCII的BEL字符                               |\n| \\b    | 后退                                                         |\n| \\c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 |\n| \\f    | 换页（formfeed）                                             |\n| \\n    | 换行                                                         |\n| \\r    | 回车（Carriage return）                                      |\n| \\t    | 水平制表符                                                   |\n| \\v    | 垂直制表符                                                   |\n| \\\\    | 一个字面上的反斜杠字符                                       |\n| \\ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             |\n| \\0ddd | 表示1到3位的八进制值字符                                     |\n\n# 流程控制\n\n## if else\n\n```shell\nif condition\nthen\n    command1 \n    command2\n    ...\n    commandN \nfi\n```\n\n## if else-if else\n\n```shell\nif condition1\nthen\n    command1\nelif condition2 \nthen \n    command2\nelse\n    commandN\nfi\n```\n\n## for循环\n\n```shell\nfor var in item1 item2 ... itemN\ndo\n    command1\n    command2\n    ...\n    commandN\ndone\n\n```\n\n## while 语句\n\n```shell\nwhile condition\ndo\n    command\ndone\n\n```\n\n## until 循环\n\nuntil 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。\n\n```shell\nuntil condition\ndo\n    command\ndone\n\n```\n\n## case语句\n\n```shell\ncase 值 in\n模式1)\n    command1\n    command2\n    ...\n    commandN\n    ;;\n模式2）\n    command1\n    command2\n    ...\n    commandN\n    ;;\nesac\n\n```\n\n## break\n\n跳出所有的循环\n\n## continue\n\n跳出当前循环\n\n# 函数\n\n```shell\n#!/bin/bash\n# author:菜鸟教程\n# url:www.runoob.com\n\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n```\n\n输出结果：\n\n```shell\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n```\n\n| 参数处理 | 说明                                                         |\n| :------- | :----------------------------------------------------------- |\n| $#       | 传递到脚本的参数个数                                         |\n| $*       | 以一个单字符串显示所有向脚本传递的参数                       |\n| $$       | 脚本运行的当前进程ID号                                       |\n| $!       | 后台运行的最后一个进程的ID号                                 |\n| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         |\n| $-       | 显示Shell使用的当前选项，与set命令功能相同。                 |\n| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n# Shell 输入/输出重定向\n\n| 命令            | 说明                                                         |\n| :-------------- | :----------------------------------------------------------- |\n| command > file  | 将输出重定向到 file。任何file内的已经存在的内容将被新内容替代 |\n| command < file  | 将输入重定向到 file。本来需要从键盘获取输入的命令会转移到文件读取内容。 |\n| command >> file | 将输出以追加的方式重定向到 file。                            |\n| n > file        | 将文件描述符为 n 的文件重定向到 file。                       |\n| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。将新内容添加在文件末尾 |\n| n >& m          | 将输出文件 m 和 n 合并。                                     |\n| n <& m          | 将输入文件 m 和 n 合并。                                     |\n| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。           |\n\n## 重定向深入讲解\n\n- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n\n- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n\n- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n  \n\n```shell\n command >> file 2>&1  #将 stdout 和 stderr 合并后重定向到 file\n\n```\n\n# Shell 文件包含\n\n和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n\n```shell\n. filename   # 注意点号(.)和文件名中间有一空格\n\n或\n\nsource filename\n```\n\n# 日期\n\n| 命令                                | 说明                  |\n| ----------------------------------- | --------------------- |\n| `date +%Y%m%d`<br>`$(date +%Y%m%d)` | 获取今天日期          |\n| `date -d -2day +%Y%m%d`             | 获取前天日期（2天前） |\n| `date -d 2day +%Y%m%d`              | 获取后天日期（2天后） |\n\n| 命令  | 说明                          | 命令  | 说明                                   |\n| ----- | ----------------------------- | ----- | -------------------------------------- |\n| `%H`  | 小时（00..23）                | `%I ` | 小时（01..12）                         |\n| `%k ` | 小时（0..23）                 | `%l ` | 小时（1..12）                          |\n| `%M`  | 分（00..59）                  | `%p`  | 显示出AM或PM                           |\n| `%r ` | 时间(hh:mm:ss AM或PM)，12小时 | `%s ` | 从1970年1月1日00:00:00到目前经历的秒数 |\n| `%S` | 秒（00..59）                  |` %T `  | 时间（24小时制）（hh:mm:ss）      |\n| `%X ` | 显示时间的格式（％H:％M:％S） | `%Z `  | 时区 日期域                                |\n| `%a`  | 星期几的简称（ Sun..Sat）                  | `%A`   | 星期几的全称（ Sunday..Saturday）          |\n| `%b`  | 月的简称（Jan..Dec）                       | `%B`   | 月的全称（January..December）              |\n| `%c ` | 日期和时间（ Mon Nov 8 14:12:46 CST 1999） | `%d`   | 一个月的第几天（01..31）                   |\n| `%D`  | 日期（mm／dd／yy）                         | `%h`   | 和%b选项相同 |\n| `%j`  | 一年的第几天（001..366） | `%m` | 月（01..12） |\n| `%w` | 一个星期的第几天（0代表星期天） | `%W` | 一年的第几个星期（00..53，星期一为第一天） |\n| `%x` | 显示日期的格式（mm/dd/yy）                 | `%y`   | 年的最后两个数字（ 1999则是99）            |\n| `%Y`  | 年（例如：1970，1996等） |       |                                        |\n\n","slug":"shell","published":1,"updated":"2019-08-12T06:43:50.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6iza0033homji7ch9aym","content":"<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>\n<h1 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h1><p>运行 Shell 脚本有两种方法：<strong>1、作为可执行程序</strong>；<strong>2、作为解释器参数</strong></p>\n<h2 id=\"1、作为可执行程序\"><a href=\"#1、作为可执行程序\" class=\"headerlink\" title=\"1、作为可执行程序\"></a>1、作为可执行程序</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class=\"line\">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、作为解释器参数\"><a href=\"#2、作为解释器参数\" class=\"headerlink\" title=\"2、作为解释器参数\"></a>2、作为解释器参数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh test.sh</span><br><span class=\"line\">/bin/php test.php</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h2><ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>\n</ul>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">your_name=\"qinjx\"</span><br><span class=\"line\">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">myUrl=\"http://www.google.com\"</span><br><span class=\"line\">readonly myUrl</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除变量\"><a href=\"#删除变量\" class=\"headerlink\" title=\"删除变量\"></a>删除变量</h2><p>使用 unset 命令可以删除变量，变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset variable_name</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h2><ul>\n<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>\n<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>\n<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>\n</ul>\n<h1 id=\"Shell-字符串\"><a href=\"#Shell-字符串\" class=\"headerlink\" title=\"Shell 字符串\"></a>Shell 字符串</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>‘-单引号</td>\n<td>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</td>\n</tr>\n<tr>\n<td>“-双引号</td>\n<td>双引号里可以有变量，双引号里可以添加转义字符</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"拼接字符\"><a href=\"#拼接字符\" class=\"headerlink\" title=\"拼接字符\"></a>拼接字符</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">your_name=\"runoob\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用双引号拼接</span></span><br><span class=\"line\">greeting=\"hello, \"$your_name\" !\"</span><br><span class=\"line\">greeting_1=\"hello, $&#123;your_name&#125; !\"</span><br><span class=\"line\">echo $greeting  $greeting_1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用单引号拼接</span></span><br><span class=\"line\">greeting_2='hello, '$your_name' !'</span><br><span class=\"line\">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class=\"line\">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello, runoob ! hello, runoob !</span><br><span class=\"line\">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"abcd\"</span><br><span class=\"line\">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"提取子字符串\"><a href=\"#提取子字符串\" class=\"headerlink\" title=\"提取子字符串\"></a>提取子字符串</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"runoob is a great site\"</span><br><span class=\"line\">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>\n<h2 id=\"查找子字符串\"><a href=\"#查找子字符串\" class=\"headerlink\" title=\"查找子字符串\"></a>查找子字符串</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"runoob is a great site\"</span><br><span class=\"line\">echo `expr index \"$string\" io`  # 输出 4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array_name=(value0 value1 value2 value3)  #定义数组</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### 读取数据</span></span></span><br><span class=\"line\">valuen=$&#123;array_name[n]&#125;    #读取单个元素</span><br><span class=\"line\">echo $&#123;array_name[@]&#125;      #读取所有元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### 数组长度</span></span></span><br><span class=\"line\">length=$&#123;#array_name[@]&#125;   #取得数组所有元素的个数</span><br><span class=\"line\">lengthn=$&#123;#array_name[n]&#125;  #取得数组单个元素的长度</span><br></pre></td></tr></table></figure>\n<h1 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数处理</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n</td>\n<td style=\"text-align:left\">n代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$#</td>\n<td style=\"text-align:left\">传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$*</td>\n<td style=\"text-align:left\">以一个单字符串显示所有向脚本传递的参数。 <br>如”$*“用「”」括起来的情况、以”$1 ​$2 … $n”的形式输出所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$@</td>\n<td style=\"text-align:left\">与$*相同，但是使用时加引号，并在引号中返回每个参数。<br> 如”​$@”用「”」括起来的情况、以”​$1” “​$2” … “$n” 的形式输出所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$$</td>\n<td style=\"text-align:left\">脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$!</td>\n<td style=\"text-align:left\">后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$-</td>\n<td style=\"text-align:left\">显示Shell使用的当前选项，与set命令功能相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$?</td>\n<td style=\"text-align:left\">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>注意</strong>：$* 与 $@ 区别：</p>\n<ul>\n<li><p>相同点：都是引用所有参数。</p>\n</li>\n<li><p>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> author:菜鸟教程</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> url:www.runoob.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo \"-- \\$* 演示 ---\"</span><br><span class=\"line\">for i in \"$*\"; do</span><br><span class=\"line\">    echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"-- \\$@ 演示 ---\"</span><br><span class=\"line\">for i in \"$@\"; do</span><br><span class=\"line\">    echo $i</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod +x test.sh </span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./test.sh 1 2 3</span></span><br><span class=\"line\">-- $* 演示 ---</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">-- $@ 演示 ---</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>取余</td>\n<td><code>expr $b % $a</code> 结果为 0。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n<td><code>a=$b</code> 将把变量 b 的值赋给 a。</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等。用于比较两个数字，相同则返回 true。</td>\n<td><code>[$a == $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等。用于比较两个数字，不相同则返回 true。</td>\n<td><code>[$a != $b ]</code>返回 true。</td>\n</tr>\n<tr>\n<td>-eq</td>\n<td>检测两个数是否相等，相等返回 true。</td>\n<td><code>[$a -eq $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>检测两个数是否不相等，不相等返回 true。</td>\n<td><code>[$a -ne $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>\n<td><code>[$a -gt $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>\n<td><code>[$a -lt $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>\n<td><code>[$a -ge $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n<td><code>[$a -le $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>\n<td><code>[!false]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true。</td>\n<td><code>[$a -lt 20 -o $b -gt 100]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true。</td>\n<td><code>[$a -lt 20 -a $b -gt 100]</code>返回 false。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑的 AND</td>\n<td><code>[[$a -lt 100 &amp;&amp; $b -gt 100]]</code> 返回 false</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>逻辑的 OR</td>\n<td><code>[[\\$a -lt 100</code> &#124;&#124; <code>$b -gt 100 ]]</code>返回 true</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=10</span><br><span class=\"line\">b=20</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo \"返回 true\"</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo \"返回 false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">检测两个字符串是否相等，相等返回 true。</td>\n<td style=\"text-align:left\">[ $a = $b ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">!=</td>\n<td style=\"text-align:left\">检测两个字符串是否相等，不相等返回 true。</td>\n<td style=\"text-align:left\">[ 、$a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-z</td>\n<td style=\"text-align:left\">检测字符串长度是否为0，为0返回 true。</td>\n<td style=\"text-align:left\">[ -z $a ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-n</td>\n<td style=\"text-align:left\">检测字符串长度是否为0，不为0返回 true。</td>\n<td style=\"text-align:left\">[ -n “$a” ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">检测字符串是否为空，不为空返回 true。</td>\n<td style=\"text-align:left\">[ $a ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b file</td>\n<td style=\"text-align:left\">检测文件是否是块设备文件，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -b $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c file</td>\n<td style=\"text-align:left\">检测文件是否是字符设备文件，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -c $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d file</td>\n<td style=\"text-align:left\">检测文件是否是目录，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -d $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f file</td>\n<td style=\"text-align:left\">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -f $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g file</td>\n<td style=\"text-align:left\">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -g $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-k file</td>\n<td style=\"text-align:left\">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -k $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p file</td>\n<td style=\"text-align:left\">检测文件是否是有名管道，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -p $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u file</td>\n<td style=\"text-align:left\">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -u $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r file</td>\n<td style=\"text-align:left\">检测文件是否可读，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -r $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w file</td>\n<td style=\"text-align:left\">检测文件是否可写，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -w $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x file</td>\n<td style=\"text-align:left\">检测文件是否可执行，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -x $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s file</td>\n<td style=\"text-align:left\">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n<td style=\"text-align:left\">[ -s $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e file</td>\n<td style=\"text-align:left\">检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -e $file ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>说明</th>\n<th>输入</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示普通字符串</td>\n<td>echo “It is a test”</td>\n<td>echo It is a test</td>\n</tr>\n<tr>\n<td>显示转义字符</td>\n<td>echo “\\”It is a test\\””</td>\n<td>“It is a test”</td>\n</tr>\n<tr>\n<td>显示变量</td>\n<td>echo “$name It is a test”</td>\n<td>ok It is a test</td>\n</tr>\n<tr>\n<td>显示换行</td>\n<td>echo -e “OK! \\n” # -e 开启转义<br>echo “It is a test”</td>\n<td>OK!<br><br>OK!  It is a test</td>\n</tr>\n<tr>\n<td>显示不换行</td>\n<td>echo -e “OK! \\c” # -e 开启转义 \\c 不换行<br>echo “It is a test”</td>\n<td>OK! It is a test</td>\n</tr>\n<tr>\n<td>显示结果定向至文件</td>\n<td>echo “It is a test” &gt; myfile</td>\n<td></td>\n</tr>\n<tr>\n<td>原样输出字符串-单引号</td>\n<td>echo ‘$name\\\\”‘</td>\n<td>$name\\”</td>\n</tr>\n<tr>\n<td>显示命令执行结果</td>\n<td>echo `date`</td>\n<td>Thu Jul 24 10:08:46 CST 2014</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876</span><br></pre></td></tr></table></figure>\n<ul>\n<li>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li>\n<li>%-4.2f 指格式化为小数，其中.2指保留2位小数。</li>\n</ul>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序列</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">\\a</td>\n<td style=\"text-align:left\">警告字符，通常为ASCII的BEL字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\b</td>\n<td style=\"text-align:left\">后退</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\c</td>\n<td style=\"text-align:left\">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\f</td>\n<td style=\"text-align:left\">换页（formfeed）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\n</td>\n<td style=\"text-align:left\">换行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\r</td>\n<td style=\"text-align:left\">回车（Carriage return）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\t</td>\n<td style=\"text-align:left\">水平制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\v</td>\n<td style=\"text-align:left\">垂直制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\\\</td>\n<td style=\"text-align:left\">一个字面上的反斜杠字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\ddd</td>\n<td style=\"text-align:left\">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\0ddd</td>\n<td style=\"text-align:left\">表示1到3位的八进制值字符</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h1><h2 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">    command1 </span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN </span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if else-if else\"></a>if else-if else</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if condition1</span><br><span class=\"line\">then</span><br><span class=\"line\">    command1</span><br><span class=\"line\">elif condition2 </span><br><span class=\"line\">then </span><br><span class=\"line\">    command2</span><br><span class=\"line\">else</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in item1 item2 ... itemN</span><br><span class=\"line\">do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"while-语句\"><a href=\"#while-语句\" class=\"headerlink\" title=\"while 语句\"></a>while 语句</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while condition</span><br><span class=\"line\">do</span><br><span class=\"line\">    command</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until condition</span><br><span class=\"line\">do</span><br><span class=\"line\">    command</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 值 in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">模式2）</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>跳出所有的循环</p>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>跳出当前循环</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> author:菜鸟教程</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> url:www.runoob.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">funWithParam()&#123;</span><br><span class=\"line\">    echo \"第一个参数为 $1 !\"</span><br><span class=\"line\">    echo \"第二个参数为 $2 !\"</span><br><span class=\"line\">    echo \"第十个参数为 $10 !\"</span><br><span class=\"line\">    echo \"第十个参数为 $&#123;10&#125; !\"</span><br><span class=\"line\">    echo \"第十一个参数为 $&#123;11&#125; !\"</span><br><span class=\"line\">    echo \"参数总数有 $# 个!\"</span><br><span class=\"line\">    echo \"作为一个字符串输出所有参数 $* !\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个参数为 1 !</span><br><span class=\"line\">第二个参数为 2 !</span><br><span class=\"line\">第十个参数为 10 !</span><br><span class=\"line\">第十个参数为 34 !</span><br><span class=\"line\">第十一个参数为 73 !</span><br><span class=\"line\">参数总数有 11 个!</span><br><span class=\"line\">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数处理</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$#</td>\n<td style=\"text-align:left\">传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$*</td>\n<td style=\"text-align:left\">以一个单字符串显示所有向脚本传递的参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$$</td>\n<td style=\"text-align:left\">脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$!</td>\n<td style=\"text-align:left\">后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$@</td>\n<td style=\"text-align:left\">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$-</td>\n<td style=\"text-align:left\">显示Shell使用的当前选项，与set命令功能相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$?</td>\n<td style=\"text-align:left\">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"Shell-输入-输出重定向\"><a href=\"#Shell-输入-输出重定向\" class=\"headerlink\" title=\"Shell 输入/输出重定向\"></a>Shell 输入/输出重定向</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">command &gt; file</td>\n<td style=\"text-align:left\">将输出重定向到 file。任何file内的已经存在的内容将被新内容替代</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command &lt; file</td>\n<td style=\"text-align:left\">将输入重定向到 file。本来需要从键盘获取输入的命令会转移到文件读取内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command &gt;&gt; file</td>\n<td style=\"text-align:left\">将输出以追加的方式重定向到 file。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt; file</td>\n<td style=\"text-align:left\">将文件描述符为 n 的文件重定向到 file。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt;&gt; file</td>\n<td style=\"text-align:left\">将文件描述符为 n 的文件以追加的方式重定向到 file。将新内容添加在文件末尾</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt;&amp; m</td>\n<td style=\"text-align:left\">将输出文件 m 和 n 合并。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &lt;&amp; m</td>\n<td style=\"text-align:left\">将输入文件 m 和 n 合并。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&lt; tag</td>\n<td style=\"text-align:left\">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"重定向深入讲解\"><a href=\"#重定向深入讲解\" class=\"headerlink\" title=\"重定向深入讲解\"></a>重定向深入讲解</h2><ul>\n<li><p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</p>\n</li>\n<li><p>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</p>\n</li>\n<li><p>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt;&gt; file 2&gt;&amp;1  #将 stdout 和 stderr 合并后重定向到 file</span><br></pre></td></tr></table></figure>\n<h1 id=\"Shell-文件包含\"><a href=\"#Shell-文件包含\" class=\"headerlink\" title=\"Shell 文件包含\"></a>Shell 文件包含</h1><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\">source filename</span><br></pre></td></tr></table></figure>\n<h1 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>date +%Y%m%d</code><br><code>$(date +%Y%m%d)</code></td>\n<td>获取今天日期</td>\n</tr>\n<tr>\n<td><code>date -d -2day +%Y%m%d</code></td>\n<td>获取前天日期（2天前）</td>\n</tr>\n<tr>\n<td><code>date -d 2day +%Y%m%d</code></td>\n<td>获取后天日期（2天后）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>%H</code></td>\n<td>小时（00..23）</td>\n<td><code>%I</code></td>\n<td>小时（01..12）</td>\n</tr>\n<tr>\n<td><code>%k</code></td>\n<td>小时（0..23）</td>\n<td><code>%l</code></td>\n<td>小时（1..12）</td>\n</tr>\n<tr>\n<td><code>%M</code></td>\n<td>分（00..59）</td>\n<td><code>%p</code></td>\n<td>显示出AM或PM</td>\n</tr>\n<tr>\n<td><code>%r</code></td>\n<td>时间(hh:mm:ss AM或PM)，12小时</td>\n<td><code>%s</code></td>\n<td>从1970年1月1日00:00:00到目前经历的秒数</td>\n</tr>\n<tr>\n<td><code>%S</code></td>\n<td>秒（00..59）</td>\n<td><code>%T</code></td>\n<td>时间（24小时制）（hh:mm:ss）</td>\n</tr>\n<tr>\n<td><code>%X</code></td>\n<td>显示时间的格式（％H:％M:％S）</td>\n<td><code>%Z</code></td>\n<td>时区 日期域</td>\n</tr>\n<tr>\n<td><code>%a</code></td>\n<td>星期几的简称（ Sun..Sat）</td>\n<td><code>%A</code></td>\n<td>星期几的全称（ Sunday..Saturday）</td>\n</tr>\n<tr>\n<td><code>%b</code></td>\n<td>月的简称（Jan..Dec）</td>\n<td><code>%B</code></td>\n<td>月的全称（January..December）</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>日期和时间（ Mon Nov 8 14:12:46 CST 1999）</td>\n<td><code>%d</code></td>\n<td>一个月的第几天（01..31）</td>\n</tr>\n<tr>\n<td><code>%D</code></td>\n<td>日期（mm／dd／yy）</td>\n<td><code>%h</code></td>\n<td>和%b选项相同</td>\n</tr>\n<tr>\n<td><code>%j</code></td>\n<td>一年的第几天（001..366）</td>\n<td><code>%m</code></td>\n<td>月（01..12）</td>\n</tr>\n<tr>\n<td><code>%w</code></td>\n<td>一个星期的第几天（0代表星期天）</td>\n<td><code>%W</code></td>\n<td>一年的第几个星期（00..53，星期一为第一天）</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>显示日期的格式（mm/dd/yy）</td>\n<td><code>%y</code></td>\n<td>年的最后两个数字（ 1999则是99）</td>\n</tr>\n<tr>\n<td><code>%Y</code></td>\n<td>年（例如：1970，1996等）</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>\n<h1 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h1><p>运行 Shell 脚本有两种方法：<strong>1、作为可执行程序</strong>；<strong>2、作为解释器参数</strong></p>\n<h2 id=\"1、作为可执行程序\"><a href=\"#1、作为可执行程序\" class=\"headerlink\" title=\"1、作为可执行程序\"></a>1、作为可执行程序</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class=\"line\">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、作为解释器参数\"><a href=\"#2、作为解释器参数\" class=\"headerlink\" title=\"2、作为解释器参数\"></a>2、作为解释器参数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/sh test.sh</span><br><span class=\"line\">/bin/php test.php</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h2><ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>\n</ul>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">your_name=\"qinjx\"</span><br><span class=\"line\">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">myUrl=\"http://www.google.com\"</span><br><span class=\"line\">readonly myUrl</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除变量\"><a href=\"#删除变量\" class=\"headerlink\" title=\"删除变量\"></a>删除变量</h2><p>使用 unset 命令可以删除变量，变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unset variable_name</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h2><ul>\n<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>\n<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>\n<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>\n</ul>\n<h1 id=\"Shell-字符串\"><a href=\"#Shell-字符串\" class=\"headerlink\" title=\"Shell 字符串\"></a>Shell 字符串</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>‘-单引号</td>\n<td>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</td>\n</tr>\n<tr>\n<td>“-双引号</td>\n<td>双引号里可以有变量，双引号里可以添加转义字符</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"拼接字符\"><a href=\"#拼接字符\" class=\"headerlink\" title=\"拼接字符\"></a>拼接字符</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">your_name=\"runoob\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用双引号拼接</span></span><br><span class=\"line\">greeting=\"hello, \"$your_name\" !\"</span><br><span class=\"line\">greeting_1=\"hello, $&#123;your_name&#125; !\"</span><br><span class=\"line\">echo $greeting  $greeting_1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用单引号拼接</span></span><br><span class=\"line\">greeting_2='hello, '$your_name' !'</span><br><span class=\"line\">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class=\"line\">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello, runoob ! hello, runoob !</span><br><span class=\"line\">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取字符串长度\"><a href=\"#获取字符串长度\" class=\"headerlink\" title=\"获取字符串长度\"></a>获取字符串长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"abcd\"</span><br><span class=\"line\">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"提取子字符串\"><a href=\"#提取子字符串\" class=\"headerlink\" title=\"提取子字符串\"></a>提取子字符串</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"runoob is a great site\"</span><br><span class=\"line\">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>\n<h2 id=\"查找子字符串\"><a href=\"#查找子字符串\" class=\"headerlink\" title=\"查找子字符串\"></a>查找子字符串</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string=\"runoob is a great site\"</span><br><span class=\"line\">echo `expr index \"$string\" io`  # 输出 4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array_name=(value0 value1 value2 value3)  #定义数组</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### 读取数据</span></span></span><br><span class=\"line\">valuen=$&#123;array_name[n]&#125;    #读取单个元素</span><br><span class=\"line\">echo $&#123;array_name[@]&#125;      #读取所有元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\">### 数组长度</span></span></span><br><span class=\"line\">length=$&#123;#array_name[@]&#125;   #取得数组所有元素的个数</span><br><span class=\"line\">lengthn=$&#123;#array_name[n]&#125;  #取得数组单个元素的长度</span><br></pre></td></tr></table></figure>\n<h1 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数处理</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$n</td>\n<td style=\"text-align:left\">n代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$#</td>\n<td style=\"text-align:left\">传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$*</td>\n<td style=\"text-align:left\">以一个单字符串显示所有向脚本传递的参数。 <br>如”$*“用「”」括起来的情况、以”$1 ​$2 … $n”的形式输出所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$@</td>\n<td style=\"text-align:left\">与$*相同，但是使用时加引号，并在引号中返回每个参数。<br> 如”​$@”用「”」括起来的情况、以”​$1” “​$2” … “$n” 的形式输出所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$$</td>\n<td style=\"text-align:left\">脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$!</td>\n<td style=\"text-align:left\">后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$-</td>\n<td style=\"text-align:left\">显示Shell使用的当前选项，与set命令功能相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$?</td>\n<td style=\"text-align:left\">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>注意</strong>：$* 与 $@ 区别：</p>\n<ul>\n<li><p>相同点：都是引用所有参数。</p>\n</li>\n<li><p>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> author:菜鸟教程</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> url:www.runoob.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo \"-- \\$* 演示 ---\"</span><br><span class=\"line\">for i in \"$*\"; do</span><br><span class=\"line\">    echo $i</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"-- \\$@ 演示 ---\"</span><br><span class=\"line\">for i in \"$@\"; do</span><br><span class=\"line\">    echo $i</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> chmod +x test.sh </span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./test.sh 1 2 3</span></span><br><span class=\"line\">-- $* 演示 ---</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">-- $@ 演示 ---</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>取余</td>\n<td><code>expr $b % $a</code> 结果为 0。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n<td><code>a=$b</code> 将把变量 b 的值赋给 a。</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等。用于比较两个数字，相同则返回 true。</td>\n<td><code>[$a == $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等。用于比较两个数字，不相同则返回 true。</td>\n<td><code>[$a != $b ]</code>返回 true。</td>\n</tr>\n<tr>\n<td>-eq</td>\n<td>检测两个数是否相等，相等返回 true。</td>\n<td><code>[$a -eq $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>检测两个数是否不相等，不相等返回 true。</td>\n<td><code>[$a -ne $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>\n<td><code>[$a -gt $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>\n<td><code>[$a -lt $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>\n<td><code>[$a -ge $b]</code> 返回 false。</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n<td><code>[$a -le $b]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>\n<td><code>[!false]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>或运算，有一个表达式为 true 则返回 true。</td>\n<td><code>[$a -lt 20 -o $b -gt 100]</code> 返回 true。</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>与运算，两个表达式都为 true 才返回 true。</td>\n<td><code>[$a -lt 20 -a $b -gt 100]</code>返回 false。</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑的 AND</td>\n<td><code>[[$a -lt 100 &amp;&amp; $b -gt 100]]</code> 返回 false</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>逻辑的 OR</td>\n<td><code>[[\\$a -lt 100</code> &#124;&#124; <code>$b -gt 100 ]]</code>返回 true</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=10</span><br><span class=\"line\">b=20</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo \"返回 true\"</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo \"返回 false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">检测两个字符串是否相等，相等返回 true。</td>\n<td style=\"text-align:left\">[ $a = $b ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">!=</td>\n<td style=\"text-align:left\">检测两个字符串是否相等，不相等返回 true。</td>\n<td style=\"text-align:left\">[ 、$a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-z</td>\n<td style=\"text-align:left\">检测字符串长度是否为0，为0返回 true。</td>\n<td style=\"text-align:left\">[ -z $a ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">-n</td>\n<td style=\"text-align:left\">检测字符串长度是否为0，不为0返回 true。</td>\n<td style=\"text-align:left\">[ -n “$a” ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:left\">检测字符串是否为空，不为空返回 true。</td>\n<td style=\"text-align:left\">[ $a ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作符</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b file</td>\n<td style=\"text-align:left\">检测文件是否是块设备文件，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -b $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c file</td>\n<td style=\"text-align:left\">检测文件是否是字符设备文件，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -c $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d file</td>\n<td style=\"text-align:left\">检测文件是否是目录，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -d $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f file</td>\n<td style=\"text-align:left\">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -f $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g file</td>\n<td style=\"text-align:left\">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -g $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-k file</td>\n<td style=\"text-align:left\">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -k $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p file</td>\n<td style=\"text-align:left\">检测文件是否是有名管道，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -p $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u file</td>\n<td style=\"text-align:left\">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -u $file ] 返回 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r file</td>\n<td style=\"text-align:left\">检测文件是否可读，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -r $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w file</td>\n<td style=\"text-align:left\">检测文件是否可写，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -w $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x file</td>\n<td style=\"text-align:left\">检测文件是否可执行，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -x $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s file</td>\n<td style=\"text-align:left\">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n<td style=\"text-align:left\">[ -s $file ] 返回 true。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e file</td>\n<td style=\"text-align:left\">检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n<td style=\"text-align:left\">[ -e $file ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"echo命令\"><a href=\"#echo命令\" class=\"headerlink\" title=\"echo命令\"></a>echo命令</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>说明</th>\n<th>输入</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>显示普通字符串</td>\n<td>echo “It is a test”</td>\n<td>echo It is a test</td>\n</tr>\n<tr>\n<td>显示转义字符</td>\n<td>echo “\\”It is a test\\””</td>\n<td>“It is a test”</td>\n</tr>\n<tr>\n<td>显示变量</td>\n<td>echo “$name It is a test”</td>\n<td>ok It is a test</td>\n</tr>\n<tr>\n<td>显示换行</td>\n<td>echo -e “OK! \\n” # -e 开启转义<br>echo “It is a test”</td>\n<td>OK!<br><br>OK!  It is a test</td>\n</tr>\n<tr>\n<td>显示不换行</td>\n<td>echo -e “OK! \\c” # -e 开启转义 \\c 不换行<br>echo “It is a test”</td>\n<td>OK! It is a test</td>\n</tr>\n<tr>\n<td>显示结果定向至文件</td>\n<td>echo “It is a test” &gt; myfile</td>\n<td></td>\n</tr>\n<tr>\n<td>原样输出字符串-单引号</td>\n<td>echo ‘$name\\\\”‘</td>\n<td>$name\\”</td>\n</tr>\n<tr>\n<td>显示命令执行结果</td>\n<td>echo `date`</td>\n<td>Thu Jul 24 10:08:46 CST 2014</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"printf\"><a href=\"#printf\" class=\"headerlink\" title=\"printf\"></a>printf</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 </span><br><span class=\"line\">printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876</span><br></pre></td></tr></table></figure>\n<ul>\n<li>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li>\n<li>%-4.2f 指格式化为小数，其中.2指保留2位小数。</li>\n</ul>\n<h1 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序列</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">\\a</td>\n<td style=\"text-align:left\">警告字符，通常为ASCII的BEL字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\b</td>\n<td style=\"text-align:left\">后退</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\c</td>\n<td style=\"text-align:left\">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\f</td>\n<td style=\"text-align:left\">换页（formfeed）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\n</td>\n<td style=\"text-align:left\">换行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\r</td>\n<td style=\"text-align:left\">回车（Carriage return）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\t</td>\n<td style=\"text-align:left\">水平制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\v</td>\n<td style=\"text-align:left\">垂直制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\\\</td>\n<td style=\"text-align:left\">一个字面上的反斜杠字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\ddd</td>\n<td style=\"text-align:left\">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\0ddd</td>\n<td style=\"text-align:left\">表示1到3位的八进制值字符</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h1><h2 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">    command1 </span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN </span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"if-else-if-else\"><a href=\"#if-else-if-else\" class=\"headerlink\" title=\"if else-if else\"></a>if else-if else</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if condition1</span><br><span class=\"line\">then</span><br><span class=\"line\">    command1</span><br><span class=\"line\">elif condition2 </span><br><span class=\"line\">then </span><br><span class=\"line\">    command2</span><br><span class=\"line\">else</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h2 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in item1 item2 ... itemN</span><br><span class=\"line\">do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"while-语句\"><a href=\"#while-语句\" class=\"headerlink\" title=\"while 语句\"></a>while 语句</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while condition</span><br><span class=\"line\">do</span><br><span class=\"line\">    command</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until condition</span><br><span class=\"line\">do</span><br><span class=\"line\">    command</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h2 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 值 in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">模式2）</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    commandN</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>跳出所有的循环</p>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>跳出当前循环</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> author:菜鸟教程</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> url:www.runoob.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">funWithParam()&#123;</span><br><span class=\"line\">    echo \"第一个参数为 $1 !\"</span><br><span class=\"line\">    echo \"第二个参数为 $2 !\"</span><br><span class=\"line\">    echo \"第十个参数为 $10 !\"</span><br><span class=\"line\">    echo \"第十个参数为 $&#123;10&#125; !\"</span><br><span class=\"line\">    echo \"第十一个参数为 $&#123;11&#125; !\"</span><br><span class=\"line\">    echo \"参数总数有 $# 个!\"</span><br><span class=\"line\">    echo \"作为一个字符串输出所有参数 $* !\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一个参数为 1 !</span><br><span class=\"line\">第二个参数为 2 !</span><br><span class=\"line\">第十个参数为 10 !</span><br><span class=\"line\">第十个参数为 34 !</span><br><span class=\"line\">第十一个参数为 73 !</span><br><span class=\"line\">参数总数有 11 个!</span><br><span class=\"line\">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数处理</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$#</td>\n<td style=\"text-align:left\">传递到脚本的参数个数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$*</td>\n<td style=\"text-align:left\">以一个单字符串显示所有向脚本传递的参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$$</td>\n<td style=\"text-align:left\">脚本运行的当前进程ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$!</td>\n<td style=\"text-align:left\">后台运行的最后一个进程的ID号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$@</td>\n<td style=\"text-align:left\">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$-</td>\n<td style=\"text-align:left\">显示Shell使用的当前选项，与set命令功能相同。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$?</td>\n<td style=\"text-align:left\">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"Shell-输入-输出重定向\"><a href=\"#Shell-输入-输出重定向\" class=\"headerlink\" title=\"Shell 输入/输出重定向\"></a>Shell 输入/输出重定向</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">command &gt; file</td>\n<td style=\"text-align:left\">将输出重定向到 file。任何file内的已经存在的内容将被新内容替代</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command &lt; file</td>\n<td style=\"text-align:left\">将输入重定向到 file。本来需要从键盘获取输入的命令会转移到文件读取内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">command &gt;&gt; file</td>\n<td style=\"text-align:left\">将输出以追加的方式重定向到 file。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt; file</td>\n<td style=\"text-align:left\">将文件描述符为 n 的文件重定向到 file。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt;&gt; file</td>\n<td style=\"text-align:left\">将文件描述符为 n 的文件以追加的方式重定向到 file。将新内容添加在文件末尾</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &gt;&amp; m</td>\n<td style=\"text-align:left\">将输出文件 m 和 n 合并。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">n &lt;&amp; m</td>\n<td style=\"text-align:left\">将输入文件 m 和 n 合并。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&lt; tag</td>\n<td style=\"text-align:left\">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"重定向深入讲解\"><a href=\"#重定向深入讲解\" class=\"headerlink\" title=\"重定向深入讲解\"></a>重定向深入讲解</h2><ul>\n<li><p>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</p>\n</li>\n<li><p>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</p>\n</li>\n<li><p>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt;&gt; file 2&gt;&amp;1  #将 stdout 和 stderr 合并后重定向到 file</span><br></pre></td></tr></table></figure>\n<h1 id=\"Shell-文件包含\"><a href=\"#Shell-文件包含\" class=\"headerlink\" title=\"Shell 文件包含\"></a>Shell 文件包含</h1><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class=\"line\"></span><br><span class=\"line\">或</span><br><span class=\"line\"></span><br><span class=\"line\">source filename</span><br></pre></td></tr></table></figure>\n<h1 id=\"日期\"><a href=\"#日期\" class=\"headerlink\" title=\"日期\"></a>日期</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>date +%Y%m%d</code><br><code>$(date +%Y%m%d)</code></td>\n<td>获取今天日期</td>\n</tr>\n<tr>\n<td><code>date -d -2day +%Y%m%d</code></td>\n<td>获取前天日期（2天前）</td>\n</tr>\n<tr>\n<td><code>date -d 2day +%Y%m%d</code></td>\n<td>获取后天日期（2天后）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>%H</code></td>\n<td>小时（00..23）</td>\n<td><code>%I</code></td>\n<td>小时（01..12）</td>\n</tr>\n<tr>\n<td><code>%k</code></td>\n<td>小时（0..23）</td>\n<td><code>%l</code></td>\n<td>小时（1..12）</td>\n</tr>\n<tr>\n<td><code>%M</code></td>\n<td>分（00..59）</td>\n<td><code>%p</code></td>\n<td>显示出AM或PM</td>\n</tr>\n<tr>\n<td><code>%r</code></td>\n<td>时间(hh:mm:ss AM或PM)，12小时</td>\n<td><code>%s</code></td>\n<td>从1970年1月1日00:00:00到目前经历的秒数</td>\n</tr>\n<tr>\n<td><code>%S</code></td>\n<td>秒（00..59）</td>\n<td><code>%T</code></td>\n<td>时间（24小时制）（hh:mm:ss）</td>\n</tr>\n<tr>\n<td><code>%X</code></td>\n<td>显示时间的格式（％H:％M:％S）</td>\n<td><code>%Z</code></td>\n<td>时区 日期域</td>\n</tr>\n<tr>\n<td><code>%a</code></td>\n<td>星期几的简称（ Sun..Sat）</td>\n<td><code>%A</code></td>\n<td>星期几的全称（ Sunday..Saturday）</td>\n</tr>\n<tr>\n<td><code>%b</code></td>\n<td>月的简称（Jan..Dec）</td>\n<td><code>%B</code></td>\n<td>月的全称（January..December）</td>\n</tr>\n<tr>\n<td><code>%c</code></td>\n<td>日期和时间（ Mon Nov 8 14:12:46 CST 1999）</td>\n<td><code>%d</code></td>\n<td>一个月的第几天（01..31）</td>\n</tr>\n<tr>\n<td><code>%D</code></td>\n<td>日期（mm／dd／yy）</td>\n<td><code>%h</code></td>\n<td>和%b选项相同</td>\n</tr>\n<tr>\n<td><code>%j</code></td>\n<td>一年的第几天（001..366）</td>\n<td><code>%m</code></td>\n<td>月（01..12）</td>\n</tr>\n<tr>\n<td><code>%w</code></td>\n<td>一个星期的第几天（0代表星期天）</td>\n<td><code>%W</code></td>\n<td>一年的第几个星期（00..53，星期一为第一天）</td>\n</tr>\n<tr>\n<td><code>%x</code></td>\n<td>显示日期的格式（mm/dd/yy）</td>\n<td><code>%y</code></td>\n<td>年的最后两个数字（ 1999则是99）</td>\n</tr>\n<tr>\n<td><code>%Y</code></td>\n<td>年（例如：1970，1996等）</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"test","date":"2019-07-30T03:06:46.000Z","_content":"\n\n\npyspark  时区操作\n\npyspark dataframe操作\n\n\n\n[hexo博客](https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)\n\n","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2019-07-30 11:06:46\ntags: test\ncategories: test\n---\n\n\n\npyspark  时区操作\n\npyspark dataframe操作\n\n\n\n[hexo博客](https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)\n\n","slug":"test","published":1,"updated":"2019-08-08T07:28:58.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izd0038homju4h4wbii","content":"<p>pyspark  时区操作</p>\n<p>pyspark dataframe操作</p>\n<p><a href=\"https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">hexo博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>pyspark  时区操作</p>\n<p>pyspark dataframe操作</p>\n<p><a href=\"https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">hexo博客</a></p>\n"},{"title":"spark","date":"2019-08-09T09:08:07.000Z","_content":"\n# [spark简介](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd)\n\nSpark是开发通用的大数据处理框架。Spark应用程序可以使用R语言、Java、Scala和Python进行编写，极少使用R语言编写Spark程序，Java和Scala语言编写的Spark程序的执行效率是相同的，但Java语言写的代码量多，Scala简洁优雅，但可读性不如Java，Python语言编写的Spark程序的执行效率不如Java和Scala。\n\n![img](spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg)\n\n<!--more-->\n\n## 运行模式\n\nSpark有4中运行模式：\n\n| 名称       | 说明                                          |\n| ---------- | --------------------------------------------- |\n| local      | 适用于测试                                    |\n| standalone | 并非是单节点，而是使用spark自带的资源调度框架 |\n| yarn       | 最流行的方式，使用yarn集群调度资源            |\n| mesos      | 国外使用的多                                  |\n\n# [RDD](./RDD-Spark.md)\n\nRDD是**弹性分布式数据集**，**是Spark中最基本的数据抽象，任何数据在Spark中都被表示为RDD**。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据是分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作从而得到结果。\n\n<center>\n\n```mermaid\ngraph TD\nA[加载数据集]--> B[使用transformations算子对RDD进行操作]\nB-->C[使用actions算子触发执行]\n```\n\n</center>\n\n## Transformation\n\n| 命令                                | 说明                                                         |\n| ----------------------------------- | ------------------------------------------------------------ |\n| filter(func)                        | 返回一个新的数据集，由经过func函数后返回值为true的原元素组成 |\n| map(func)                           | 返回一个新的分布式数据集，由每个原元素经过func函数转换后组成 |\n| flatMap(func)                       | 类似于map，但是每一个输入元素，会被映射为0到多个输出元素（因此，func函数的返回值是一个Seq，而不是单一元素） |\n| ample(withReplacement, frac, seed)  | 根据给定的随机种子seed，随机抽样出数量为frac的数据           |\n| union(otherDataset)                 | 返回一个新的数据集，由原数据集和参数联合而成                 |\n| groupByKey([numTasks])              | 在一个由（K,V）对组成的数据集上调用，返回一个（K，Seq[V])对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入numTask可选参数，根据数据量设置不同数目的Task |\n| reduceByKey(func, [numTasks])       | 在一个（K，V)对的数据集上使用，返回一个（K，V）对的数据集，key相同的值，都被使用指定的reduce函数聚合到一起。和groupbykey类似，任务的个数是可以通过第二个可选参数来配置的。 |\n| join(otherDataset, [numTasks])      | 在类型为（K,V)和（K,W)类型的数据集上调用，返回一个（K,(V,W))对，每个key中的所有元素都在一起的数据集 |\n| groupWith(otherDataset, [numTasks]) | 在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup |\n| cartesian(otherDataset)             | 笛卡尔积。但在数据集T和U上调用时，返回一个(T，U）对的数据集，所有元素交互进行笛卡尔积。 |\n|                                     |                                                              |\n|                                     |                                                              |\n|                                     |                                                              |\n| map(func)                           | 返回一个新的分布式数据集，由每个原元素经过func函数转换后组成 |\n\n\n## Actions\n\n| 命令                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| `reduce(func)`             | 通过函数`func`聚集数据集中的所有元素。`func`函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行 |\n| `collect()`                | 在`Driver`的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用`filter`或者其它操作后，返回一个足够小的数据子集再使用，直接将整个`RDD`集Collect返回，很可能会让`Driver`程序OOM |\n| `count()`                  | 统计`RDD`中元素的个数                                        |\n| `take(n)`                  | 取`RDD`中的前`n`个元素。注意，这个操作目前并非在多个节点上，并行执行，而是`Driver`程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用） |\n| `first()`                  | 返回数据集的第一个元素（类似于`take(1)`  ）                  |\n| `reduce(func)`             | 按照指定规则聚合`RDD`中的元素                                |\n| `countByValue()`           | 统计出`RDD`中每个元素的个数                                  |\n| `countByKey()`             | 统计出`KV`格式的`RDD`中相同的K的个数                         |\n| `foreach(func)`            | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `foreachPartition(func)`   | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `saveAsTextFile(path)`     | 将数据集的元素，以t`extfile`的形式，保存到本地文件系统，`hdfs`或者任何其它`hadoop`支持的文件系统。Spark将会调用每个元素的`toString`方法，并将它转换为文件中的一行文本 |\n| `saveAsSequenceFile(path)` | 将数据集的元素，以`sequencefile`的格式，保存到指定的目录下，本地系统，`hdfs`或者任何其它`hadoop`支持的文件系统。`RDD`的元素必须由`key-value`对组成，并都实现了`Hadoop`的`Writable`接口，或隐式可以转换为`Writable`（Spark包括了基本类型的转换，例如`Int`，`Double`，`String`等等） |\n\n# [MLlib](https://spark.apache.org/docs/latest/ml-classification-regression.html)与ML\n\n- `spark.mllib`包含基于RDD的原始算法API。Spark MLlib 历史比较长，在1.0 以前的版本即已经包含了，提供的算法实现都是基于原始的 RDD。\n\n- `spark.ml`则提供了基于[DataFrames](http://spark.apache.org/docs/latest/sql-programming-guide.html#dataframes) 高层次的API，可以用来构建机器学习工作流（PipeLine）。ML Pipeline 弥补了原始 MLlib 库的不足，向用户提供了一个基于 DataFrame 的机器学习工作流式 API 套件。\n\n使用 `ML Pipeline API`可以很方便的把数据处理，特征转换，正则化，以及多个机器学习算法联合起来，构建一个单一完整的机器学习流水线。这种方式给我们提供了更灵活的方法，更符合机器学习过程的特点，也更容易从其他语言迁移。**Spark官方推荐使用`spark.ml`**。如果新的算法能够适用于机器学习管道的概念，就应该将其放到`spark.ml`包中，如：特征提取器和转换器。开发者需要注意的是，从`Spark2.0`开始，基于`RDD`的`API`进入维护模式（即不增加任何新的特性），**并预期于3.0版本的时候被移除出`MLlib**`。\n\n# SQL、DataFrame和DataSet\n\n\n\n\n\n# 附录\n\n## RDD与DataFrame、DataSet\n\n`DataFrame = SchemaRDD = RDD<ROW>`\n\n从图虫颜色来区分，DataFrame是列式存储。当要取Age这一列时，RDD必须先取出person再取Age，而DataFrame可以直接取Age这一列\n\n![img](spark/15052983161313.jpg)","source":"_posts/spark.md","raw":"---\n\ntitle: spark\ndate: 2019-08-09 17:08:07\ntags: [人工智能,分布式系统]\ncategories: spark\n---\n\n# [spark简介](https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd)\n\nSpark是开发通用的大数据处理框架。Spark应用程序可以使用R语言、Java、Scala和Python进行编写，极少使用R语言编写Spark程序，Java和Scala语言编写的Spark程序的执行效率是相同的，但Java语言写的代码量多，Scala简洁优雅，但可读性不如Java，Python语言编写的Spark程序的执行效率不如Java和Scala。\n\n![img](spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg)\n\n<!--more-->\n\n## 运行模式\n\nSpark有4中运行模式：\n\n| 名称       | 说明                                          |\n| ---------- | --------------------------------------------- |\n| local      | 适用于测试                                    |\n| standalone | 并非是单节点，而是使用spark自带的资源调度框架 |\n| yarn       | 最流行的方式，使用yarn集群调度资源            |\n| mesos      | 国外使用的多                                  |\n\n# [RDD](./RDD-Spark.md)\n\nRDD是**弹性分布式数据集**，**是Spark中最基本的数据抽象，任何数据在Spark中都被表示为RDD**。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据是分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作从而得到结果。\n\n<center>\n\n```mermaid\ngraph TD\nA[加载数据集]--> B[使用transformations算子对RDD进行操作]\nB-->C[使用actions算子触发执行]\n```\n\n</center>\n\n## Transformation\n\n| 命令                                | 说明                                                         |\n| ----------------------------------- | ------------------------------------------------------------ |\n| filter(func)                        | 返回一个新的数据集，由经过func函数后返回值为true的原元素组成 |\n| map(func)                           | 返回一个新的分布式数据集，由每个原元素经过func函数转换后组成 |\n| flatMap(func)                       | 类似于map，但是每一个输入元素，会被映射为0到多个输出元素（因此，func函数的返回值是一个Seq，而不是单一元素） |\n| ample(withReplacement, frac, seed)  | 根据给定的随机种子seed，随机抽样出数量为frac的数据           |\n| union(otherDataset)                 | 返回一个新的数据集，由原数据集和参数联合而成                 |\n| groupByKey([numTasks])              | 在一个由（K,V）对组成的数据集上调用，返回一个（K，Seq[V])对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入numTask可选参数，根据数据量设置不同数目的Task |\n| reduceByKey(func, [numTasks])       | 在一个（K，V)对的数据集上使用，返回一个（K，V）对的数据集，key相同的值，都被使用指定的reduce函数聚合到一起。和groupbykey类似，任务的个数是可以通过第二个可选参数来配置的。 |\n| join(otherDataset, [numTasks])      | 在类型为（K,V)和（K,W)类型的数据集上调用，返回一个（K,(V,W))对，每个key中的所有元素都在一起的数据集 |\n| groupWith(otherDataset, [numTasks]) | 在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup |\n| cartesian(otherDataset)             | 笛卡尔积。但在数据集T和U上调用时，返回一个(T，U）对的数据集，所有元素交互进行笛卡尔积。 |\n|                                     |                                                              |\n|                                     |                                                              |\n|                                     |                                                              |\n| map(func)                           | 返回一个新的分布式数据集，由每个原元素经过func函数转换后组成 |\n\n\n## Actions\n\n| 命令                       | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| `reduce(func)`             | 通过函数`func`聚集数据集中的所有元素。`func`函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行 |\n| `collect()`                | 在`Driver`的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用`filter`或者其它操作后，返回一个足够小的数据子集再使用，直接将整个`RDD`集Collect返回，很可能会让`Driver`程序OOM |\n| `count()`                  | 统计`RDD`中元素的个数                                        |\n| `take(n)`                  | 取`RDD`中的前`n`个元素。注意，这个操作目前并非在多个节点上，并行执行，而是`Driver`程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用） |\n| `first()`                  | 返回数据集的第一个元素（类似于`take(1)`  ）                  |\n| `reduce(func)`             | 按照指定规则聚合`RDD`中的元素                                |\n| `countByValue()`           | 统计出`RDD`中每个元素的个数                                  |\n| `countByKey()`             | 统计出`KV`格式的`RDD`中相同的K的个数                         |\n| `foreach(func)`            | 以元素为单位，遍历`RDD`，运行`func`函数。                    |\n| `foreachPartition(func)`   | 以分区为单位，遍历`RDD`，运行`func`函数。                    |\n| `saveAsTextFile(path)`     | 将数据集的元素，以t`extfile`的形式，保存到本地文件系统，`hdfs`或者任何其它`hadoop`支持的文件系统。Spark将会调用每个元素的`toString`方法，并将它转换为文件中的一行文本 |\n| `saveAsSequenceFile(path)` | 将数据集的元素，以`sequencefile`的格式，保存到指定的目录下，本地系统，`hdfs`或者任何其它`hadoop`支持的文件系统。`RDD`的元素必须由`key-value`对组成，并都实现了`Hadoop`的`Writable`接口，或隐式可以转换为`Writable`（Spark包括了基本类型的转换，例如`Int`，`Double`，`String`等等） |\n\n# [MLlib](https://spark.apache.org/docs/latest/ml-classification-regression.html)与ML\n\n- `spark.mllib`包含基于RDD的原始算法API。Spark MLlib 历史比较长，在1.0 以前的版本即已经包含了，提供的算法实现都是基于原始的 RDD。\n\n- `spark.ml`则提供了基于[DataFrames](http://spark.apache.org/docs/latest/sql-programming-guide.html#dataframes) 高层次的API，可以用来构建机器学习工作流（PipeLine）。ML Pipeline 弥补了原始 MLlib 库的不足，向用户提供了一个基于 DataFrame 的机器学习工作流式 API 套件。\n\n使用 `ML Pipeline API`可以很方便的把数据处理，特征转换，正则化，以及多个机器学习算法联合起来，构建一个单一完整的机器学习流水线。这种方式给我们提供了更灵活的方法，更符合机器学习过程的特点，也更容易从其他语言迁移。**Spark官方推荐使用`spark.ml`**。如果新的算法能够适用于机器学习管道的概念，就应该将其放到`spark.ml`包中，如：特征提取器和转换器。开发者需要注意的是，从`Spark2.0`开始，基于`RDD`的`API`进入维护模式（即不增加任何新的特性），**并预期于3.0版本的时候被移除出`MLlib**`。\n\n# SQL、DataFrame和DataSet\n\n\n\n\n\n# 附录\n\n## RDD与DataFrame、DataSet\n\n`DataFrame = SchemaRDD = RDD<ROW>`\n\n从图虫颜色来区分，DataFrame是列式存储。当要取Age这一列时，RDD必须先取出person再取Age，而DataFrame可以直接取Age这一列\n\n![img](spark/15052983161313.jpg)","slug":"spark","published":1,"updated":"2019-08-16T12:31:38.156Z","_id":"cjzdr6ize003bhomjv1senrqg","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"spark简介\"><a href=\"#spark简介\" class=\"headerlink\" title=\"spark简介\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd\" target=\"_blank\" rel=\"noopener\">spark简介</a></h1><p>Spark是开发通用的大数据处理框架。Spark应用程序可以使用R语言、Java、Scala和Python进行编写，极少使用R语言编写Spark程序，Java和Scala语言编写的Spark程序的执行效率是相同的，但Java语言写的代码量多，Scala简洁优雅，但可读性不如Java，Python语言编写的Spark程序的执行效率不如Java和Scala。</p>\n<p><img src=\"/2019/08/09/spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg\" alt=\"img\"></p>\n<a id=\"more\"></a>\n<h2 id=\"运行模式\"><a href=\"#运行模式\" class=\"headerlink\" title=\"运行模式\"></a>运行模式</h2><p>Spark有4中运行模式：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>local</td>\n<td>适用于测试</td>\n</tr>\n<tr>\n<td>standalone</td>\n<td>并非是单节点，而是使用spark自带的资源调度框架</td>\n</tr>\n<tr>\n<td>yarn</td>\n<td>最流行的方式，使用yarn集群调度资源</td>\n</tr>\n<tr>\n<td>mesos</td>\n<td>国外使用的多</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"RDD\"><a href=\"#RDD\" class=\"headerlink\" title=\"RDD\"></a><a href=\"./RDD-Spark.md\">RDD</a></h1><p>RDD是<strong>弹性分布式数据集</strong>，<strong>是Spark中最基本的数据抽象，任何数据在Spark中都被表示为RDD</strong>。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据是分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作从而得到结果。</p>\n<center>\n\n<pre class=\"mermaid\">graph TD\nA[加载数据集]--> B[使用transformations算子对RDD进行操作]\nB-->C[使用actions算子触发执行]</pre>\n\n</center>\n\n<h2 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter(func)</td>\n<td>返回一个新的数据集，由经过func函数后返回值为true的原元素组成</td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>返回一个新的分布式数据集，由每个原元素经过func函数转换后组成</td>\n</tr>\n<tr>\n<td>flatMap(func)</td>\n<td>类似于map，但是每一个输入元素，会被映射为0到多个输出元素（因此，func函数的返回值是一个Seq，而不是单一元素）</td>\n</tr>\n<tr>\n<td>ample(withReplacement, frac, seed)</td>\n<td>根据给定的随机种子seed，随机抽样出数量为frac的数据</td>\n</tr>\n<tr>\n<td>union(otherDataset)</td>\n<td>返回一个新的数据集，由原数据集和参数联合而成</td>\n</tr>\n<tr>\n<td>groupByKey([numTasks])</td>\n<td>在一个由（K,V）对组成的数据集上调用，返回一个（K，Seq[V])对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入numTask可选参数，根据数据量设置不同数目的Task</td>\n</tr>\n<tr>\n<td>reduceByKey(func, [numTasks])</td>\n<td>在一个（K，V)对的数据集上使用，返回一个（K，V）对的数据集，key相同的值，都被使用指定的reduce函数聚合到一起。和groupbykey类似，任务的个数是可以通过第二个可选参数来配置的。</td>\n</tr>\n<tr>\n<td>join(otherDataset, [numTasks])</td>\n<td>在类型为（K,V)和（K,W)类型的数据集上调用，返回一个（K,(V,W))对，每个key中的所有元素都在一起的数据集</td>\n</tr>\n<tr>\n<td>groupWith(otherDataset, [numTasks])</td>\n<td>在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup</td>\n</tr>\n<tr>\n<td>cartesian(otherDataset)</td>\n<td>笛卡尔积。但在数据集T和U上调用时，返回一个(T，U）对的数据集，所有元素交互进行笛卡尔积。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>返回一个新的分布式数据集，由每个原元素经过func函数转换后组成</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>通过函数<code>func</code>聚集数据集中的所有元素。<code>func</code>函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行</td>\n</tr>\n<tr>\n<td><code>collect()</code></td>\n<td>在<code>Driver</code>的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用<code>filter</code>或者其它操作后，返回一个足够小的数据子集再使用，直接将整个<code>RDD</code>集Collect返回，很可能会让<code>Driver</code>程序OOM</td>\n</tr>\n<tr>\n<td><code>count()</code></td>\n<td>统计<code>RDD</code>中元素的个数</td>\n</tr>\n<tr>\n<td><code>take(n)</code></td>\n<td>取<code>RDD</code>中的前<code>n</code>个元素。注意，这个操作目前并非在多个节点上，并行执行，而是<code>Driver</code>程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用）</td>\n</tr>\n<tr>\n<td><code>first()</code></td>\n<td>返回数据集的第一个元素（类似于<code>take(1)</code>  ）</td>\n</tr>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>按照指定规则聚合<code>RDD</code>中的元素</td>\n</tr>\n<tr>\n<td><code>countByValue()</code></td>\n<td>统计出<code>RDD</code>中每个元素的个数</td>\n</tr>\n<tr>\n<td><code>countByKey()</code></td>\n<td>统计出<code>KV</code>格式的<code>RDD</code>中相同的K的个数</td>\n</tr>\n<tr>\n<td><code>foreach(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>foreachPartition(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>saveAsTextFile(path)</code></td>\n<td>将数据集的元素，以t<code>extfile</code>的形式，保存到本地文件系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。Spark将会调用每个元素的<code>toString</code>方法，并将它转换为文件中的一行文本</td>\n</tr>\n<tr>\n<td><code>saveAsSequenceFile(path)</code></td>\n<td>将数据集的元素，以<code>sequencefile</code>的格式，保存到指定的目录下，本地系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。<code>RDD</code>的元素必须由<code>key-value</code>对组成，并都实现了<code>Hadoop</code>的<code>Writable</code>接口，或隐式可以转换为<code>Writable</code>（Spark包括了基本类型的转换，例如<code>Int</code>，<code>Double</code>，<code>String</code>等等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"MLlib与ML\"><a href=\"#MLlib与ML\" class=\"headerlink\" title=\"MLlib与ML\"></a><a href=\"https://spark.apache.org/docs/latest/ml-classification-regression.html\" target=\"_blank\" rel=\"noopener\">MLlib</a>与ML</h1><ul>\n<li><p><code>spark.mllib</code>包含基于RDD的原始算法API。Spark MLlib 历史比较长，在1.0 以前的版本即已经包含了，提供的算法实现都是基于原始的 RDD。</p>\n</li>\n<li><p><code>spark.ml</code>则提供了基于<a href=\"http://spark.apache.org/docs/latest/sql-programming-guide.html#dataframes\" target=\"_blank\" rel=\"noopener\">DataFrames</a> 高层次的API，可以用来构建机器学习工作流（PipeLine）。ML Pipeline 弥补了原始 MLlib 库的不足，向用户提供了一个基于 DataFrame 的机器学习工作流式 API 套件。</p>\n</li>\n</ul>\n<p>使用 <code>ML Pipeline API</code>可以很方便的把数据处理，特征转换，正则化，以及多个机器学习算法联合起来，构建一个单一完整的机器学习流水线。这种方式给我们提供了更灵活的方法，更符合机器学习过程的特点，也更容易从其他语言迁移。<strong>Spark官方推荐使用<code>spark.ml</code></strong>。如果新的算法能够适用于机器学习管道的概念，就应该将其放到<code>spark.ml</code>包中，如：特征提取器和转换器。开发者需要注意的是，从<code>Spark2.0</code>开始，基于<code>RDD</code>的<code>API</code>进入维护模式（即不增加任何新的特性），<strong>并预期于3.0版本的时候被移除出`MLlib</strong>`。</p>\n<h1 id=\"SQL、DataFrame和DataSet\"><a href=\"#SQL、DataFrame和DataSet\" class=\"headerlink\" title=\"SQL、DataFrame和DataSet\"></a>SQL、DataFrame和DataSet</h1><h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"RDD与DataFrame、DataSet\"><a href=\"#RDD与DataFrame、DataSet\" class=\"headerlink\" title=\"RDD与DataFrame、DataSet\"></a>RDD与DataFrame、DataSet</h2><p><code>DataFrame = SchemaRDD = RDD&lt;ROW&gt;</code></p>\n<p>从图虫颜色来区分，DataFrame是列式存储。当要取Age这一列时，RDD必须先取出person再取Age，而DataFrame可以直接取Age这一列</p>\n<p><img src=\"/2019/08/09/spark/15052983161313.jpg\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"spark简介\"><a href=\"#spark简介\" class=\"headerlink\" title=\"spark简介\"></a><a href=\"https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/sql-guide.html#rdd\" target=\"_blank\" rel=\"noopener\">spark简介</a></h1><p>Spark是开发通用的大数据处理框架。Spark应用程序可以使用R语言、Java、Scala和Python进行编写，极少使用R语言编写Spark程序，Java和Scala语言编写的Spark程序的执行效率是相同的，但Java语言写的代码量多，Scala简洁优雅，但可读性不如Java，Python语言编写的Spark程序的执行效率不如Java和Scala。</p>\n<p><img src=\"/2019/08/09/spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg\" alt=\"img\"></p>","more":"<h2 id=\"运行模式\"><a href=\"#运行模式\" class=\"headerlink\" title=\"运行模式\"></a>运行模式</h2><p>Spark有4中运行模式：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>local</td>\n<td>适用于测试</td>\n</tr>\n<tr>\n<td>standalone</td>\n<td>并非是单节点，而是使用spark自带的资源调度框架</td>\n</tr>\n<tr>\n<td>yarn</td>\n<td>最流行的方式，使用yarn集群调度资源</td>\n</tr>\n<tr>\n<td>mesos</td>\n<td>国外使用的多</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"RDD\"><a href=\"#RDD\" class=\"headerlink\" title=\"RDD\"></a><a href=\"./RDD-Spark.md\">RDD</a></h1><p>RDD是<strong>弹性分布式数据集</strong>，<strong>是Spark中最基本的数据抽象，任何数据在Spark中都被表示为RDD</strong>。从编程的角度来看，RDD可以简单看成是一个数组。和普通数组的区别是，RDD中的数据是分区存储的，这样不同分区的数据就可以分布在不同的机器上，同时可以被并行处理。因此，Spark应用程序所做的无非是把需要处理的数据转换为RDD，然后对RDD进行一系列的变换和操作从而得到结果。</p>\n<center>\n\n<pre class=\"mermaid\">graph TD\nA[加载数据集]--> B[使用transformations算子对RDD进行操作]\nB-->C[使用actions算子触发执行]</pre>\n\n</center>\n\n<h2 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>filter(func)</td>\n<td>返回一个新的数据集，由经过func函数后返回值为true的原元素组成</td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>返回一个新的分布式数据集，由每个原元素经过func函数转换后组成</td>\n</tr>\n<tr>\n<td>flatMap(func)</td>\n<td>类似于map，但是每一个输入元素，会被映射为0到多个输出元素（因此，func函数的返回值是一个Seq，而不是单一元素）</td>\n</tr>\n<tr>\n<td>ample(withReplacement, frac, seed)</td>\n<td>根据给定的随机种子seed，随机抽样出数量为frac的数据</td>\n</tr>\n<tr>\n<td>union(otherDataset)</td>\n<td>返回一个新的数据集，由原数据集和参数联合而成</td>\n</tr>\n<tr>\n<td>groupByKey([numTasks])</td>\n<td>在一个由（K,V）对组成的数据集上调用，返回一个（K，Seq[V])对的数据集。注意：默认情况下，使用8个并行任务进行分组，你可以传入numTask可选参数，根据数据量设置不同数目的Task</td>\n</tr>\n<tr>\n<td>reduceByKey(func, [numTasks])</td>\n<td>在一个（K，V)对的数据集上使用，返回一个（K，V）对的数据集，key相同的值，都被使用指定的reduce函数聚合到一起。和groupbykey类似，任务的个数是可以通过第二个可选参数来配置的。</td>\n</tr>\n<tr>\n<td>join(otherDataset, [numTasks])</td>\n<td>在类型为（K,V)和（K,W)类型的数据集上调用，返回一个（K,(V,W))对，每个key中的所有元素都在一起的数据集</td>\n</tr>\n<tr>\n<td>groupWith(otherDataset, [numTasks])</td>\n<td>在类型为（K,V)和(K,W)类型的数据集上调用，返回一个数据集，组成元素为（K, Seq[V], Seq[W]) Tuples。这个操作在其它框架，称为CoGroup</td>\n</tr>\n<tr>\n<td>cartesian(otherDataset)</td>\n<td>笛卡尔积。但在数据集T和U上调用时，返回一个(T，U）对的数据集，所有元素交互进行笛卡尔积。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map(func)</td>\n<td>返回一个新的分布式数据集，由每个原元素经过func函数转换后组成</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>通过函数<code>func</code>聚集数据集中的所有元素。<code>func</code>函数接受2个参数，返回一个值。这个函数必须是关联性的，确保可以被正确的并发执行</td>\n</tr>\n<tr>\n<td><code>collect()</code></td>\n<td>在<code>Driver</code>的程序中，以数组的形式，返回数据集的所有元素。这通常会在使用<code>filter</code>或者其它操作后，返回一个足够小的数据子集再使用，直接将整个<code>RDD</code>集Collect返回，很可能会让<code>Driver</code>程序OOM</td>\n</tr>\n<tr>\n<td><code>count()</code></td>\n<td>统计<code>RDD</code>中元素的个数</td>\n</tr>\n<tr>\n<td><code>take(n)</code></td>\n<td>取<code>RDD</code>中的前<code>n</code>个元素。注意，这个操作目前并非在多个节点上，并行执行，而是<code>Driver</code>程序所在机器，单机计算所有的元素(Gateway的内存压力会增大，需要谨慎使用）</td>\n</tr>\n<tr>\n<td><code>first()</code></td>\n<td>返回数据集的第一个元素（类似于<code>take(1)</code>  ）</td>\n</tr>\n<tr>\n<td><code>reduce(func)</code></td>\n<td>按照指定规则聚合<code>RDD</code>中的元素</td>\n</tr>\n<tr>\n<td><code>countByValue()</code></td>\n<td>统计出<code>RDD</code>中每个元素的个数</td>\n</tr>\n<tr>\n<td><code>countByKey()</code></td>\n<td>统计出<code>KV</code>格式的<code>RDD</code>中相同的K的个数</td>\n</tr>\n<tr>\n<td><code>foreach(func)</code></td>\n<td>以元素为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>foreachPartition(func)</code></td>\n<td>以分区为单位，遍历<code>RDD</code>，运行<code>func</code>函数。</td>\n</tr>\n<tr>\n<td><code>saveAsTextFile(path)</code></td>\n<td>将数据集的元素，以t<code>extfile</code>的形式，保存到本地文件系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。Spark将会调用每个元素的<code>toString</code>方法，并将它转换为文件中的一行文本</td>\n</tr>\n<tr>\n<td><code>saveAsSequenceFile(path)</code></td>\n<td>将数据集的元素，以<code>sequencefile</code>的格式，保存到指定的目录下，本地系统，<code>hdfs</code>或者任何其它<code>hadoop</code>支持的文件系统。<code>RDD</code>的元素必须由<code>key-value</code>对组成，并都实现了<code>Hadoop</code>的<code>Writable</code>接口，或隐式可以转换为<code>Writable</code>（Spark包括了基本类型的转换，例如<code>Int</code>，<code>Double</code>，<code>String</code>等等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"MLlib与ML\"><a href=\"#MLlib与ML\" class=\"headerlink\" title=\"MLlib与ML\"></a><a href=\"https://spark.apache.org/docs/latest/ml-classification-regression.html\" target=\"_blank\" rel=\"noopener\">MLlib</a>与ML</h1><ul>\n<li><p><code>spark.mllib</code>包含基于RDD的原始算法API。Spark MLlib 历史比较长，在1.0 以前的版本即已经包含了，提供的算法实现都是基于原始的 RDD。</p>\n</li>\n<li><p><code>spark.ml</code>则提供了基于<a href=\"http://spark.apache.org/docs/latest/sql-programming-guide.html#dataframes\" target=\"_blank\" rel=\"noopener\">DataFrames</a> 高层次的API，可以用来构建机器学习工作流（PipeLine）。ML Pipeline 弥补了原始 MLlib 库的不足，向用户提供了一个基于 DataFrame 的机器学习工作流式 API 套件。</p>\n</li>\n</ul>\n<p>使用 <code>ML Pipeline API</code>可以很方便的把数据处理，特征转换，正则化，以及多个机器学习算法联合起来，构建一个单一完整的机器学习流水线。这种方式给我们提供了更灵活的方法，更符合机器学习过程的特点，也更容易从其他语言迁移。<strong>Spark官方推荐使用<code>spark.ml</code></strong>。如果新的算法能够适用于机器学习管道的概念，就应该将其放到<code>spark.ml</code>包中，如：特征提取器和转换器。开发者需要注意的是，从<code>Spark2.0</code>开始，基于<code>RDD</code>的<code>API</code>进入维护模式（即不增加任何新的特性），<strong>并预期于3.0版本的时候被移除出`MLlib</strong>`。</p>\n<h1 id=\"SQL、DataFrame和DataSet\"><a href=\"#SQL、DataFrame和DataSet\" class=\"headerlink\" title=\"SQL、DataFrame和DataSet\"></a>SQL、DataFrame和DataSet</h1><h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"RDD与DataFrame、DataSet\"><a href=\"#RDD与DataFrame、DataSet\" class=\"headerlink\" title=\"RDD与DataFrame、DataSet\"></a>RDD与DataFrame、DataSet</h2><p><code>DataFrame = SchemaRDD = RDD&lt;ROW&gt;</code></p>\n<p>从图虫颜色来区分，DataFrame是列式存储。当要取Age这一列时，RDD必须先取出person再取Age，而DataFrame可以直接取Age这一列</p>\n<p><img src=\"/2019/08/09/spark/15052983161313.jpg\" alt=\"img\"></p>"},{"title":"vim","date":"2019-07-31T07:06:09.000Z","_content":"\n![1564556925963](vim/1564556925963.png)\n\n<!--more-->\n\n# 命令模式\n\n| 功能      | 描述                                                         |\n| --------- | ------------------------------------------------------------ |\n| 常用命令  | i、a、o\t                  切换到输入模式，以输入字符<br/>x\t                             删除当前光标所在处的字符。<br/>:\t                              切换到底线命令模式，以在最底一行输入命令。<br/>HOME(0)   END($)\t移动光标到行首/行尾 |\n| 搜索/替换 |                                                              |\n| 删除      | nx\t          n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br/>dd\t          删除游标所在的那一整行(常用)<br/>ndd\t        n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)<br/>d1G\t        删除光标所在到第一行的所有数据<br/>dG\t          删除光标所在到最后一行的所有数据<br/>d$\t           删除游标所在处，到该行的最后一个字符<br/>d0\t           那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 |\n| 复制      | yy\t                   复制游标所在的那一行(常用)<br/>nyy\tn              为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)<br/>y1G\t                复制游标所在行到第一行的所有数据<br/>yG\t                  复制游标所在行到最后一行的所有数据<br/>y0\t                   复制光标所在的那个字符到该行行首的所有数据 |\n| 粘贴      | p, P\t                 p 为将已复制的数据在光标下一行贴上，<br/>J\t                       将光标所在行与下一行的数据结合成同一行<br/>c\t                      重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br/>c\t                      重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br/>u\t                      复原前一个动作。(常用) |\n\n## 搜索与替换\n\n| 命令                 | 说明                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| /word                | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |\n| ?word                | 向光标之上寻找一个字符串名称为 word 的字符串。               |\n| n                    | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |\n| N                    | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |\n| n1,n2s/word1/word2/g | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>`『:100,200s/vbird/VBIRD/g』。` |\n\n# 输入模式\n\n| 命令                  | 说明                                           |\n| --------------------- | ---------------------------------------------- |\n| 字符按键以及Shift组合 | 输入字符                                       |\n| ENTER                 | 回车键，换行                                   |\n| BACK SPACE            | 退格键，删除光标前一个字符                     |\n| DEL                   | 删除键，删除光标后一个字符                     |\n| 方向键                | 在文本中移动光标                               |\n| HOME/END              | 移动光标到行首/行尾                            |\n| Page Up/Page Down     | 上/下翻页                                      |\n| Insert                | 切换光标为输入/替换模式，光标将变成竖线/下划线 |\n| ESC                   | 退出输入模式，切换到命令模式                   |\n\n# 底线命令模式\n\n| 命令                | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| q                   | 退出程序                                                     |\n| w                   | 保存文件                                                     |\n| :q!                 | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |\n| :w [filename]       | 将编辑的数据储存成另一个档案（类似另存新档）                 |\n| :r [filename]       | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |\n| :n1,n2 w [filename] | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |\n| :! command          | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>`『:! ls /home』`即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ |\n| 行号                | :set nu           显示行号<br>:set nonu      不显示行号      |\n\n","source":"_posts/vim.md","raw":"---\ntitle: vim\ndate: 2019-07-31 15:06:09\ntags: [操作系统,编辑器]\ncategories: linux\n---\n\n![1564556925963](vim/1564556925963.png)\n\n<!--more-->\n\n# 命令模式\n\n| 功能      | 描述                                                         |\n| --------- | ------------------------------------------------------------ |\n| 常用命令  | i、a、o\t                  切换到输入模式，以输入字符<br/>x\t                             删除当前光标所在处的字符。<br/>:\t                              切换到底线命令模式，以在最底一行输入命令。<br/>HOME(0)   END($)\t移动光标到行首/行尾 |\n| 搜索/替换 |                                                              |\n| 删除      | nx\t          n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br/>dd\t          删除游标所在的那一整行(常用)<br/>ndd\t        n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)<br/>d1G\t        删除光标所在到第一行的所有数据<br/>dG\t          删除光标所在到最后一行的所有数据<br/>d$\t           删除游标所在处，到该行的最后一个字符<br/>d0\t           那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 |\n| 复制      | yy\t                   复制游标所在的那一行(常用)<br/>nyy\tn              为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)<br/>y1G\t                复制游标所在行到第一行的所有数据<br/>yG\t                  复制游标所在行到最后一行的所有数据<br/>y0\t                   复制光标所在的那个字符到该行行首的所有数据 |\n| 粘贴      | p, P\t                 p 为将已复制的数据在光标下一行贴上，<br/>J\t                       将光标所在行与下一行的数据结合成同一行<br/>c\t                      重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br/>c\t                      重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br/>u\t                      复原前一个动作。(常用) |\n\n## 搜索与替换\n\n| 命令                 | 说明                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| /word                | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |\n| ?word                | 向光标之上寻找一个字符串名称为 word 的字符串。               |\n| n                    | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |\n| N                    | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |\n| n1,n2s/word1/word2/g | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>`『:100,200s/vbird/VBIRD/g』。` |\n\n# 输入模式\n\n| 命令                  | 说明                                           |\n| --------------------- | ---------------------------------------------- |\n| 字符按键以及Shift组合 | 输入字符                                       |\n| ENTER                 | 回车键，换行                                   |\n| BACK SPACE            | 退格键，删除光标前一个字符                     |\n| DEL                   | 删除键，删除光标后一个字符                     |\n| 方向键                | 在文本中移动光标                               |\n| HOME/END              | 移动光标到行首/行尾                            |\n| Page Up/Page Down     | 上/下翻页                                      |\n| Insert                | 切换光标为输入/替换模式，光标将变成竖线/下划线 |\n| ESC                   | 退出输入模式，切换到命令模式                   |\n\n# 底线命令模式\n\n| 命令                | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| q                   | 退出程序                                                     |\n| w                   | 保存文件                                                     |\n| :q!                 | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |\n| :w [filename]       | 将编辑的数据储存成另一个档案（类似另存新档）                 |\n| :r [filename]       | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |\n| :n1,n2 w [filename] | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |\n| :! command          | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>`『:! ls /home』`即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ |\n| 行号                | :set nu           显示行号<br>:set nonu      不显示行号      |\n\n","slug":"vim","published":1,"updated":"2019-08-06T01:52:30.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izg003ghomjaddjkvjx","content":"<p><img src=\"/2019/07/31/vim/1564556925963.png\" alt=\"1564556925963\"></p>\n<a id=\"more\"></a>\n<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>常用命令</td>\n<td>i、a、o                      切换到输入模式，以输入字符<br>x                                 删除当前光标所在处的字符。<br>:                                  切换到底线命令模式，以在最底一行输入命令。<br>HOME(0)   END($)    移动光标到行首/行尾</td>\n</tr>\n<tr>\n<td>搜索/替换</td>\n<td></td>\n</tr>\n<tr>\n<td>删除</td>\n<td>nx              n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br>dd              删除游标所在的那一整行(常用)<br>ndd            n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)<br>d1G            删除光标所在到第一行的所有数据<br>dG              删除光标所在到最后一行的所有数据<br>d$               删除游标所在处，到该行的最后一个字符<br>d0               那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>\n</tr>\n<tr>\n<td>复制</td>\n<td>yy                       复制游标所在的那一行(常用)<br>nyy    n              为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)<br>y1G                    复制游标所在行到第一行的所有数据<br>yG                      复制游标所在行到最后一行的所有数据<br>y0                       复制光标所在的那个字符到该行行首的所有数据</td>\n</tr>\n<tr>\n<td>粘贴</td>\n<td>p, P                     p 为将已复制的数据在光标下一行贴上，<br>J                           将光标所在行与下一行的数据结合成同一行<br>c                          重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>c                          重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>u                          复原前一个动作。(常用)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"搜索与替换\"><a href=\"#搜索与替换\" class=\"headerlink\" title=\"搜索与替换\"></a>搜索与替换</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/word</td>\n<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td>\n</tr>\n<tr>\n<td>?word</td>\n<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>\n</tr>\n<tr>\n<td>n</td>\n<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>\n</tr>\n<tr>\n<td>N</td>\n<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>\n</tr>\n<tr>\n<td>n1,n2s/word1/word2/g</td>\n<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br><code>『:100,200s/vbird/VBIRD/g』。</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"输入模式\"><a href=\"#输入模式\" class=\"headerlink\" title=\"输入模式\"></a>输入模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>字符按键以及Shift组合</td>\n<td>输入字符</td>\n</tr>\n<tr>\n<td>ENTER</td>\n<td>回车键，换行</td>\n</tr>\n<tr>\n<td>BACK SPACE</td>\n<td>退格键，删除光标前一个字符</td>\n</tr>\n<tr>\n<td>DEL</td>\n<td>删除键，删除光标后一个字符</td>\n</tr>\n<tr>\n<td>方向键</td>\n<td>在文本中移动光标</td>\n</tr>\n<tr>\n<td>HOME/END</td>\n<td>移动光标到行首/行尾</td>\n</tr>\n<tr>\n<td>Page Up/Page Down</td>\n<td>上/下翻页</td>\n</tr>\n<tr>\n<td>Insert</td>\n<td>切换光标为输入/替换模式，光标将变成竖线/下划线</td>\n</tr>\n<tr>\n<td>ESC</td>\n<td>退出输入模式，切换到命令模式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"底线命令模式\"><a href=\"#底线命令模式\" class=\"headerlink\" title=\"底线命令模式\"></a>底线命令模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>q</td>\n<td>退出程序</td>\n</tr>\n<tr>\n<td>w</td>\n<td>保存文件</td>\n</tr>\n<tr>\n<td>:q!</td>\n<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>\n</tr>\n<tr>\n<td>:w [filename]</td>\n<td>将编辑的数据储存成另一个档案（类似另存新档）</td>\n</tr>\n<tr>\n<td>:r [filename]</td>\n<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>\n</tr>\n<tr>\n<td>:n1,n2 w [filename]</td>\n<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>\n</tr>\n<tr>\n<td>:! command</td>\n<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br><code>『:! ls /home』</code>即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>\n</tr>\n<tr>\n<td>行号</td>\n<td>:set nu           显示行号<br>:set nonu      不显示行号</td>\n</tr>\n</tbody>\n</table>\n</div>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2019/07/31/vim/1564556925963.png\" alt=\"1564556925963\"></p>","more":"<h1 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>常用命令</td>\n<td>i、a、o                      切换到输入模式，以输入字符<br>x                                 删除当前光标所在处的字符。<br>:                                  切换到底线命令模式，以在最底一行输入命令。<br>HOME(0)   END($)    移动光标到行首/行尾</td>\n</tr>\n<tr>\n<td>搜索/替换</td>\n<td></td>\n</tr>\n<tr>\n<td>删除</td>\n<td>nx              n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br>dd              删除游标所在的那一整行(常用)<br>ndd            n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)<br>d1G            删除光标所在到第一行的所有数据<br>dG              删除光标所在到最后一行的所有数据<br>d$               删除游标所在处，到该行的最后一个字符<br>d0               那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>\n</tr>\n<tr>\n<td>复制</td>\n<td>yy                       复制游标所在的那一行(常用)<br>nyy    n              为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)<br>y1G                    复制游标所在行到第一行的所有数据<br>yG                      复制游标所在行到最后一行的所有数据<br>y0                       复制光标所在的那个字符到该行行首的所有数据</td>\n</tr>\n<tr>\n<td>粘贴</td>\n<td>p, P                     p 为将已复制的数据在光标下一行贴上，<br>J                           将光标所在行与下一行的数据结合成同一行<br>c                          重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>c                          重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>u                          复原前一个动作。(常用)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"搜索与替换\"><a href=\"#搜索与替换\" class=\"headerlink\" title=\"搜索与替换\"></a>搜索与替换</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/word</td>\n<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td>\n</tr>\n<tr>\n<td>?word</td>\n<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>\n</tr>\n<tr>\n<td>n</td>\n<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>\n</tr>\n<tr>\n<td>N</td>\n<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>\n</tr>\n<tr>\n<td>n1,n2s/word1/word2/g</td>\n<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br><code>『:100,200s/vbird/VBIRD/g』。</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"输入模式\"><a href=\"#输入模式\" class=\"headerlink\" title=\"输入模式\"></a>输入模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>字符按键以及Shift组合</td>\n<td>输入字符</td>\n</tr>\n<tr>\n<td>ENTER</td>\n<td>回车键，换行</td>\n</tr>\n<tr>\n<td>BACK SPACE</td>\n<td>退格键，删除光标前一个字符</td>\n</tr>\n<tr>\n<td>DEL</td>\n<td>删除键，删除光标后一个字符</td>\n</tr>\n<tr>\n<td>方向键</td>\n<td>在文本中移动光标</td>\n</tr>\n<tr>\n<td>HOME/END</td>\n<td>移动光标到行首/行尾</td>\n</tr>\n<tr>\n<td>Page Up/Page Down</td>\n<td>上/下翻页</td>\n</tr>\n<tr>\n<td>Insert</td>\n<td>切换光标为输入/替换模式，光标将变成竖线/下划线</td>\n</tr>\n<tr>\n<td>ESC</td>\n<td>退出输入模式，切换到命令模式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"底线命令模式\"><a href=\"#底线命令模式\" class=\"headerlink\" title=\"底线命令模式\"></a>底线命令模式</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>q</td>\n<td>退出程序</td>\n</tr>\n<tr>\n<td>w</td>\n<td>保存文件</td>\n</tr>\n<tr>\n<td>:q!</td>\n<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>\n</tr>\n<tr>\n<td>:w [filename]</td>\n<td>将编辑的数据储存成另一个档案（类似另存新档）</td>\n</tr>\n<tr>\n<td>:r [filename]</td>\n<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>\n</tr>\n<tr>\n<td>:n1,n2 w [filename]</td>\n<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>\n</tr>\n<tr>\n<td>:! command</td>\n<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br><code>『:! ls /home』</code>即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>\n</tr>\n<tr>\n<td>行号</td>\n<td>:set nu           显示行号<br>:set nonu      不显示行号</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"title":"xgboost","date":"2018-08-13T03:11:19.000Z","_content":"\n# [简介](https://yxzf.github.io/2017/03/xgboost-v1/)\n下图就是CART树和一堆CART树的示例，用来判断一个人是否会喜欢计算机游戏\n\n\n![](xgboost/h-18fe29f8.png)\n\n<!-- more -->\n![](xgboost/h-597ed097.png)\n\n## 算法\n![](xgboost/xgboost-634b5dbd.png)\n\n# 模型\n我们希望训练出 $K$ 颗树，将它们集成起来从而预测我们的$y$。我们可以用以下公式表示：\n$$\\hat{y}=\\sum_{k=1}^Kf_k(x_i)\\\\\nf(x)=w_{q(x)}$$\n在这里，我们用一个函数 $f_k(x)$ 来表示一颗决策树，那个函数 $f$ 可以理解为将样本x映射到树的某个叶子结点中，树中的每个叶子结点都会对应着一个权重$w$。\n![](xgboost/xgboost-b2122f64.png)\n如图，这就是提升树的一个例子，这里一共有两颗树，意味着我们有两个函数 $f_1,f_2，K=2$ ，然后将样本分别放到我们的两颗树中，就可以计算出两个值，把它加起来就是我们要预测的y\n\n# 目标函数\n\n$K$ 表示有 $K$ 棵树，$f_k$ 相当于第 $k$ 棵。因此我们的目标函数可以写成\n$$Obj=\\sum_il(\\hat{y_i},y)+\\sum_k\\Omega(f_k)\\\\\nwhere\\ \\Omega(f)=\\gamma T+\\frac{1}{2}\\lambda||w||^2$$\n其中 $l$ 是可导且凸的**损失函数**，用来衡量 $\\hat{y}$ 与 $y$ 的相近程度，第二项 $Ω$ 则是**正则项**，它包含了两个部分，第一个是 $γT$，这里的 $T$ 表示**叶子结点的数量**，$γ$ 是超参，也就是说如果 $γ$ 越大，那么我们的叶子结点数量就会越小。另外一部分则是L2正则项，通过对叶子结点的权重进行惩罚，使得不会存在权重过大的叶子结点防止过拟合。$w$ 就表示叶子结点的权重。\n\n\n\n# 梯度提升\n假设第 $t$ 轮的预测值为$y^{(t)}$ ，第 $t$ 颗回归树为 $f_t(x)$。则模型迭代如下:\n$$\\begin{align}\\hat y_i^{(0)} &= 0 \\\\  y_i^{(0)} & = f_1(x_i)= \\hat y_i^{(0)}+f_1(x_i) \\\\  y_i^{(2)}&=f_1(x_i)+f_2(x_i)= \\hat y_i^{(1)}+f_2(x_i) \\\\ &\\cdots \\\\ y_i^{(t)}&=\\sum_{k=1}^tf_k(x_i)= \\hat y_i^{(t-1)}+f_t(x_i) \\end{align}$$\n\n但是对于上面这么一个目标函数，我们是很难进行优化的，于是我们将它变换一下，我们通过每一步增加一个基分类器 $f_t(x)$ ，贪婪地去优化这个目标函数，使得每次增加 $f_t(x)$，都使得loss变小。如此一来，我们就得到了一个可以用于评价当前分类器 $f_t(x)$ 性能的一个评价函数：\n$$\\begin{align*}\nObj^{(t)}&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t)})+ \\sum_{i=1}^t\\Omega(f_t) \\\\\n&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t-1)}+f_t(x_i))+\\Omega(f_t) + constant\n\\end{align*}$$\n选取一个 $f_t(x)$来使得我们的目标函数尽量最大地降低。$constant$就是前 $t-1$ 棵树的复杂度\n\n\n\n**泰勒展开**\n\n![](xgboost/h-a1fde941.png)\n\n因为 $l(y_i,\\hat y_i^{(t-1)})$ 是常数字所以最优化可以化简为下式子\n\n$$ \\begin{align*}\nObj^{(t)} &=\\sum_{i=1}^n [ g_if_t(x_i)+\\frac 1 2 h_if_t^2(x_i)] + \\Omega (f_t) \\\\\n&=\\sum_{i=1}^n [ g_iw_q(x_i)+\\frac 1 2 h_iw_q^2(x_i)] + \\gamma T + \\lambda \\frac{1}{2}\\sum _{j=1}^Tw_j^2\\\\\n&= \\sum_{j=1}^T [( \\sum_{i \\in I_j} g_i)w_j+\\frac 1 2(\\sum_{i \\in I_j} h_i + \\lambda)w_j^2] + \\gamma T \\\\\n&= \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T\n\\end{align*} $$\n\n$j$为叶子结点的序号，$T$ 为叶子结点的总数 ；$i$ 为样本的序号，$n$ 为样本的总数；$w_q(x_i)$是求取$x_i$权值的对应函数；$\\sum_{i \\in I_j} g_i$ 为同一叶子结点的 $g_i$ 的和；$\\sum_{i \\in I_j} g_i w_j$ 为同一结点的 $g_i w_j$ ;$\\sum_{j=1}^T \\sum_{i \\in I_j} = \\sum_{i=1}^n$。其中\n\n$$g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad  h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\\nG_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i$$\n\n# 求取基模型$f_t(x)$-叶子结点权值$w$\n** $f_t(x_i)$ 是什么？它其实就是 $f_t$ 的某个叶子结点的值 $w$ 。之前我们提到过，叶子结点的值是可以作为模型的参数**\n$$Obj^{(t)}  = \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T$$\n\n令$\\frac{\\partial Obj^{(t)}}{\\partial w}=0$ 得到\n$$w_j^* = - \\frac {G_j} {H_j + \\lambda}$$\n带入上式得到\n$$Obj^{(t)} = - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T$$\n\n# 划分点\n$$\\begin{align}\n    Obj_{split} &= - \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda}] + \\gamma T_{split} \\\\\n    Obj_{noSplit} &=  - \\frac 1 2 \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda} + \\gamma T_{noSplit} \\\\\n    Gain &= Obj_{noSplit} - Obj_{split} \\\\\n         &= \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma(T_{split} - T_{nosplit}) \\\\\n         &=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma\n\\end{align}$$\n因为是二分类，二叉树所以$T_{split} - T_{nosplit} = 1$，**$Gain$越大越好**\n\n\n\n# 总结\n## 目标函数与叶子结点权值\n$$w_j^* = - \\frac {G_j} {H_j + \\lambda}$$\n\n$$Obj= - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T$$\n\n其中\n$$g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\ G_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i$$\n\n## 打分函数示例\nObj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)\n![](xgboost/xgboost-5847b944.png)\n\n## 分裂结点\n论文中给出了两种分裂结点的方法，贪心算法遍历所有分割点进行划分挑选增益最大的切分点。近似算法:对于数据量大的情况下进行近似算法\n### 贪心法：\n直观的方法是枚举所有的树结构，并根据上面数structure score来打分，找出最优的那棵树加入模型中，再不断重复。但暴力枚举根本不可行，所以类似于一般决策树的构建，XGBoost也是采用贪心算法，**每一次尝试去对已有的叶子加入一个分割。对于一个具体的分割方案，增益计算如下**：\n\n$$Gain=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma$$\n\n对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有 $x < a$ 这样的条件，对于某个特定的分割 $a$ 我们要计算 $a$ 左边和右边的导数和。对于所有的 $a$，首先根据需要划分的那列特征值排序，然后从左到右的扫描就可以枚举出所有分割的梯度和$G_L$和$G_R$，再用上面的公式计算每个分割方案的分数就可以了。\n![](xgboost/xgboost-b691aaff.png)\n观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic（启发式）而进行的操作了。\n\n#### 算法说明\n上面是针对一个特征，如果有m个特征，需要对所有参数都采取一样的操作，然后找到最好的那个特征所对应的划分。\n![](xgboost/xgboost-3eee29c4.png)\n\n### [近似算法](https://zhuanlan.zhihu.com/p/38297689)\nXGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。\n该算法会首先根据**特征分布的百分位数** (percentiles of feature distribution)，提出候选划分点 (candidate splitting points)。接着，该算法将连续型特征映射到由这些候选点划分的分桶(buckets) 中，聚合统计信息，基于该聚合统计找到在 proposal 间的最优解。\n- Global：学习每棵树前，提出候选切分点；\n- Local：每次分裂前，重新提出候选切分点；\n![](xgboost/xgboost-5a61a64a.png)\n - 第一个for循环做的工作：对特征 $K$ 根据该特征分布的分位数找到切割点的候选集合 $S_k = \\{s_{k1}, s_{k2}, ... ,s_{kl} \\}$；这样做的目的是提取出部分的切分点不用遍历所有的切分点。其中获取某个特征K的候选切割点的方式叫proposal。主要有两种proposal方式：global proposal和local proposal。\n - 第二个for循环的工作：将每个特征的取值映射到由这些该特征对应的候选点集划分的分桶(buckets)区间 $\\{s_{k,v}≥x_{jk}>s_{k,v−1}\\}$ 中，对每个桶（区间）内的样本统计值 $G,H$ 进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。这样做的主要目的是获取每个特征的候选分割点的 $G,H$ 量。\n\n#### 近似算法举例\n![](xgboost/xgboost-994eafca.png)\n\n\n# xgboost与GBDT的区别\n1. Xgboost是GB算法的高效实现，xgboost中的基学习器除了可以是CART（gbtree）也可以是线性分类器（gblinear）。\n1. 传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。\n1. 传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。\n1. xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子结点个数、每个叶子结点上输出的score的L2模的平方和\n1. 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。\n1. 支持并行化处理。xgboost的并行是在特征粒度上的，在训练之前，预先对特征进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行结点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。\n1. 可以处理稀疏、缺失数据(结点分裂算法能自动利用特征的稀疏性),可以学习出它的分裂方向，加快稀疏计算速度。\n","source":"_posts/xgboost.md","raw":"---\ntitle: xgboost\ndate: 2018-08-13 11:11:19\ntags: [人工智能,模型,树模型,集成学习]\ncategories: 机器学习\n---\n\n# [简介](https://yxzf.github.io/2017/03/xgboost-v1/)\n下图就是CART树和一堆CART树的示例，用来判断一个人是否会喜欢计算机游戏\n\n\n![](xgboost/h-18fe29f8.png)\n\n<!-- more -->\n![](xgboost/h-597ed097.png)\n\n## 算法\n![](xgboost/xgboost-634b5dbd.png)\n\n# 模型\n我们希望训练出 $K$ 颗树，将它们集成起来从而预测我们的$y$。我们可以用以下公式表示：\n$$\\hat{y}=\\sum_{k=1}^Kf_k(x_i)\\\\\nf(x)=w_{q(x)}$$\n在这里，我们用一个函数 $f_k(x)$ 来表示一颗决策树，那个函数 $f$ 可以理解为将样本x映射到树的某个叶子结点中，树中的每个叶子结点都会对应着一个权重$w$。\n![](xgboost/xgboost-b2122f64.png)\n如图，这就是提升树的一个例子，这里一共有两颗树，意味着我们有两个函数 $f_1,f_2，K=2$ ，然后将样本分别放到我们的两颗树中，就可以计算出两个值，把它加起来就是我们要预测的y\n\n# 目标函数\n\n$K$ 表示有 $K$ 棵树，$f_k$ 相当于第 $k$ 棵。因此我们的目标函数可以写成\n$$Obj=\\sum_il(\\hat{y_i},y)+\\sum_k\\Omega(f_k)\\\\\nwhere\\ \\Omega(f)=\\gamma T+\\frac{1}{2}\\lambda||w||^2$$\n其中 $l$ 是可导且凸的**损失函数**，用来衡量 $\\hat{y}$ 与 $y$ 的相近程度，第二项 $Ω$ 则是**正则项**，它包含了两个部分，第一个是 $γT$，这里的 $T$ 表示**叶子结点的数量**，$γ$ 是超参，也就是说如果 $γ$ 越大，那么我们的叶子结点数量就会越小。另外一部分则是L2正则项，通过对叶子结点的权重进行惩罚，使得不会存在权重过大的叶子结点防止过拟合。$w$ 就表示叶子结点的权重。\n\n\n\n# 梯度提升\n假设第 $t$ 轮的预测值为$y^{(t)}$ ，第 $t$ 颗回归树为 $f_t(x)$。则模型迭代如下:\n$$\\begin{align}\\hat y_i^{(0)} &= 0 \\\\  y_i^{(0)} & = f_1(x_i)= \\hat y_i^{(0)}+f_1(x_i) \\\\  y_i^{(2)}&=f_1(x_i)+f_2(x_i)= \\hat y_i^{(1)}+f_2(x_i) \\\\ &\\cdots \\\\ y_i^{(t)}&=\\sum_{k=1}^tf_k(x_i)= \\hat y_i^{(t-1)}+f_t(x_i) \\end{align}$$\n\n但是对于上面这么一个目标函数，我们是很难进行优化的，于是我们将它变换一下，我们通过每一步增加一个基分类器 $f_t(x)$ ，贪婪地去优化这个目标函数，使得每次增加 $f_t(x)$，都使得loss变小。如此一来，我们就得到了一个可以用于评价当前分类器 $f_t(x)$ 性能的一个评价函数：\n$$\\begin{align*}\nObj^{(t)}&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t)})+ \\sum_{i=1}^t\\Omega(f_t) \\\\\n&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t-1)}+f_t(x_i))+\\Omega(f_t) + constant\n\\end{align*}$$\n选取一个 $f_t(x)$来使得我们的目标函数尽量最大地降低。$constant$就是前 $t-1$ 棵树的复杂度\n\n\n\n**泰勒展开**\n\n![](xgboost/h-a1fde941.png)\n\n因为 $l(y_i,\\hat y_i^{(t-1)})$ 是常数字所以最优化可以化简为下式子\n\n$$ \\begin{align*}\nObj^{(t)} &=\\sum_{i=1}^n [ g_if_t(x_i)+\\frac 1 2 h_if_t^2(x_i)] + \\Omega (f_t) \\\\\n&=\\sum_{i=1}^n [ g_iw_q(x_i)+\\frac 1 2 h_iw_q^2(x_i)] + \\gamma T + \\lambda \\frac{1}{2}\\sum _{j=1}^Tw_j^2\\\\\n&= \\sum_{j=1}^T [( \\sum_{i \\in I_j} g_i)w_j+\\frac 1 2(\\sum_{i \\in I_j} h_i + \\lambda)w_j^2] + \\gamma T \\\\\n&= \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T\n\\end{align*} $$\n\n$j$为叶子结点的序号，$T$ 为叶子结点的总数 ；$i$ 为样本的序号，$n$ 为样本的总数；$w_q(x_i)$是求取$x_i$权值的对应函数；$\\sum_{i \\in I_j} g_i$ 为同一叶子结点的 $g_i$ 的和；$\\sum_{i \\in I_j} g_i w_j$ 为同一结点的 $g_i w_j$ ;$\\sum_{j=1}^T \\sum_{i \\in I_j} = \\sum_{i=1}^n$。其中\n\n$$g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad  h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\\nG_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i$$\n\n# 求取基模型$f_t(x)$-叶子结点权值$w$\n** $f_t(x_i)$ 是什么？它其实就是 $f_t$ 的某个叶子结点的值 $w$ 。之前我们提到过，叶子结点的值是可以作为模型的参数**\n$$Obj^{(t)}  = \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T$$\n\n令$\\frac{\\partial Obj^{(t)}}{\\partial w}=0$ 得到\n$$w_j^* = - \\frac {G_j} {H_j + \\lambda}$$\n带入上式得到\n$$Obj^{(t)} = - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T$$\n\n# 划分点\n$$\\begin{align}\n    Obj_{split} &= - \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda}] + \\gamma T_{split} \\\\\n    Obj_{noSplit} &=  - \\frac 1 2 \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda} + \\gamma T_{noSplit} \\\\\n    Gain &= Obj_{noSplit} - Obj_{split} \\\\\n         &= \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma(T_{split} - T_{nosplit}) \\\\\n         &=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma\n\\end{align}$$\n因为是二分类，二叉树所以$T_{split} - T_{nosplit} = 1$，**$Gain$越大越好**\n\n\n\n# 总结\n## 目标函数与叶子结点权值\n$$w_j^* = - \\frac {G_j} {H_j + \\lambda}$$\n\n$$Obj= - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T$$\n\n其中\n$$g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\ G_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i$$\n\n## 打分函数示例\nObj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)\n![](xgboost/xgboost-5847b944.png)\n\n## 分裂结点\n论文中给出了两种分裂结点的方法，贪心算法遍历所有分割点进行划分挑选增益最大的切分点。近似算法:对于数据量大的情况下进行近似算法\n### 贪心法：\n直观的方法是枚举所有的树结构，并根据上面数structure score来打分，找出最优的那棵树加入模型中，再不断重复。但暴力枚举根本不可行，所以类似于一般决策树的构建，XGBoost也是采用贪心算法，**每一次尝试去对已有的叶子加入一个分割。对于一个具体的分割方案，增益计算如下**：\n\n$$Gain=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma$$\n\n对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有 $x < a$ 这样的条件，对于某个特定的分割 $a$ 我们要计算 $a$ 左边和右边的导数和。对于所有的 $a$，首先根据需要划分的那列特征值排序，然后从左到右的扫描就可以枚举出所有分割的梯度和$G_L$和$G_R$，再用上面的公式计算每个分割方案的分数就可以了。\n![](xgboost/xgboost-b691aaff.png)\n观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic（启发式）而进行的操作了。\n\n#### 算法说明\n上面是针对一个特征，如果有m个特征，需要对所有参数都采取一样的操作，然后找到最好的那个特征所对应的划分。\n![](xgboost/xgboost-3eee29c4.png)\n\n### [近似算法](https://zhuanlan.zhihu.com/p/38297689)\nXGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。\n该算法会首先根据**特征分布的百分位数** (percentiles of feature distribution)，提出候选划分点 (candidate splitting points)。接着，该算法将连续型特征映射到由这些候选点划分的分桶(buckets) 中，聚合统计信息，基于该聚合统计找到在 proposal 间的最优解。\n- Global：学习每棵树前，提出候选切分点；\n- Local：每次分裂前，重新提出候选切分点；\n![](xgboost/xgboost-5a61a64a.png)\n - 第一个for循环做的工作：对特征 $K$ 根据该特征分布的分位数找到切割点的候选集合 $S_k = \\{s_{k1}, s_{k2}, ... ,s_{kl} \\}$；这样做的目的是提取出部分的切分点不用遍历所有的切分点。其中获取某个特征K的候选切割点的方式叫proposal。主要有两种proposal方式：global proposal和local proposal。\n - 第二个for循环的工作：将每个特征的取值映射到由这些该特征对应的候选点集划分的分桶(buckets)区间 $\\{s_{k,v}≥x_{jk}>s_{k,v−1}\\}$ 中，对每个桶（区间）内的样本统计值 $G,H$ 进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。这样做的主要目的是获取每个特征的候选分割点的 $G,H$ 量。\n\n#### 近似算法举例\n![](xgboost/xgboost-994eafca.png)\n\n\n# xgboost与GBDT的区别\n1. Xgboost是GB算法的高效实现，xgboost中的基学习器除了可以是CART（gbtree）也可以是线性分类器（gblinear）。\n1. 传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。\n1. 传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。\n1. xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子结点个数、每个叶子结点上输出的score的L2模的平方和\n1. 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。\n1. 支持并行化处理。xgboost的并行是在特征粒度上的，在训练之前，预先对特征进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行结点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。\n1. 可以处理稀疏、缺失数据(结点分裂算法能自动利用特征的稀疏性),可以学习出它的分裂方向，加快稀疏计算速度。\n","slug":"xgboost","published":1,"updated":"2019-07-30T01:54:38.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izi003ihomj8gl3p9qq","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"https://yxzf.github.io/2017/03/xgboost-v1/\" target=\"_blank\" rel=\"noopener\">简介</a></h1><p>下图就是CART树和一堆CART树的示例，用来判断一个人是否会喜欢计算机游戏</p>\n<p><img src=\"/2018/08/13/xgboost/h-18fe29f8.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p><img src=\"/2018/08/13/xgboost/h-597ed097.png\" alt=\"\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><img src=\"/2018/08/13/xgboost/xgboost-634b5dbd.png\" alt=\"\"></p>\n<h1 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h1><p>我们希望训练出 $K$ 颗树，将它们集成起来从而预测我们的$y$。我们可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\\hat{y}=\\sum_{k=1}^Kf_k(x_i)\\\\\nf(x)=w_{q(x)}</script><p>在这里，我们用一个函数 $f_k(x)$ 来表示一颗决策树，那个函数 $f$ 可以理解为将样本x映射到树的某个叶子结点中，树中的每个叶子结点都会对应着一个权重$w$。<br><img src=\"/2018/08/13/xgboost/xgboost-b2122f64.png\" alt=\"\"><br>如图，这就是提升树的一个例子，这里一共有两颗树，意味着我们有两个函数 $f_1,f_2，K=2$ ，然后将样本分别放到我们的两颗树中，就可以计算出两个值，把它加起来就是我们要预测的y</p>\n<h1 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h1><p>$K$ 表示有 $K$ 棵树，$f_k$ 相当于第 $k$ 棵。因此我们的目标函数可以写成</p>\n<script type=\"math/tex; mode=display\">Obj=\\sum_il(\\hat{y_i},y)+\\sum_k\\Omega(f_k)\\\\\nwhere\\ \\Omega(f)=\\gamma T+\\frac{1}{2}\\lambda||w||^2</script><p>其中 $l$ 是可导且凸的<strong>损失函数</strong>，用来衡量 $\\hat{y}$ 与 $y$ 的相近程度，第二项 $Ω$ 则是<strong>正则项</strong>，它包含了两个部分，第一个是 $γT$，这里的 $T$ 表示<strong>叶子结点的数量</strong>，$γ$ 是超参，也就是说如果 $γ$ 越大，那么我们的叶子结点数量就会越小。另外一部分则是L2正则项，通过对叶子结点的权重进行惩罚，使得不会存在权重过大的叶子结点防止过拟合。$w$ 就表示叶子结点的权重。</p>\n<h1 id=\"梯度提升\"><a href=\"#梯度提升\" class=\"headerlink\" title=\"梯度提升\"></a>梯度提升</h1><p>假设第 $t$ 轮的预测值为$y^{(t)}$ ，第 $t$ 颗回归树为 $f_t(x)$。则模型迭代如下:</p>\n<script type=\"math/tex; mode=display\">\\begin{align}\\hat y_i^{(0)} &= 0 \\\\  y_i^{(0)} & = f_1(x_i)= \\hat y_i^{(0)}+f_1(x_i) \\\\  y_i^{(2)}&=f_1(x_i)+f_2(x_i)= \\hat y_i^{(1)}+f_2(x_i) \\\\ &\\cdots \\\\ y_i^{(t)}&=\\sum_{k=1}^tf_k(x_i)= \\hat y_i^{(t-1)}+f_t(x_i) \\end{align}</script><p>但是对于上面这么一个目标函数，我们是很难进行优化的，于是我们将它变换一下，我们通过每一步增加一个基分类器 $f_t(x)$ ，贪婪地去优化这个目标函数，使得每次增加 $f_t(x)$，都使得loss变小。如此一来，我们就得到了一个可以用于评价当前分类器 $f_t(x)$ 性能的一个评价函数：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nObj^{(t)}&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t)})+ \\sum_{i=1}^t\\Omega(f_t) \\\\\n&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t-1)}+f_t(x_i))+\\Omega(f_t) + constant\n\\end{align*}</script><p>选取一个 $f_t(x)$来使得我们的目标函数尽量最大地降低。$constant$就是前 $t-1$ 棵树的复杂度</p>\n<p><strong>泰勒展开</strong></p>\n<p><img src=\"/2018/08/13/xgboost/h-a1fde941.png\" alt=\"\"></p>\n<p>因为 $l(y_i,\\hat y_i^{(t-1)})$ 是常数字所以最优化可以化简为下式子</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nObj^{(t)} &=\\sum_{i=1}^n [ g_if_t(x_i)+\\frac 1 2 h_if_t^2(x_i)] + \\Omega (f_t) \\\\\n&=\\sum_{i=1}^n [ g_iw_q(x_i)+\\frac 1 2 h_iw_q^2(x_i)] + \\gamma T + \\lambda \\frac{1}{2}\\sum _{j=1}^Tw_j^2\\\\\n&= \\sum_{j=1}^T [( \\sum_{i \\in I_j} g_i)w_j+\\frac 1 2(\\sum_{i \\in I_j} h_i + \\lambda)w_j^2] + \\gamma T \\\\\n&= \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T\n\\end{align*}</script><p>$j$为叶子结点的序号，$T$ 为叶子结点的总数 ；$i$ 为样本的序号，$n$ 为样本的总数；$w_q(x_i)$是求取$x_i$权值的对应函数；$\\sum_{i \\in I_j} g_i$ 为同一叶子结点的 $g_i$ 的和；$\\sum_{i \\in I_j} g_i w_j$ 为同一结点的 $g_i w_j$ ;$\\sum_{j=1}^T \\sum_{i \\in I_j} = \\sum_{i=1}^n$。其中</p>\n<script type=\"math/tex; mode=display\">g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad  h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\\nG_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i</script><h1 id=\"求取基模型-f-t-x-叶子结点权值-w\"><a href=\"#求取基模型-f-t-x-叶子结点权值-w\" class=\"headerlink\" title=\"求取基模型$f_t(x)$-叶子结点权值$w$\"></a>求取基模型$f_t(x)$-叶子结点权值$w$</h1><p><strong> $f_t(x_i)$ 是什么？它其实就是 $f_t$ 的某个叶子结点的值 $w$ 。之前我们提到过，叶子结点的值是可以作为模型的参数</strong></p>\n<script type=\"math/tex; mode=display\">Obj^{(t)}  = \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T</script><p>令$\\frac{\\partial Obj^{(t)}}{\\partial w}=0$ 得到</p>\n<script type=\"math/tex; mode=display\">w_j^* = - \\frac {G_j} {H_j + \\lambda}</script><p>带入上式得到</p>\n<script type=\"math/tex; mode=display\">Obj^{(t)} = - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T</script><h1 id=\"划分点\"><a href=\"#划分点\" class=\"headerlink\" title=\"划分点\"></a>划分点</h1><script type=\"math/tex; mode=display\">\\begin{align}\n    Obj_{split} &= - \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda}] + \\gamma T_{split} \\\\\n    Obj_{noSplit} &=  - \\frac 1 2 \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda} + \\gamma T_{noSplit} \\\\\n    Gain &= Obj_{noSplit} - Obj_{split} \\\\\n         &= \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma(T_{split} - T_{nosplit}) \\\\\n         &=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma\n\\end{align}</script><p>因为是二分类，二叉树所以$T_{split} - T_{nosplit} = 1$，<strong>$Gain$越大越好</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"目标函数与叶子结点权值\"><a href=\"#目标函数与叶子结点权值\" class=\"headerlink\" title=\"目标函数与叶子结点权值\"></a>目标函数与叶子结点权值</h2><script type=\"math/tex; mode=display\">w_j^* = - \\frac {G_j} {H_j + \\lambda}</script><script type=\"math/tex; mode=display\">Obj= - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T</script><p>其中</p>\n<script type=\"math/tex; mode=display\">g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\ G_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i</script><h2 id=\"打分函数示例\"><a href=\"#打分函数示例\" class=\"headerlink\" title=\"打分函数示例\"></a>打分函数示例</h2><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)<br><img src=\"/2018/08/13/xgboost/xgboost-5847b944.png\" alt=\"\"></p>\n<h2 id=\"分裂结点\"><a href=\"#分裂结点\" class=\"headerlink\" title=\"分裂结点\"></a>分裂结点</h2><p>论文中给出了两种分裂结点的方法，贪心算法遍历所有分割点进行划分挑选增益最大的切分点。近似算法:对于数据量大的情况下进行近似算法</p>\n<h3 id=\"贪心法：\"><a href=\"#贪心法：\" class=\"headerlink\" title=\"贪心法：\"></a>贪心法：</h3><p>直观的方法是枚举所有的树结构，并根据上面数structure score来打分，找出最优的那棵树加入模型中，再不断重复。但暴力枚举根本不可行，所以类似于一般决策树的构建，XGBoost也是采用贪心算法，<strong>每一次尝试去对已有的叶子加入一个分割。对于一个具体的分割方案，增益计算如下</strong>：</p>\n<script type=\"math/tex; mode=display\">Gain=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma</script><p>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有 $x &lt; a$ 这样的条件，对于某个特定的分割 $a$ 我们要计算 $a$ 左边和右边的导数和。对于所有的 $a$，首先根据需要划分的那列特征值排序，然后从左到右的扫描就可以枚举出所有分割的梯度和$G_L$和$G_R$，再用上面的公式计算每个分割方案的分数就可以了。<br><img src=\"/2018/08/13/xgboost/xgboost-b691aaff.png\" alt=\"\"><br>观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic（启发式）而进行的操作了。</p>\n<h4 id=\"算法说明\"><a href=\"#算法说明\" class=\"headerlink\" title=\"算法说明\"></a>算法说明</h4><p>上面是针对一个特征，如果有m个特征，需要对所有参数都采取一样的操作，然后找到最好的那个特征所对应的划分。<br><img src=\"/2018/08/13/xgboost/xgboost-3eee29c4.png\" alt=\"\"></p>\n<h3 id=\"近似算法\"><a href=\"#近似算法\" class=\"headerlink\" title=\"近似算法\"></a><a href=\"https://zhuanlan.zhihu.com/p/38297689\" target=\"_blank\" rel=\"noopener\">近似算法</a></h3><p>XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。<br>该算法会首先根据<strong>特征分布的百分位数</strong> (percentiles of feature distribution)，提出候选划分点 (candidate splitting points)。接着，该算法将连续型特征映射到由这些候选点划分的分桶(buckets) 中，聚合统计信息，基于该聚合统计找到在 proposal 间的最优解。</p>\n<ul>\n<li>Global：学习每棵树前，提出候选切分点；</li>\n<li>Local：每次分裂前，重新提出候选切分点；<br><img src=\"/2018/08/13/xgboost/xgboost-5a61a64a.png\" alt=\"\"><ul>\n<li>第一个for循环做的工作：对特征 $K$ 根据该特征分布的分位数找到切割点的候选集合 $S_k = \\{s_{k1}, s_{k2}, … ,s_{kl} \\}$；这样做的目的是提取出部分的切分点不用遍历所有的切分点。其中获取某个特征K的候选切割点的方式叫proposal。主要有两种proposal方式：global proposal和local proposal。</li>\n<li>第二个for循环的工作：将每个特征的取值映射到由这些该特征对应的候选点集划分的分桶(buckets)区间 $\\{s_{k,v}≥x_{jk}&gt;s_{k,v−1}\\}$ 中，对每个桶（区间）内的样本统计值 $G,H$ 进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。这样做的主要目的是获取每个特征的候选分割点的 $G,H$ 量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"近似算法举例\"><a href=\"#近似算法举例\" class=\"headerlink\" title=\"近似算法举例\"></a>近似算法举例</h4><p><img src=\"/2018/08/13/xgboost/xgboost-994eafca.png\" alt=\"\"></p>\n<h1 id=\"xgboost与GBDT的区别\"><a href=\"#xgboost与GBDT的区别\" class=\"headerlink\" title=\"xgboost与GBDT的区别\"></a>xgboost与GBDT的区别</h1><ol>\n<li>Xgboost是GB算法的高效实现，xgboost中的基学习器除了可以是CART（gbtree）也可以是线性分类器（gblinear）。</li>\n<li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li>\n<li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li>\n<li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子结点个数、每个叶子结点上输出的score的L2模的平方和</li>\n<li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li>\n<li>支持并行化处理。xgboost的并行是在特征粒度上的，在训练之前，预先对特征进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行结点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。</li>\n<li>可以处理稀疏、缺失数据(结点分裂算法能自动利用特征的稀疏性),可以学习出它的分裂方向，加快稀疏计算速度。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"https://yxzf.github.io/2017/03/xgboost-v1/\" target=\"_blank\" rel=\"noopener\">简介</a></h1><p>下图就是CART树和一堆CART树的示例，用来判断一个人是否会喜欢计算机游戏</p>\n<p><img src=\"/2018/08/13/xgboost/h-18fe29f8.png\" alt=\"\"></p>","more":"<p><img src=\"/2018/08/13/xgboost/h-597ed097.png\" alt=\"\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><img src=\"/2018/08/13/xgboost/xgboost-634b5dbd.png\" alt=\"\"></p>\n<h1 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h1><p>我们希望训练出 $K$ 颗树，将它们集成起来从而预测我们的$y$。我们可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\\hat{y}=\\sum_{k=1}^Kf_k(x_i)\\\\\nf(x)=w_{q(x)}</script><p>在这里，我们用一个函数 $f_k(x)$ 来表示一颗决策树，那个函数 $f$ 可以理解为将样本x映射到树的某个叶子结点中，树中的每个叶子结点都会对应着一个权重$w$。<br><img src=\"/2018/08/13/xgboost/xgboost-b2122f64.png\" alt=\"\"><br>如图，这就是提升树的一个例子，这里一共有两颗树，意味着我们有两个函数 $f_1,f_2，K=2$ ，然后将样本分别放到我们的两颗树中，就可以计算出两个值，把它加起来就是我们要预测的y</p>\n<h1 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h1><p>$K$ 表示有 $K$ 棵树，$f_k$ 相当于第 $k$ 棵。因此我们的目标函数可以写成</p>\n<script type=\"math/tex; mode=display\">Obj=\\sum_il(\\hat{y_i},y)+\\sum_k\\Omega(f_k)\\\\\nwhere\\ \\Omega(f)=\\gamma T+\\frac{1}{2}\\lambda||w||^2</script><p>其中 $l$ 是可导且凸的<strong>损失函数</strong>，用来衡量 $\\hat{y}$ 与 $y$ 的相近程度，第二项 $Ω$ 则是<strong>正则项</strong>，它包含了两个部分，第一个是 $γT$，这里的 $T$ 表示<strong>叶子结点的数量</strong>，$γ$ 是超参，也就是说如果 $γ$ 越大，那么我们的叶子结点数量就会越小。另外一部分则是L2正则项，通过对叶子结点的权重进行惩罚，使得不会存在权重过大的叶子结点防止过拟合。$w$ 就表示叶子结点的权重。</p>\n<h1 id=\"梯度提升\"><a href=\"#梯度提升\" class=\"headerlink\" title=\"梯度提升\"></a>梯度提升</h1><p>假设第 $t$ 轮的预测值为$y^{(t)}$ ，第 $t$ 颗回归树为 $f_t(x)$。则模型迭代如下:</p>\n<script type=\"math/tex; mode=display\">\\begin{align}\\hat y_i^{(0)} &= 0 \\\\  y_i^{(0)} & = f_1(x_i)= \\hat y_i^{(0)}+f_1(x_i) \\\\  y_i^{(2)}&=f_1(x_i)+f_2(x_i)= \\hat y_i^{(1)}+f_2(x_i) \\\\ &\\cdots \\\\ y_i^{(t)}&=\\sum_{k=1}^tf_k(x_i)= \\hat y_i^{(t-1)}+f_t(x_i) \\end{align}</script><p>但是对于上面这么一个目标函数，我们是很难进行优化的，于是我们将它变换一下，我们通过每一步增加一个基分类器 $f_t(x)$ ，贪婪地去优化这个目标函数，使得每次增加 $f_t(x)$，都使得loss变小。如此一来，我们就得到了一个可以用于评价当前分类器 $f_t(x)$ 性能的一个评价函数：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nObj^{(t)}&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t)})+ \\sum_{i=1}^t\\Omega(f_t) \\\\\n&=\\sum_{i=1}^nl(y_i,\\hat{y_i}^{(t-1)}+f_t(x_i))+\\Omega(f_t) + constant\n\\end{align*}</script><p>选取一个 $f_t(x)$来使得我们的目标函数尽量最大地降低。$constant$就是前 $t-1$ 棵树的复杂度</p>\n<p><strong>泰勒展开</strong></p>\n<p><img src=\"/2018/08/13/xgboost/h-a1fde941.png\" alt=\"\"></p>\n<p>因为 $l(y_i,\\hat y_i^{(t-1)})$ 是常数字所以最优化可以化简为下式子</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nObj^{(t)} &=\\sum_{i=1}^n [ g_if_t(x_i)+\\frac 1 2 h_if_t^2(x_i)] + \\Omega (f_t) \\\\\n&=\\sum_{i=1}^n [ g_iw_q(x_i)+\\frac 1 2 h_iw_q^2(x_i)] + \\gamma T + \\lambda \\frac{1}{2}\\sum _{j=1}^Tw_j^2\\\\\n&= \\sum_{j=1}^T [( \\sum_{i \\in I_j} g_i)w_j+\\frac 1 2(\\sum_{i \\in I_j} h_i + \\lambda)w_j^2] + \\gamma T \\\\\n&= \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T\n\\end{align*}</script><p>$j$为叶子结点的序号，$T$ 为叶子结点的总数 ；$i$ 为样本的序号，$n$ 为样本的总数；$w_q(x_i)$是求取$x_i$权值的对应函数；$\\sum_{i \\in I_j} g_i$ 为同一叶子结点的 $g_i$ 的和；$\\sum_{i \\in I_j} g_i w_j$ 为同一结点的 $g_i w_j$ ;$\\sum_{j=1}^T \\sum_{i \\in I_j} = \\sum_{i=1}^n$。其中</p>\n<script type=\"math/tex; mode=display\">g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad  h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\\nG_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i</script><h1 id=\"求取基模型-f-t-x-叶子结点权值-w\"><a href=\"#求取基模型-f-t-x-叶子结点权值-w\" class=\"headerlink\" title=\"求取基模型$f_t(x)$-叶子结点权值$w$\"></a>求取基模型$f_t(x)$-叶子结点权值$w$</h1><p><strong> $f_t(x_i)$ 是什么？它其实就是 $f_t$ 的某个叶子结点的值 $w$ 。之前我们提到过，叶子结点的值是可以作为模型的参数</strong></p>\n<script type=\"math/tex; mode=display\">Obj^{(t)}  = \\sum_{j=1}^T [G_j w_j + \\frac 1 2 (H_j + \\lambda) w_j^2] + \\gamma T</script><p>令$\\frac{\\partial Obj^{(t)}}{\\partial w}=0$ 得到</p>\n<script type=\"math/tex; mode=display\">w_j^* = - \\frac {G_j} {H_j + \\lambda}</script><p>带入上式得到</p>\n<script type=\"math/tex; mode=display\">Obj^{(t)} = - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T</script><h1 id=\"划分点\"><a href=\"#划分点\" class=\"headerlink\" title=\"划分点\"></a>划分点</h1><script type=\"math/tex; mode=display\">\\begin{align}\n    Obj_{split} &= - \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda}] + \\gamma T_{split} \\\\\n    Obj_{noSplit} &=  - \\frac 1 2 \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda} + \\gamma T_{noSplit} \\\\\n    Gain &= Obj_{noSplit} - Obj_{split} \\\\\n         &= \\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma(T_{split} - T_{nosplit}) \\\\\n         &=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma\n\\end{align}</script><p>因为是二分类，二叉树所以$T_{split} - T_{nosplit} = 1$，<strong>$Gain$越大越好</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"目标函数与叶子结点权值\"><a href=\"#目标函数与叶子结点权值\" class=\"headerlink\" title=\"目标函数与叶子结点权值\"></a>目标函数与叶子结点权值</h2><script type=\"math/tex; mode=display\">w_j^* = - \\frac {G_j} {H_j + \\lambda}</script><script type=\"math/tex; mode=display\">Obj= - \\frac 1 2 \\sum_{j=1}^T \\frac {G_j^2} {H_j + \\lambda} + \\gamma T</script><p>其中</p>\n<script type=\"math/tex; mode=display\">g_i=\\frac{\\partial l(y_i,\\hat{y_i}^{(t-1)})}{\\partial \\hat{y_i}^{(t-1)}} \\quad h_i=\\frac{\\partial ^2l(y_i,\\hat{y_i}^{(t-1)})}{\\partial ^2\\hat{y_i}^{(t-1)}} \\\\ G_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i</script><h2 id=\"打分函数示例\"><a href=\"#打分函数示例\" class=\"headerlink\" title=\"打分函数示例\"></a>打分函数示例</h2><p>Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少。我们可以把它叫做结构分数(structure score)<br><img src=\"/2018/08/13/xgboost/xgboost-5847b944.png\" alt=\"\"></p>\n<h2 id=\"分裂结点\"><a href=\"#分裂结点\" class=\"headerlink\" title=\"分裂结点\"></a>分裂结点</h2><p>论文中给出了两种分裂结点的方法，贪心算法遍历所有分割点进行划分挑选增益最大的切分点。近似算法:对于数据量大的情况下进行近似算法</p>\n<h3 id=\"贪心法：\"><a href=\"#贪心法：\" class=\"headerlink\" title=\"贪心法：\"></a>贪心法：</h3><p>直观的方法是枚举所有的树结构，并根据上面数structure score来打分，找出最优的那棵树加入模型中，再不断重复。但暴力枚举根本不可行，所以类似于一般决策树的构建，XGBoost也是采用贪心算法，<strong>每一次尝试去对已有的叶子加入一个分割。对于一个具体的分割方案，增益计算如下</strong>：</p>\n<script type=\"math/tex; mode=display\">Gain=\\frac 1 2 [\\frac {G_L^2}{H_L + \\lambda} + \\frac {G_R^2}{H_R + \\lambda} - \\frac {(G_L + G_R)^2}{H_L + H_R + \\lambda}] - \\gamma</script><p>对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有 $x &lt; a$ 这样的条件，对于某个特定的分割 $a$ 我们要计算 $a$ 左边和右边的导数和。对于所有的 $a$，首先根据需要划分的那列特征值排序，然后从左到右的扫描就可以枚举出所有分割的梯度和$G_L$和$G_R$，再用上面的公式计算每个分割方案的分数就可以了。<br><img src=\"/2018/08/13/xgboost/xgboost-b691aaff.png\" alt=\"\"><br>观察这个目标函数，大家会发现第二个值得注意的事情就是引入分割不一定会使得情况变好，因为我们有一个引入新叶子的惩罚项。优化这个目标对应了树的剪枝， 当引入的分割带来的增益小于一个阀值的时候，我们可以剪掉这个分割。大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为heuristic（启发式）而进行的操作了。</p>\n<h4 id=\"算法说明\"><a href=\"#算法说明\" class=\"headerlink\" title=\"算法说明\"></a>算法说明</h4><p>上面是针对一个特征，如果有m个特征，需要对所有参数都采取一样的操作，然后找到最好的那个特征所对应的划分。<br><img src=\"/2018/08/13/xgboost/xgboost-3eee29c4.png\" alt=\"\"></p>\n<h3 id=\"近似算法\"><a href=\"#近似算法\" class=\"headerlink\" title=\"近似算法\"></a><a href=\"https://zhuanlan.zhihu.com/p/38297689\" target=\"_blank\" rel=\"noopener\">近似算法</a></h3><p>XGBoost使用exact greedy算法来寻找分割点建树，但是当数据量非常大难以被全部加载进内存时或者分布式环境下时，exact greedy算法将不再合适。因此作者提出近似算法来寻找分割点。近似算法的大致流程见下面的算法。<br>该算法会首先根据<strong>特征分布的百分位数</strong> (percentiles of feature distribution)，提出候选划分点 (candidate splitting points)。接着，该算法将连续型特征映射到由这些候选点划分的分桶(buckets) 中，聚合统计信息，基于该聚合统计找到在 proposal 间的最优解。</p>\n<ul>\n<li>Global：学习每棵树前，提出候选切分点；</li>\n<li>Local：每次分裂前，重新提出候选切分点；<br><img src=\"/2018/08/13/xgboost/xgboost-5a61a64a.png\" alt=\"\"><ul>\n<li>第一个for循环做的工作：对特征 $K$ 根据该特征分布的分位数找到切割点的候选集合 $S_k = \\{s_{k1}, s_{k2}, … ,s_{kl} \\}$；这样做的目的是提取出部分的切分点不用遍历所有的切分点。其中获取某个特征K的候选切割点的方式叫proposal。主要有两种proposal方式：global proposal和local proposal。</li>\n<li>第二个for循环的工作：将每个特征的取值映射到由这些该特征对应的候选点集划分的分桶(buckets)区间 $\\{s_{k,v}≥x_{jk}&gt;s_{k,v−1}\\}$ 中，对每个桶（区间）内的样本统计值 $G,H$ 进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。这样做的主要目的是获取每个特征的候选分割点的 $G,H$ 量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"近似算法举例\"><a href=\"#近似算法举例\" class=\"headerlink\" title=\"近似算法举例\"></a>近似算法举例</h4><p><img src=\"/2018/08/13/xgboost/xgboost-994eafca.png\" alt=\"\"></p>\n<h1 id=\"xgboost与GBDT的区别\"><a href=\"#xgboost与GBDT的区别\" class=\"headerlink\" title=\"xgboost与GBDT的区别\"></a>xgboost与GBDT的区别</h1><ol>\n<li>Xgboost是GB算法的高效实现，xgboost中的基学习器除了可以是CART（gbtree）也可以是线性分类器（gblinear）。</li>\n<li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li>\n<li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li>\n<li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子结点个数、每个叶子结点上输出的score的L2模的平方和</li>\n<li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li>\n<li>支持并行化处理。xgboost的并行是在特征粒度上的，在训练之前，预先对特征进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。在进行结点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行，即在不同的特征属性上采用多线程并行方式寻找最佳分割点。</li>\n<li>可以处理稀疏、缺失数据(结点分裂算法能自动利用特征的稀疏性),可以学习出它的分裂方向，加快稀疏计算速度。</li>\n</ol>"},{"title":"一维随机变量","date":"2017-08-15T14:23:46.000Z","_content":"\n本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。\n<!--more-->\n\n# 离散型随机变量的分布\n## 伯努利分布\n伯努利分布又名**两点分布**或者**0-1分布**，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为\n$$P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)$$\n如果试验E只有两种结果，则称试验E为**伯努利试验**。如果独立的进行 n 次试验E，则称为**n重伯努利试验**。\n\n## 二项分布\n以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：\n\n$$P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n$$\n其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。\n\n## 泊松分布\n随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为\n\n$$P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….$$\n则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$\n其分布规律通过图像直观表示为\n\n![](一维随机变量/一维随机变量-42feaec2.png)\n\n泊松分布适合于描述**单位时间内随机事件发生的次数的概率分布**。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。\n\n下面介绍用**泊松分布来逼近二项分布的定理，也就是泊松定理**。\n\n泊松定理：设 $λ>0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有\n$$\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}$$\n即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。\n\n# 连续型随机变量的分布\n## 分布函数和概率密度函数\n首先需要清楚，**分布函数是针对随机变量的，离散或连续都可以；而概率密度函数是针对连续随机变量的。**下面是这两者的定义以及联系\n\n**分布函数的定义**如下：\n\n$X$ 是一个随机变量，$x$ 是任意实数，则 $X$ 的分布函数定义为\n\n$$F(x)=P(X≤x),(−∞<x<∞)$$\n\n则对于任意实数 $x_1,x_2(x_1 < x_2)$,有\n\n$$P(x_1 < X \\le x_2) = p(X \\le x_2) - p(X \\le x_1) = F(x_2) - F(x_1)$$\n即如果我们知道了 $X$ 的分布函数，则可以知道 $X$ 落在任一区间上的概率，也就是说通过分布函数可以完整描述随机变量的统计规律特性。\n\n概率密度函数定义如下：\n\n对于分布函数 $F(X)$，假如存在 $f(x)$ 使得以下公式成立：\n\n$$F(x) = \\int_{-\\infty}^x f(t) dt$$\n则 X 为连续型随机变量，f(x)为随机变量的概率密度函数。$f(x)$ 具有以下性质\n\n1. $f(x)≥0$\n1. $\\int_{-\\infty}^{\\infty} f(x) dx = 1$\n3. 对于任意实数 $x_1,x_2(x_1 < x_2)$，有\n$$P(x_1< X \\le x_2) = F(x_2) - F(x_1) = \\int_{x_1}^{x_2} f(x) dx$$\n且当 $f(x)￥ 在点 $x$ 连续的时候，有\n$$F′(x)=f(x)$$\n通过上面这个性质可以推导出下面的约等式\n$$P(x<X≤x+Δx)≈f(x)Δx$$\n也就是说概率密度函数在某点的值的大小一定程度上反映了随机变量落在该点附近的概率的大小。\n\n上面讲了随机变量的分布函数，下面讲一下随机变量的函数的分布函数，例如 $X$ 为一个随机变量，则 $Y=(X−1)^2$ 是随机变量 $X$ 的函数，且 $Y$ 也是一个随机变量， 因此 $Y$ 也有自己的分布律。下面是两个例子，其中一个是离散型随机变量，一个是连续型随机变量。\n![](一维随机变量/一维随机变量-0b775c82.png)\n![](一维随机变量/一维随机变量-a664c725.png)\n\n\n离散型随机变量的函数的分布律容易求，对于连续型随机变量的函数的分布律的求法一般是先按定义写出 $Y$ 的分布函数 $F(Y<=y)$, 然后替换成 $F(g(X)<=Y)$, 再转换成 $X$ 的分布函数和概率密度函数。\n\n## 均匀分布\n若随机变量 $X$ 的概率密度函数为\n$$f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}$$\n则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$\n## 指数分布\n若随机变量 $X$ 的概率密度函数为\n\n$$f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n则称 $X$ 服从参数为 $θ$ 的指数分布。\n\n其图像如下所示:\n\n![](一维随机变量/一维随机变量-e5379494.png)\n\n其分布函数为\n$$F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里\n\n关于指数分布的一个有趣的性质为：\n\n$$P(X>s+t | X>s) = P(X>t)$$\n该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。\n\n## 正态分布\n正态分布也叫高斯分布，其概率密度函数为\n\n$$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$\n则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示\n\n![](一维随机变量/一维随机变量-a7f11452.png)\n\n从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望\n","source":"_posts/一维随机变量.md","raw":"---\ntitle: 一维随机变量\ndate: 2017-08-15 22:23:46\ntags: [人工智能,概率,分布]\ncategories: 数学\n---\n\n本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。\n<!--more-->\n\n# 离散型随机变量的分布\n## 伯努利分布\n伯努利分布又名**两点分布**或者**0-1分布**，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为\n$$P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)$$\n如果试验E只有两种结果，则称试验E为**伯努利试验**。如果独立的进行 n 次试验E，则称为**n重伯努利试验**。\n\n## 二项分布\n以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：\n\n$$P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n$$\n其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。\n\n## 泊松分布\n随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为\n\n$$P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….$$\n则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$\n其分布规律通过图像直观表示为\n\n![](一维随机变量/一维随机变量-42feaec2.png)\n\n泊松分布适合于描述**单位时间内随机事件发生的次数的概率分布**。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。\n\n下面介绍用**泊松分布来逼近二项分布的定理，也就是泊松定理**。\n\n泊松定理：设 $λ>0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有\n$$\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}$$\n即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。\n\n# 连续型随机变量的分布\n## 分布函数和概率密度函数\n首先需要清楚，**分布函数是针对随机变量的，离散或连续都可以；而概率密度函数是针对连续随机变量的。**下面是这两者的定义以及联系\n\n**分布函数的定义**如下：\n\n$X$ 是一个随机变量，$x$ 是任意实数，则 $X$ 的分布函数定义为\n\n$$F(x)=P(X≤x),(−∞<x<∞)$$\n\n则对于任意实数 $x_1,x_2(x_1 < x_2)$,有\n\n$$P(x_1 < X \\le x_2) = p(X \\le x_2) - p(X \\le x_1) = F(x_2) - F(x_1)$$\n即如果我们知道了 $X$ 的分布函数，则可以知道 $X$ 落在任一区间上的概率，也就是说通过分布函数可以完整描述随机变量的统计规律特性。\n\n概率密度函数定义如下：\n\n对于分布函数 $F(X)$，假如存在 $f(x)$ 使得以下公式成立：\n\n$$F(x) = \\int_{-\\infty}^x f(t) dt$$\n则 X 为连续型随机变量，f(x)为随机变量的概率密度函数。$f(x)$ 具有以下性质\n\n1. $f(x)≥0$\n1. $\\int_{-\\infty}^{\\infty} f(x) dx = 1$\n3. 对于任意实数 $x_1,x_2(x_1 < x_2)$，有\n$$P(x_1< X \\le x_2) = F(x_2) - F(x_1) = \\int_{x_1}^{x_2} f(x) dx$$\n且当 $f(x)￥ 在点 $x$ 连续的时候，有\n$$F′(x)=f(x)$$\n通过上面这个性质可以推导出下面的约等式\n$$P(x<X≤x+Δx)≈f(x)Δx$$\n也就是说概率密度函数在某点的值的大小一定程度上反映了随机变量落在该点附近的概率的大小。\n\n上面讲了随机变量的分布函数，下面讲一下随机变量的函数的分布函数，例如 $X$ 为一个随机变量，则 $Y=(X−1)^2$ 是随机变量 $X$ 的函数，且 $Y$ 也是一个随机变量， 因此 $Y$ 也有自己的分布律。下面是两个例子，其中一个是离散型随机变量，一个是连续型随机变量。\n![](一维随机变量/一维随机变量-0b775c82.png)\n![](一维随机变量/一维随机变量-a664c725.png)\n\n\n离散型随机变量的函数的分布律容易求，对于连续型随机变量的函数的分布律的求法一般是先按定义写出 $Y$ 的分布函数 $F(Y<=y)$, 然后替换成 $F(g(X)<=Y)$, 再转换成 $X$ 的分布函数和概率密度函数。\n\n## 均匀分布\n若随机变量 $X$ 的概率密度函数为\n$$f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}$$\n则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$\n## 指数分布\n若随机变量 $X$ 的概率密度函数为\n\n$$f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n则称 $X$ 服从参数为 $θ$ 的指数分布。\n\n其图像如下所示:\n\n![](一维随机变量/一维随机变量-e5379494.png)\n\n其分布函数为\n$$F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里\n\n关于指数分布的一个有趣的性质为：\n\n$$P(X>s+t | X>s) = P(X>t)$$\n该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。\n\n## 正态分布\n正态分布也叫高斯分布，其概率密度函数为\n\n$$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$\n则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示\n\n![](一维随机变量/一维随机变量-a7f11452.png)\n\n从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望\n","slug":"一维随机变量","published":1,"updated":"2019-07-30T01:54:38.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izk003mhomjeyq94pg2","content":"<p>本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。<br><a id=\"more\"></a></p>\n<h1 id=\"离散型随机变量的分布\"><a href=\"#离散型随机变量的分布\" class=\"headerlink\" title=\"离散型随机变量的分布\"></a>离散型随机变量的分布</h1><h2 id=\"伯努利分布\"><a href=\"#伯努利分布\" class=\"headerlink\" title=\"伯努利分布\"></a>伯努利分布</h2><p>伯努利分布又名<strong>两点分布</strong>或者<strong>0-1分布</strong>，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)</script><p>如果试验E只有两种结果，则称试验E为<strong>伯努利试验</strong>。如果独立的进行 n 次试验E，则称为<strong>n重伯努利试验</strong>。</p>\n<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><p>以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：</p>\n<script type=\"math/tex; mode=display\">P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n</script><p>其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><p>随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….</script><p>则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$<br>其分布规律通过图像直观表示为</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-42feaec2.png\" alt=\"\"></p>\n<p>泊松分布适合于描述<strong>单位时间内随机事件发生的次数的概率分布</strong>。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。</p>\n<p>下面介绍用<strong>泊松分布来逼近二项分布的定理，也就是泊松定理</strong>。</p>\n<p>泊松定理：设 $λ&gt;0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}</script><p>即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。</p>\n<h1 id=\"连续型随机变量的分布\"><a href=\"#连续型随机变量的分布\" class=\"headerlink\" title=\"连续型随机变量的分布\"></a>连续型随机变量的分布</h1><h2 id=\"分布函数和概率密度函数\"><a href=\"#分布函数和概率密度函数\" class=\"headerlink\" title=\"分布函数和概率密度函数\"></a>分布函数和概率密度函数</h2><p>首先需要清楚，<strong>分布函数是针对随机变量的，离散或连续都可以；而概率密度函数是针对连续随机变量的。</strong>下面是这两者的定义以及联系</p>\n<p><strong>分布函数的定义</strong>如下：</p>\n<p>$X$ 是一个随机变量，$x$ 是任意实数，则 $X$ 的分布函数定义为</p>\n<script type=\"math/tex; mode=display\">F(x)=P(X≤x),(−∞<x<∞)</script><p>则对于任意实数 $x_1,x_2(x_1 &lt; x_2)$,有</p>\n<script type=\"math/tex; mode=display\">P(x_1 < X \\le x_2) = p(X \\le x_2) - p(X \\le x_1) = F(x_2) - F(x_1)</script><p>即如果我们知道了 $X$ 的分布函数，则可以知道 $X$ 落在任一区间上的概率，也就是说通过分布函数可以完整描述随机变量的统计规律特性。</p>\n<p>概率密度函数定义如下：</p>\n<p>对于分布函数 $F(X)$，假如存在 $f(x)$ 使得以下公式成立：</p>\n<script type=\"math/tex; mode=display\">F(x) = \\int_{-\\infty}^x f(t) dt</script><p>则 X 为连续型随机变量，f(x)为随机变量的概率密度函数。$f(x)$ 具有以下性质</p>\n<ol>\n<li>$f(x)≥0$</li>\n<li>$\\int_{-\\infty}^{\\infty} f(x) dx = 1$</li>\n<li>对于任意实数 $x_1,x_2(x_1 &lt; x_2)$，有<script type=\"math/tex; mode=display\">P(x_1< X \\le x_2) = F(x_2) - F(x_1) = \\int_{x_1}^{x_2} f(x) dx</script>且当 $f(x)￥ 在点 $x$ 连续的时候，有<script type=\"math/tex; mode=display\">F′(x)=f(x)</script>通过上面这个性质可以推导出下面的约等式<script type=\"math/tex; mode=display\">P(x<X≤x+Δx)≈f(x)Δx</script>也就是说概率密度函数在某点的值的大小一定程度上反映了随机变量落在该点附近的概率的大小。</li>\n</ol>\n<p>上面讲了随机变量的分布函数，下面讲一下随机变量的函数的分布函数，例如 $X$ 为一个随机变量，则 $Y=(X−1)^2$ 是随机变量 $X$ 的函数，且 $Y$ 也是一个随机变量， 因此 $Y$ 也有自己的分布律。下面是两个例子，其中一个是离散型随机变量，一个是连续型随机变量。<br><img src=\"/2017/08/15/一维随机变量/一维随机变量-0b775c82.png\" alt=\"\"><br><img src=\"/2017/08/15/一维随机变量/一维随机变量-a664c725.png\" alt=\"\"></p>\n<p>离散型随机变量的函数的分布律容易求，对于连续型随机变量的函数的分布律的求法一般是先按定义写出 $Y$ 的分布函数 $F(Y&lt;=y)$, 然后替换成 $F(g(X)&lt;=Y)$, 再转换成 $X$ 的分布函数和概率密度函数。</p>\n<h2 id=\"均匀分布\"><a href=\"#均匀分布\" class=\"headerlink\" title=\"均匀分布\"></a>均匀分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}</script><p>则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$</p>\n<h2 id=\"指数分布\"><a href=\"#指数分布\" class=\"headerlink\" title=\"指数分布\"></a>指数分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>则称 $X$ 服从参数为 $θ$ 的指数分布。</p>\n<p>其图像如下所示:</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-e5379494.png\" alt=\"\"></p>\n<p>其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里</p>\n<p>关于指数分布的一个有趣的性质为：</p>\n<script type=\"math/tex; mode=display\">P(X>s+t | X>s) = P(X>t)</script><p>该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布也叫高斯分布，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</script><p>则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-a7f11452.png\" alt=\"\"></p>\n<p>从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。<br></p>","more":"<p></p>\n<h1 id=\"离散型随机变量的分布\"><a href=\"#离散型随机变量的分布\" class=\"headerlink\" title=\"离散型随机变量的分布\"></a>离散型随机变量的分布</h1><h2 id=\"伯努利分布\"><a href=\"#伯努利分布\" class=\"headerlink\" title=\"伯努利分布\"></a>伯努利分布</h2><p>伯努利分布又名<strong>两点分布</strong>或者<strong>0-1分布</strong>，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)</script><p>如果试验E只有两种结果，则称试验E为<strong>伯努利试验</strong>。如果独立的进行 n 次试验E，则称为<strong>n重伯努利试验</strong>。</p>\n<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><p>以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：</p>\n<script type=\"math/tex; mode=display\">P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n</script><p>其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><p>随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….</script><p>则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$<br>其分布规律通过图像直观表示为</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-42feaec2.png\" alt=\"\"></p>\n<p>泊松分布适合于描述<strong>单位时间内随机事件发生的次数的概率分布</strong>。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。</p>\n<p>下面介绍用<strong>泊松分布来逼近二项分布的定理，也就是泊松定理</strong>。</p>\n<p>泊松定理：设 $λ&gt;0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}</script><p>即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。</p>\n<h1 id=\"连续型随机变量的分布\"><a href=\"#连续型随机变量的分布\" class=\"headerlink\" title=\"连续型随机变量的分布\"></a>连续型随机变量的分布</h1><h2 id=\"分布函数和概率密度函数\"><a href=\"#分布函数和概率密度函数\" class=\"headerlink\" title=\"分布函数和概率密度函数\"></a>分布函数和概率密度函数</h2><p>首先需要清楚，<strong>分布函数是针对随机变量的，离散或连续都可以；而概率密度函数是针对连续随机变量的。</strong>下面是这两者的定义以及联系</p>\n<p><strong>分布函数的定义</strong>如下：</p>\n<p>$X$ 是一个随机变量，$x$ 是任意实数，则 $X$ 的分布函数定义为</p>\n<script type=\"math/tex; mode=display\">F(x)=P(X≤x),(−∞<x<∞)</script><p>则对于任意实数 $x_1,x_2(x_1 &lt; x_2)$,有</p>\n<script type=\"math/tex; mode=display\">P(x_1 < X \\le x_2) = p(X \\le x_2) - p(X \\le x_1) = F(x_2) - F(x_1)</script><p>即如果我们知道了 $X$ 的分布函数，则可以知道 $X$ 落在任一区间上的概率，也就是说通过分布函数可以完整描述随机变量的统计规律特性。</p>\n<p>概率密度函数定义如下：</p>\n<p>对于分布函数 $F(X)$，假如存在 $f(x)$ 使得以下公式成立：</p>\n<script type=\"math/tex; mode=display\">F(x) = \\int_{-\\infty}^x f(t) dt</script><p>则 X 为连续型随机变量，f(x)为随机变量的概率密度函数。$f(x)$ 具有以下性质</p>\n<ol>\n<li>$f(x)≥0$</li>\n<li>$\\int_{-\\infty}^{\\infty} f(x) dx = 1$</li>\n<li>对于任意实数 $x_1,x_2(x_1 &lt; x_2)$，有<script type=\"math/tex; mode=display\">P(x_1< X \\le x_2) = F(x_2) - F(x_1) = \\int_{x_1}^{x_2} f(x) dx</script>且当 $f(x)￥ 在点 $x$ 连续的时候，有<script type=\"math/tex; mode=display\">F′(x)=f(x)</script>通过上面这个性质可以推导出下面的约等式<script type=\"math/tex; mode=display\">P(x<X≤x+Δx)≈f(x)Δx</script>也就是说概率密度函数在某点的值的大小一定程度上反映了随机变量落在该点附近的概率的大小。</li>\n</ol>\n<p>上面讲了随机变量的分布函数，下面讲一下随机变量的函数的分布函数，例如 $X$ 为一个随机变量，则 $Y=(X−1)^2$ 是随机变量 $X$ 的函数，且 $Y$ 也是一个随机变量， 因此 $Y$ 也有自己的分布律。下面是两个例子，其中一个是离散型随机变量，一个是连续型随机变量。<br><img src=\"/2017/08/15/一维随机变量/一维随机变量-0b775c82.png\" alt=\"\"><br><img src=\"/2017/08/15/一维随机变量/一维随机变量-a664c725.png\" alt=\"\"></p>\n<p>离散型随机变量的函数的分布律容易求，对于连续型随机变量的函数的分布律的求法一般是先按定义写出 $Y$ 的分布函数 $F(Y&lt;=y)$, 然后替换成 $F(g(X)&lt;=Y)$, 再转换成 $X$ 的分布函数和概率密度函数。</p>\n<h2 id=\"均匀分布\"><a href=\"#均匀分布\" class=\"headerlink\" title=\"均匀分布\"></a>均匀分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}</script><p>则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$</p>\n<h2 id=\"指数分布\"><a href=\"#指数分布\" class=\"headerlink\" title=\"指数分布\"></a>指数分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>则称 $X$ 服从参数为 $θ$ 的指数分布。</p>\n<p>其图像如下所示:</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-e5379494.png\" alt=\"\"></p>\n<p>其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里</p>\n<p>关于指数分布的一个有趣的性质为：</p>\n<script type=\"math/tex; mode=display\">P(X>s+t | X>s) = P(X>t)</script><p>该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布也叫高斯分布，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</script><p>则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示</p>\n<p><img src=\"/2017/08/15/一维随机变量/一维随机变量-a7f11452.png\" alt=\"\"></p>\n<p>从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望</p>"},{"title":"二维随机变量","date":"2017-08-15T14:24:02.000Z","_content":"\n# 联合分布函数\n假设 $X$ 和 $Y$ 都是随机变量，那么我们定义其分布函数如下：\n\n$$F(x,y) = P ((X \\le x)\\cap(Y \\le y)) =  P (X \\le x, Y \\le y )$$\n上面的 $F(x,y)$ 称作随机变量$(X,Y)$的分布函数，也叫作联合分布函数。\n<!--more-->\n## 离散型随机变量联合分布\n如果上面的 $X$ 和 $Y$ 都是离散随机变量，那么对于 $(X,Y)$ 的所有取值可记为\n\n$$P(X=x_i, Y=y_i) = p_{ij},i,j=1,2,….$$\n上面的所有P的取值为二维离散随机变量的分布律，也叫联合分布律。直观用表格表示如下所示\n\n![](二维随机变量/二维随机变量-a083d527.png)\n\n连续型随机变量联合分布\n类似地，如果上面的X和Y都是连续随机变量，那么分布函数可定义为\n\n$$F(x,y) = \\int_{-\\infty}^y\\int_{-\\infty}^xf(u,v)dudv$$\n其中 $f(x,y)$ 被称为概率密度函数，也叫联合概率密度函数。\n\n其性质与一维随机变量的概率密度函数非常相似\n1. $f(x,y)≥0$\n1. $\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$\n3. 设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在$G$内的概率为\n$$\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$$\n4. 若 $f(x,y)$ 在点 $(x,y)$ 连续，则\n$$\\frac{\\partial^2F(X,Y)}{\\partial x \\partial y} = f(x, y)$$\n\n# 边缘分布函数\n二维随机变量 $(X,Y)$ 作为一个整体的时候，其分布函数为联合分布函数，但是 $X$ 和 $Y$ 是随机变量，各自也有分布函数，将其分别记为 $F_X(x),F_Y(y)$，称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的**边缘分布函数**。\n\n边缘分布函数可通过联合分布函数确定，关系如下\n\n$$F_X(x) = P(X \\le x) = P(X \\le x,Y \\lt \\infty) = F(x, \\infty)$$\n\n\n$$F_X(x)=F(x,∞)\\\\\nF_Y(y)=F(∞,y)$$\n\n\n## 离散型随机变量边缘分布\n假如 $X$ 和 $Y$ 是离散型随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布定义下\n$$\np_{i.} = \\sum_{j=1}^{\\infty} p_{ij} = P(X = x_i), i=1,2,3…..n \\\\\np_{.j} = \\sum_{i=1}^{\\infty} p_{ij} = P(Y = y_j), j=1,2,3…..n\n$$\n上面的式子分别称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布率。\n\n## 连续型随机变量边缘分布\n假如 $X$ 和 $Y$ 分别是连续性随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 的边缘分布函数定义为\n\n$$F_X(x) = F(x,\\infty) = \\int_{-\\infty}^{x}(\\int_{-\\infty}^{\\infty}f(x,y)dy)dx=\\int_{-\\infty}^{\\infty}f(x,y)dy$$\n则被称为随机变量 $(X,Y)$ 关于 $Y$ 的 边缘概率密度函数\n\n# 条件分布\n由条件概率可以比较容易推导出条件分布的含义，其定义如下：\n\n## 离散型随机变量的条件分布\n对于离散型随机变量，条件分布的定义如下：\n\n设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P(Y=y_j)>0$, 则称\n$$P(X = x_i|Y= y_j) = \\frac{P(X = x_i, Y=y_j)}{P(Y=y_j)} = \\frac{p_{ij}}{p_{.j}}, i = 1,2,3$$\n\n为在 $Y=y_j$ 条件下随机变量X的条件分布律。同理，交换 $X$ 和 $Y$ 的位置得到的是在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。\n\n## 连续型随机变量的条件分布\n对于连续型的随机变量，条件分布的定义如下：\n\n设二维随机变量 $(X,Y)$ 的概率密度函数为 $f(x,y),(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ .若对于固定的 $y，f_Y(y)>0$ ，则称 $\\frac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度。记为\n$$f_{X|Y}(x|y) = \\frac{f(x,y)}{f_Y(y)}$$\n有了条件概率密度(就是条件概率密度函数)，我们也可以定义出条件分布函数如下\n\n$$\\int_{-\\infty}^x f_{X|Y}(x|y)dx = \\int_{-\\infty}^x \\frac{f(x,y)}{f_Y(y)}dx$$\n上面的函数为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为\n\n$$F_{X|Y}(x|y) = P(X \\le x| Y=y)$$\n# 相互独立的随机变量\n两个随机变量 $X,Y$ 相互独立的充要条件如下：\n\n$$F(x,y) = F_X(x)F_Y(y)$$\n上面的 $F(x,y),F_X(x),F_Y(y)$ 分别是二维随机变量的联合分布函数及关于 $X$ 和 $Y$ 的边缘分布函数。\n\n除了通过分布函数，对于具体的连续型随机变量或离散型随机变量，还可通过概率密度函数和分布律来定义相互独立的条件。\n\n对于连续型随机变量，上面的式子等价于\n\n$$f(x,y) = f_X(x)f_Y(y)$$\n式子中的 $f(x,y),f_X(x),f_Y(y)$ 分别为 随机变量 $(X,Y)$ 的条件概率密度函数和边缘概率密度函数。\n\n对于离散型随机变量则有：\n\n$$P(X = x_i, Y = y_j) = P(X=x_i)P(Y=y_j)$$\n# 二维随机变量的函数的分布\n在讨论一维随机变量的分布函数的时候，也讨论了一维随机变量的函数的分布函数，同样对于二维随机变量，我们也可以讨论其函数的分布函数。下面主要讨论 $Z=X+Y，Z=XY，Z=Y/X，M=max(X,Y)，N=min(X,Y)$ 这几个函数的分布函数（X，Y 为相互独立的随机变量），这里主要给出具体的公式，证明省略。\n\n## $Z=X+Y$ 的分布\n设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)， Z=X+Y$ 仍然为连续性随机变量，其概率密度函数为\n\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(z-y,y)dy$$\n\n或\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(x,z-x)dx$$\n\n当 $X,Y$ 相互独立时，其边缘概率密度函数具有以下性质\n\n$$f(x,y) = f_X(x)f_Y(y)$$\n因此上面的式子也可以化成下面的形式\n\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(z-y)f_Y(y)dy\\\\\nf_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(x)f_Y(z-x)dx$$\n\n## $Z=XY$ 和 $Z=Y/X$ 的分布\n设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)$， $Z = \\frac{Y}{X},Z = XY$仍然为连续性随机变量，其概率密度函数为\n\n$$f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f(x,xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f(x,z/x)dx$$\n当 $X,Y$ 相互独立时，同样有下面的性质\n\n$$f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f_X(x)f_Y(xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f_X(x)f_Y(z/x)dx$$\n## $M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布\n讨论 $max(X,Y)$ 和 $min(X,Y)$ 的分布的时候， 一般假设 $X,Y$ 相互独立，因为这样才有下面的性质。\n\n对于 $M=max(X,Y)$ 的分布有\n\n$$F_{max}(z) = P(M \\le z) = P(X \\le z, Y \\le z) = P(X \\le z)P(Y \\le z)$$\n由于 $X$ 和 $Y$ 相互独立，因此有\n\n$$F_{max}(z) = F_X(z)F_Y(z)$$\n同样对 $N=min(X,Y)$ 有\n\n$$F_{min}(z) = P(N \\le z) = 1 - P(N \\gt z) = 1 - P(X > z)P(Y>z)$$\n即\n\n$$F_{min}(z) = 1 - (1 - F_X(z))(1 - F_Y(z))$$\n推广到 n 个相互独立的随机变量有下面的性质\n\n$M = max \\lbrace X_1,X_2…,X_n \\rbrace$ 及 $N = min\\lbrace X_1,X_2…,X_n \\rbrace$ 的分布函数分别为\n$$F_{max}(z) = F_{X_1}(z)F_{X_2}(z)…F_{X_n}(z) \\\\\nF_{min}(z) = 1 - (1 - F_{X_1}(z))(1 - F_{X_2}(z))…(1 - F_{X_n}(z))$$\n而当 $X_1,X_2…,X_n$ 独立同分布的时候，上式变为如下所示\n\n$$F_{max}(z) = [F(z)]^n\\\\\nF_{min}(z) = 1 - (1 - F(z))^n$$\n","source":"_posts/二维随机变量.md","raw":"---\ntitle: 二维随机变量\ndate: 2017-08-15 22:24:02\ntags: [人工智能,概率,分布]\ncategories: 数学\n---\n\n# 联合分布函数\n假设 $X$ 和 $Y$ 都是随机变量，那么我们定义其分布函数如下：\n\n$$F(x,y) = P ((X \\le x)\\cap(Y \\le y)) =  P (X \\le x, Y \\le y )$$\n上面的 $F(x,y)$ 称作随机变量$(X,Y)$的分布函数，也叫作联合分布函数。\n<!--more-->\n## 离散型随机变量联合分布\n如果上面的 $X$ 和 $Y$ 都是离散随机变量，那么对于 $(X,Y)$ 的所有取值可记为\n\n$$P(X=x_i, Y=y_i) = p_{ij},i,j=1,2,….$$\n上面的所有P的取值为二维离散随机变量的分布律，也叫联合分布律。直观用表格表示如下所示\n\n![](二维随机变量/二维随机变量-a083d527.png)\n\n连续型随机变量联合分布\n类似地，如果上面的X和Y都是连续随机变量，那么分布函数可定义为\n\n$$F(x,y) = \\int_{-\\infty}^y\\int_{-\\infty}^xf(u,v)dudv$$\n其中 $f(x,y)$ 被称为概率密度函数，也叫联合概率密度函数。\n\n其性质与一维随机变量的概率密度函数非常相似\n1. $f(x,y)≥0$\n1. $\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$\n3. 设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在$G$内的概率为\n$$\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$$\n4. 若 $f(x,y)$ 在点 $(x,y)$ 连续，则\n$$\\frac{\\partial^2F(X,Y)}{\\partial x \\partial y} = f(x, y)$$\n\n# 边缘分布函数\n二维随机变量 $(X,Y)$ 作为一个整体的时候，其分布函数为联合分布函数，但是 $X$ 和 $Y$ 是随机变量，各自也有分布函数，将其分别记为 $F_X(x),F_Y(y)$，称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的**边缘分布函数**。\n\n边缘分布函数可通过联合分布函数确定，关系如下\n\n$$F_X(x) = P(X \\le x) = P(X \\le x,Y \\lt \\infty) = F(x, \\infty)$$\n\n\n$$F_X(x)=F(x,∞)\\\\\nF_Y(y)=F(∞,y)$$\n\n\n## 离散型随机变量边缘分布\n假如 $X$ 和 $Y$ 是离散型随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布定义下\n$$\np_{i.} = \\sum_{j=1}^{\\infty} p_{ij} = P(X = x_i), i=1,2,3…..n \\\\\np_{.j} = \\sum_{i=1}^{\\infty} p_{ij} = P(Y = y_j), j=1,2,3…..n\n$$\n上面的式子分别称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布率。\n\n## 连续型随机变量边缘分布\n假如 $X$ 和 $Y$ 分别是连续性随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 的边缘分布函数定义为\n\n$$F_X(x) = F(x,\\infty) = \\int_{-\\infty}^{x}(\\int_{-\\infty}^{\\infty}f(x,y)dy)dx=\\int_{-\\infty}^{\\infty}f(x,y)dy$$\n则被称为随机变量 $(X,Y)$ 关于 $Y$ 的 边缘概率密度函数\n\n# 条件分布\n由条件概率可以比较容易推导出条件分布的含义，其定义如下：\n\n## 离散型随机变量的条件分布\n对于离散型随机变量，条件分布的定义如下：\n\n设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P(Y=y_j)>0$, 则称\n$$P(X = x_i|Y= y_j) = \\frac{P(X = x_i, Y=y_j)}{P(Y=y_j)} = \\frac{p_{ij}}{p_{.j}}, i = 1,2,3$$\n\n为在 $Y=y_j$ 条件下随机变量X的条件分布律。同理，交换 $X$ 和 $Y$ 的位置得到的是在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。\n\n## 连续型随机变量的条件分布\n对于连续型的随机变量，条件分布的定义如下：\n\n设二维随机变量 $(X,Y)$ 的概率密度函数为 $f(x,y),(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ .若对于固定的 $y，f_Y(y)>0$ ，则称 $\\frac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度。记为\n$$f_{X|Y}(x|y) = \\frac{f(x,y)}{f_Y(y)}$$\n有了条件概率密度(就是条件概率密度函数)，我们也可以定义出条件分布函数如下\n\n$$\\int_{-\\infty}^x f_{X|Y}(x|y)dx = \\int_{-\\infty}^x \\frac{f(x,y)}{f_Y(y)}dx$$\n上面的函数为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为\n\n$$F_{X|Y}(x|y) = P(X \\le x| Y=y)$$\n# 相互独立的随机变量\n两个随机变量 $X,Y$ 相互独立的充要条件如下：\n\n$$F(x,y) = F_X(x)F_Y(y)$$\n上面的 $F(x,y),F_X(x),F_Y(y)$ 分别是二维随机变量的联合分布函数及关于 $X$ 和 $Y$ 的边缘分布函数。\n\n除了通过分布函数，对于具体的连续型随机变量或离散型随机变量，还可通过概率密度函数和分布律来定义相互独立的条件。\n\n对于连续型随机变量，上面的式子等价于\n\n$$f(x,y) = f_X(x)f_Y(y)$$\n式子中的 $f(x,y),f_X(x),f_Y(y)$ 分别为 随机变量 $(X,Y)$ 的条件概率密度函数和边缘概率密度函数。\n\n对于离散型随机变量则有：\n\n$$P(X = x_i, Y = y_j) = P(X=x_i)P(Y=y_j)$$\n# 二维随机变量的函数的分布\n在讨论一维随机变量的分布函数的时候，也讨论了一维随机变量的函数的分布函数，同样对于二维随机变量，我们也可以讨论其函数的分布函数。下面主要讨论 $Z=X+Y，Z=XY，Z=Y/X，M=max(X,Y)，N=min(X,Y)$ 这几个函数的分布函数（X，Y 为相互独立的随机变量），这里主要给出具体的公式，证明省略。\n\n## $Z=X+Y$ 的分布\n设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)， Z=X+Y$ 仍然为连续性随机变量，其概率密度函数为\n\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(z-y,y)dy$$\n\n或\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(x,z-x)dx$$\n\n当 $X,Y$ 相互独立时，其边缘概率密度函数具有以下性质\n\n$$f(x,y) = f_X(x)f_Y(y)$$\n因此上面的式子也可以化成下面的形式\n\n$$f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(z-y)f_Y(y)dy\\\\\nf_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(x)f_Y(z-x)dx$$\n\n## $Z=XY$ 和 $Z=Y/X$ 的分布\n设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)$， $Z = \\frac{Y}{X},Z = XY$仍然为连续性随机变量，其概率密度函数为\n\n$$f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f(x,xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f(x,z/x)dx$$\n当 $X,Y$ 相互独立时，同样有下面的性质\n\n$$f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f_X(x)f_Y(xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f_X(x)f_Y(z/x)dx$$\n## $M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布\n讨论 $max(X,Y)$ 和 $min(X,Y)$ 的分布的时候， 一般假设 $X,Y$ 相互独立，因为这样才有下面的性质。\n\n对于 $M=max(X,Y)$ 的分布有\n\n$$F_{max}(z) = P(M \\le z) = P(X \\le z, Y \\le z) = P(X \\le z)P(Y \\le z)$$\n由于 $X$ 和 $Y$ 相互独立，因此有\n\n$$F_{max}(z) = F_X(z)F_Y(z)$$\n同样对 $N=min(X,Y)$ 有\n\n$$F_{min}(z) = P(N \\le z) = 1 - P(N \\gt z) = 1 - P(X > z)P(Y>z)$$\n即\n\n$$F_{min}(z) = 1 - (1 - F_X(z))(1 - F_Y(z))$$\n推广到 n 个相互独立的随机变量有下面的性质\n\n$M = max \\lbrace X_1,X_2…,X_n \\rbrace$ 及 $N = min\\lbrace X_1,X_2…,X_n \\rbrace$ 的分布函数分别为\n$$F_{max}(z) = F_{X_1}(z)F_{X_2}(z)…F_{X_n}(z) \\\\\nF_{min}(z) = 1 - (1 - F_{X_1}(z))(1 - F_{X_2}(z))…(1 - F_{X_n}(z))$$\n而当 $X_1,X_2…,X_n$ 独立同分布的时候，上式变为如下所示\n\n$$F_{max}(z) = [F(z)]^n\\\\\nF_{min}(z) = 1 - (1 - F(z))^n$$\n","slug":"二维随机变量","published":1,"updated":"2019-07-30T01:54:38.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izm003qhomjbgyqv6dw","content":"<h1 id=\"联合分布函数\"><a href=\"#联合分布函数\" class=\"headerlink\" title=\"联合分布函数\"></a>联合分布函数</h1><p>假设 $X$ 和 $Y$ 都是随机变量，那么我们定义其分布函数如下：</p>\n<script type=\"math/tex; mode=display\">F(x,y) = P ((X \\le x)\\cap(Y \\le y)) =  P (X \\le x, Y \\le y )</script><p>上面的 $F(x,y)$ 称作随机变量$(X,Y)$的分布函数，也叫作联合分布函数。<br><a id=\"more\"></a></p>\n<h2 id=\"离散型随机变量联合分布\"><a href=\"#离散型随机变量联合分布\" class=\"headerlink\" title=\"离散型随机变量联合分布\"></a>离散型随机变量联合分布</h2><p>如果上面的 $X$ 和 $Y$ 都是离散随机变量，那么对于 $(X,Y)$ 的所有取值可记为</p>\n<script type=\"math/tex; mode=display\">P(X=x_i, Y=y_i) = p_{ij},i,j=1,2,….</script><p>上面的所有P的取值为二维离散随机变量的分布律，也叫联合分布律。直观用表格表示如下所示</p>\n<p><img src=\"/2017/08/15/二维随机变量/二维随机变量-a083d527.png\" alt=\"\"></p>\n<p>连续型随机变量联合分布<br>类似地，如果上面的X和Y都是连续随机变量，那么分布函数可定义为</p>\n<script type=\"math/tex; mode=display\">F(x,y) = \\int_{-\\infty}^y\\int_{-\\infty}^xf(u,v)dudv</script><p>其中 $f(x,y)$ 被称为概率密度函数，也叫联合概率密度函数。</p>\n<p>其性质与一维随机变量的概率密度函数非常相似</p>\n<ol>\n<li>$f(x,y)≥0$</li>\n<li>$\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$</li>\n<li>设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在$G$内的概率为<script type=\"math/tex; mode=display\">\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)</script></li>\n<li>若 $f(x,y)$ 在点 $(x,y)$ 连续，则<script type=\"math/tex; mode=display\">\\frac{\\partial^2F(X,Y)}{\\partial x \\partial y} = f(x, y)</script></li>\n</ol>\n<h1 id=\"边缘分布函数\"><a href=\"#边缘分布函数\" class=\"headerlink\" title=\"边缘分布函数\"></a>边缘分布函数</h1><p>二维随机变量 $(X,Y)$ 作为一个整体的时候，其分布函数为联合分布函数，但是 $X$ 和 $Y$ 是随机变量，各自也有分布函数，将其分别记为 $F_X(x),F_Y(y)$，称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的<strong>边缘分布函数</strong>。</p>\n<p>边缘分布函数可通过联合分布函数确定，关系如下</p>\n<script type=\"math/tex; mode=display\">F_X(x) = P(X \\le x) = P(X \\le x,Y \\lt \\infty) = F(x, \\infty)</script><script type=\"math/tex; mode=display\">F_X(x)=F(x,∞)\\\\\nF_Y(y)=F(∞,y)</script><h2 id=\"离散型随机变量边缘分布\"><a href=\"#离散型随机变量边缘分布\" class=\"headerlink\" title=\"离散型随机变量边缘分布\"></a>离散型随机变量边缘分布</h2><p>假如 $X$ 和 $Y$ 是离散型随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布定义下</p>\n<script type=\"math/tex; mode=display\">\np_{i.} = \\sum_{j=1}^{\\infty} p_{ij} = P(X = x_i), i=1,2,3…..n \\\\\np_{.j} = \\sum_{i=1}^{\\infty} p_{ij} = P(Y = y_j), j=1,2,3…..n</script><p>上面的式子分别称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布率。</p>\n<h2 id=\"连续型随机变量边缘分布\"><a href=\"#连续型随机变量边缘分布\" class=\"headerlink\" title=\"连续型随机变量边缘分布\"></a>连续型随机变量边缘分布</h2><p>假如 $X$ 和 $Y$ 分别是连续性随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 的边缘分布函数定义为</p>\n<script type=\"math/tex; mode=display\">F_X(x) = F(x,\\infty) = \\int_{-\\infty}^{x}(\\int_{-\\infty}^{\\infty}f(x,y)dy)dx=\\int_{-\\infty}^{\\infty}f(x,y)dy</script><p>则被称为随机变量 $(X,Y)$ 关于 $Y$ 的 边缘概率密度函数</p>\n<h1 id=\"条件分布\"><a href=\"#条件分布\" class=\"headerlink\" title=\"条件分布\"></a>条件分布</h1><p>由条件概率可以比较容易推导出条件分布的含义，其定义如下：</p>\n<h2 id=\"离散型随机变量的条件分布\"><a href=\"#离散型随机变量的条件分布\" class=\"headerlink\" title=\"离散型随机变量的条件分布\"></a>离散型随机变量的条件分布</h2><p>对于离散型随机变量，条件分布的定义如下：</p>\n<p>设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P(Y=y_j)&gt;0$, 则称</p>\n<script type=\"math/tex; mode=display\">P(X = x_i|Y= y_j) = \\frac{P(X = x_i, Y=y_j)}{P(Y=y_j)} = \\frac{p_{ij}}{p_{.j}}, i = 1,2,3</script><p>为在 $Y=y_j$ 条件下随机变量X的条件分布律。同理，交换 $X$ 和 $Y$ 的位置得到的是在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。</p>\n<h2 id=\"连续型随机变量的条件分布\"><a href=\"#连续型随机变量的条件分布\" class=\"headerlink\" title=\"连续型随机变量的条件分布\"></a>连续型随机变量的条件分布</h2><p>对于连续型的随机变量，条件分布的定义如下：</p>\n<p>设二维随机变量 $(X,Y)$ 的概率密度函数为 $f(x,y),(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ .若对于固定的 $y，f_Y(y)&gt;0$ ，则称 $\\frac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度。记为</p>\n<script type=\"math/tex; mode=display\">f_{X|Y}(x|y) = \\frac{f(x,y)}{f_Y(y)}</script><p>有了条件概率密度(就是条件概率密度函数)，我们也可以定义出条件分布函数如下</p>\n<script type=\"math/tex; mode=display\">\\int_{-\\infty}^x f_{X|Y}(x|y)dx = \\int_{-\\infty}^x \\frac{f(x,y)}{f_Y(y)}dx</script><p>上面的函数为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为</p>\n<script type=\"math/tex; mode=display\">F_{X|Y}(x|y) = P(X \\le x| Y=y)</script><h1 id=\"相互独立的随机变量\"><a href=\"#相互独立的随机变量\" class=\"headerlink\" title=\"相互独立的随机变量\"></a>相互独立的随机变量</h1><p>两个随机变量 $X,Y$ 相互独立的充要条件如下：</p>\n<script type=\"math/tex; mode=display\">F(x,y) = F_X(x)F_Y(y)</script><p>上面的 $F(x,y),F_X(x),F_Y(y)$ 分别是二维随机变量的联合分布函数及关于 $X$ 和 $Y$ 的边缘分布函数。</p>\n<p>除了通过分布函数，对于具体的连续型随机变量或离散型随机变量，还可通过概率密度函数和分布律来定义相互独立的条件。</p>\n<p>对于连续型随机变量，上面的式子等价于</p>\n<script type=\"math/tex; mode=display\">f(x,y) = f_X(x)f_Y(y)</script><p>式子中的 $f(x,y),f_X(x),f_Y(y)$ 分别为 随机变量 $(X,Y)$ 的条件概率密度函数和边缘概率密度函数。</p>\n<p>对于离散型随机变量则有：</p>\n<script type=\"math/tex; mode=display\">P(X = x_i, Y = y_j) = P(X=x_i)P(Y=y_j)</script><h1 id=\"二维随机变量的函数的分布\"><a href=\"#二维随机变量的函数的分布\" class=\"headerlink\" title=\"二维随机变量的函数的分布\"></a>二维随机变量的函数的分布</h1><p>在讨论一维随机变量的分布函数的时候，也讨论了一维随机变量的函数的分布函数，同样对于二维随机变量，我们也可以讨论其函数的分布函数。下面主要讨论 $Z=X+Y，Z=XY，Z=Y/X，M=max(X,Y)，N=min(X,Y)$ 这几个函数的分布函数（X，Y 为相互独立的随机变量），这里主要给出具体的公式，证明省略。</p>\n<h2 id=\"Z-X-Y-的分布\"><a href=\"#Z-X-Y-的分布\" class=\"headerlink\" title=\"$Z=X+Y$ 的分布\"></a>$Z=X+Y$ 的分布</h2><p>设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)， Z=X+Y$ 仍然为连续性随机变量，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(z-y,y)dy</script><p>或</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(x,z-x)dx</script><p>当 $X,Y$ 相互独立时，其边缘概率密度函数具有以下性质</p>\n<script type=\"math/tex; mode=display\">f(x,y) = f_X(x)f_Y(y)</script><p>因此上面的式子也可以化成下面的形式</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(z-y)f_Y(y)dy\\\\\nf_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(x)f_Y(z-x)dx</script><h2 id=\"Z-XY-和-Z-Y-X-的分布\"><a href=\"#Z-XY-和-Z-Y-X-的分布\" class=\"headerlink\" title=\"$Z=XY$ 和 $Z=Y/X$ 的分布\"></a>$Z=XY$ 和 $Z=Y/X$ 的分布</h2><p>设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)$， $Z = \\frac{Y}{X},Z = XY$仍然为连续性随机变量，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f(x,xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f(x,z/x)dx</script><p>当 $X,Y$ 相互独立时，同样有下面的性质</p>\n<script type=\"math/tex; mode=display\">f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f_X(x)f_Y(xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f_X(x)f_Y(z/x)dx</script><h2 id=\"M-max-X-Y-和-N-min-X-Y-的分布\"><a href=\"#M-max-X-Y-和-N-min-X-Y-的分布\" class=\"headerlink\" title=\"$M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布\"></a>$M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布</h2><p>讨论 $max(X,Y)$ 和 $min(X,Y)$ 的分布的时候， 一般假设 $X,Y$ 相互独立，因为这样才有下面的性质。</p>\n<p>对于 $M=max(X,Y)$ 的分布有</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = P(M \\le z) = P(X \\le z, Y \\le z) = P(X \\le z)P(Y \\le z)</script><p>由于 $X$ 和 $Y$ 相互独立，因此有</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = F_X(z)F_Y(z)</script><p>同样对 $N=min(X,Y)$ 有</p>\n<script type=\"math/tex; mode=display\">F_{min}(z) = P(N \\le z) = 1 - P(N \\gt z) = 1 - P(X > z)P(Y>z)</script><p>即</p>\n<script type=\"math/tex; mode=display\">F_{min}(z) = 1 - (1 - F_X(z))(1 - F_Y(z))</script><p>推广到 n 个相互独立的随机变量有下面的性质</p>\n<p>$M = max \\lbrace X_1,X_2…,X_n \\rbrace$ 及 $N = min\\lbrace X_1,X_2…,X_n \\rbrace$ 的分布函数分别为</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = F_{X_1}(z)F_{X_2}(z)…F_{X_n}(z) \\\\\nF_{min}(z) = 1 - (1 - F_{X_1}(z))(1 - F_{X_2}(z))…(1 - F_{X_n}(z))</script><p>而当 $X_1,X_2…,X_n$ 独立同分布的时候，上式变为如下所示</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = [F(z)]^n\\\\\nF_{min}(z) = 1 - (1 - F(z))^n</script>","site":{"data":{}},"excerpt":"<h1 id=\"联合分布函数\"><a href=\"#联合分布函数\" class=\"headerlink\" title=\"联合分布函数\"></a>联合分布函数</h1><p>假设 $X$ 和 $Y$ 都是随机变量，那么我们定义其分布函数如下：</p>\n<script type=\"math/tex; mode=display\">F(x,y) = P ((X \\le x)\\cap(Y \\le y)) =  P (X \\le x, Y \\le y )</script><p>上面的 $F(x,y)$ 称作随机变量$(X,Y)$的分布函数，也叫作联合分布函数。<br></p>","more":"<p></p>\n<h2 id=\"离散型随机变量联合分布\"><a href=\"#离散型随机变量联合分布\" class=\"headerlink\" title=\"离散型随机变量联合分布\"></a>离散型随机变量联合分布</h2><p>如果上面的 $X$ 和 $Y$ 都是离散随机变量，那么对于 $(X,Y)$ 的所有取值可记为</p>\n<script type=\"math/tex; mode=display\">P(X=x_i, Y=y_i) = p_{ij},i,j=1,2,….</script><p>上面的所有P的取值为二维离散随机变量的分布律，也叫联合分布律。直观用表格表示如下所示</p>\n<p><img src=\"/2017/08/15/二维随机变量/二维随机变量-a083d527.png\" alt=\"\"></p>\n<p>连续型随机变量联合分布<br>类似地，如果上面的X和Y都是连续随机变量，那么分布函数可定义为</p>\n<script type=\"math/tex; mode=display\">F(x,y) = \\int_{-\\infty}^y\\int_{-\\infty}^xf(u,v)dudv</script><p>其中 $f(x,y)$ 被称为概率密度函数，也叫联合概率密度函数。</p>\n<p>其性质与一维随机变量的概率密度函数非常相似</p>\n<ol>\n<li>$f(x,y)≥0$</li>\n<li>$\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)$</li>\n<li>设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在$G$内的概率为<script type=\"math/tex; mode=display\">\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)dxdy = F(\\infty,\\infty)</script></li>\n<li>若 $f(x,y)$ 在点 $(x,y)$ 连续，则<script type=\"math/tex; mode=display\">\\frac{\\partial^2F(X,Y)}{\\partial x \\partial y} = f(x, y)</script></li>\n</ol>\n<h1 id=\"边缘分布函数\"><a href=\"#边缘分布函数\" class=\"headerlink\" title=\"边缘分布函数\"></a>边缘分布函数</h1><p>二维随机变量 $(X,Y)$ 作为一个整体的时候，其分布函数为联合分布函数，但是 $X$ 和 $Y$ 是随机变量，各自也有分布函数，将其分别记为 $F_X(x),F_Y(y)$，称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的<strong>边缘分布函数</strong>。</p>\n<p>边缘分布函数可通过联合分布函数确定，关系如下</p>\n<script type=\"math/tex; mode=display\">F_X(x) = P(X \\le x) = P(X \\le x,Y \\lt \\infty) = F(x, \\infty)</script><script type=\"math/tex; mode=display\">F_X(x)=F(x,∞)\\\\\nF_Y(y)=F(∞,y)</script><h2 id=\"离散型随机变量边缘分布\"><a href=\"#离散型随机变量边缘分布\" class=\"headerlink\" title=\"离散型随机变量边缘分布\"></a>离散型随机变量边缘分布</h2><p>假如 $X$ 和 $Y$ 是离散型随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布定义下</p>\n<script type=\"math/tex; mode=display\">\np_{i.} = \\sum_{j=1}^{\\infty} p_{ij} = P(X = x_i), i=1,2,3…..n \\\\\np_{.j} = \\sum_{i=1}^{\\infty} p_{ij} = P(Y = y_j), j=1,2,3…..n</script><p>上面的式子分别称为随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布率。</p>\n<h2 id=\"连续型随机变量边缘分布\"><a href=\"#连续型随机变量边缘分布\" class=\"headerlink\" title=\"连续型随机变量边缘分布\"></a>连续型随机变量边缘分布</h2><p>假如 $X$ 和 $Y$ 分别是连续性随机变量，那么随机变量 $(X,Y)$ 关于 $X$ 的边缘分布函数定义为</p>\n<script type=\"math/tex; mode=display\">F_X(x) = F(x,\\infty) = \\int_{-\\infty}^{x}(\\int_{-\\infty}^{\\infty}f(x,y)dy)dx=\\int_{-\\infty}^{\\infty}f(x,y)dy</script><p>则被称为随机变量 $(X,Y)$ 关于 $Y$ 的 边缘概率密度函数</p>\n<h1 id=\"条件分布\"><a href=\"#条件分布\" class=\"headerlink\" title=\"条件分布\"></a>条件分布</h1><p>由条件概率可以比较容易推导出条件分布的含义，其定义如下：</p>\n<h2 id=\"离散型随机变量的条件分布\"><a href=\"#离散型随机变量的条件分布\" class=\"headerlink\" title=\"离散型随机变量的条件分布\"></a>离散型随机变量的条件分布</h2><p>对于离散型随机变量，条件分布的定义如下：</p>\n<p>设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P(Y=y_j)&gt;0$, 则称</p>\n<script type=\"math/tex; mode=display\">P(X = x_i|Y= y_j) = \\frac{P(X = x_i, Y=y_j)}{P(Y=y_j)} = \\frac{p_{ij}}{p_{.j}}, i = 1,2,3</script><p>为在 $Y=y_j$ 条件下随机变量X的条件分布律。同理，交换 $X$ 和 $Y$ 的位置得到的是在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。</p>\n<h2 id=\"连续型随机变量的条件分布\"><a href=\"#连续型随机变量的条件分布\" class=\"headerlink\" title=\"连续型随机变量的条件分布\"></a>连续型随机变量的条件分布</h2><p>对于连续型的随机变量，条件分布的定义如下：</p>\n<p>设二维随机变量 $(X,Y)$ 的概率密度函数为 $f(x,y),(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ .若对于固定的 $y，f_Y(y)&gt;0$ ，则称 $\\frac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度。记为</p>\n<script type=\"math/tex; mode=display\">f_{X|Y}(x|y) = \\frac{f(x,y)}{f_Y(y)}</script><p>有了条件概率密度(就是条件概率密度函数)，我们也可以定义出条件分布函数如下</p>\n<script type=\"math/tex; mode=display\">\\int_{-\\infty}^x f_{X|Y}(x|y)dx = \\int_{-\\infty}^x \\frac{f(x,y)}{f_Y(y)}dx</script><p>上面的函数为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为</p>\n<script type=\"math/tex; mode=display\">F_{X|Y}(x|y) = P(X \\le x| Y=y)</script><h1 id=\"相互独立的随机变量\"><a href=\"#相互独立的随机变量\" class=\"headerlink\" title=\"相互独立的随机变量\"></a>相互独立的随机变量</h1><p>两个随机变量 $X,Y$ 相互独立的充要条件如下：</p>\n<script type=\"math/tex; mode=display\">F(x,y) = F_X(x)F_Y(y)</script><p>上面的 $F(x,y),F_X(x),F_Y(y)$ 分别是二维随机变量的联合分布函数及关于 $X$ 和 $Y$ 的边缘分布函数。</p>\n<p>除了通过分布函数，对于具体的连续型随机变量或离散型随机变量，还可通过概率密度函数和分布律来定义相互独立的条件。</p>\n<p>对于连续型随机变量，上面的式子等价于</p>\n<script type=\"math/tex; mode=display\">f(x,y) = f_X(x)f_Y(y)</script><p>式子中的 $f(x,y),f_X(x),f_Y(y)$ 分别为 随机变量 $(X,Y)$ 的条件概率密度函数和边缘概率密度函数。</p>\n<p>对于离散型随机变量则有：</p>\n<script type=\"math/tex; mode=display\">P(X = x_i, Y = y_j) = P(X=x_i)P(Y=y_j)</script><h1 id=\"二维随机变量的函数的分布\"><a href=\"#二维随机变量的函数的分布\" class=\"headerlink\" title=\"二维随机变量的函数的分布\"></a>二维随机变量的函数的分布</h1><p>在讨论一维随机变量的分布函数的时候，也讨论了一维随机变量的函数的分布函数，同样对于二维随机变量，我们也可以讨论其函数的分布函数。下面主要讨论 $Z=X+Y，Z=XY，Z=Y/X，M=max(X,Y)，N=min(X,Y)$ 这几个函数的分布函数（X，Y 为相互独立的随机变量），这里主要给出具体的公式，证明省略。</p>\n<h2 id=\"Z-X-Y-的分布\"><a href=\"#Z-X-Y-的分布\" class=\"headerlink\" title=\"$Z=X+Y$ 的分布\"></a>$Z=X+Y$ 的分布</h2><p>设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)， Z=X+Y$ 仍然为连续性随机变量，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(z-y,y)dy</script><p>或</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f(x,z-x)dx</script><p>当 $X,Y$ 相互独立时，其边缘概率密度函数具有以下性质</p>\n<script type=\"math/tex; mode=display\">f(x,y) = f_X(x)f_Y(y)</script><p>因此上面的式子也可以化成下面的形式</p>\n<script type=\"math/tex; mode=display\">f_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(z-y)f_Y(y)dy\\\\\nf_{X+Y}(z) = \\int_{-\\infty}^{\\infty} f_X(x)f_Y(z-x)dx</script><h2 id=\"Z-XY-和-Z-Y-X-的分布\"><a href=\"#Z-XY-和-Z-Y-X-的分布\" class=\"headerlink\" title=\"$Z=XY$ 和 $Z=Y/X$ 的分布\"></a>$Z=XY$ 和 $Z=Y/X$ 的分布</h2><p>设 $(X,Y)$ 是二维连续型随机变量，其概率密度函数为 $f(x,y)$， $Z = \\frac{Y}{X},Z = XY$仍然为连续性随机变量，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f(x,xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f(x,z/x)dx</script><p>当 $X,Y$ 相互独立时，同样有下面的性质</p>\n<script type=\"math/tex; mode=display\">f_{Y/X}(z) = \\int_{-\\infty}^{\\infty} |x|f_X(x)f_Y(xz)dx\\\\\nf_{XY}(z) = \\int_{-\\infty}^{\\infty} \\frac{1}{|x|}f_X(x)f_Y(z/x)dx</script><h2 id=\"M-max-X-Y-和-N-min-X-Y-的分布\"><a href=\"#M-max-X-Y-和-N-min-X-Y-的分布\" class=\"headerlink\" title=\"$M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布\"></a>$M=max(X,Y)$ 和 $N=min(X,Y)$ 的分布</h2><p>讨论 $max(X,Y)$ 和 $min(X,Y)$ 的分布的时候， 一般假设 $X,Y$ 相互独立，因为这样才有下面的性质。</p>\n<p>对于 $M=max(X,Y)$ 的分布有</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = P(M \\le z) = P(X \\le z, Y \\le z) = P(X \\le z)P(Y \\le z)</script><p>由于 $X$ 和 $Y$ 相互独立，因此有</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = F_X(z)F_Y(z)</script><p>同样对 $N=min(X,Y)$ 有</p>\n<script type=\"math/tex; mode=display\">F_{min}(z) = P(N \\le z) = 1 - P(N \\gt z) = 1 - P(X > z)P(Y>z)</script><p>即</p>\n<script type=\"math/tex; mode=display\">F_{min}(z) = 1 - (1 - F_X(z))(1 - F_Y(z))</script><p>推广到 n 个相互独立的随机变量有下面的性质</p>\n<p>$M = max \\lbrace X_1,X_2…,X_n \\rbrace$ 及 $N = min\\lbrace X_1,X_2…,X_n \\rbrace$ 的分布函数分别为</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = F_{X_1}(z)F_{X_2}(z)…F_{X_n}(z) \\\\\nF_{min}(z) = 1 - (1 - F_{X_1}(z))(1 - F_{X_2}(z))…(1 - F_{X_n}(z))</script><p>而当 $X_1,X_2…,X_n$ 独立同分布的时候，上式变为如下所示</p>\n<script type=\"math/tex; mode=display\">F_{max}(z) = [F(z)]^n\\\\\nF_{min}(z) = 1 - (1 - F(z))^n</script>"},{"title":"先验概率与后验概率","date":"2017-08-15T14:18:36.000Z","_content":"\n**本文主要讲述先验概率，后验概率，共轭分布和共轭先验这几个概念。**\n\n众所周知，概率论中有两大学派：频率学派和贝叶斯学派。先验概率，后验概率，共轭分布和共轭先验是贝叶斯学派中的几个概念。原因是贝叶斯学派认为分布存在先验分布和后验分布的不同，而频率学派则认为一个事件的概率只有一个。\n\n下面先以一个直观的例子来说明先验概率和后验概率的概念\n\n比如说，你来到一个山洞,这个山洞里可能有熊也可能没有熊, 记你觉得山洞有熊的为事件 $Y$. 然后,你也许听到山洞里传来熊的吼声, 记听到熊吼声为事件 $X$. 你一开始认为山洞有熊的概率是 $P(Y)$; 听到熊的吼声之后,你认为有熊的概率是 $P(Y|X)$。在这里，$P(Y)$ 就是先验概率, $P(Y|X)$ 是后验概率.\n<!--more-->\n\n回到概率论中一个经典的例子:抛硬币。抛硬币时抛出正面的概率为多大？假如事前关于这枚硬币没有任何额外信息，那么一般都会认为是 1/2，这时候的 1/2 就是正面朝上的先验概率 。但是在经过一系列实验确认后再得到的正面朝上的概率很可能就不是1/2了(受到到硬币的质地，重量分布等因素的影响)，这个概率便是后验概率。\n\n简单理解就是在事件发生之前，**根据以往的经验推测的与该事件相关的概率就是先验概率，而在事件(试验)真正发生后，通过事件(试验)的结果可以修正先验概率，从而得到后验概率。**\n\n# 贝叶斯学派\n那么对于抛硬币这个事件来说，抛出正面硬币的概率就应该是一个概率的概率，也就是说它的结果不是一个单一的值 1/2，而是一个概率分布，可能有很高的概率是1/2，但是也有一定的概率是100%（比如抛100次结果还真都100次都是正面）。那么在这里这个概率的分布用函数来表示就是一个似然函数，所以似然函数也被称为“分布的分布”。用公式来表示就是：\n\n<center>\n后验概率（posterior probability）$∝$ 似然函数（likelyhood function）*先验概率（prior probability）\n</center>\n即：\n\n$$P(θ|X)∝P(θ|X)∗P(θ)$$\n这里 $X$ 表示一组观测实验(比如我扔了五次硬币得到5次正反面的结果)，$θ$ 表示随机函数里面的参数（在这里就是硬币掷为正面的概率）。\n\n注意这里是正比于而不是等于，这个是理解似然函数的一个关键，右侧直接的乘积其实是不满足概率分布归一化的条件的（就是右侧的积分最后不会等于1）那么这个正比符号怎样才能变成等号呢？其实只要再除以一个系数进行归一化就可以了：\n\n$$P(θ|x) = ( P(x|θ) * P(θ) ) / P(x)$$\n\n- $P(θ|x)$ 是后验概率，一般是我们求解的目标。\n- $P(x|θ)$ 是条件概率，又叫似然概率，一般是通过历史数据统计得到。一般不把它叫做先验概率，但从定义上也符合先验定义。\n- $P(θ)$ 是先验概率，一般都是人主观给出的。贝叶斯中的先验概率一般特指它。\n- $P(x)$ 其实也是先验概率，只是在贝叶斯的很多应用中不重要（因为只要最大后验不求绝对值），需要时往往用全概率公式计算得到。\n\n\n\n\n# 频率学派\n\n频率学派认为每个事件的概率是一个客观存在的常数值，只是我们不知道而已。比如抛硬币，在实验估计之前我们不知道它是多少，频率学派也不会管之前大家说抛硬币出现正面的概率是1/2还是多少，所谓“眼见为实，耳听为虚”，他们的最终结论只和在实验中观测到的数据有关系。但是它肯定是一个确定的常数，然后我们通过观察实验，获得一组样本值 $D$，再将这组样本值代入似然函数 $P(D|X)$ ，求解使得似然函数最大的值就是估计出来的（当然由于实验的结果不同，这个估计出来的也很可能不是1/2，实验不同得到的结果也不同，但是根据大数定律，理论上实验次数足够多以后，求出来的是会越来越接近真实的概率的）。也就是说频率学派认为答案只有一个，我们不断地通过各种估计法来猜测这个值。\n\n而贝叶斯学派并不会完全拒绝大家之前所说的“硬币扔出正面的概率是1/2”的说法，只是贝叶斯学派认为最终硬币扔出正面反面的概率并不是一个常数值，不是一个有唯一答案的真理，这个值本身应该也是一个随机变量，是在不断变化的一个数值，如何得到这个值，贝叶斯学派认为也需要通过实验在“硬币扔出正面的概率是1/2”的说法（先验概率）的基础上通过实验数据（似然函数）不断去预估这个扔出正面概率的实际分布（后验分布）。\n\n# 举例说明\n\n举个例子：假如我扔了5次硬币，先出现了3次正面，后出现了两次反面，那么这时的似然函数就应该是 $P(X|θ)=L(θ)=θ∗θ∗θ∗(1−θ)∗(1−θ)$ ($θ$ 是硬币抛正面的概率，在似然函数里就相当于概率分布函数里的随机变量一样变成一个随机变化的值了）\n\n如果用我们以前统计课本上的频率学派的最大似然估计法，对$L(θ)$求导求最大值，得到 $θ=3/5$， 那么得出结论就是最后抛硬币为正面的概率就是 $3/5$，当然还要附上一个参数估计的置信度，表示这个结论自然不是100%准确的\n\n但是如果采用贝叶斯学派的后验概率$P(θ|X)=P(X|θ)∗P(θ)/P(X)=L(θ)∗P(θ)/P(X)$，\n\n其中 $P(X)$ 可以简单地由古典概型算出来：$P(X)=1/=1/32=0.03125$。如果 $θ$ 取了 $3/5$，代入上式那么抛硬币为正面的概率就是 $0.6*0.6*0.6*0.4*0.4*0.5/0.03125=0.55296$其中先验概率$P(θ)=0.5$，而不是1/2，当然贝叶斯学派最终得到的后验概率是一个随 $θ$ 变化的分布，只不过在这种情况这个分布取到 0.55296 这个值的概率最大而已\n\n清楚似然函数、先验概率、后验概率的几个贝叶斯学派的基本概念，要明白共轭分布和共轭先验就很简单了，所谓共轭分布就是先验概率和后验概率具有一样函数形式的分布形式，\n\n那么共轭先验又是什么概念呢？因为在现实建模问题中，往往我们先得到和固定的反而是似然函数（其实也很好理解，客观的实验观察数据才是第一手最solid的材料），这时先验函数（可以理解为先验知识或者是对后验分布的一种假设和猜测）是可以选择的。这时如果我选的先验分布最后乘上这个似然函数，使得后验分布与先验分布共轭，那么我们就称这个先验函数为似然函数的共轭先验。基于上面说到的共轭分布的好处，往往选择先验函数时都会让先验概率分布和后验概率分布共轭。\n","source":"_posts/先验概率与后验概率.md","raw":"---\ntitle: 先验概率与后验概率\ndate: 2017-08-15 22:18:36\ntags: [人工智能,概率,统计]\ncategories: 数学\n---\n\n**本文主要讲述先验概率，后验概率，共轭分布和共轭先验这几个概念。**\n\n众所周知，概率论中有两大学派：频率学派和贝叶斯学派。先验概率，后验概率，共轭分布和共轭先验是贝叶斯学派中的几个概念。原因是贝叶斯学派认为分布存在先验分布和后验分布的不同，而频率学派则认为一个事件的概率只有一个。\n\n下面先以一个直观的例子来说明先验概率和后验概率的概念\n\n比如说，你来到一个山洞,这个山洞里可能有熊也可能没有熊, 记你觉得山洞有熊的为事件 $Y$. 然后,你也许听到山洞里传来熊的吼声, 记听到熊吼声为事件 $X$. 你一开始认为山洞有熊的概率是 $P(Y)$; 听到熊的吼声之后,你认为有熊的概率是 $P(Y|X)$。在这里，$P(Y)$ 就是先验概率, $P(Y|X)$ 是后验概率.\n<!--more-->\n\n回到概率论中一个经典的例子:抛硬币。抛硬币时抛出正面的概率为多大？假如事前关于这枚硬币没有任何额外信息，那么一般都会认为是 1/2，这时候的 1/2 就是正面朝上的先验概率 。但是在经过一系列实验确认后再得到的正面朝上的概率很可能就不是1/2了(受到到硬币的质地，重量分布等因素的影响)，这个概率便是后验概率。\n\n简单理解就是在事件发生之前，**根据以往的经验推测的与该事件相关的概率就是先验概率，而在事件(试验)真正发生后，通过事件(试验)的结果可以修正先验概率，从而得到后验概率。**\n\n# 贝叶斯学派\n那么对于抛硬币这个事件来说，抛出正面硬币的概率就应该是一个概率的概率，也就是说它的结果不是一个单一的值 1/2，而是一个概率分布，可能有很高的概率是1/2，但是也有一定的概率是100%（比如抛100次结果还真都100次都是正面）。那么在这里这个概率的分布用函数来表示就是一个似然函数，所以似然函数也被称为“分布的分布”。用公式来表示就是：\n\n<center>\n后验概率（posterior probability）$∝$ 似然函数（likelyhood function）*先验概率（prior probability）\n</center>\n即：\n\n$$P(θ|X)∝P(θ|X)∗P(θ)$$\n这里 $X$ 表示一组观测实验(比如我扔了五次硬币得到5次正反面的结果)，$θ$ 表示随机函数里面的参数（在这里就是硬币掷为正面的概率）。\n\n注意这里是正比于而不是等于，这个是理解似然函数的一个关键，右侧直接的乘积其实是不满足概率分布归一化的条件的（就是右侧的积分最后不会等于1）那么这个正比符号怎样才能变成等号呢？其实只要再除以一个系数进行归一化就可以了：\n\n$$P(θ|x) = ( P(x|θ) * P(θ) ) / P(x)$$\n\n- $P(θ|x)$ 是后验概率，一般是我们求解的目标。\n- $P(x|θ)$ 是条件概率，又叫似然概率，一般是通过历史数据统计得到。一般不把它叫做先验概率，但从定义上也符合先验定义。\n- $P(θ)$ 是先验概率，一般都是人主观给出的。贝叶斯中的先验概率一般特指它。\n- $P(x)$ 其实也是先验概率，只是在贝叶斯的很多应用中不重要（因为只要最大后验不求绝对值），需要时往往用全概率公式计算得到。\n\n\n\n\n# 频率学派\n\n频率学派认为每个事件的概率是一个客观存在的常数值，只是我们不知道而已。比如抛硬币，在实验估计之前我们不知道它是多少，频率学派也不会管之前大家说抛硬币出现正面的概率是1/2还是多少，所谓“眼见为实，耳听为虚”，他们的最终结论只和在实验中观测到的数据有关系。但是它肯定是一个确定的常数，然后我们通过观察实验，获得一组样本值 $D$，再将这组样本值代入似然函数 $P(D|X)$ ，求解使得似然函数最大的值就是估计出来的（当然由于实验的结果不同，这个估计出来的也很可能不是1/2，实验不同得到的结果也不同，但是根据大数定律，理论上实验次数足够多以后，求出来的是会越来越接近真实的概率的）。也就是说频率学派认为答案只有一个，我们不断地通过各种估计法来猜测这个值。\n\n而贝叶斯学派并不会完全拒绝大家之前所说的“硬币扔出正面的概率是1/2”的说法，只是贝叶斯学派认为最终硬币扔出正面反面的概率并不是一个常数值，不是一个有唯一答案的真理，这个值本身应该也是一个随机变量，是在不断变化的一个数值，如何得到这个值，贝叶斯学派认为也需要通过实验在“硬币扔出正面的概率是1/2”的说法（先验概率）的基础上通过实验数据（似然函数）不断去预估这个扔出正面概率的实际分布（后验分布）。\n\n# 举例说明\n\n举个例子：假如我扔了5次硬币，先出现了3次正面，后出现了两次反面，那么这时的似然函数就应该是 $P(X|θ)=L(θ)=θ∗θ∗θ∗(1−θ)∗(1−θ)$ ($θ$ 是硬币抛正面的概率，在似然函数里就相当于概率分布函数里的随机变量一样变成一个随机变化的值了）\n\n如果用我们以前统计课本上的频率学派的最大似然估计法，对$L(θ)$求导求最大值，得到 $θ=3/5$， 那么得出结论就是最后抛硬币为正面的概率就是 $3/5$，当然还要附上一个参数估计的置信度，表示这个结论自然不是100%准确的\n\n但是如果采用贝叶斯学派的后验概率$P(θ|X)=P(X|θ)∗P(θ)/P(X)=L(θ)∗P(θ)/P(X)$，\n\n其中 $P(X)$ 可以简单地由古典概型算出来：$P(X)=1/=1/32=0.03125$。如果 $θ$ 取了 $3/5$，代入上式那么抛硬币为正面的概率就是 $0.6*0.6*0.6*0.4*0.4*0.5/0.03125=0.55296$其中先验概率$P(θ)=0.5$，而不是1/2，当然贝叶斯学派最终得到的后验概率是一个随 $θ$ 变化的分布，只不过在这种情况这个分布取到 0.55296 这个值的概率最大而已\n\n清楚似然函数、先验概率、后验概率的几个贝叶斯学派的基本概念，要明白共轭分布和共轭先验就很简单了，所谓共轭分布就是先验概率和后验概率具有一样函数形式的分布形式，\n\n那么共轭先验又是什么概念呢？因为在现实建模问题中，往往我们先得到和固定的反而是似然函数（其实也很好理解，客观的实验观察数据才是第一手最solid的材料），这时先验函数（可以理解为先验知识或者是对后验分布的一种假设和猜测）是可以选择的。这时如果我选的先验分布最后乘上这个似然函数，使得后验分布与先验分布共轭，那么我们就称这个先验函数为似然函数的共轭先验。基于上面说到的共轭分布的好处，往往选择先验函数时都会让先验概率分布和后验概率分布共轭。\n","slug":"先验概率与后验概率","published":1,"updated":"2019-07-30T01:54:38.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izo003thomj569m2p5j","content":"<p><strong>本文主要讲述先验概率，后验概率，共轭分布和共轭先验这几个概念。</strong></p>\n<p>众所周知，概率论中有两大学派：频率学派和贝叶斯学派。先验概率，后验概率，共轭分布和共轭先验是贝叶斯学派中的几个概念。原因是贝叶斯学派认为分布存在先验分布和后验分布的不同，而频率学派则认为一个事件的概率只有一个。</p>\n<p>下面先以一个直观的例子来说明先验概率和后验概率的概念</p>\n<p>比如说，你来到一个山洞,这个山洞里可能有熊也可能没有熊, 记你觉得山洞有熊的为事件 $Y$. 然后,你也许听到山洞里传来熊的吼声, 记听到熊吼声为事件 $X$. 你一开始认为山洞有熊的概率是 $P(Y)$; 听到熊的吼声之后,你认为有熊的概率是 $P(Y|X)$。在这里，$P(Y)$ 就是先验概率, $P(Y|X)$ 是后验概率.<br><a id=\"more\"></a></p>\n<p>回到概率论中一个经典的例子:抛硬币。抛硬币时抛出正面的概率为多大？假如事前关于这枚硬币没有任何额外信息，那么一般都会认为是 1/2，这时候的 1/2 就是正面朝上的先验概率 。但是在经过一系列实验确认后再得到的正面朝上的概率很可能就不是1/2了(受到到硬币的质地，重量分布等因素的影响)，这个概率便是后验概率。</p>\n<p>简单理解就是在事件发生之前，<strong>根据以往的经验推测的与该事件相关的概率就是先验概率，而在事件(试验)真正发生后，通过事件(试验)的结果可以修正先验概率，从而得到后验概率。</strong></p>\n<h1 id=\"贝叶斯学派\"><a href=\"#贝叶斯学派\" class=\"headerlink\" title=\"贝叶斯学派\"></a>贝叶斯学派</h1><p>那么对于抛硬币这个事件来说，抛出正面硬币的概率就应该是一个概率的概率，也就是说它的结果不是一个单一的值 1/2，而是一个概率分布，可能有很高的概率是1/2，但是也有一定的概率是100%（比如抛100次结果还真都100次都是正面）。那么在这里这个概率的分布用函数来表示就是一个似然函数，所以似然函数也被称为“分布的分布”。用公式来表示就是：</p>\n<p><center>\n后验概率（posterior probability）$∝$ 似然函数（likelyhood function）*先验概率（prior probability）\n</center><br>即：</p>\n<script type=\"math/tex; mode=display\">P(θ|X)∝P(θ|X)∗P(θ)</script><p>这里 $X$ 表示一组观测实验(比如我扔了五次硬币得到5次正反面的结果)，$θ$ 表示随机函数里面的参数（在这里就是硬币掷为正面的概率）。</p>\n<p>注意这里是正比于而不是等于，这个是理解似然函数的一个关键，右侧直接的乘积其实是不满足概率分布归一化的条件的（就是右侧的积分最后不会等于1）那么这个正比符号怎样才能变成等号呢？其实只要再除以一个系数进行归一化就可以了：</p>\n<script type=\"math/tex; mode=display\">P(θ|x) = ( P(x|θ) * P(θ) ) / P(x)</script><ul>\n<li>$P(θ|x)$ 是后验概率，一般是我们求解的目标。</li>\n<li>$P(x|θ)$ 是条件概率，又叫似然概率，一般是通过历史数据统计得到。一般不把它叫做先验概率，但从定义上也符合先验定义。</li>\n<li>$P(θ)$ 是先验概率，一般都是人主观给出的。贝叶斯中的先验概率一般特指它。</li>\n<li>$P(x)$ 其实也是先验概率，只是在贝叶斯的很多应用中不重要（因为只要最大后验不求绝对值），需要时往往用全概率公式计算得到。</li>\n</ul>\n<h1 id=\"频率学派\"><a href=\"#频率学派\" class=\"headerlink\" title=\"频率学派\"></a>频率学派</h1><p>频率学派认为每个事件的概率是一个客观存在的常数值，只是我们不知道而已。比如抛硬币，在实验估计之前我们不知道它是多少，频率学派也不会管之前大家说抛硬币出现正面的概率是1/2还是多少，所谓“眼见为实，耳听为虚”，他们的最终结论只和在实验中观测到的数据有关系。但是它肯定是一个确定的常数，然后我们通过观察实验，获得一组样本值 $D$，再将这组样本值代入似然函数 $P(D|X)$ ，求解使得似然函数最大的值就是估计出来的（当然由于实验的结果不同，这个估计出来的也很可能不是1/2，实验不同得到的结果也不同，但是根据大数定律，理论上实验次数足够多以后，求出来的是会越来越接近真实的概率的）。也就是说频率学派认为答案只有一个，我们不断地通过各种估计法来猜测这个值。</p>\n<p>而贝叶斯学派并不会完全拒绝大家之前所说的“硬币扔出正面的概率是1/2”的说法，只是贝叶斯学派认为最终硬币扔出正面反面的概率并不是一个常数值，不是一个有唯一答案的真理，这个值本身应该也是一个随机变量，是在不断变化的一个数值，如何得到这个值，贝叶斯学派认为也需要通过实验在“硬币扔出正面的概率是1/2”的说法（先验概率）的基础上通过实验数据（似然函数）不断去预估这个扔出正面概率的实际分布（后验分布）。</p>\n<h1 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h1><p>举个例子：假如我扔了5次硬币，先出现了3次正面，后出现了两次反面，那么这时的似然函数就应该是 $P(X|θ)=L(θ)=θ∗θ∗θ∗(1−θ)∗(1−θ)$ ($θ$ 是硬币抛正面的概率，在似然函数里就相当于概率分布函数里的随机变量一样变成一个随机变化的值了）</p>\n<p>如果用我们以前统计课本上的频率学派的最大似然估计法，对$L(θ)$求导求最大值，得到 $θ=3/5$， 那么得出结论就是最后抛硬币为正面的概率就是 $3/5$，当然还要附上一个参数估计的置信度，表示这个结论自然不是100%准确的</p>\n<p>但是如果采用贝叶斯学派的后验概率$P(θ|X)=P(X|θ)∗P(θ)/P(X)=L(θ)∗P(θ)/P(X)$，</p>\n<p>其中 $P(X)$ 可以简单地由古典概型算出来：$P(X)=1/=1/32=0.03125$。如果 $θ$ 取了 $3/5$，代入上式那么抛硬币为正面的概率就是 $0.6<em>0.6</em>0.6<em>0.4</em>0.4*0.5/0.03125=0.55296$其中先验概率$P(θ)=0.5$，而不是1/2，当然贝叶斯学派最终得到的后验概率是一个随 $θ$ 变化的分布，只不过在这种情况这个分布取到 0.55296 这个值的概率最大而已</p>\n<p>清楚似然函数、先验概率、后验概率的几个贝叶斯学派的基本概念，要明白共轭分布和共轭先验就很简单了，所谓共轭分布就是先验概率和后验概率具有一样函数形式的分布形式，</p>\n<p>那么共轭先验又是什么概念呢？因为在现实建模问题中，往往我们先得到和固定的反而是似然函数（其实也很好理解，客观的实验观察数据才是第一手最solid的材料），这时先验函数（可以理解为先验知识或者是对后验分布的一种假设和猜测）是可以选择的。这时如果我选的先验分布最后乘上这个似然函数，使得后验分布与先验分布共轭，那么我们就称这个先验函数为似然函数的共轭先验。基于上面说到的共轭分布的好处，往往选择先验函数时都会让先验概率分布和后验概率分布共轭。</p>\n","site":{"data":{}},"excerpt":"<p><strong>本文主要讲述先验概率，后验概率，共轭分布和共轭先验这几个概念。</strong></p>\n<p>众所周知，概率论中有两大学派：频率学派和贝叶斯学派。先验概率，后验概率，共轭分布和共轭先验是贝叶斯学派中的几个概念。原因是贝叶斯学派认为分布存在先验分布和后验分布的不同，而频率学派则认为一个事件的概率只有一个。</p>\n<p>下面先以一个直观的例子来说明先验概率和后验概率的概念</p>\n<p>比如说，你来到一个山洞,这个山洞里可能有熊也可能没有熊, 记你觉得山洞有熊的为事件 $Y$. 然后,你也许听到山洞里传来熊的吼声, 记听到熊吼声为事件 $X$. 你一开始认为山洞有熊的概率是 $P(Y)$; 听到熊的吼声之后,你认为有熊的概率是 $P(Y|X)$。在这里，$P(Y)$ 就是先验概率, $P(Y|X)$ 是后验概率.<br></p>","more":"<p></p>\n<p>回到概率论中一个经典的例子:抛硬币。抛硬币时抛出正面的概率为多大？假如事前关于这枚硬币没有任何额外信息，那么一般都会认为是 1/2，这时候的 1/2 就是正面朝上的先验概率 。但是在经过一系列实验确认后再得到的正面朝上的概率很可能就不是1/2了(受到到硬币的质地，重量分布等因素的影响)，这个概率便是后验概率。</p>\n<p>简单理解就是在事件发生之前，<strong>根据以往的经验推测的与该事件相关的概率就是先验概率，而在事件(试验)真正发生后，通过事件(试验)的结果可以修正先验概率，从而得到后验概率。</strong></p>\n<h1 id=\"贝叶斯学派\"><a href=\"#贝叶斯学派\" class=\"headerlink\" title=\"贝叶斯学派\"></a>贝叶斯学派</h1><p>那么对于抛硬币这个事件来说，抛出正面硬币的概率就应该是一个概率的概率，也就是说它的结果不是一个单一的值 1/2，而是一个概率分布，可能有很高的概率是1/2，但是也有一定的概率是100%（比如抛100次结果还真都100次都是正面）。那么在这里这个概率的分布用函数来表示就是一个似然函数，所以似然函数也被称为“分布的分布”。用公式来表示就是：</p>\n<p><center>\n后验概率（posterior probability）$∝$ 似然函数（likelyhood function）*先验概率（prior probability）\n</center><br>即：</p>\n<script type=\"math/tex; mode=display\">P(θ|X)∝P(θ|X)∗P(θ)</script><p>这里 $X$ 表示一组观测实验(比如我扔了五次硬币得到5次正反面的结果)，$θ$ 表示随机函数里面的参数（在这里就是硬币掷为正面的概率）。</p>\n<p>注意这里是正比于而不是等于，这个是理解似然函数的一个关键，右侧直接的乘积其实是不满足概率分布归一化的条件的（就是右侧的积分最后不会等于1）那么这个正比符号怎样才能变成等号呢？其实只要再除以一个系数进行归一化就可以了：</p>\n<script type=\"math/tex; mode=display\">P(θ|x) = ( P(x|θ) * P(θ) ) / P(x)</script><ul>\n<li>$P(θ|x)$ 是后验概率，一般是我们求解的目标。</li>\n<li>$P(x|θ)$ 是条件概率，又叫似然概率，一般是通过历史数据统计得到。一般不把它叫做先验概率，但从定义上也符合先验定义。</li>\n<li>$P(θ)$ 是先验概率，一般都是人主观给出的。贝叶斯中的先验概率一般特指它。</li>\n<li>$P(x)$ 其实也是先验概率，只是在贝叶斯的很多应用中不重要（因为只要最大后验不求绝对值），需要时往往用全概率公式计算得到。</li>\n</ul>\n<h1 id=\"频率学派\"><a href=\"#频率学派\" class=\"headerlink\" title=\"频率学派\"></a>频率学派</h1><p>频率学派认为每个事件的概率是一个客观存在的常数值，只是我们不知道而已。比如抛硬币，在实验估计之前我们不知道它是多少，频率学派也不会管之前大家说抛硬币出现正面的概率是1/2还是多少，所谓“眼见为实，耳听为虚”，他们的最终结论只和在实验中观测到的数据有关系。但是它肯定是一个确定的常数，然后我们通过观察实验，获得一组样本值 $D$，再将这组样本值代入似然函数 $P(D|X)$ ，求解使得似然函数最大的值就是估计出来的（当然由于实验的结果不同，这个估计出来的也很可能不是1/2，实验不同得到的结果也不同，但是根据大数定律，理论上实验次数足够多以后，求出来的是会越来越接近真实的概率的）。也就是说频率学派认为答案只有一个，我们不断地通过各种估计法来猜测这个值。</p>\n<p>而贝叶斯学派并不会完全拒绝大家之前所说的“硬币扔出正面的概率是1/2”的说法，只是贝叶斯学派认为最终硬币扔出正面反面的概率并不是一个常数值，不是一个有唯一答案的真理，这个值本身应该也是一个随机变量，是在不断变化的一个数值，如何得到这个值，贝叶斯学派认为也需要通过实验在“硬币扔出正面的概率是1/2”的说法（先验概率）的基础上通过实验数据（似然函数）不断去预估这个扔出正面概率的实际分布（后验分布）。</p>\n<h1 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h1><p>举个例子：假如我扔了5次硬币，先出现了3次正面，后出现了两次反面，那么这时的似然函数就应该是 $P(X|θ)=L(θ)=θ∗θ∗θ∗(1−θ)∗(1−θ)$ ($θ$ 是硬币抛正面的概率，在似然函数里就相当于概率分布函数里的随机变量一样变成一个随机变化的值了）</p>\n<p>如果用我们以前统计课本上的频率学派的最大似然估计法，对$L(θ)$求导求最大值，得到 $θ=3/5$， 那么得出结论就是最后抛硬币为正面的概率就是 $3/5$，当然还要附上一个参数估计的置信度，表示这个结论自然不是100%准确的</p>\n<p>但是如果采用贝叶斯学派的后验概率$P(θ|X)=P(X|θ)∗P(θ)/P(X)=L(θ)∗P(θ)/P(X)$，</p>\n<p>其中 $P(X)$ 可以简单地由古典概型算出来：$P(X)=1/=1/32=0.03125$。如果 $θ$ 取了 $3/5$，代入上式那么抛硬币为正面的概率就是 $0.6<em>0.6</em>0.6<em>0.4</em>0.4*0.5/0.03125=0.55296$其中先验概率$P(θ)=0.5$，而不是1/2，当然贝叶斯学派最终得到的后验概率是一个随 $θ$ 变化的分布，只不过在这种情况这个分布取到 0.55296 这个值的概率最大而已</p>\n<p>清楚似然函数、先验概率、后验概率的几个贝叶斯学派的基本概念，要明白共轭分布和共轭先验就很简单了，所谓共轭分布就是先验概率和后验概率具有一样函数形式的分布形式，</p>\n<p>那么共轭先验又是什么概念呢？因为在现实建模问题中，往往我们先得到和固定的反而是似然函数（其实也很好理解，客观的实验观察数据才是第一手最solid的材料），这时先验函数（可以理解为先验知识或者是对后验分布的一种假设和猜测）是可以选择的。这时如果我选的先验分布最后乘上这个似然函数，使得后验分布与先验分布共轭，那么我们就称这个先验函数为似然函数的共轭先验。基于上面说到的共轭分布的好处，往往选择先验函数时都会让先验概率分布和后验概率分布共轭。</p>"},{"title":"关系运算-SQL","date":"2019-07-31T03:05:24.000Z","_content":"\n# 集合运算\n\n![数据说明](关系运算-SQL/1564988154852.png)\n\n<!--more-->\n\n## 并\n\n![1564974696180](关系运算-SQL/1564974696180.png)\n\n```sql\nSelect * from R UNION Select * from S;\n```\n\n## 差\n\n![1564974788006](关系运算-SQL/1564974788006.png)\n\n```sql\nSelect * from R Except Select * from S;\n```\n\n## 交\n\n![1564974826998](关系运算-SQL/1564974826998.png)\n\n```sql\nSelect * from R Intersect Select * from S\n```\n\n\n\n## 笛卡尔积\n\n![1565058855783](关系运算-SQL/1565058855783.png)\n\n```sql\nSelect * from R,S\n```\n\n\n\n# 关系运算\n\n## 选择\n\n```sql\nSELECT R.学号，R.课程名,R.分数 from R WHERE 分数>85\n```\n\n![1564989251630](关系运算-SQL/1564989251630.png)\n\n## 投影\n\n```sql\nSELECT 课程名 FROM R;\n```\n\n![1564989369086](关系运算-SQL/1564989369086.png)\n\n## 连接\n\n从关系R和关系S的广义笛卡儿积中选取满足给定条件的元组组成新的关系称为R和S的连接\n\n### 自然连接\n\n给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作 $R⋈S$ ，它由关系R和关系S的笛卡尔积中，选取R与S的笛卡尔积中选取相同属性组B上值相等的元组组成。 \n\n```sql\nSELECT * from R natual join S\n```\n\n![1565060913297](关系运算-SQL/1565060913297.png)\n\n### $\\theta$连接\n\n给定一个关系R 和关系S，R 与S 的 $θ$ 连接运算结果也是一个关系，记作$R\\underset{A\\theta B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性E之间满足 $θ$ 条件的元组组成。 \n\n```sql\nSELECT * from R \njoin\nSELECT * from S\non R.B<S.H\n```\n\n![1565060112787](关系运算-SQL/1565060112787.png)\n\n### 等值连接\n\n给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作$R\\underset{A= B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B上值相等的元组组成。 \n\n```shell\nSELECT * from R \njoin\nSELECT * from S\non R.B=S.H\n```\n\n![1565060172932](关系运算-SQL/1565060172932.png)\n\n### 外连接\n\n两个关系R与S进行连接时，如果关系R(或S)中的元组在S（或R）中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接（Outer Join）\n\n```sql\nselect * from R left outer join S;\nselect * from R right outer join S;\nselect * from R full outer join S;\n```\n\n![1565063996276](关系运算-SQL/1565063996276.png)\n\n![1565064351620](关系运算-SQL/1565064351620.png)\n\n## 除\n\n给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(X)与S(Y)组成的元组都在R(X,Y)中。\n$$\nP(X)=R(X,Y) \\div S(Y,Z)\n$$\n\n```sql\nSELECT DISTINCT R.X FROM R  R1\nWHERE NOT EXISTS \n(\t\n    SELECT S.Y FROM S \n    WHERE NOT EXISTS \n    (\n        SELECT * FROM R R2 \n        where R1.X=R2.X and R2.Y=S.Y\n    )\n) \n```\n\n\n\n![1564990536278](关系运算-SQL/1564990536278.png)\n\n### 习题\n\n![1564994840753](关系运算-SQL/1564994840753.png)\n\n![1564994851980](关系运算-SQL/1564994851980.png)\n\n![1564994863174](关系运算-SQL/1564994863174.png)\n\n- 求至少选择了C001和C003两门课程的学生学号\n\n  ```sql\n  select distinct sno from sc A\n  where not exists\n  (\n  \tselect * from course B where cno in ('C002','C003') and not exists\n      (\n      \tselect * from sc C where A.sno=C.sno and B.cno=C.cno\n      )\n  )\n  ```\n\n  ","source":"_posts/关系运算-SQL.md","raw":"---\ntitle: 关系运算-SQL\ndate: 2019-07-31 11:05:24\ntags: [数据库,编程语言]\ncategories: SQL\npermalink: SQL/关系运算-SQL.md\n---\n\n# 集合运算\n\n![数据说明](关系运算-SQL/1564988154852.png)\n\n<!--more-->\n\n## 并\n\n![1564974696180](关系运算-SQL/1564974696180.png)\n\n```sql\nSelect * from R UNION Select * from S;\n```\n\n## 差\n\n![1564974788006](关系运算-SQL/1564974788006.png)\n\n```sql\nSelect * from R Except Select * from S;\n```\n\n## 交\n\n![1564974826998](关系运算-SQL/1564974826998.png)\n\n```sql\nSelect * from R Intersect Select * from S\n```\n\n\n\n## 笛卡尔积\n\n![1565058855783](关系运算-SQL/1565058855783.png)\n\n```sql\nSelect * from R,S\n```\n\n\n\n# 关系运算\n\n## 选择\n\n```sql\nSELECT R.学号，R.课程名,R.分数 from R WHERE 分数>85\n```\n\n![1564989251630](关系运算-SQL/1564989251630.png)\n\n## 投影\n\n```sql\nSELECT 课程名 FROM R;\n```\n\n![1564989369086](关系运算-SQL/1564989369086.png)\n\n## 连接\n\n从关系R和关系S的广义笛卡儿积中选取满足给定条件的元组组成新的关系称为R和S的连接\n\n### 自然连接\n\n给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作 $R⋈S$ ，它由关系R和关系S的笛卡尔积中，选取R与S的笛卡尔积中选取相同属性组B上值相等的元组组成。 \n\n```sql\nSELECT * from R natual join S\n```\n\n![1565060913297](关系运算-SQL/1565060913297.png)\n\n### $\\theta$连接\n\n给定一个关系R 和关系S，R 与S 的 $θ$ 连接运算结果也是一个关系，记作$R\\underset{A\\theta B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性E之间满足 $θ$ 条件的元组组成。 \n\n```sql\nSELECT * from R \njoin\nSELECT * from S\non R.B<S.H\n```\n\n![1565060112787](关系运算-SQL/1565060112787.png)\n\n### 等值连接\n\n给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作$R\\underset{A= B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B上值相等的元组组成。 \n\n```shell\nSELECT * from R \njoin\nSELECT * from S\non R.B=S.H\n```\n\n![1565060172932](关系运算-SQL/1565060172932.png)\n\n### 外连接\n\n两个关系R与S进行连接时，如果关系R(或S)中的元组在S（或R）中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接（Outer Join）\n\n```sql\nselect * from R left outer join S;\nselect * from R right outer join S;\nselect * from R full outer join S;\n```\n\n![1565063996276](关系运算-SQL/1565063996276.png)\n\n![1565064351620](关系运算-SQL/1565064351620.png)\n\n## 除\n\n给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(X)与S(Y)组成的元组都在R(X,Y)中。\n$$\nP(X)=R(X,Y) \\div S(Y,Z)\n$$\n\n```sql\nSELECT DISTINCT R.X FROM R  R1\nWHERE NOT EXISTS \n(\t\n    SELECT S.Y FROM S \n    WHERE NOT EXISTS \n    (\n        SELECT * FROM R R2 \n        where R1.X=R2.X and R2.Y=S.Y\n    )\n) \n```\n\n\n\n![1564990536278](关系运算-SQL/1564990536278.png)\n\n### 习题\n\n![1564994840753](关系运算-SQL/1564994840753.png)\n\n![1564994851980](关系运算-SQL/1564994851980.png)\n\n![1564994863174](关系运算-SQL/1564994863174.png)\n\n- 求至少选择了C001和C003两门课程的学生学号\n\n  ```sql\n  select distinct sno from sc A\n  where not exists\n  (\n  \tselect * from course B where cno in ('C002','C003') and not exists\n      (\n      \tselect * from sc C where A.sno=C.sno and B.cno=C.cno\n      )\n  )\n  ```\n\n  ","slug":"SQL/关系运算-SQL.md","published":1,"updated":"2019-08-09T03:25:22.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izq003xhomj8bjenbsg","content":"<h1 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h1><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564988154852.png\" alt=\"数据说明\"></p>\n<a id=\"more\"></a>\n<h2 id=\"并\"><a href=\"#并\" class=\"headerlink\" title=\"并\"></a>并</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974696180.png\" alt=\"1564974696180\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">UNION</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S;</span><br></pre></td></tr></table></figure>\n<h2 id=\"差\"><a href=\"#差\" class=\"headerlink\" title=\"差\"></a>差</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974788006.png\" alt=\"1564974788006\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">Except</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S;</span><br></pre></td></tr></table></figure>\n<h2 id=\"交\"><a href=\"#交\" class=\"headerlink\" title=\"交\"></a>交</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974826998.png\" alt=\"1564974826998\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">Intersect</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S</span><br></pre></td></tr></table></figure>\n<h2 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565058855783.png\" alt=\"1565058855783\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R,S</span><br></pre></td></tr></table></figure>\n<h1 id=\"关系运算\"><a href=\"#关系运算\" class=\"headerlink\" title=\"关系运算\"></a>关系运算</h1><h2 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R.学号，R.课程名,R.分数 <span class=\"keyword\">from</span> R <span class=\"keyword\">WHERE</span> 分数&gt;<span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564989251630.png\" alt=\"1564989251630\"></p>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a>投影</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 课程名 <span class=\"keyword\">FROM</span> R;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564989369086.png\" alt=\"1564989369086\"></p>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>从关系R和关系S的广义笛卡儿积中选取满足给定条件的元组组成新的关系称为R和S的连接</p>\n<h3 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h3><p>给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作 $R⋈S$ ，它由关系R和关系S的笛卡尔积中，选取R与S的笛卡尔积中选取相同属性组B上值相等的元组组成。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> R natual <span class=\"keyword\">join</span> S</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060913297.png\" alt=\"1565060913297\"></p>\n<h3 id=\"theta-连接\"><a href=\"#theta-连接\" class=\"headerlink\" title=\"$\\theta$连接\"></a>$\\theta$连接</h3><p>给定一个关系R 和关系S，R 与S 的 $θ$ 连接运算结果也是一个关系，记作$R\\underset{A\\theta B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性E之间满足 $θ$ 条件的元组组成。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> R </span><br><span class=\"line\"><span class=\"keyword\">join</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> S</span><br><span class=\"line\"><span class=\"keyword\">on</span> R.B&lt;S.H</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060112787.png\" alt=\"1565060112787\"></p>\n<h3 id=\"等值连接\"><a href=\"#等值连接\" class=\"headerlink\" title=\"等值连接\"></a>等值连接</h3><p>给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作$R\\underset{A= B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B上值相等的元组组成。 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * from R </span><br><span class=\"line\">join</span><br><span class=\"line\">SELECT * from S</span><br><span class=\"line\">on R.B=S.H</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060172932.png\" alt=\"1565060172932\"></p>\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>两个关系R与S进行连接时，如果关系R(或S)中的元组在S（或R）中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接（Outer Join）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">left</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">right</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">full</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565063996276.png\" alt=\"1565063996276\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565064351620.png\" alt=\"1565064351620\"></p>\n<h2 id=\"除\"><a href=\"#除\" class=\"headerlink\" title=\"除\"></a>除</h2><p>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(X)与S(Y)组成的元组都在R(X,Y)中。</p>\n<script type=\"math/tex; mode=display\">\nP(X)=R(X,Y) \\div S(Y,Z)</script><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> R.X <span class=\"keyword\">FROM</span> R  R1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> </span><br><span class=\"line\">(\t</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> S.Y <span class=\"keyword\">FROM</span> S </span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> </span><br><span class=\"line\">    (</span><br><span class=\"line\">        <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> R R2 </span><br><span class=\"line\">        <span class=\"keyword\">where</span> R1.X=R2.X <span class=\"keyword\">and</span> R2.Y=S.Y</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564990536278.png\" alt=\"1564990536278\"></p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994840753.png\" alt=\"1564994840753\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994851980.png\" alt=\"1564994851980\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994863174.png\" alt=\"1564994863174\"></p>\n<ul>\n<li><p>求至少选择了C001和C003两门课程的学生学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> sno <span class=\"keyword\">from</span> sc A</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> course B <span class=\"keyword\">where</span> cno <span class=\"keyword\">in</span> (<span class=\"string\">'C002'</span>,<span class=\"string\">'C003'</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span></span><br><span class=\"line\">    (</span><br><span class=\"line\">    \t<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sc C <span class=\"keyword\">where</span> A.sno=C.sno <span class=\"keyword\">and</span> B.cno=C.cno</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h1><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564988154852.png\" alt=\"数据说明\"></p>","more":"<h2 id=\"并\"><a href=\"#并\" class=\"headerlink\" title=\"并\"></a>并</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974696180.png\" alt=\"1564974696180\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">UNION</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S;</span><br></pre></td></tr></table></figure>\n<h2 id=\"差\"><a href=\"#差\" class=\"headerlink\" title=\"差\"></a>差</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974788006.png\" alt=\"1564974788006\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">Except</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S;</span><br></pre></td></tr></table></figure>\n<h2 id=\"交\"><a href=\"#交\" class=\"headerlink\" title=\"交\"></a>交</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564974826998.png\" alt=\"1564974826998\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">Intersect</span> <span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> S</span><br></pre></td></tr></table></figure>\n<h2 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h2><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565058855783.png\" alt=\"1565058855783\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Select</span> * <span class=\"keyword\">from</span> R,S</span><br></pre></td></tr></table></figure>\n<h1 id=\"关系运算\"><a href=\"#关系运算\" class=\"headerlink\" title=\"关系运算\"></a>关系运算</h1><h2 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R.学号，R.课程名,R.分数 <span class=\"keyword\">from</span> R <span class=\"keyword\">WHERE</span> 分数&gt;<span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564989251630.png\" alt=\"1564989251630\"></p>\n<h2 id=\"投影\"><a href=\"#投影\" class=\"headerlink\" title=\"投影\"></a>投影</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 课程名 <span class=\"keyword\">FROM</span> R;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564989369086.png\" alt=\"1564989369086\"></p>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>从关系R和关系S的广义笛卡儿积中选取满足给定条件的元组组成新的关系称为R和S的连接</p>\n<h3 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h3><p>给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作 $R⋈S$ ，它由关系R和关系S的笛卡尔积中，选取R与S的笛卡尔积中选取相同属性组B上值相等的元组组成。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> R natual <span class=\"keyword\">join</span> S</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060913297.png\" alt=\"1565060913297\"></p>\n<h3 id=\"theta-连接\"><a href=\"#theta-连接\" class=\"headerlink\" title=\"$\\theta$连接\"></a>$\\theta$连接</h3><p>给定一个关系R 和关系S，R 与S 的 $θ$ 连接运算结果也是一个关系，记作$R\\underset{A\\theta B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性E之间满足 $θ$ 条件的元组组成。 </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> R </span><br><span class=\"line\"><span class=\"keyword\">join</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">from</span> S</span><br><span class=\"line\"><span class=\"keyword\">on</span> R.B&lt;S.H</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060112787.png\" alt=\"1565060112787\"></p>\n<h3 id=\"等值连接\"><a href=\"#等值连接\" class=\"headerlink\" title=\"等值连接\"></a>等值连接</h3><p>给定一个关系R和关系S，R与S的等值连接运算结果也是一个关系，记作$R\\underset{A= B}{\\bowtie} S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B上值相等的元组组成。 </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * from R </span><br><span class=\"line\">join</span><br><span class=\"line\">SELECT * from S</span><br><span class=\"line\">on R.B=S.H</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565060172932.png\" alt=\"1565060172932\"></p>\n<h3 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h3><p>两个关系R与S进行连接时，如果关系R(或S)中的元组在S（或R）中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接（Outer Join）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">left</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">right</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> R <span class=\"keyword\">full</span> <span class=\"keyword\">outer</span> <span class=\"keyword\">join</span> S;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565063996276.png\" alt=\"1565063996276\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1565064351620.png\" alt=\"1565064351620\"></p>\n<h2 id=\"除\"><a href=\"#除\" class=\"headerlink\" title=\"除\"></a>除</h2><p>给定关系R (X， Y) 和S (Y， Z)， 其中X， Y， Z为属性组。R中的Y与S中的Y出自相同的域集。R与S的除运算得到一个新的关系P(X)。其中P(X)与S(Y)组成的元组都在R(X,Y)中。</p>\n<script type=\"math/tex; mode=display\">\nP(X)=R(X,Y) \\div S(Y,Z)</script><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> R.X <span class=\"keyword\">FROM</span> R  R1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> </span><br><span class=\"line\">(\t</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> S.Y <span class=\"keyword\">FROM</span> S </span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> </span><br><span class=\"line\">    (</span><br><span class=\"line\">        <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> R R2 </span><br><span class=\"line\">        <span class=\"keyword\">where</span> R1.X=R2.X <span class=\"keyword\">and</span> R2.Y=S.Y</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564990536278.png\" alt=\"1564990536278\"></p>\n<h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994840753.png\" alt=\"1564994840753\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994851980.png\" alt=\"1564994851980\"></p>\n<p><img src=\"/2019/07/31/SQL/关系运算-SQL.md/1564994863174.png\" alt=\"1564994863174\"></p>\n<ul>\n<li><p>求至少选择了C001和C003两门课程的学生学号</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> sno <span class=\"keyword\">from</span> sc A</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> course B <span class=\"keyword\">where</span> cno <span class=\"keyword\">in</span> (<span class=\"string\">'C002'</span>,<span class=\"string\">'C003'</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"keyword\">exists</span></span><br><span class=\"line\">    (</span><br><span class=\"line\">    \t<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sc C <span class=\"keyword\">where</span> A.sno=C.sno <span class=\"keyword\">and</span> B.cno=C.cno</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"决策树","date":"2017-06-21T03:24:28.000Z","_content":"# 简介\n分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。决策树案例图如下图所示。\n![决策树案例图](决策树/决策树-b46cf4a2.png)\n\n\n算法|特征选择|目标\n-|-|-\nID3|信息增益<br>$g(D,A)=H(D)-H(D\\mid A)$|信息增益最大的\nC4.5|信息增益比<br>$g_{R}(D,A)=\\frac{g(D,A)}{H_A(D)}$|信息增益比大的\nCART|分类：基尼指数<br>$Gini( p )=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$<br>回归：平方差|\n\n<!--more-->\n\n# 特征选择\n\n## 信息增益（用于ID3算法）\n信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。**信息增益=信息熵-条件熵；换句话说，信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度**\n- 定义\n特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$，定义为集合 $D$ 的信息熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的条件熵 $H(D|A)$ 之差，即\n$$g(D,A)=H(D)-H(D|A)$$\n- 算法\n设训练数据集为 $D$，$|D|$ 表示其样本容量，即样本个数。设有 $K$ 个类 $C_k，k＝1,2,…,K$ ，$|C_k|$ 为属于类 $C_k$ 的样本个数。设特征 $A$ 有 $n$ 个不同的取值 ${a_1，a_2,…,a_n}$ ，根据特征 $A$ 的取值将 $D$ 划分为$n$个子集 $D_1,D_2,…,D_n$，$|D_i|$ 为 $D_i$ 的样本个数，$\\sum_{i=1}^{n}|D_i|=|D|$。记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，即 $D_{ik}＝D_i⋂C_k$，$|D_{ik}|$ 为 $D_{ik}$ 的样本个数。于是信息增益的算法如下：\n输入：训练数据集$D$和特征$A$；\n输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$。\n 1. 计算数据集$D$的信息熵$H(D)$\n  $$H(D)=-\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$$\n 1. 计算特征$A$对数据集$D$的经验条件熵$H(D|A)$\n  $$H(D|A)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}$$\n\n\n## 信息增益比\n\n当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此**信息增益比较偏向取值较多的特征**。例如面对连续增益(体重、身高、年龄等)，(极端情况下所有数据都独一无二)，在这种情况下，我们采用信息增益比。\n$$\\begin{align*}\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)}\\\\\nH_A(D)&=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_{i}|}{|D|}\n\\end{align*}\n$$\n\n### 为什么使用信息增益比\nDay | Temperatrue | Outlook | Humidity | Windy | PlayGolf?\n-|-|-|-|-|-\n07-05 | hot | sunny | high | false | no\n07-06 | hot | sunny | high | true | no\n07-07 | hot | overcast | high | false | yes\n07-09 | cool | rain | normal | false | yes\n07-10 | cool | overcast | normal | true | yes\n07-12 | mild | sunny | high | false | no\n07-14 | cool | sunny | normal | false | yes\n07-15 | mild | rain | normal | false | yes\n07-20 | mild | sunny | normal | true | yes\n07-21 | mild | overcast | high | true | yes\n07-22 | hot | overcast | normal | false | yes\n07-23 | mild | sunny | high | true | no\n07-26 | cool | sunny | normal | true | no\n07-30 | mild | sunny | high | false | yes\n\n\n还是以此表为例，假如我们想用Day来做为特征(当然实际上一般人也不会傻到用Day用做特征)，显然，每一天都可以将样本分开，也就是形成了一颗叶子数量为14，深度只有两层的树。\n\n#### 信息增益\n$$\\begin{align*}\nH(D) &= -\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}\\\\\n&=-{5\\over14}log {5\\over14} - {9\\over14}log {9\\over14} =0.9403\\\\\nH(D|A) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}\\\\\n&=\\sum_{i=1}^{14}1\\times H(D_i)=\\sum_{i=1}^{14}1\\times\\sum_{k=1}^{2}1\\times log_2 \\frac{1}{1}=0\\\\\ng(D,A)&=H(D)-H(D|A)=0.9403\n\\end{align*}$$\n**信息增益比较偏向取值较多的特征**。\n\n#### 信息增益比\n$$\\begin{align*}\nH_A(D) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_i|}{|D|}\\\\\n&=-\\sum_{i=1}^{14}\\frac{1}{14}log_2\\frac{1}{14}=3.807\\\\\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)} \\\\\n&=\\frac{0.9403}{3.807}=0.247\n\\end{align*}$$\n\n## 基尼指数\n分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为\n$$\\begin{align*}\nGini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\nGini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n\\end{align*}$$\n如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为\n$$Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)$$\n基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强\n\n# 决策树生成\n迭代终止条件：\n1. 所有的特征都用了，没有特征可以继续来进行特征选择\n2. 当前特征集中的最大的信息增益小于我们设定的阈值\n3. 树的结点深度达到预定值\n\n\n![](决策树/决策树-d82a16be.png)\n\n## ID3\nID3算法使用了信息增益。信息增益的缺点是：对取值数目比较多的属性有偏好。一个特征的信息增益越大，表明属性对样本熵减少的能力越强，不确定性变成确定性的能力越强。用信息增益训练出来的决策树深度很浅的树。\n### 不足\n- **ID3没有考虑连续特征**，比如长度，密度都是连续值，无法在ID3运用。这大大限制了ID3的用途。\n- **ID3偏好选择取值多的特征做分支**，ID3采用信息增益大的特征优先建立决策树的结点。很快就被人发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大。直白解释：取值比较多的特征，就可以分叉出更多的分支，分支更多，每个分支的纯度必然更高！\n- **ID3算法对于缺失值的情况没有做考虑**\n- **没有考虑过拟合的问题，即没有剪枝处理**\n\n### 计算实例\n$A_1$：年龄    $A_2$：有工作    $A_3$：有自己的房子    $A_4$：信贷情况\n1. 根结点\n$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$\n![](决策树/决策树-03065a1a.png)![](决策树/决策树-eaef32cd.png)![](决策树/决策树-f545d0d4.png)\n由此可知$g(D,A_3)$最大，所以选择$A_3$（有自己的房子）作为根结点做为划分\n1. 树结点\n它将训练数据集 $D$ 划分为两个子集 $D_1$（$A_3$取值为“是”）和 $D_2$（$A_3$取值为“否”）。当 $A_3$ 取值为“是”的时候，$D_1$ 全部为是；当 $A_3$ 取值为“否”的时候，对 $D_2$ 进行划分\n$H(D_2)=-\\frac{3}{9}log_2\\frac{3}{9}-\\frac{6}{9}log_2\\frac{6}{9}=0.918$\n![](决策树/决策树-2ab90e01.png)由此可知 $g(D,A_2)$ 最大，所以选择 $A_2$（有工作）作为树结点做为划分\n1. 结果\n![](决策树/决策树-49620760.png)\n\n## C4.5\n采用信息增益比作为特征选择标准，与算法与ID3类似\n- 对与 **ID3没有考虑连续特征**(以两个相邻连续值的平均数进行划分)\n详情请参考如下连续值处理问题\n- 对与 **ID3偏好选择取值多的特征做分支**\n改用信息增益比作为分支指标，因为特征数越多的特征对应的特征熵越大，它作为分母，可以校正信息增益容易偏向于取值较多的特征的问题。\n- 对与 **ID3算法对于缺失值的情况没有做考虑**\n- 对与**没有考虑过拟合的问题**\nC4.5引入了正则化系数进行初步的剪枝。\n\n## [CART](/2017/07/21/回归树/)\n\n\n# 决策树剪枝(ID3与C4.5)\n决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现**过拟合现象**。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的**决策树进行简化**。\n## 预减枝\n通过设定阈值，提前停止树的构建而对树剪枝，一旦停止，结点就是树叶。停止决策树生长最简单的方法有：\n1. 定义一个高度，当决策树达到该高度时就停止决策树的生长\n2. 达到某个结点的实例具有相同的特征向量，及时这些实例不属于同一类，也可以停止决策树的生长。这个方法对于处理数据的数据冲突问题比较有效。\n3. 定义一个阈值，当达到某个结点的实例个数小于阈值时就可以停止决策树的生长\n4. 定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值大小来决定是否停止决策树的生长。\n\n## 后剪枝\n### 定义新的损失函数\n\n$$C_α(T)=C(T)+α|T|$$\n其中，$C(T)$即是该 Node 和不确定性相关的损失、$|T|$则是该 Node 下属叶结点的个数。不妨设第 $t$ 个叶结点含有 $N_t$个样本且这 $N_t$ 个样本的不确定性为 $H_t(T)$，那么新损失一般可以直接定义为加权不确定性：\n$$C\\left( T \\right) = \\sum_{t = 1}^{\\left| T \\right|}{N_{t}H_{t}(T)}$$\n\n#### 经验熵的损失函数\n当不确定性为经验熵$H_t(T)=-\\sum_{k}\\frac{N_{tk}}{N_t}log\\: \\frac{N_{tk}}{N_t}$时，其损失函数为\n$$C(T)=\\sum_{t=1}^{\\left | T \\right |}N_tH_t(T)=-\\sum_{t=1}^{\\left | T \\right |} \\sum_{k=1}^KN_{tk}log\\: \\frac{N_{tk}}{N_t}$$\n其中树的叶子结点个数为$\\left | T \\right |$,$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,...,K$,$H(t)$为叶结点$t$上的经验熵，$\\alpha \\geqslant 0$为参数\n\n### 算法\n![](决策树/决策树-4abd1db5.png)\n\n\n# 连续值的处理\n比如$m$个样本的连续特征$A$有$m$个，从小到大排列为$a_1,a_2,…,a_m$,则取相邻两样本值的中位数，一共取得$m−1$个划分点，其中第$i$个划分点$T_i$表示为：\n\n$$T_i = \\frac{a_i+a_{i+1}}{2}$$\n\n对于这$m−1$个点，分别计算以该点作为二元分类点时的信息增益。选择信息增益最大的点作为该连续特征的二元离散分类点。比如取到的增益最大的点$a_t$,则小于$a_t$的值为类别1，大于$a_t$的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与离散属性不同的是，**如果当前结点为连续属性，则该属性后面还可以参与子结点的产生选择过程。**\n\n# 缺失值的处理\n可以简单的抛弃不完整样本，但是如果不完整样本太多，就不能简单的抛弃。面对不完整样本我们有两个问题需要解决：\n- 如何在属性值缺失的情况下进行划分属性选择\n- 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分\n\n给定训练集$D$和属性$A$，令$\\tilde{D}$表示$D$中属性$A$上没有缺失值的样本子集。**对问题(1)，显然我们仅可根据$\\tilde{D}$来判断属性$A$的优劣**。假设属性$A$有$V$个可取的值${a^1,...,a^V}$，令$\\tilde{D}_v$表示$\\tilde{D}$中在属性$A$上取值为$a^V$的样本子集，$\\tilde{D}_k$表示$\\tilde{D}$中属于第$k$类$k=1,...,K$的样本子集，则显然有$\\tilde{D}=\\bigcup _{k=1}^K\\tilde{D}_k$、$\\tilde{D}=\\bigcup _{v=1}^V\\tilde{D}_v$。假定我们为每个样本$x$赋予一个权重$w_x$并定义\n$\\rho =\\frac{\\sum _{x \\in \\tilde{D}}w_x}{\\sum _{x \\in D}w_x}$    $\\rho $表示无缺失样本所占的比例\n$\\tilde{p}_k =\\frac{\\sum _{x \\in \\tilde{D}_k}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant K)$         $\\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例\n$\\tilde{r}_v =\\frac{\\sum _{x \\in \\tilde{D}_v}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant V)$  $\\tilde{r}_v$表示无缺失值样本中在属性$A$上取值$a^v$所占的样本比例\n$$\\begin{align*}\nGain(D|A)&=\\rho \\times Gain(\\tilde{D} ,A) \\\\\n &= \\rho \\times \\left ( Ent(\\tilde{D})-\\sum_{v=1}^{V} \\tilde{r}_v Ent(\\tilde{D_v})\\right )\\\\\nEnt(\\tilde{D}) &= -\\sum_{k=1}^{\\left | \\gamma  \\right |}\\tilde{p_k}log_2\\; \\tilde{p_k}\n\\end{align*}$$\n对问题(2)，若样本$x$在属性$A$上的取值已知，则将$x$划入取值相对应的子结点，且样本权重保持为$w_x$。若样本$x$在属性$A$上的取值未知，则将$x$同时划入所有的子结点，且样本权值在属性值$a^v$对应的子结点中调整为$\\tilde{r}_v \\cdot w_x$\n## 缺失值处理\n在某些情况下，可供使用的数据可能缺少某些属性的值。假如$〈x，c(x)〉$是样本集$S$中的一个训练实例，但是其属性$A$的值$A(x)$未知。处理缺少属性值的一种策略是赋给它结点$n$所对应的训练实例中该属性的最常见值；另外一种更复杂的策略是为$A$的每个可能值赋予一个概率。例如，给定一个布尔属性$A$，如果结点$n$包含6个已知$A=1$和4个$A=0$的实例，那么$A(x)=1$的概率是0.6，而$A(x)=0$的概率是0.4。于是，实例$x$的60%被分配到$A=1$的分支，40%被分配到另一个分支。这些片断样例的目的是计算信息增益，另外，如果有第二个缺少值的属性必须被测试，这些样例可以在后继的树分支中被进一步细分。C4.5就是使用这种方法处理缺少的属性值。\n 1. 计算属性$A$的增益或者增益率时，如果有些样本没有属性$A$，可以有这么几种处理方式： \n  (1). 忽略这些缺失属性$A$的样本。 \n  (2). 给缺失属性$A$的样本赋予属性$A$一个均值或者最常用的的值。\n  (3). 计算增益或者增益率时根据缺失属性样本个数所占的比率对增益/增益率进行相应的“打折”。 （请看周志华的机器学习）\n  (4). 根据其他未知的属性想办法把这些样本缺失的属性补全。\n 2. 当属性$A$已经被选择，该对样本进行分支的时候，如果有些样本缺失了属性$A$,那么： \n   (1).忽略这些样本。 \n   (2).把这些样本的属性$A$赋予一个均值或者最常出现的值，然后再对他们进行处理。\n   (3).把属性缺失样本分配给所有的子集，也就是说每个子集都有这些属性缺失样本。 \n   (4).单独为属性缺失的样本划分一个分支子集。\n   (5).对于缺失属性$A$的样本，尝试着根据其他属性给他分配一个属性$A$的值，然后继续处理将其划分到相应的子集。\n 3. 对于一个确实属性$A$的待分类样本，有这么几种解释\n   (1).如果有单独的确实分支，依据此分支\n   (2).把待分类的样本的属性$A$值分配一个最常见出现的$A$的属性值，然后进行分支预测\n   (3).估计其他属性为该待分类样本填充一个属性$A$值，然后进行分支处理\n   (4).在决策树中属性$A$结点的分支上，遍历属性$A$结点的所有分支，探索可能所有的分类结果，然后把这些分类结果结合起来一起考虑，按照概率决定一个分类。\n   (5).待分类样本在到达属性$A$结点时就终止分类，然后根据此时$A$结点所覆盖的叶子节结点类别状况其分配一个发生概率最高的类\n","source":"_posts/决策树.md","raw":"---\ntitle: 决策树\ndate: 2017-06-21 11:24:28\ntags: [人工智能,模型,树模型]\ncategories: 机器学习\n---\n# 简介\n分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。决策树案例图如下图所示。\n![决策树案例图](决策树/决策树-b46cf4a2.png)\n\n\n算法|特征选择|目标\n-|-|-\nID3|信息增益<br>$g(D,A)=H(D)-H(D\\mid A)$|信息增益最大的\nC4.5|信息增益比<br>$g_{R}(D,A)=\\frac{g(D,A)}{H_A(D)}$|信息增益比大的\nCART|分类：基尼指数<br>$Gini( p )=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$<br>回归：平方差|\n\n<!--more-->\n\n# 特征选择\n\n## 信息增益（用于ID3算法）\n信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。**信息增益=信息熵-条件熵；换句话说，信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度**\n- 定义\n特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$，定义为集合 $D$ 的信息熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的条件熵 $H(D|A)$ 之差，即\n$$g(D,A)=H(D)-H(D|A)$$\n- 算法\n设训练数据集为 $D$，$|D|$ 表示其样本容量，即样本个数。设有 $K$ 个类 $C_k，k＝1,2,…,K$ ，$|C_k|$ 为属于类 $C_k$ 的样本个数。设特征 $A$ 有 $n$ 个不同的取值 ${a_1，a_2,…,a_n}$ ，根据特征 $A$ 的取值将 $D$ 划分为$n$个子集 $D_1,D_2,…,D_n$，$|D_i|$ 为 $D_i$ 的样本个数，$\\sum_{i=1}^{n}|D_i|=|D|$。记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，即 $D_{ik}＝D_i⋂C_k$，$|D_{ik}|$ 为 $D_{ik}$ 的样本个数。于是信息增益的算法如下：\n输入：训练数据集$D$和特征$A$；\n输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$。\n 1. 计算数据集$D$的信息熵$H(D)$\n  $$H(D)=-\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}$$\n 1. 计算特征$A$对数据集$D$的经验条件熵$H(D|A)$\n  $$H(D|A)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}$$\n\n\n## 信息增益比\n\n当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此**信息增益比较偏向取值较多的特征**。例如面对连续增益(体重、身高、年龄等)，(极端情况下所有数据都独一无二)，在这种情况下，我们采用信息增益比。\n$$\\begin{align*}\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)}\\\\\nH_A(D)&=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_{i}|}{|D|}\n\\end{align*}\n$$\n\n### 为什么使用信息增益比\nDay | Temperatrue | Outlook | Humidity | Windy | PlayGolf?\n-|-|-|-|-|-\n07-05 | hot | sunny | high | false | no\n07-06 | hot | sunny | high | true | no\n07-07 | hot | overcast | high | false | yes\n07-09 | cool | rain | normal | false | yes\n07-10 | cool | overcast | normal | true | yes\n07-12 | mild | sunny | high | false | no\n07-14 | cool | sunny | normal | false | yes\n07-15 | mild | rain | normal | false | yes\n07-20 | mild | sunny | normal | true | yes\n07-21 | mild | overcast | high | true | yes\n07-22 | hot | overcast | normal | false | yes\n07-23 | mild | sunny | high | true | no\n07-26 | cool | sunny | normal | true | no\n07-30 | mild | sunny | high | false | yes\n\n\n还是以此表为例，假如我们想用Day来做为特征(当然实际上一般人也不会傻到用Day用做特征)，显然，每一天都可以将样本分开，也就是形成了一颗叶子数量为14，深度只有两层的树。\n\n#### 信息增益\n$$\\begin{align*}\nH(D) &= -\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}\\\\\n&=-{5\\over14}log {5\\over14} - {9\\over14}log {9\\over14} =0.9403\\\\\nH(D|A) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}\\\\\n&=\\sum_{i=1}^{14}1\\times H(D_i)=\\sum_{i=1}^{14}1\\times\\sum_{k=1}^{2}1\\times log_2 \\frac{1}{1}=0\\\\\ng(D,A)&=H(D)-H(D|A)=0.9403\n\\end{align*}$$\n**信息增益比较偏向取值较多的特征**。\n\n#### 信息增益比\n$$\\begin{align*}\nH_A(D) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_i|}{|D|}\\\\\n&=-\\sum_{i=1}^{14}\\frac{1}{14}log_2\\frac{1}{14}=3.807\\\\\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)} \\\\\n&=\\frac{0.9403}{3.807}=0.247\n\\end{align*}$$\n\n## 基尼指数\n分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为\n$$\\begin{align*}\nGini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\nGini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n\\end{align*}$$\n如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为\n$$Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)$$\n基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强\n\n# 决策树生成\n迭代终止条件：\n1. 所有的特征都用了，没有特征可以继续来进行特征选择\n2. 当前特征集中的最大的信息增益小于我们设定的阈值\n3. 树的结点深度达到预定值\n\n\n![](决策树/决策树-d82a16be.png)\n\n## ID3\nID3算法使用了信息增益。信息增益的缺点是：对取值数目比较多的属性有偏好。一个特征的信息增益越大，表明属性对样本熵减少的能力越强，不确定性变成确定性的能力越强。用信息增益训练出来的决策树深度很浅的树。\n### 不足\n- **ID3没有考虑连续特征**，比如长度，密度都是连续值，无法在ID3运用。这大大限制了ID3的用途。\n- **ID3偏好选择取值多的特征做分支**，ID3采用信息增益大的特征优先建立决策树的结点。很快就被人发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大。直白解释：取值比较多的特征，就可以分叉出更多的分支，分支更多，每个分支的纯度必然更高！\n- **ID3算法对于缺失值的情况没有做考虑**\n- **没有考虑过拟合的问题，即没有剪枝处理**\n\n### 计算实例\n$A_1$：年龄    $A_2$：有工作    $A_3$：有自己的房子    $A_4$：信贷情况\n1. 根结点\n$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$\n![](决策树/决策树-03065a1a.png)![](决策树/决策树-eaef32cd.png)![](决策树/决策树-f545d0d4.png)\n由此可知$g(D,A_3)$最大，所以选择$A_3$（有自己的房子）作为根结点做为划分\n1. 树结点\n它将训练数据集 $D$ 划分为两个子集 $D_1$（$A_3$取值为“是”）和 $D_2$（$A_3$取值为“否”）。当 $A_3$ 取值为“是”的时候，$D_1$ 全部为是；当 $A_3$ 取值为“否”的时候，对 $D_2$ 进行划分\n$H(D_2)=-\\frac{3}{9}log_2\\frac{3}{9}-\\frac{6}{9}log_2\\frac{6}{9}=0.918$\n![](决策树/决策树-2ab90e01.png)由此可知 $g(D,A_2)$ 最大，所以选择 $A_2$（有工作）作为树结点做为划分\n1. 结果\n![](决策树/决策树-49620760.png)\n\n## C4.5\n采用信息增益比作为特征选择标准，与算法与ID3类似\n- 对与 **ID3没有考虑连续特征**(以两个相邻连续值的平均数进行划分)\n详情请参考如下连续值处理问题\n- 对与 **ID3偏好选择取值多的特征做分支**\n改用信息增益比作为分支指标，因为特征数越多的特征对应的特征熵越大，它作为分母，可以校正信息增益容易偏向于取值较多的特征的问题。\n- 对与 **ID3算法对于缺失值的情况没有做考虑**\n- 对与**没有考虑过拟合的问题**\nC4.5引入了正则化系数进行初步的剪枝。\n\n## [CART](/2017/07/21/回归树/)\n\n\n# 决策树剪枝(ID3与C4.5)\n决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现**过拟合现象**。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的**决策树进行简化**。\n## 预减枝\n通过设定阈值，提前停止树的构建而对树剪枝，一旦停止，结点就是树叶。停止决策树生长最简单的方法有：\n1. 定义一个高度，当决策树达到该高度时就停止决策树的生长\n2. 达到某个结点的实例具有相同的特征向量，及时这些实例不属于同一类，也可以停止决策树的生长。这个方法对于处理数据的数据冲突问题比较有效。\n3. 定义一个阈值，当达到某个结点的实例个数小于阈值时就可以停止决策树的生长\n4. 定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值大小来决定是否停止决策树的生长。\n\n## 后剪枝\n### 定义新的损失函数\n\n$$C_α(T)=C(T)+α|T|$$\n其中，$C(T)$即是该 Node 和不确定性相关的损失、$|T|$则是该 Node 下属叶结点的个数。不妨设第 $t$ 个叶结点含有 $N_t$个样本且这 $N_t$ 个样本的不确定性为 $H_t(T)$，那么新损失一般可以直接定义为加权不确定性：\n$$C\\left( T \\right) = \\sum_{t = 1}^{\\left| T \\right|}{N_{t}H_{t}(T)}$$\n\n#### 经验熵的损失函数\n当不确定性为经验熵$H_t(T)=-\\sum_{k}\\frac{N_{tk}}{N_t}log\\: \\frac{N_{tk}}{N_t}$时，其损失函数为\n$$C(T)=\\sum_{t=1}^{\\left | T \\right |}N_tH_t(T)=-\\sum_{t=1}^{\\left | T \\right |} \\sum_{k=1}^KN_{tk}log\\: \\frac{N_{tk}}{N_t}$$\n其中树的叶子结点个数为$\\left | T \\right |$,$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,...,K$,$H(t)$为叶结点$t$上的经验熵，$\\alpha \\geqslant 0$为参数\n\n### 算法\n![](决策树/决策树-4abd1db5.png)\n\n\n# 连续值的处理\n比如$m$个样本的连续特征$A$有$m$个，从小到大排列为$a_1,a_2,…,a_m$,则取相邻两样本值的中位数，一共取得$m−1$个划分点，其中第$i$个划分点$T_i$表示为：\n\n$$T_i = \\frac{a_i+a_{i+1}}{2}$$\n\n对于这$m−1$个点，分别计算以该点作为二元分类点时的信息增益。选择信息增益最大的点作为该连续特征的二元离散分类点。比如取到的增益最大的点$a_t$,则小于$a_t$的值为类别1，大于$a_t$的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与离散属性不同的是，**如果当前结点为连续属性，则该属性后面还可以参与子结点的产生选择过程。**\n\n# 缺失值的处理\n可以简单的抛弃不完整样本，但是如果不完整样本太多，就不能简单的抛弃。面对不完整样本我们有两个问题需要解决：\n- 如何在属性值缺失的情况下进行划分属性选择\n- 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分\n\n给定训练集$D$和属性$A$，令$\\tilde{D}$表示$D$中属性$A$上没有缺失值的样本子集。**对问题(1)，显然我们仅可根据$\\tilde{D}$来判断属性$A$的优劣**。假设属性$A$有$V$个可取的值${a^1,...,a^V}$，令$\\tilde{D}_v$表示$\\tilde{D}$中在属性$A$上取值为$a^V$的样本子集，$\\tilde{D}_k$表示$\\tilde{D}$中属于第$k$类$k=1,...,K$的样本子集，则显然有$\\tilde{D}=\\bigcup _{k=1}^K\\tilde{D}_k$、$\\tilde{D}=\\bigcup _{v=1}^V\\tilde{D}_v$。假定我们为每个样本$x$赋予一个权重$w_x$并定义\n$\\rho =\\frac{\\sum _{x \\in \\tilde{D}}w_x}{\\sum _{x \\in D}w_x}$    $\\rho $表示无缺失样本所占的比例\n$\\tilde{p}_k =\\frac{\\sum _{x \\in \\tilde{D}_k}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant K)$         $\\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例\n$\\tilde{r}_v =\\frac{\\sum _{x \\in \\tilde{D}_v}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant V)$  $\\tilde{r}_v$表示无缺失值样本中在属性$A$上取值$a^v$所占的样本比例\n$$\\begin{align*}\nGain(D|A)&=\\rho \\times Gain(\\tilde{D} ,A) \\\\\n &= \\rho \\times \\left ( Ent(\\tilde{D})-\\sum_{v=1}^{V} \\tilde{r}_v Ent(\\tilde{D_v})\\right )\\\\\nEnt(\\tilde{D}) &= -\\sum_{k=1}^{\\left | \\gamma  \\right |}\\tilde{p_k}log_2\\; \\tilde{p_k}\n\\end{align*}$$\n对问题(2)，若样本$x$在属性$A$上的取值已知，则将$x$划入取值相对应的子结点，且样本权重保持为$w_x$。若样本$x$在属性$A$上的取值未知，则将$x$同时划入所有的子结点，且样本权值在属性值$a^v$对应的子结点中调整为$\\tilde{r}_v \\cdot w_x$\n## 缺失值处理\n在某些情况下，可供使用的数据可能缺少某些属性的值。假如$〈x，c(x)〉$是样本集$S$中的一个训练实例，但是其属性$A$的值$A(x)$未知。处理缺少属性值的一种策略是赋给它结点$n$所对应的训练实例中该属性的最常见值；另外一种更复杂的策略是为$A$的每个可能值赋予一个概率。例如，给定一个布尔属性$A$，如果结点$n$包含6个已知$A=1$和4个$A=0$的实例，那么$A(x)=1$的概率是0.6，而$A(x)=0$的概率是0.4。于是，实例$x$的60%被分配到$A=1$的分支，40%被分配到另一个分支。这些片断样例的目的是计算信息增益，另外，如果有第二个缺少值的属性必须被测试，这些样例可以在后继的树分支中被进一步细分。C4.5就是使用这种方法处理缺少的属性值。\n 1. 计算属性$A$的增益或者增益率时，如果有些样本没有属性$A$，可以有这么几种处理方式： \n  (1). 忽略这些缺失属性$A$的样本。 \n  (2). 给缺失属性$A$的样本赋予属性$A$一个均值或者最常用的的值。\n  (3). 计算增益或者增益率时根据缺失属性样本个数所占的比率对增益/增益率进行相应的“打折”。 （请看周志华的机器学习）\n  (4). 根据其他未知的属性想办法把这些样本缺失的属性补全。\n 2. 当属性$A$已经被选择，该对样本进行分支的时候，如果有些样本缺失了属性$A$,那么： \n   (1).忽略这些样本。 \n   (2).把这些样本的属性$A$赋予一个均值或者最常出现的值，然后再对他们进行处理。\n   (3).把属性缺失样本分配给所有的子集，也就是说每个子集都有这些属性缺失样本。 \n   (4).单独为属性缺失的样本划分一个分支子集。\n   (5).对于缺失属性$A$的样本，尝试着根据其他属性给他分配一个属性$A$的值，然后继续处理将其划分到相应的子集。\n 3. 对于一个确实属性$A$的待分类样本，有这么几种解释\n   (1).如果有单独的确实分支，依据此分支\n   (2).把待分类的样本的属性$A$值分配一个最常见出现的$A$的属性值，然后进行分支预测\n   (3).估计其他属性为该待分类样本填充一个属性$A$值，然后进行分支处理\n   (4).在决策树中属性$A$结点的分支上，遍历属性$A$结点的所有分支，探索可能所有的分类结果，然后把这些分类结果结合起来一起考虑，按照概率决定一个分类。\n   (5).待分类样本在到达属性$A$结点时就终止分类，然后根据此时$A$结点所覆盖的叶子节结点类别状况其分配一个发生概率最高的类\n","slug":"决策树","published":1,"updated":"2019-07-30T01:54:38.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izr003zhomja0voofmm","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。决策树案例图如下图所示。<br><img src=\"/2017/06/21/决策树/决策树-b46cf4a2.png\" alt=\"决策树案例图\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>特征选择</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID3</td>\n<td>信息增益<br>$g(D,A)=H(D)-H(D\\mid A)$</td>\n<td>信息增益最大的</td>\n</tr>\n<tr>\n<td>C4.5</td>\n<td>信息增益比<br>$g_{R}(D,A)=\\frac{g(D,A)}{H_A(D)}$</td>\n<td>信息增益比大的</td>\n</tr>\n<tr>\n<td>CART</td>\n<td>分类：基尼指数<br>$Gini( p )=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$<br>回归：平方差</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"特征选择\"><a href=\"#特征选择\" class=\"headerlink\" title=\"特征选择\"></a>特征选择</h1><h2 id=\"信息增益（用于ID3算法）\"><a href=\"#信息增益（用于ID3算法）\" class=\"headerlink\" title=\"信息增益（用于ID3算法）\"></a>信息增益（用于ID3算法）</h2><p>信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。<strong>信息增益=信息熵-条件熵；换句话说，信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度</strong></p>\n<ul>\n<li>定义<br>特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$，定义为集合 $D$ 的信息熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的条件熵 $H(D|A)$ 之差，即<script type=\"math/tex; mode=display\">g(D,A)=H(D)-H(D|A)</script></li>\n<li>算法<br>设训练数据集为 $D$，$|D|$ 表示其样本容量，即样本个数。设有 $K$ 个类 $C_k，k＝1,2,…,K$ ，$|C_k|$ 为属于类 $C_k$ 的样本个数。设特征 $A$ 有 $n$ 个不同的取值 ${a_1，a_2,…,a_n}$ ，根据特征 $A$ 的取值将 $D$ 划分为$n$个子集 $D_1,D_2,…,D_n$，$|D_i|$ 为 $D_i$ 的样本个数，$\\sum_{i=1}^{n}|D_i|=|D|$。记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，即 $D_{ik}＝D_i⋂C_k$，$|D_{ik}|$ 为 $D_{ik}$ 的样本个数。于是信息增益的算法如下：<br>输入：训练数据集$D$和特征$A$；<br>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$。<ol>\n<li>计算数据集$D$的信息熵$H(D)$<script type=\"math/tex; mode=display\">H(D)=-\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}</script></li>\n<li>计算特征$A$对数据集$D$的经验条件熵$H(D|A)$<script type=\"math/tex; mode=display\">H(D|A)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}</script></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"信息增益比\"><a href=\"#信息增益比\" class=\"headerlink\" title=\"信息增益比\"></a>信息增益比</h2><p>当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此<strong>信息增益比较偏向取值较多的特征</strong>。例如面对连续增益(体重、身高、年龄等)，(极端情况下所有数据都独一无二)，在这种情况下，我们采用信息增益比。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)}\\\\\nH_A(D)&=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_{i}|}{|D|}\n\\end{align*}</script><h3 id=\"为什么使用信息增益比\"><a href=\"#为什么使用信息增益比\" class=\"headerlink\" title=\"为什么使用信息增益比\"></a>为什么使用信息增益比</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Day</th>\n<th>Temperatrue</th>\n<th>Outlook</th>\n<th>Humidity</th>\n<th>Windy</th>\n<th>PlayGolf?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>07-05</td>\n<td>hot</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-06</td>\n<td>hot</td>\n<td>sunny</td>\n<td>high</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-07</td>\n<td>hot</td>\n<td>overcast</td>\n<td>high</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-09</td>\n<td>cool</td>\n<td>rain</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-10</td>\n<td>cool</td>\n<td>overcast</td>\n<td>normal</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-12</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-14</td>\n<td>cool</td>\n<td>sunny</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-15</td>\n<td>mild</td>\n<td>rain</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-20</td>\n<td>mild</td>\n<td>sunny</td>\n<td>normal</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-21</td>\n<td>mild</td>\n<td>overcast</td>\n<td>high</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-22</td>\n<td>hot</td>\n<td>overcast</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-23</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-26</td>\n<td>cool</td>\n<td>sunny</td>\n<td>normal</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-30</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>还是以此表为例，假如我们想用Day来做为特征(当然实际上一般人也不会傻到用Day用做特征)，显然，每一天都可以将样本分开，也就是形成了一颗叶子数量为14，深度只有两层的树。</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><script type=\"math/tex; mode=display\">\\begin{align*}\nH(D) &= -\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}\\\\\n&=-{5\\over14}log {5\\over14} - {9\\over14}log {9\\over14} =0.9403\\\\\nH(D|A) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}\\\\\n&=\\sum_{i=1}^{14}1\\times H(D_i)=\\sum_{i=1}^{14}1\\times\\sum_{k=1}^{2}1\\times log_2 \\frac{1}{1}=0\\\\\ng(D,A)&=H(D)-H(D|A)=0.9403\n\\end{align*}</script><p><strong>信息增益比较偏向取值较多的特征</strong>。</p>\n<h4 id=\"信息增益比-1\"><a href=\"#信息增益比-1\" class=\"headerlink\" title=\"信息增益比\"></a>信息增益比</h4><script type=\"math/tex; mode=display\">\\begin{align*}\nH_A(D) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_i|}{|D|}\\\\\n&=-\\sum_{i=1}^{14}\\frac{1}{14}log_2\\frac{1}{14}=3.807\\\\\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)} \\\\\n&=\\frac{0.9403}{3.807}=0.247\n\\end{align*}</script><h2 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h2><p>分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nGini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\nGini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n\\end{align*}</script><p>如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)</script><p>基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强</p>\n<h1 id=\"决策树生成\"><a href=\"#决策树生成\" class=\"headerlink\" title=\"决策树生成\"></a>决策树生成</h1><p>迭代终止条件：</p>\n<ol>\n<li>所有的特征都用了，没有特征可以继续来进行特征选择</li>\n<li>当前特征集中的最大的信息增益小于我们设定的阈值</li>\n<li>树的结点深度达到预定值</li>\n</ol>\n<p><img src=\"/2017/06/21/决策树/决策树-d82a16be.png\" alt=\"\"></p>\n<h2 id=\"ID3\"><a href=\"#ID3\" class=\"headerlink\" title=\"ID3\"></a>ID3</h2><p>ID3算法使用了信息增益。信息增益的缺点是：对取值数目比较多的属性有偏好。一个特征的信息增益越大，表明属性对样本熵减少的能力越强，不确定性变成确定性的能力越强。用信息增益训练出来的决策树深度很浅的树。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><ul>\n<li><strong>ID3没有考虑连续特征</strong>，比如长度，密度都是连续值，无法在ID3运用。这大大限制了ID3的用途。</li>\n<li><strong>ID3偏好选择取值多的特征做分支</strong>，ID3采用信息增益大的特征优先建立决策树的结点。很快就被人发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大。直白解释：取值比较多的特征，就可以分叉出更多的分支，分支更多，每个分支的纯度必然更高！</li>\n<li><strong>ID3算法对于缺失值的情况没有做考虑</strong></li>\n<li><strong>没有考虑过拟合的问题，即没有剪枝处理</strong></li>\n</ul>\n<h3 id=\"计算实例\"><a href=\"#计算实例\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h3><p>$A_1$：年龄    $A_2$：有工作    $A_3$：有自己的房子    $A_4$：信贷情况</p>\n<ol>\n<li>根结点<br>$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$<br><img src=\"/2017/06/21/决策树/决策树-03065a1a.png\" alt=\"\"><img src=\"/2017/06/21/决策树/决策树-eaef32cd.png\" alt=\"\"><img src=\"/2017/06/21/决策树/决策树-f545d0d4.png\" alt=\"\"><br>由此可知$g(D,A_3)$最大，所以选择$A_3$（有自己的房子）作为根结点做为划分</li>\n<li>树结点<br>它将训练数据集 $D$ 划分为两个子集 $D_1$（$A_3$取值为“是”）和 $D_2$（$A_3$取值为“否”）。当 $A_3$ 取值为“是”的时候，$D_1$ 全部为是；当 $A_3$ 取值为“否”的时候，对 $D_2$ 进行划分<br>$H(D_2)=-\\frac{3}{9}log_2\\frac{3}{9}-\\frac{6}{9}log_2\\frac{6}{9}=0.918$<br><img src=\"/2017/06/21/决策树/决策树-2ab90e01.png\" alt=\"\">由此可知 $g(D,A_2)$ 最大，所以选择 $A_2$（有工作）作为树结点做为划分</li>\n<li>结果<br><img src=\"/2017/06/21/决策树/决策树-49620760.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"C4-5\"><a href=\"#C4-5\" class=\"headerlink\" title=\"C4.5\"></a>C4.5</h2><p>采用信息增益比作为特征选择标准，与算法与ID3类似</p>\n<ul>\n<li>对与 <strong>ID3没有考虑连续特征</strong>(以两个相邻连续值的平均数进行划分)<br>详情请参考如下连续值处理问题</li>\n<li>对与 <strong>ID3偏好选择取值多的特征做分支</strong><br>改用信息增益比作为分支指标，因为特征数越多的特征对应的特征熵越大，它作为分母，可以校正信息增益容易偏向于取值较多的特征的问题。</li>\n<li>对与 <strong>ID3算法对于缺失值的情况没有做考虑</strong></li>\n<li>对与<strong>没有考虑过拟合的问题</strong><br>C4.5引入了正则化系数进行初步的剪枝。</li>\n</ul>\n<h2 id=\"CART\"><a href=\"#CART\" class=\"headerlink\" title=\"CART\"></a><a href=\"/2017/07/21/回归树/\">CART</a></h2><h1 id=\"决策树剪枝-ID3与C4-5\"><a href=\"#决策树剪枝-ID3与C4-5\" class=\"headerlink\" title=\"决策树剪枝(ID3与C4.5)\"></a>决策树剪枝(ID3与C4.5)</h1><p>决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现<strong>过拟合现象</strong>。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的<strong>决策树进行简化</strong>。</p>\n<h2 id=\"预减枝\"><a href=\"#预减枝\" class=\"headerlink\" title=\"预减枝\"></a>预减枝</h2><p>通过设定阈值，提前停止树的构建而对树剪枝，一旦停止，结点就是树叶。停止决策树生长最简单的方法有：</p>\n<ol>\n<li>定义一个高度，当决策树达到该高度时就停止决策树的生长</li>\n<li>达到某个结点的实例具有相同的特征向量，及时这些实例不属于同一类，也可以停止决策树的生长。这个方法对于处理数据的数据冲突问题比较有效。</li>\n<li>定义一个阈值，当达到某个结点的实例个数小于阈值时就可以停止决策树的生长</li>\n<li>定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值大小来决定是否停止决策树的生长。</li>\n</ol>\n<h2 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h2><h3 id=\"定义新的损失函数\"><a href=\"#定义新的损失函数\" class=\"headerlink\" title=\"定义新的损失函数\"></a>定义新的损失函数</h3><script type=\"math/tex; mode=display\">C_α(T)=C(T)+α|T|</script><p>其中，$C(T)$即是该 Node 和不确定性相关的损失、$|T|$则是该 Node 下属叶结点的个数。不妨设第 $t$ 个叶结点含有 $N_t$个样本且这 $N_t$ 个样本的不确定性为 $H_t(T)$，那么新损失一般可以直接定义为加权不确定性：</p>\n<script type=\"math/tex; mode=display\">C\\left( T \\right) = \\sum_{t = 1}^{\\left| T \\right|}{N_{t}H_{t}(T)}</script><h4 id=\"经验熵的损失函数\"><a href=\"#经验熵的损失函数\" class=\"headerlink\" title=\"经验熵的损失函数\"></a>经验熵的损失函数</h4><p>当不确定性为经验熵$H_t(T)=-\\sum_{k}\\frac{N_{tk}}{N_t}log\\: \\frac{N_{tk}}{N_t}$时，其损失函数为</p>\n<script type=\"math/tex; mode=display\">C(T)=\\sum_{t=1}^{\\left | T \\right |}N_tH_t(T)=-\\sum_{t=1}^{\\left | T \\right |} \\sum_{k=1}^KN_{tk}log\\: \\frac{N_{tk}}{N_t}</script><p>其中树的叶子结点个数为$\\left | T \\right |$,$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,…,K$,$H(t)$为叶结点$t$上的经验熵，$\\alpha \\geqslant 0$为参数</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p><img src=\"/2017/06/21/决策树/决策树-4abd1db5.png\" alt=\"\"></p>\n<h1 id=\"连续值的处理\"><a href=\"#连续值的处理\" class=\"headerlink\" title=\"连续值的处理\"></a>连续值的处理</h1><p>比如$m$个样本的连续特征$A$有$m$个，从小到大排列为$a_1,a_2,…,a_m$,则取相邻两样本值的中位数，一共取得$m−1$个划分点，其中第$i$个划分点$T_i$表示为：</p>\n<script type=\"math/tex; mode=display\">T_i = \\frac{a_i+a_{i+1}}{2}</script><p>对于这$m−1$个点，分别计算以该点作为二元分类点时的信息增益。选择信息增益最大的点作为该连续特征的二元离散分类点。比如取到的增益最大的点$a_t$,则小于$a_t$的值为类别1，大于$a_t$的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与离散属性不同的是，<strong>如果当前结点为连续属性，则该属性后面还可以参与子结点的产生选择过程。</strong></p>\n<h1 id=\"缺失值的处理\"><a href=\"#缺失值的处理\" class=\"headerlink\" title=\"缺失值的处理\"></a>缺失值的处理</h1><p>可以简单的抛弃不完整样本，但是如果不完整样本太多，就不能简单的抛弃。面对不完整样本我们有两个问题需要解决：</p>\n<ul>\n<li>如何在属性值缺失的情况下进行划分属性选择</li>\n<li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分</li>\n</ul>\n<p>给定训练集$D$和属性$A$，令$\\tilde{D}$表示$D$中属性$A$上没有缺失值的样本子集。<strong>对问题(1)，显然我们仅可根据$\\tilde{D}$来判断属性$A$的优劣</strong>。假设属性$A$有$V$个可取的值${a^1,…,a^V}$，令$\\tilde{D}_v$表示$\\tilde{D}$中在属性$A$上取值为$a^V$的样本子集，$\\tilde{D}_k$表示$\\tilde{D}$中属于第$k$类$k=1,…,K$的样本子集，则显然有$\\tilde{D}=\\bigcup _{k=1}^K\\tilde{D}_k$、$\\tilde{D}=\\bigcup _{v=1}^V\\tilde{D}_v$。假定我们为每个样本$x$赋予一个权重$w_x$并定义<br>$\\rho =\\frac{\\sum _{x \\in \\tilde{D}}w_x}{\\sum _{x \\in D}w_x}$    $\\rho $表示无缺失样本所占的比例<br>$\\tilde{p}_k =\\frac{\\sum _{x \\in \\tilde{D}_k}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant K)$         $\\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例<br>$\\tilde{r}_v =\\frac{\\sum _{x \\in \\tilde{D}_v}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant V)$  $\\tilde{r}_v$表示无缺失值样本中在属性$A$上取值$a^v$所占的样本比例</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nGain(D|A)&=\\rho \\times Gain(\\tilde{D} ,A) \\\\\n &= \\rho \\times \\left ( Ent(\\tilde{D})-\\sum_{v=1}^{V} \\tilde{r}_v Ent(\\tilde{D_v})\\right )\\\\\nEnt(\\tilde{D}) &= -\\sum_{k=1}^{\\left | \\gamma  \\right |}\\tilde{p_k}log_2\\; \\tilde{p_k}\n\\end{align*}</script><p>对问题(2)，若样本$x$在属性$A$上的取值已知，则将$x$划入取值相对应的子结点，且样本权重保持为$w_x$。若样本$x$在属性$A$上的取值未知，则将$x$同时划入所有的子结点，且样本权值在属性值$a^v$对应的子结点中调整为$\\tilde{r}_v \\cdot w_x$</p>\n<h2 id=\"缺失值处理\"><a href=\"#缺失值处理\" class=\"headerlink\" title=\"缺失值处理\"></a>缺失值处理</h2><p>在某些情况下，可供使用的数据可能缺少某些属性的值。假如$〈x，c(x)〉$是样本集$S$中的一个训练实例，但是其属性$A$的值$A(x)$未知。处理缺少属性值的一种策略是赋给它结点$n$所对应的训练实例中该属性的最常见值；另外一种更复杂的策略是为$A$的每个可能值赋予一个概率。例如，给定一个布尔属性$A$，如果结点$n$包含6个已知$A=1$和4个$A=0$的实例，那么$A(x)=1$的概率是0.6，而$A(x)=0$的概率是0.4。于是，实例$x$的60%被分配到$A=1$的分支，40%被分配到另一个分支。这些片断样例的目的是计算信息增益，另外，如果有第二个缺少值的属性必须被测试，这些样例可以在后继的树分支中被进一步细分。C4.5就是使用这种方法处理缺少的属性值。</p>\n<ol>\n<li>计算属性$A$的增益或者增益率时，如果有些样本没有属性$A$，可以有这么几种处理方式： <br>(1). 忽略这些缺失属性$A$的样本。 <br>(2). 给缺失属性$A$的样本赋予属性$A$一个均值或者最常用的的值。<br>(3). 计算增益或者增益率时根据缺失属性样本个数所占的比率对增益/增益率进行相应的“打折”。 （请看周志华的机器学习）<br>(4). 根据其他未知的属性想办法把这些样本缺失的属性补全。</li>\n<li>当属性$A$已经被选择，该对样本进行分支的时候，如果有些样本缺失了属性$A$,那么： <br>(1).忽略这些样本。 <br>(2).把这些样本的属性$A$赋予一个均值或者最常出现的值，然后再对他们进行处理。<br>(3).把属性缺失样本分配给所有的子集，也就是说每个子集都有这些属性缺失样本。 <br>(4).单独为属性缺失的样本划分一个分支子集。<br>(5).对于缺失属性$A$的样本，尝试着根据其他属性给他分配一个属性$A$的值，然后继续处理将其划分到相应的子集。</li>\n<li>对于一个确实属性$A$的待分类样本，有这么几种解释<br>(1).如果有单独的确实分支，依据此分支<br>(2).把待分类的样本的属性$A$值分配一个最常见出现的$A$的属性值，然后进行分支预测<br>(3).估计其他属性为该待分类样本填充一个属性$A$值，然后进行分支处理<br>(4).在决策树中属性$A$结点的分支上，遍历属性$A$结点的所有分支，探索可能所有的分类结果，然后把这些分类结果结合起来一起考虑，按照概率决定一个分类。<br>(5).待分类样本在到达属性$A$结点时就终止分类，然后根据此时$A$结点所覆盖的叶子节结点类别状况其分配一个发生概率最高的类</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点（node）和有向边（directed edge）组成。结点有两种类型：内部结点（internal node）和叶结点（leaf node）。内部结点表示一个特征或属性，叶结点表示一个类。决策树案例图如下图所示。<br><img src=\"/2017/06/21/决策树/决策树-b46cf4a2.png\" alt=\"决策树案例图\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>特征选择</th>\n<th>目标</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ID3</td>\n<td>信息增益<br>$g(D,A)=H(D)-H(D\\mid A)$</td>\n<td>信息增益最大的</td>\n</tr>\n<tr>\n<td>C4.5</td>\n<td>信息增益比<br>$g_{R}(D,A)=\\frac{g(D,A)}{H_A(D)}$</td>\n<td>信息增益比大的</td>\n</tr>\n<tr>\n<td>CART</td>\n<td>分类：基尼指数<br>$Gini( p )=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2$<br>回归：平方差</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"特征选择\"><a href=\"#特征选择\" class=\"headerlink\" title=\"特征选择\"></a>特征选择</h1><h2 id=\"信息增益（用于ID3算法）\"><a href=\"#信息增益（用于ID3算法）\" class=\"headerlink\" title=\"信息增益（用于ID3算法）\"></a>信息增益（用于ID3算法）</h2><p>信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。<strong>信息增益=信息熵-条件熵；换句话说，信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度</strong></p>\n<ul>\n<li>定义<br>特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$，定义为集合 $D$ 的信息熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的条件熵 $H(D|A)$ 之差，即<script type=\"math/tex; mode=display\">g(D,A)=H(D)-H(D|A)</script></li>\n<li>算法<br>设训练数据集为 $D$，$|D|$ 表示其样本容量，即样本个数。设有 $K$ 个类 $C_k，k＝1,2,…,K$ ，$|C_k|$ 为属于类 $C_k$ 的样本个数。设特征 $A$ 有 $n$ 个不同的取值 ${a_1，a_2,…,a_n}$ ，根据特征 $A$ 的取值将 $D$ 划分为$n$个子集 $D_1,D_2,…,D_n$，$|D_i|$ 为 $D_i$ 的样本个数，$\\sum_{i=1}^{n}|D_i|=|D|$。记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，即 $D_{ik}＝D_i⋂C_k$，$|D_{ik}|$ 为 $D_{ik}$ 的样本个数。于是信息增益的算法如下：<br>输入：训练数据集$D$和特征$A$；<br>输出：特征$A$对训练数据集$D$的信息增益$g(D,A)$。<ol>\n<li>计算数据集$D$的信息熵$H(D)$<script type=\"math/tex; mode=display\">H(D)=-\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}</script></li>\n<li>计算特征$A$对数据集$D$的经验条件熵$H(D|A)$<script type=\"math/tex; mode=display\">H(D|A)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}</script></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"信息增益比\"><a href=\"#信息增益比\" class=\"headerlink\" title=\"信息增益比\"></a>信息增益比</h2><p>当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低，由于划分前的熵是一定的，因此信息增益更大，因此<strong>信息增益比较偏向取值较多的特征</strong>。例如面对连续增益(体重、身高、年龄等)，(极端情况下所有数据都独一无二)，在这种情况下，我们采用信息增益比。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)}\\\\\nH_A(D)&=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_{i}|}{|D|}\n\\end{align*}</script><h3 id=\"为什么使用信息增益比\"><a href=\"#为什么使用信息增益比\" class=\"headerlink\" title=\"为什么使用信息增益比\"></a>为什么使用信息增益比</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Day</th>\n<th>Temperatrue</th>\n<th>Outlook</th>\n<th>Humidity</th>\n<th>Windy</th>\n<th>PlayGolf?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>07-05</td>\n<td>hot</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-06</td>\n<td>hot</td>\n<td>sunny</td>\n<td>high</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-07</td>\n<td>hot</td>\n<td>overcast</td>\n<td>high</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-09</td>\n<td>cool</td>\n<td>rain</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-10</td>\n<td>cool</td>\n<td>overcast</td>\n<td>normal</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-12</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-14</td>\n<td>cool</td>\n<td>sunny</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-15</td>\n<td>mild</td>\n<td>rain</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-20</td>\n<td>mild</td>\n<td>sunny</td>\n<td>normal</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-21</td>\n<td>mild</td>\n<td>overcast</td>\n<td>high</td>\n<td>true</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-22</td>\n<td>hot</td>\n<td>overcast</td>\n<td>normal</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>07-23</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-26</td>\n<td>cool</td>\n<td>sunny</td>\n<td>normal</td>\n<td>true</td>\n<td>no</td>\n</tr>\n<tr>\n<td>07-30</td>\n<td>mild</td>\n<td>sunny</td>\n<td>high</td>\n<td>false</td>\n<td>yes</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>还是以此表为例，假如我们想用Day来做为特征(当然实际上一般人也不会傻到用Day用做特征)，显然，每一天都可以将样本分开，也就是形成了一颗叶子数量为14，深度只有两层的树。</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><script type=\"math/tex; mode=display\">\\begin{align*}\nH(D) &= -\\sum_{k=1}^{K}\\frac{|C_k|}{|D|}log_2\\frac{|C_k|}{|D|}\\\\\n&=-{5\\over14}log {5\\over14} - {9\\over14}log {9\\over14} =0.9403\\\\\nH(D|A) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}\\sum_{k=1}^{K}\\frac{|D_{ik}|}{|D_i|}log_2\\frac{|D_{ik}|}{|D_i|}\\\\\n&=\\sum_{i=1}^{14}1\\times H(D_i)=\\sum_{i=1}^{14}1\\times\\sum_{k=1}^{2}1\\times log_2 \\frac{1}{1}=0\\\\\ng(D,A)&=H(D)-H(D|A)=0.9403\n\\end{align*}</script><p><strong>信息增益比较偏向取值较多的特征</strong>。</p>\n<h4 id=\"信息增益比-1\"><a href=\"#信息增益比-1\" class=\"headerlink\" title=\"信息增益比\"></a>信息增益比</h4><script type=\"math/tex; mode=display\">\\begin{align*}\nH_A(D) &=-\\sum_{i=1}^{n}\\frac{|D_i|}{|D|}log_2\\frac{|D_i|}{|D|}\\\\\n&=-\\sum_{i=1}^{14}\\frac{1}{14}log_2\\frac{1}{14}=3.807\\\\\ng_{R}(D,A)&=\\frac{g(D,A)}{H_A(D)} \\\\\n&=\\frac{0.9403}{3.807}=0.247\n\\end{align*}</script><h2 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h2><p>分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nGini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\nGini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n\\end{align*}</script><p>如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)</script><p>基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强</p>\n<h1 id=\"决策树生成\"><a href=\"#决策树生成\" class=\"headerlink\" title=\"决策树生成\"></a>决策树生成</h1><p>迭代终止条件：</p>\n<ol>\n<li>所有的特征都用了，没有特征可以继续来进行特征选择</li>\n<li>当前特征集中的最大的信息增益小于我们设定的阈值</li>\n<li>树的结点深度达到预定值</li>\n</ol>\n<p><img src=\"/2017/06/21/决策树/决策树-d82a16be.png\" alt=\"\"></p>\n<h2 id=\"ID3\"><a href=\"#ID3\" class=\"headerlink\" title=\"ID3\"></a>ID3</h2><p>ID3算法使用了信息增益。信息增益的缺点是：对取值数目比较多的属性有偏好。一个特征的信息增益越大，表明属性对样本熵减少的能力越强，不确定性变成确定性的能力越强。用信息增益训练出来的决策树深度很浅的树。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><ul>\n<li><strong>ID3没有考虑连续特征</strong>，比如长度，密度都是连续值，无法在ID3运用。这大大限制了ID3的用途。</li>\n<li><strong>ID3偏好选择取值多的特征做分支</strong>，ID3采用信息增益大的特征优先建立决策树的结点。很快就被人发现，在相同条件下，取值比较多的特征比取值少的特征信息增益大。直白解释：取值比较多的特征，就可以分叉出更多的分支，分支更多，每个分支的纯度必然更高！</li>\n<li><strong>ID3算法对于缺失值的情况没有做考虑</strong></li>\n<li><strong>没有考虑过拟合的问题，即没有剪枝处理</strong></li>\n</ul>\n<h3 id=\"计算实例\"><a href=\"#计算实例\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h3><p>$A_1$：年龄    $A_2$：有工作    $A_3$：有自己的房子    $A_4$：信贷情况</p>\n<ol>\n<li>根结点<br>$H(D)=-\\frac{9}{15}log_2\\frac{9}{15}-\\frac{6}{15}log_2\\frac{6}{15}=0.971$<br><img src=\"/2017/06/21/决策树/决策树-03065a1a.png\" alt=\"\"><img src=\"/2017/06/21/决策树/决策树-eaef32cd.png\" alt=\"\"><img src=\"/2017/06/21/决策树/决策树-f545d0d4.png\" alt=\"\"><br>由此可知$g(D,A_3)$最大，所以选择$A_3$（有自己的房子）作为根结点做为划分</li>\n<li>树结点<br>它将训练数据集 $D$ 划分为两个子集 $D_1$（$A_3$取值为“是”）和 $D_2$（$A_3$取值为“否”）。当 $A_3$ 取值为“是”的时候，$D_1$ 全部为是；当 $A_3$ 取值为“否”的时候，对 $D_2$ 进行划分<br>$H(D_2)=-\\frac{3}{9}log_2\\frac{3}{9}-\\frac{6}{9}log_2\\frac{6}{9}=0.918$<br><img src=\"/2017/06/21/决策树/决策树-2ab90e01.png\" alt=\"\">由此可知 $g(D,A_2)$ 最大，所以选择 $A_2$（有工作）作为树结点做为划分</li>\n<li>结果<br><img src=\"/2017/06/21/决策树/决策树-49620760.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"C4-5\"><a href=\"#C4-5\" class=\"headerlink\" title=\"C4.5\"></a>C4.5</h2><p>采用信息增益比作为特征选择标准，与算法与ID3类似</p>\n<ul>\n<li>对与 <strong>ID3没有考虑连续特征</strong>(以两个相邻连续值的平均数进行划分)<br>详情请参考如下连续值处理问题</li>\n<li>对与 <strong>ID3偏好选择取值多的特征做分支</strong><br>改用信息增益比作为分支指标，因为特征数越多的特征对应的特征熵越大，它作为分母，可以校正信息增益容易偏向于取值较多的特征的问题。</li>\n<li>对与 <strong>ID3算法对于缺失值的情况没有做考虑</strong></li>\n<li>对与<strong>没有考虑过拟合的问题</strong><br>C4.5引入了正则化系数进行初步的剪枝。</li>\n</ul>\n<h2 id=\"CART\"><a href=\"#CART\" class=\"headerlink\" title=\"CART\"></a><a href=\"/2017/07/21/回归树/\">CART</a></h2><h1 id=\"决策树剪枝-ID3与C4-5\"><a href=\"#决策树剪枝-ID3与C4-5\" class=\"headerlink\" title=\"决策树剪枝(ID3与C4.5)\"></a>决策树剪枝(ID3与C4.5)</h1><p>决策树生成算法递归地产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现<strong>过拟合现象</strong>。过拟合的原因在于学习时过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法是考虑决策树的复杂度，对已生成的<strong>决策树进行简化</strong>。</p>\n<h2 id=\"预减枝\"><a href=\"#预减枝\" class=\"headerlink\" title=\"预减枝\"></a>预减枝</h2><p>通过设定阈值，提前停止树的构建而对树剪枝，一旦停止，结点就是树叶。停止决策树生长最简单的方法有：</p>\n<ol>\n<li>定义一个高度，当决策树达到该高度时就停止决策树的生长</li>\n<li>达到某个结点的实例具有相同的特征向量，及时这些实例不属于同一类，也可以停止决策树的生长。这个方法对于处理数据的数据冲突问题比较有效。</li>\n<li>定义一个阈值，当达到某个结点的实例个数小于阈值时就可以停止决策树的生长</li>\n<li>定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值大小来决定是否停止决策树的生长。</li>\n</ol>\n<h2 id=\"后剪枝\"><a href=\"#后剪枝\" class=\"headerlink\" title=\"后剪枝\"></a>后剪枝</h2><h3 id=\"定义新的损失函数\"><a href=\"#定义新的损失函数\" class=\"headerlink\" title=\"定义新的损失函数\"></a>定义新的损失函数</h3><script type=\"math/tex; mode=display\">C_α(T)=C(T)+α|T|</script><p>其中，$C(T)$即是该 Node 和不确定性相关的损失、$|T|$则是该 Node 下属叶结点的个数。不妨设第 $t$ 个叶结点含有 $N_t$个样本且这 $N_t$ 个样本的不确定性为 $H_t(T)$，那么新损失一般可以直接定义为加权不确定性：</p>\n<script type=\"math/tex; mode=display\">C\\left( T \\right) = \\sum_{t = 1}^{\\left| T \\right|}{N_{t}H_{t}(T)}</script><h4 id=\"经验熵的损失函数\"><a href=\"#经验熵的损失函数\" class=\"headerlink\" title=\"经验熵的损失函数\"></a>经验熵的损失函数</h4><p>当不确定性为经验熵$H_t(T)=-\\sum_{k}\\frac{N_{tk}}{N_t}log\\: \\frac{N_{tk}}{N_t}$时，其损失函数为</p>\n<script type=\"math/tex; mode=display\">C(T)=\\sum_{t=1}^{\\left | T \\right |}N_tH_t(T)=-\\sum_{t=1}^{\\left | T \\right |} \\sum_{k=1}^KN_{tk}log\\: \\frac{N_{tk}}{N_t}</script><p>其中树的叶子结点个数为$\\left | T \\right |$,$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，$k=1,2,…,K$,$H(t)$为叶结点$t$上的经验熵，$\\alpha \\geqslant 0$为参数</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p><img src=\"/2017/06/21/决策树/决策树-4abd1db5.png\" alt=\"\"></p>\n<h1 id=\"连续值的处理\"><a href=\"#连续值的处理\" class=\"headerlink\" title=\"连续值的处理\"></a>连续值的处理</h1><p>比如$m$个样本的连续特征$A$有$m$个，从小到大排列为$a_1,a_2,…,a_m$,则取相邻两样本值的中位数，一共取得$m−1$个划分点，其中第$i$个划分点$T_i$表示为：</p>\n<script type=\"math/tex; mode=display\">T_i = \\frac{a_i+a_{i+1}}{2}</script><p>对于这$m−1$个点，分别计算以该点作为二元分类点时的信息增益。选择信息增益最大的点作为该连续特征的二元离散分类点。比如取到的增益最大的点$a_t$,则小于$a_t$的值为类别1，大于$a_t$的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与离散属性不同的是，<strong>如果当前结点为连续属性，则该属性后面还可以参与子结点的产生选择过程。</strong></p>\n<h1 id=\"缺失值的处理\"><a href=\"#缺失值的处理\" class=\"headerlink\" title=\"缺失值的处理\"></a>缺失值的处理</h1><p>可以简单的抛弃不完整样本，但是如果不完整样本太多，就不能简单的抛弃。面对不完整样本我们有两个问题需要解决：</p>\n<ul>\n<li>如何在属性值缺失的情况下进行划分属性选择</li>\n<li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分</li>\n</ul>\n<p>给定训练集$D$和属性$A$，令$\\tilde{D}$表示$D$中属性$A$上没有缺失值的样本子集。<strong>对问题(1)，显然我们仅可根据$\\tilde{D}$来判断属性$A$的优劣</strong>。假设属性$A$有$V$个可取的值${a^1,…,a^V}$，令$\\tilde{D}_v$表示$\\tilde{D}$中在属性$A$上取值为$a^V$的样本子集，$\\tilde{D}_k$表示$\\tilde{D}$中属于第$k$类$k=1,…,K$的样本子集，则显然有$\\tilde{D}=\\bigcup _{k=1}^K\\tilde{D}_k$、$\\tilde{D}=\\bigcup _{v=1}^V\\tilde{D}_v$。假定我们为每个样本$x$赋予一个权重$w_x$并定义<br>$\\rho =\\frac{\\sum _{x \\in \\tilde{D}}w_x}{\\sum _{x \\in D}w_x}$    $\\rho $表示无缺失样本所占的比例<br>$\\tilde{p}_k =\\frac{\\sum _{x \\in \\tilde{D}_k}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant K)$         $\\tilde{p}_k$表示无缺失值样本中第$k$类所占的比例<br>$\\tilde{r}_v =\\frac{\\sum _{x \\in \\tilde{D}_v}w_x}{\\sum _{x \\in \\tilde{D}}w_x}\\: \\: (1\\leqslant k\\leqslant V)$  $\\tilde{r}_v$表示无缺失值样本中在属性$A$上取值$a^v$所占的样本比例</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nGain(D|A)&=\\rho \\times Gain(\\tilde{D} ,A) \\\\\n &= \\rho \\times \\left ( Ent(\\tilde{D})-\\sum_{v=1}^{V} \\tilde{r}_v Ent(\\tilde{D_v})\\right )\\\\\nEnt(\\tilde{D}) &= -\\sum_{k=1}^{\\left | \\gamma  \\right |}\\tilde{p_k}log_2\\; \\tilde{p_k}\n\\end{align*}</script><p>对问题(2)，若样本$x$在属性$A$上的取值已知，则将$x$划入取值相对应的子结点，且样本权重保持为$w_x$。若样本$x$在属性$A$上的取值未知，则将$x$同时划入所有的子结点，且样本权值在属性值$a^v$对应的子结点中调整为$\\tilde{r}_v \\cdot w_x$</p>\n<h2 id=\"缺失值处理\"><a href=\"#缺失值处理\" class=\"headerlink\" title=\"缺失值处理\"></a>缺失值处理</h2><p>在某些情况下，可供使用的数据可能缺少某些属性的值。假如$〈x，c(x)〉$是样本集$S$中的一个训练实例，但是其属性$A$的值$A(x)$未知。处理缺少属性值的一种策略是赋给它结点$n$所对应的训练实例中该属性的最常见值；另外一种更复杂的策略是为$A$的每个可能值赋予一个概率。例如，给定一个布尔属性$A$，如果结点$n$包含6个已知$A=1$和4个$A=0$的实例，那么$A(x)=1$的概率是0.6，而$A(x)=0$的概率是0.4。于是，实例$x$的60%被分配到$A=1$的分支，40%被分配到另一个分支。这些片断样例的目的是计算信息增益，另外，如果有第二个缺少值的属性必须被测试，这些样例可以在后继的树分支中被进一步细分。C4.5就是使用这种方法处理缺少的属性值。</p>\n<ol>\n<li>计算属性$A$的增益或者增益率时，如果有些样本没有属性$A$，可以有这么几种处理方式： <br>(1). 忽略这些缺失属性$A$的样本。 <br>(2). 给缺失属性$A$的样本赋予属性$A$一个均值或者最常用的的值。<br>(3). 计算增益或者增益率时根据缺失属性样本个数所占的比率对增益/增益率进行相应的“打折”。 （请看周志华的机器学习）<br>(4). 根据其他未知的属性想办法把这些样本缺失的属性补全。</li>\n<li>当属性$A$已经被选择，该对样本进行分支的时候，如果有些样本缺失了属性$A$,那么： <br>(1).忽略这些样本。 <br>(2).把这些样本的属性$A$赋予一个均值或者最常出现的值，然后再对他们进行处理。<br>(3).把属性缺失样本分配给所有的子集，也就是说每个子集都有这些属性缺失样本。 <br>(4).单独为属性缺失的样本划分一个分支子集。<br>(5).对于缺失属性$A$的样本，尝试着根据其他属性给他分配一个属性$A$的值，然后继续处理将其划分到相应的子集。</li>\n<li>对于一个确实属性$A$的待分类样本，有这么几种解释<br>(1).如果有单独的确实分支，依据此分支<br>(2).把待分类的样本的属性$A$值分配一个最常见出现的$A$的属性值，然后进行分支预测<br>(3).估计其他属性为该待分类样本填充一个属性$A$值，然后进行分支处理<br>(4).在决策树中属性$A$结点的分支上，遍历属性$A$结点的所有分支，探索可能所有的分类结果，然后把这些分类结果结合起来一起考虑，按照概率决定一个分类。<br>(5).待分类样本在到达属性$A$结点时就终止分类，然后根据此时$A$结点所覆盖的叶子节结点类别状况其分配一个发生概率最高的类</li>\n</ol>"},{"title":"凸集，凸函数和凸优化","date":"2017-08-18T09:51:00.000Z","_content":"**凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。**\n\n\n# 凸集\n\n\n对于集合 $K$ ，$\\forall x_1,x_2 \\in K$,若 $\\alpha x_1 + (1-\\alpha)x_2 \\in K$,其中$α∈[0,1])$,则 $K$ 为凸集，即集合中任意两点的连线均在凸集中，如在下图所示\n\n![凸集概念](凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png)\n\n<!--more-->\n有时候需要对某个凸集进行放缩转换等操作，对凸集进行以下操作后，得到的集合依然是凸集\n\n1. 凸集的重叠（intersection）部分任然为凸集\n1. 若 $C$ 为凸集，则\n$$aC+b = \\lbrace ax+b , x \\in C, \\forall a, b\\rbrace$$\n也为凸集\n1. 对于函数 $f(x)=Ax+b$, 若 $C$ 为凸集，则下面得到的转换也为凸集，注意这里的 $A$ 是矩阵\n$$f(C) = \\lbrace f(x):x\\in C\\rbrace$$\n而当 $D$ 是一个凸集的时候，下面得到的转换也是凸集\n$$f^{-1}(D) = \\lbrace x: f(x)\\in D\\rbrace$$\n这两个转换互为逆反关系\n\n常见的凸集有下面这些(下式中 $a,x,b$ 均为向量, $A$ 为矩阵)\n\n- 点（point）、线（line）、面（plane）\n- norm ball: $\\{x:||x||≤r\\}$\n- hyperplane: $\\{x:a^Tx=b\\}$\n- halfspace: $\\{x:a^Tx≤b\\}$\n- affine space: $\\{x:Ax=b\\}$\n- polyhedron: $\\{x:Ax<b\\}$\n\n![polyheron的图像](## 凸函数的性质\n\n凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质\n\n1. 一阶特性（First-order characterization）：\n$$f(y) \\ge f(x) + \\nabla f(x)(y - x)$$\n1. 二阶特性（Second-order characterization）：\n函数的$∇^2f(x)$是半正定的。\n1. Jensen不等式（Jensen’s inequality）：\n$$f(E(x))≤E(f(x))$$\n这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。\n1. sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集/凸集，凸函数和凸优化-a587ad27.png)\n\n# 凸函数\n凸函数的定义如下\n\n设 $f(x)$ 为定义在 $n$ 维欧氏空间中某个凸集 $S$ 上的函数，若对于任何实数 $α(0<α<1)$ 以及 $S$ 中的任意不同两点 $x$ 和 $y$，均有\n$$f(\\alpha x^{(1)}+ (1-\\alpha)x^{(2)}) \\le \\alpha f(x^{(1)}) + (1-\\alpha)f(x^{(2)})$$\n则称 $f(x)$ 为定义在凸集 $S$ 上的凸函数。假如上面不等式中的 $≤$ 改为 $<$， 则称其为严格凸函数。\n\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png)\n\n## 判断凸函数\n根据凸函数的定义来判断一个函数是否为凸函数往往比较困难，**这里分别通过一阶条件和二阶条件判断凸函数。**\n### 一阶条件\n设 $f(x)$ 在凸集 $S$上有一阶连续偏导数，则 $f(x)$ 为 $S$ 上的凸函数的充要条件为：对于 任意不同两点 $x^{(1)}$和 $x^{(2)}$，均有\n$$f(x^{(2)}) \\ge f(x^{(1)}) + \\nabla f(x^{(1)})^T(x^{(2)} - x^{(1)})$$\n\n### 二阶条件\n\n设 $f(x)$ 在凸集 $S$上有二阶连续偏导数，则 $f(x)$ 为 $S$上的凸函数的充要条件为：$f(x)$ 的海塞矩阵 $∇^2f(x)$在 $S$ 上处处半正定(为凹函数的充要条件为处处半负定)。\n注意：假如海塞矩阵 $∇^2f(x)$在 $S$ 上处处正定，则 $f(x)$ 为严格凸函数，但是反过来不成立。\n\n#### 顺序主子式的定义\n\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png)\n\n##### 海塞矩阵判断凸函数例子\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png)\n\n\n## 凸函数的性质\n\n凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质\n\n1. 一阶特性（First-order characterization）：\n$$ f(y) \\ge f(x) + \\nabla f(x)(y - x) $$\n1. 二阶特性（Second-order characterization）：\n$$\\nabla^2f(x) \\succeq 0$$\n这里的 $⪰0$ 表示 Hessian 矩阵是半正定的。\n1. Jensen不等式（Jensen’s inequality）：\n$$f(E(x))≤E(f(x))$$\n这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。\n1. sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集\n\n## 常见的凸函数有下面这些\n\n1. 仿射函数( Affine function ): $a^Tx+b$\n1. 二次函数( quadratic function),注意这里的 $Q$ 必须为半正定矩阵: $\\frac{1}{2}x^TQx + b^Tx+c(Q \\succeq 0)$\n1. 最小平方误差( Least squares loss ): $||y-Ax||_2^2$ (总是凸的，因为 $A^TA$ 总是半正定的)\n1. 示性函数（Indicator function）：\n$$I_C(X) = \\begin{cases} 0&x \\in C\\\\ \\infty & x \\notin C\\end{cases}$$\n1. max function: $f(x) = max \\lbrace x_1,…x_n \\rbrace$\n1. 范数（Norm）：范数分为向量范数和矩阵范数，任意范数均为凸的，各种范数的定义如下\n - 向量范数\n0范数：$||x||_0$ 向量中非零元素的个数\n1范数： $||x||_1 = \\sum_{i=1}^n |x_i|$\n$p$ 范数：$||x||_p = (\\sum_{i=1}^nx_i^p)^{1/p}~~(p > 1)$\n无穷范数: $||x||_{\\infty} = max_{i=1,…n} |x_i|$\n\n - 矩阵范数\n核(nuclear)范数: $||X||_{tr} = \\sum_{i=1}^{r}\\sigma_i(X)$ , ($\\sigma_i(X)$是矩阵分解后的奇异值,核范数即为矩阵所有奇异值之和)\n谱（spectral）范数：$||X||_{op} = max_{i=1,…r}\\sigma_i(X)$, 即为最大的奇异值\n\n# 凸优化\n对于下面的优化问题\n$$\\begin{align*} &\\min_x\\quad f(x)\\\\ &\\begin{array}\\\\ s.t.&g_i(x) \\le 0,~i=1,\\ldots,m\\\\ &h_j(x)=0,~j=1,\\ldots,r \\end{array} \\end{align*}$$\n当 $f(x),gi(x$ 均为凸函数， 而 $h_j(x)$ 为仿射函数（affine function）时，该优化称为凸优化,注意上面的 min 以及约束条件的符号均要符合规定。\n**凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。**\n\n## 常见的一些凸优化问题\n常见的一些凸优化问题有：线性规划（linear programs），二次规划（quadratic programs），半正定规划（semidefinite programs），且 $LP∈QP∈SDP$, 即后者是包含前者的关系。\n\n- 线性规划问题一般原型如下($c$为向量，$D,A$为矩阵)\n\n$$\\begin{align*} &\\min_x\\quad c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}$$\n\n- 二次规划问题一般原型如下（要求矩阵 $Q$ 半正定）\n\n$$\\begin{align*} &\\min_x\\quad \\frac{1}{2}x^TQx+c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}$$\n\n- 而半正定规划问题一般原型如下(X 在这里表示矩阵)\n\n$$\\begin{align*} &\\min_X\\quad CX\\\\ &\\begin{array}\\\\ s.t.&A_iX \\le b_i, i=1,…m\\\\ &X \\succeq 0 \\end{array} \\end{align*}$$\n","source":"_posts/凸集，凸函数和凸优化.md","raw":"---\ntitle: 凸集，凸函数和凸优化\ndate: 2017-08-18 17:51:00\ntags: [人工智能,凸优化]\ncategories: 数学\n---\n**凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。**\n\n\n# 凸集\n\n\n对于集合 $K$ ，$\\forall x_1,x_2 \\in K$,若 $\\alpha x_1 + (1-\\alpha)x_2 \\in K$,其中$α∈[0,1])$,则 $K$ 为凸集，即集合中任意两点的连线均在凸集中，如在下图所示\n\n![凸集概念](凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png)\n\n<!--more-->\n有时候需要对某个凸集进行放缩转换等操作，对凸集进行以下操作后，得到的集合依然是凸集\n\n1. 凸集的重叠（intersection）部分任然为凸集\n1. 若 $C$ 为凸集，则\n$$aC+b = \\lbrace ax+b , x \\in C, \\forall a, b\\rbrace$$\n也为凸集\n1. 对于函数 $f(x)=Ax+b$, 若 $C$ 为凸集，则下面得到的转换也为凸集，注意这里的 $A$ 是矩阵\n$$f(C) = \\lbrace f(x):x\\in C\\rbrace$$\n而当 $D$ 是一个凸集的时候，下面得到的转换也是凸集\n$$f^{-1}(D) = \\lbrace x: f(x)\\in D\\rbrace$$\n这两个转换互为逆反关系\n\n常见的凸集有下面这些(下式中 $a,x,b$ 均为向量, $A$ 为矩阵)\n\n- 点（point）、线（line）、面（plane）\n- norm ball: $\\{x:||x||≤r\\}$\n- hyperplane: $\\{x:a^Tx=b\\}$\n- halfspace: $\\{x:a^Tx≤b\\}$\n- affine space: $\\{x:Ax=b\\}$\n- polyhedron: $\\{x:Ax<b\\}$\n\n![polyheron的图像](## 凸函数的性质\n\n凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质\n\n1. 一阶特性（First-order characterization）：\n$$f(y) \\ge f(x) + \\nabla f(x)(y - x)$$\n1. 二阶特性（Second-order characterization）：\n函数的$∇^2f(x)$是半正定的。\n1. Jensen不等式（Jensen’s inequality）：\n$$f(E(x))≤E(f(x))$$\n这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。\n1. sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集/凸集，凸函数和凸优化-a587ad27.png)\n\n# 凸函数\n凸函数的定义如下\n\n设 $f(x)$ 为定义在 $n$ 维欧氏空间中某个凸集 $S$ 上的函数，若对于任何实数 $α(0<α<1)$ 以及 $S$ 中的任意不同两点 $x$ 和 $y$，均有\n$$f(\\alpha x^{(1)}+ (1-\\alpha)x^{(2)}) \\le \\alpha f(x^{(1)}) + (1-\\alpha)f(x^{(2)})$$\n则称 $f(x)$ 为定义在凸集 $S$ 上的凸函数。假如上面不等式中的 $≤$ 改为 $<$， 则称其为严格凸函数。\n\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png)\n\n## 判断凸函数\n根据凸函数的定义来判断一个函数是否为凸函数往往比较困难，**这里分别通过一阶条件和二阶条件判断凸函数。**\n### 一阶条件\n设 $f(x)$ 在凸集 $S$上有一阶连续偏导数，则 $f(x)$ 为 $S$ 上的凸函数的充要条件为：对于 任意不同两点 $x^{(1)}$和 $x^{(2)}$，均有\n$$f(x^{(2)}) \\ge f(x^{(1)}) + \\nabla f(x^{(1)})^T(x^{(2)} - x^{(1)})$$\n\n### 二阶条件\n\n设 $f(x)$ 在凸集 $S$上有二阶连续偏导数，则 $f(x)$ 为 $S$上的凸函数的充要条件为：$f(x)$ 的海塞矩阵 $∇^2f(x)$在 $S$ 上处处半正定(为凹函数的充要条件为处处半负定)。\n注意：假如海塞矩阵 $∇^2f(x)$在 $S$ 上处处正定，则 $f(x)$ 为严格凸函数，但是反过来不成立。\n\n#### 顺序主子式的定义\n\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png)\n\n##### 海塞矩阵判断凸函数例子\n![](凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png)\n\n\n## 凸函数的性质\n\n凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质\n\n1. 一阶特性（First-order characterization）：\n$$ f(y) \\ge f(x) + \\nabla f(x)(y - x) $$\n1. 二阶特性（Second-order characterization）：\n$$\\nabla^2f(x) \\succeq 0$$\n这里的 $⪰0$ 表示 Hessian 矩阵是半正定的。\n1. Jensen不等式（Jensen’s inequality）：\n$$f(E(x))≤E(f(x))$$\n这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。\n1. sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集\n\n## 常见的凸函数有下面这些\n\n1. 仿射函数( Affine function ): $a^Tx+b$\n1. 二次函数( quadratic function),注意这里的 $Q$ 必须为半正定矩阵: $\\frac{1}{2}x^TQx + b^Tx+c(Q \\succeq 0)$\n1. 最小平方误差( Least squares loss ): $||y-Ax||_2^2$ (总是凸的，因为 $A^TA$ 总是半正定的)\n1. 示性函数（Indicator function）：\n$$I_C(X) = \\begin{cases} 0&x \\in C\\\\ \\infty & x \\notin C\\end{cases}$$\n1. max function: $f(x) = max \\lbrace x_1,…x_n \\rbrace$\n1. 范数（Norm）：范数分为向量范数和矩阵范数，任意范数均为凸的，各种范数的定义如下\n - 向量范数\n0范数：$||x||_0$ 向量中非零元素的个数\n1范数： $||x||_1 = \\sum_{i=1}^n |x_i|$\n$p$ 范数：$||x||_p = (\\sum_{i=1}^nx_i^p)^{1/p}~~(p > 1)$\n无穷范数: $||x||_{\\infty} = max_{i=1,…n} |x_i|$\n\n - 矩阵范数\n核(nuclear)范数: $||X||_{tr} = \\sum_{i=1}^{r}\\sigma_i(X)$ , ($\\sigma_i(X)$是矩阵分解后的奇异值,核范数即为矩阵所有奇异值之和)\n谱（spectral）范数：$||X||_{op} = max_{i=1,…r}\\sigma_i(X)$, 即为最大的奇异值\n\n# 凸优化\n对于下面的优化问题\n$$\\begin{align*} &\\min_x\\quad f(x)\\\\ &\\begin{array}\\\\ s.t.&g_i(x) \\le 0,~i=1,\\ldots,m\\\\ &h_j(x)=0,~j=1,\\ldots,r \\end{array} \\end{align*}$$\n当 $f(x),gi(x$ 均为凸函数， 而 $h_j(x)$ 为仿射函数（affine function）时，该优化称为凸优化,注意上面的 min 以及约束条件的符号均要符合规定。\n**凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。**\n\n## 常见的一些凸优化问题\n常见的一些凸优化问题有：线性规划（linear programs），二次规划（quadratic programs），半正定规划（semidefinite programs），且 $LP∈QP∈SDP$, 即后者是包含前者的关系。\n\n- 线性规划问题一般原型如下($c$为向量，$D,A$为矩阵)\n\n$$\\begin{align*} &\\min_x\\quad c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}$$\n\n- 二次规划问题一般原型如下（要求矩阵 $Q$ 半正定）\n\n$$\\begin{align*} &\\min_x\\quad \\frac{1}{2}x^TQx+c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}$$\n\n- 而半正定规划问题一般原型如下(X 在这里表示矩阵)\n\n$$\\begin{align*} &\\min_X\\quad CX\\\\ &\\begin{array}\\\\ s.t.&A_iX \\le b_i, i=1,…m\\\\ &X \\succeq 0 \\end{array} \\end{align*}$$\n","slug":"凸集，凸函数和凸优化","published":1,"updated":"2019-07-30T01:54:38.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izu0044homj6wqfpckb","content":"<p><strong>凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。</strong></p>\n<h1 id=\"凸集\"><a href=\"#凸集\" class=\"headerlink\" title=\"凸集\"></a>凸集</h1><p>对于集合 $K$ ，$\\forall x_1,x_2 \\in K$,若 $\\alpha x_1 + (1-\\alpha)x_2 \\in K$,其中$α∈[0,1])$,则 $K$ 为凸集，即集合中任意两点的连线均在凸集中，如在下图所示</p>\n<p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png\" alt=\"凸集概念\"></p>\n<a id=\"more\"></a>\n<p>有时候需要对某个凸集进行放缩转换等操作，对凸集进行以下操作后，得到的集合依然是凸集</p>\n<ol>\n<li>凸集的重叠（intersection）部分任然为凸集</li>\n<li>若 $C$ 为凸集，则<script type=\"math/tex; mode=display\">aC+b = \\lbrace ax+b , x \\in C, \\forall a, b\\rbrace</script>也为凸集</li>\n<li>对于函数 $f(x)=Ax+b$, 若 $C$ 为凸集，则下面得到的转换也为凸集，注意这里的 $A$ 是矩阵<script type=\"math/tex; mode=display\">f(C) = \\lbrace f(x):x\\in C\\rbrace</script>而当 $D$ 是一个凸集的时候，下面得到的转换也是凸集<script type=\"math/tex; mode=display\">f^{-1}(D) = \\lbrace x: f(x)\\in D\\rbrace</script>这两个转换互为逆反关系</li>\n</ol>\n<p>常见的凸集有下面这些(下式中 $a,x,b$ 均为向量, $A$ 为矩阵)</p>\n<ul>\n<li>点（point）、线（line）、面（plane）</li>\n<li>norm ball: $\\{x:||x||≤r\\}$</li>\n<li>hyperplane: $\\{x:a^Tx=b\\}$</li>\n<li>halfspace: $\\{x:a^Tx≤b\\}$</li>\n<li>affine space: $\\{x:Ax=b\\}$</li>\n<li>polyhedron: $\\{x:Ax&lt;b\\}$</li>\n</ul>\n<p>![polyheron的图像](## 凸函数的性质</p>\n<p>凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质</p>\n<ol>\n<li>一阶特性（First-order characterization）：<script type=\"math/tex; mode=display\">f(y) \\ge f(x) + \\nabla f(x)(y - x)</script></li>\n<li>二阶特性（Second-order characterization）：<br>函数的$∇^2f(x)$是半正定的。</li>\n<li>Jensen不等式（Jensen’s inequality）：<script type=\"math/tex; mode=display\">f(E(x))≤E(f(x))</script>这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。</li>\n<li>sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集/凸集，凸函数和凸优化-a587ad27.png)</li>\n</ol>\n<h1 id=\"凸函数\"><a href=\"#凸函数\" class=\"headerlink\" title=\"凸函数\"></a>凸函数</h1><p>凸函数的定义如下</p>\n<p>设 $f(x)$ 为定义在 $n$ 维欧氏空间中某个凸集 $S$ 上的函数，若对于任何实数 $α(0&lt;α&lt;1)$ 以及 $S$ 中的任意不同两点 $x$ 和 $y$，均有</p>\n<script type=\"math/tex; mode=display\">f(\\alpha x^{(1)}+ (1-\\alpha)x^{(2)}) \\le \\alpha f(x^{(1)}) + (1-\\alpha)f(x^{(2)})</script><p>则称 $f(x)$ 为定义在凸集 $S$ 上的凸函数。假如上面不等式中的 $≤$ 改为 $&lt;$， 则称其为严格凸函数。</p>\n<p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png\" alt=\"\"></p>\n<h2 id=\"判断凸函数\"><a href=\"#判断凸函数\" class=\"headerlink\" title=\"判断凸函数\"></a>判断凸函数</h2><p>根据凸函数的定义来判断一个函数是否为凸函数往往比较困难，<strong>这里分别通过一阶条件和二阶条件判断凸函数。</strong></p>\n<h3 id=\"一阶条件\"><a href=\"#一阶条件\" class=\"headerlink\" title=\"一阶条件\"></a>一阶条件</h3><p>设 $f(x)$ 在凸集 $S$上有一阶连续偏导数，则 $f(x)$ 为 $S$ 上的凸函数的充要条件为：对于 任意不同两点 $x^{(1)}$和 $x^{(2)}$，均有</p>\n<script type=\"math/tex; mode=display\">f(x^{(2)}) \\ge f(x^{(1)}) + \\nabla f(x^{(1)})^T(x^{(2)} - x^{(1)})</script><h3 id=\"二阶条件\"><a href=\"#二阶条件\" class=\"headerlink\" title=\"二阶条件\"></a>二阶条件</h3><p>设 $f(x)$ 在凸集 $S$上有二阶连续偏导数，则 $f(x)$ 为 $S$上的凸函数的充要条件为：$f(x)$ 的海塞矩阵 $∇^2f(x)$在 $S$ 上处处半正定(为凹函数的充要条件为处处半负定)。<br>注意：假如海塞矩阵 $∇^2f(x)$在 $S$ 上处处正定，则 $f(x)$ 为严格凸函数，但是反过来不成立。</p>\n<h4 id=\"顺序主子式的定义\"><a href=\"#顺序主子式的定义\" class=\"headerlink\" title=\"顺序主子式的定义\"></a>顺序主子式的定义</h4><p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png\" alt=\"\"></p>\n<h5 id=\"海塞矩阵判断凸函数例子\"><a href=\"#海塞矩阵判断凸函数例子\" class=\"headerlink\" title=\"海塞矩阵判断凸函数例子\"></a>海塞矩阵判断凸函数例子</h5><p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png\" alt=\"\"></p>\n<h2 id=\"凸函数的性质\"><a href=\"#凸函数的性质\" class=\"headerlink\" title=\"凸函数的性质\"></a>凸函数的性质</h2><p>凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质</p>\n<ol>\n<li>一阶特性（First-order characterization）：<script type=\"math/tex; mode=display\">f(y) \\ge f(x) + \\nabla f(x)(y - x)</script></li>\n<li>二阶特性（Second-order characterization）：<script type=\"math/tex; mode=display\">\\nabla^2f(x) \\succeq 0</script>这里的 $⪰0$ 表示 Hessian 矩阵是半正定的。</li>\n<li>Jensen不等式（Jensen’s inequality）：<script type=\"math/tex; mode=display\">f(E(x))≤E(f(x))</script>这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。</li>\n<li>sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集</li>\n</ol>\n<h2 id=\"常见的凸函数有下面这些\"><a href=\"#常见的凸函数有下面这些\" class=\"headerlink\" title=\"常见的凸函数有下面这些\"></a>常见的凸函数有下面这些</h2><ol>\n<li>仿射函数( Affine function ): $a^Tx+b$</li>\n<li>二次函数( quadratic function),注意这里的 $Q$ 必须为半正定矩阵: $\\frac{1}{2}x^TQx + b^Tx+c(Q \\succeq 0)$</li>\n<li>最小平方误差( Least squares loss ): $||y-Ax||_2^2$ (总是凸的，因为 $A^TA$ 总是半正定的)</li>\n<li>示性函数（Indicator function）：<script type=\"math/tex; mode=display\">I_C(X) = \\begin{cases} 0&x \\in C\\\\ \\infty & x \\notin C\\end{cases}</script></li>\n<li>max function: $f(x) = max \\lbrace x_1,…x_n \\rbrace$</li>\n<li><p>范数（Norm）：范数分为向量范数和矩阵范数，任意范数均为凸的，各种范数的定义如下</p>\n<ul>\n<li><p>向量范数<br>0范数：$||x||_0$ 向量中非零元素的个数<br>1范数： $||x||_1 = \\sum_{i=1}^n |x_i|$<br>$p$ 范数：$||x||_p = (\\sum_{i=1}^nx_i^p)^{1/p}~~(p &gt; 1)$<br>无穷范数: $||x||_{\\infty} = max_{i=1,…n} |x_i|$</p>\n</li>\n<li><p>矩阵范数<br>核(nuclear)范数: $||X||_{tr} = \\sum_{i=1}^{r}\\sigma_i(X)$ , ($\\sigma_i(X)$是矩阵分解后的奇异值,核范数即为矩阵所有奇异值之和)<br>谱（spectral）范数：$||X||_{op} = max_{i=1,…r}\\sigma_i(X)$, 即为最大的奇异值</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"凸优化\"><a href=\"#凸优化\" class=\"headerlink\" title=\"凸优化\"></a>凸优化</h1><p>对于下面的优化问题</p>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad f(x)\\\\ &\\begin{array}\\\\ s.t.&g_i(x) \\le 0,~i=1,\\ldots,m\\\\ &h_j(x)=0,~j=1,\\ldots,r \\end{array} \\end{align*}</script><p>当 $f(x),gi(x$ 均为凸函数， 而 $h_j(x)$ 为仿射函数（affine function）时，该优化称为凸优化,注意上面的 min 以及约束条件的符号均要符合规定。<br><strong>凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。</strong></p>\n<h2 id=\"常见的一些凸优化问题\"><a href=\"#常见的一些凸优化问题\" class=\"headerlink\" title=\"常见的一些凸优化问题\"></a>常见的一些凸优化问题</h2><p>常见的一些凸优化问题有：线性规划（linear programs），二次规划（quadratic programs），半正定规划（semidefinite programs），且 $LP∈QP∈SDP$, 即后者是包含前者的关系。</p>\n<ul>\n<li>线性规划问题一般原型如下($c$为向量，$D,A$为矩阵)</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}</script><ul>\n<li>二次规划问题一般原型如下（要求矩阵 $Q$ 半正定）</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad \\frac{1}{2}x^TQx+c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}</script><ul>\n<li>而半正定规划问题一般原型如下(X 在这里表示矩阵)</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_X\\quad CX\\\\ &\\begin{array}\\\\ s.t.&A_iX \\le b_i, i=1,…m\\\\ &X \\succeq 0 \\end{array} \\end{align*}</script>","site":{"data":{}},"excerpt":"<p><strong>凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。</strong></p>\n<h1 id=\"凸集\"><a href=\"#凸集\" class=\"headerlink\" title=\"凸集\"></a>凸集</h1><p>对于集合 $K$ ，$\\forall x_1,x_2 \\in K$,若 $\\alpha x_1 + (1-\\alpha)x_2 \\in K$,其中$α∈[0,1])$,则 $K$ 为凸集，即集合中任意两点的连线均在凸集中，如在下图所示</p>\n<p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png\" alt=\"凸集概念\"></p>","more":"<p>有时候需要对某个凸集进行放缩转换等操作，对凸集进行以下操作后，得到的集合依然是凸集</p>\n<ol>\n<li>凸集的重叠（intersection）部分任然为凸集</li>\n<li>若 $C$ 为凸集，则<script type=\"math/tex; mode=display\">aC+b = \\lbrace ax+b , x \\in C, \\forall a, b\\rbrace</script>也为凸集</li>\n<li>对于函数 $f(x)=Ax+b$, 若 $C$ 为凸集，则下面得到的转换也为凸集，注意这里的 $A$ 是矩阵<script type=\"math/tex; mode=display\">f(C) = \\lbrace f(x):x\\in C\\rbrace</script>而当 $D$ 是一个凸集的时候，下面得到的转换也是凸集<script type=\"math/tex; mode=display\">f^{-1}(D) = \\lbrace x: f(x)\\in D\\rbrace</script>这两个转换互为逆反关系</li>\n</ol>\n<p>常见的凸集有下面这些(下式中 $a,x,b$ 均为向量, $A$ 为矩阵)</p>\n<ul>\n<li>点（point）、线（line）、面（plane）</li>\n<li>norm ball: $\\{x:||x||≤r\\}$</li>\n<li>hyperplane: $\\{x:a^Tx=b\\}$</li>\n<li>halfspace: $\\{x:a^Tx≤b\\}$</li>\n<li>affine space: $\\{x:Ax=b\\}$</li>\n<li>polyhedron: $\\{x:Ax&lt;b\\}$</li>\n</ul>\n<p>![polyheron的图像](## 凸函数的性质</p>\n<p>凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质</p>\n<ol>\n<li>一阶特性（First-order characterization）：<script type=\"math/tex; mode=display\">f(y) \\ge f(x) + \\nabla f(x)(y - x)</script></li>\n<li>二阶特性（Second-order characterization）：<br>函数的$∇^2f(x)$是半正定的。</li>\n<li>Jensen不等式（Jensen’s inequality）：<script type=\"math/tex; mode=display\">f(E(x))≤E(f(x))</script>这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。</li>\n<li>sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集/凸集，凸函数和凸优化-a587ad27.png)</li>\n</ol>\n<h1 id=\"凸函数\"><a href=\"#凸函数\" class=\"headerlink\" title=\"凸函数\"></a>凸函数</h1><p>凸函数的定义如下</p>\n<p>设 $f(x)$ 为定义在 $n$ 维欧氏空间中某个凸集 $S$ 上的函数，若对于任何实数 $α(0&lt;α&lt;1)$ 以及 $S$ 中的任意不同两点 $x$ 和 $y$，均有</p>\n<script type=\"math/tex; mode=display\">f(\\alpha x^{(1)}+ (1-\\alpha)x^{(2)}) \\le \\alpha f(x^{(1)}) + (1-\\alpha)f(x^{(2)})</script><p>则称 $f(x)$ 为定义在凸集 $S$ 上的凸函数。假如上面不等式中的 $≤$ 改为 $&lt;$， 则称其为严格凸函数。</p>\n<p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png\" alt=\"\"></p>\n<h2 id=\"判断凸函数\"><a href=\"#判断凸函数\" class=\"headerlink\" title=\"判断凸函数\"></a>判断凸函数</h2><p>根据凸函数的定义来判断一个函数是否为凸函数往往比较困难，<strong>这里分别通过一阶条件和二阶条件判断凸函数。</strong></p>\n<h3 id=\"一阶条件\"><a href=\"#一阶条件\" class=\"headerlink\" title=\"一阶条件\"></a>一阶条件</h3><p>设 $f(x)$ 在凸集 $S$上有一阶连续偏导数，则 $f(x)$ 为 $S$ 上的凸函数的充要条件为：对于 任意不同两点 $x^{(1)}$和 $x^{(2)}$，均有</p>\n<script type=\"math/tex; mode=display\">f(x^{(2)}) \\ge f(x^{(1)}) + \\nabla f(x^{(1)})^T(x^{(2)} - x^{(1)})</script><h3 id=\"二阶条件\"><a href=\"#二阶条件\" class=\"headerlink\" title=\"二阶条件\"></a>二阶条件</h3><p>设 $f(x)$ 在凸集 $S$上有二阶连续偏导数，则 $f(x)$ 为 $S$上的凸函数的充要条件为：$f(x)$ 的海塞矩阵 $∇^2f(x)$在 $S$ 上处处半正定(为凹函数的充要条件为处处半负定)。<br>注意：假如海塞矩阵 $∇^2f(x)$在 $S$ 上处处正定，则 $f(x)$ 为严格凸函数，但是反过来不成立。</p>\n<h4 id=\"顺序主子式的定义\"><a href=\"#顺序主子式的定义\" class=\"headerlink\" title=\"顺序主子式的定义\"></a>顺序主子式的定义</h4><p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png\" alt=\"\"></p>\n<h5 id=\"海塞矩阵判断凸函数例子\"><a href=\"#海塞矩阵判断凸函数例子\" class=\"headerlink\" title=\"海塞矩阵判断凸函数例子\"></a>海塞矩阵判断凸函数例子</h5><p><img src=\"/2017/08/18/凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png\" alt=\"\"></p>\n<h2 id=\"凸函数的性质\"><a href=\"#凸函数的性质\" class=\"headerlink\" title=\"凸函数的性质\"></a>凸函数的性质</h2><p>凸函数有几个非常重要的性质，对于一个凸函数 $f$, 其重要性质</p>\n<ol>\n<li>一阶特性（First-order characterization）：<script type=\"math/tex; mode=display\">f(y) \\ge f(x) + \\nabla f(x)(y - x)</script></li>\n<li>二阶特性（Second-order characterization）：<script type=\"math/tex; mode=display\">\\nabla^2f(x) \\succeq 0</script>这里的 $⪰0$ 表示 Hessian 矩阵是半正定的。</li>\n<li>Jensen不等式（Jensen’s inequality）：<script type=\"math/tex; mode=display\">f(E(x))≤E(f(x))</script>这里的 $E$ 表示的是期望，这是从凸函数拓展到概率论的一个推论，这里不详细展开。</li>\n<li>sublevel sets，即集合 $\\{x:f(x)≤t\\}$ 是一个凸集</li>\n</ol>\n<h2 id=\"常见的凸函数有下面这些\"><a href=\"#常见的凸函数有下面这些\" class=\"headerlink\" title=\"常见的凸函数有下面这些\"></a>常见的凸函数有下面这些</h2><ol>\n<li>仿射函数( Affine function ): $a^Tx+b$</li>\n<li>二次函数( quadratic function),注意这里的 $Q$ 必须为半正定矩阵: $\\frac{1}{2}x^TQx + b^Tx+c(Q \\succeq 0)$</li>\n<li>最小平方误差( Least squares loss ): $||y-Ax||_2^2$ (总是凸的，因为 $A^TA$ 总是半正定的)</li>\n<li>示性函数（Indicator function）：<script type=\"math/tex; mode=display\">I_C(X) = \\begin{cases} 0&x \\in C\\\\ \\infty & x \\notin C\\end{cases}</script></li>\n<li>max function: $f(x) = max \\lbrace x_1,…x_n \\rbrace$</li>\n<li><p>范数（Norm）：范数分为向量范数和矩阵范数，任意范数均为凸的，各种范数的定义如下</p>\n<ul>\n<li><p>向量范数<br>0范数：$||x||_0$ 向量中非零元素的个数<br>1范数： $||x||_1 = \\sum_{i=1}^n |x_i|$<br>$p$ 范数：$||x||_p = (\\sum_{i=1}^nx_i^p)^{1/p}~~(p &gt; 1)$<br>无穷范数: $||x||_{\\infty} = max_{i=1,…n} |x_i|$</p>\n</li>\n<li><p>矩阵范数<br>核(nuclear)范数: $||X||_{tr} = \\sum_{i=1}^{r}\\sigma_i(X)$ , ($\\sigma_i(X)$是矩阵分解后的奇异值,核范数即为矩阵所有奇异值之和)<br>谱（spectral）范数：$||X||_{op} = max_{i=1,…r}\\sigma_i(X)$, 即为最大的奇异值</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"凸优化\"><a href=\"#凸优化\" class=\"headerlink\" title=\"凸优化\"></a>凸优化</h1><p>对于下面的优化问题</p>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad f(x)\\\\ &\\begin{array}\\\\ s.t.&g_i(x) \\le 0,~i=1,\\ldots,m\\\\ &h_j(x)=0,~j=1,\\ldots,r \\end{array} \\end{align*}</script><p>当 $f(x),gi(x$ 均为凸函数， 而 $h_j(x)$ 为仿射函数（affine function）时，该优化称为凸优化,注意上面的 min 以及约束条件的符号均要符合规定。<br><strong>凸优化也可以解释为目标函数 $f(x)$ 为凸函数而起约束围成的可行域为一个凸集。</strong></p>\n<h2 id=\"常见的一些凸优化问题\"><a href=\"#常见的一些凸优化问题\" class=\"headerlink\" title=\"常见的一些凸优化问题\"></a>常见的一些凸优化问题</h2><p>常见的一些凸优化问题有：线性规划（linear programs），二次规划（quadratic programs），半正定规划（semidefinite programs），且 $LP∈QP∈SDP$, 即后者是包含前者的关系。</p>\n<ul>\n<li>线性规划问题一般原型如下($c$为向量，$D,A$为矩阵)</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}</script><ul>\n<li>二次规划问题一般原型如下（要求矩阵 $Q$ 半正定）</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_x\\quad \\frac{1}{2}x^TQx+c^Tx\\\\ &\\begin{array}\\\\ s.t.&Dx \\le d\\\\ &Ax=b \\end{array} \\end{align*}</script><ul>\n<li>而半正定规划问题一般原型如下(X 在这里表示矩阵)</li>\n</ul>\n<script type=\"math/tex; mode=display\">\\begin{align*} &\\min_X\\quad CX\\\\ &\\begin{array}\\\\ s.t.&A_iX \\le b_i, i=1,…m\\\\ &X \\succeq 0 \\end{array} \\end{align*}</script>"},{"title":"单链表","date":"2017-08-28T13:52:41.000Z","_content":"# [定义](https://www.jianshu.com/p/a34924b229d9)\n\n数据域：存储数据元素信息的域，指针域：存储直接后继位置的域。指针域中存储的信息成为指针或链。这两部分信息组成数据元素成为存储映像，成为结点(Node)。\n数据域|指针域\n-|-\ndata|next\n# 头结点与头指针\n- 头结点\n头结点是加在单链表之前附设的一个头结点。头结点的数据域一般不存储任何信息，也可以存放一些关于线性表的长度的附加信息。\n-头指针\n头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。\n<!--more-->\n# 代码\n```c\n#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#define NULL 0\n\ntypedef int ElemType;\n\nvoid Error(char *s){\n    cout<<s<<endl;\n    exit(1);\n}\n\ntypedef struct LNode\n{\n    ElemType data;\n    struct LNode *next;\n}LNode;\ntypedef LNode *Linklist;    //头指针\nvoid Error(char *s)           //错误指示\n{\n    std::cout << s << endl;\n    exit(1);\n}\n//创建链表,生成一个新节点作为头结点,并设其指针域为空\nVoid InitList(Linklist &L)\n{\n    L=new LNode;\n    L->next=NULL;\n}\n//销毁链表,从链表的头结点开始依次释放表中每一个结点所占用的存储空间\nVoid DestroyList(Linklist L)\n{\n    while(L){\n        LNode *p=L;\n        L=L->next;\n        delete p;\n    }\n}\n//设置单链表为空表，并释放所有结点空间\nvoid ClearList(Linklist &L)\n{\n    LNode *p = L->next;\n    L->next=NULL;\n    L.length=0;\n    while (p)\n    {\n        Linklist *q=p;\n        p = p->next;\n        delete q;\n    }\n}\n//求链表长度\nint ListLength(Linklist L)\n{\n    int length=0;\n    LNode *p = L;\n    while(p->next){\n        length++;\n        p=p->next;\n    }\n    return length;\n}\n//返回链表中第i个结点数据域的值，1<=i<=表长;若i值不合法，则给出错误信息\nElemType GetElem_L(Linklist L, int i)\n{\n    int count = 1;\n    LNode *p = L->next;\n    while (p && (count < i)) {\n        p = p->next;\n        count++;\n    }\n    if (!(p->next)||count>i)  Error(\"position Error\") ;\n    else  return  p->data;\n}\n//查找链表中第一个数据域值和x相等的结点\nLNode *LocateElem_L(Linklist L, ElemType x)\n{\n    LNode *p =L->next;              //将指针头传给指针p\n    int j = 1;\n    while (p && (p->data != x))   //向后扫描查找\n    {\n        p = p->next;\n    }\n    return p;\n}\n//向链表中第i个位置插入元素x ,1<=x<=表长+1\n//若插入位置不合理则给出相应信息\nvoid ListInsert(Linklist &L, int i, int stu)\n\n{\n    LNode *p =L;              //将指针头传给指针p\n    int j = 0;\n    while (p && (j < i - 1))   //向后扫描查找\n    {\n        p = p->next;\n        j++;\n    }\n    if (!p || (j > i - 1))     //输入参数不对，给出错误提示，并跳出\n        Error(\"Postion Eeeor!\");\n    else\n    {\n        LNode *s = new  LNode;\n        s->next = p->next;\n        p->next = s;\n    }\n}\n//删除链表L中第i个结点数据域值，并用返回,1<=x<=表长+1\n//若删除位置不合理则给出相应信息\nElemType ListDelete_L(Linklist &L, int i)\n{\n    LNode *p = L; //将指针头传给指针p\n    int j = 0;\n    while ((p ->next) && (j < i - 1))\n    {\n        p = p->next;\n        j++;\n    }\n    if (!(p->next) || (j > i - 1))\n        Error(\"Postion Eeeor!\"); // 输入参数不对，给出错误提示，并跳出\n    else\n    {\n        LNode *q = p->next;\n        ElemType x= p->data;\n        p->next = q->next;\n        delete q;\n        return x;\n    }\n}\n```\n# 单链表正标操作\n## 整表创建\n### 头插法\n```\n/**\n* 头插法\n*/\nvoid CreatListHead(LinkList *L, int n){\n\n    LinkList p;\n    int i;\n\n    srand(time(0));  // 初始化随机数种子\n\n    *L = (LinkList)malloc(sizeof(Node));\n    (*L)->next = NULL;\n\n    for (i = 0; i < n; i++) {\n\n        p = (LinkList)malloc(sizeof(Node)); // 生成新节点\n        p ->data = rand()%100 + 1;\n        p->next = (*L)->next;\n        (*L)->next = p;\n\n    }\n}\n```\n### 尾插法\n```c\n\n/**\n* 尾插法\n*/\nvoid CreatListTail(LinkList *L, int n){\n\n    LinkList p, r;\n    int i;\n\n    srand(time(0));\n    *L = (LinkList)malloc(sizeof(Node));\n    r = *L;\n\n    for (i = 0; i < n; i++) {\n\n        p = (Node *)malloc(sizeof(Node));\n        p->data = rand()%100+1;\n        r->next = p;\n        r = p;\n    }\n\n    r->next = NULL;\n}\n```\n## 整表删除\n```c\nStatus ClearList(LinkList *L){\n\n    LinkList p,q;\n\n    p = (*L)->next;\n\n    while (p) {\n        q = p->next;\n        free(p);\n        p = q;\n    }\n\n    (*L)->next = NULL;\n\n    return OK;\n}\n\n```\n","source":"_posts/单链表.md","raw":"---\ntitle: 单链表\ndate: 2017-08-28 21:52:41\ntags: [线性表]\ncategories: 数据结构\n---\n# [定义](https://www.jianshu.com/p/a34924b229d9)\n\n数据域：存储数据元素信息的域，指针域：存储直接后继位置的域。指针域中存储的信息成为指针或链。这两部分信息组成数据元素成为存储映像，成为结点(Node)。\n数据域|指针域\n-|-\ndata|next\n# 头结点与头指针\n- 头结点\n头结点是加在单链表之前附设的一个头结点。头结点的数据域一般不存储任何信息，也可以存放一些关于线性表的长度的附加信息。\n-头指针\n头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。\n<!--more-->\n# 代码\n```c\n#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#define NULL 0\n\ntypedef int ElemType;\n\nvoid Error(char *s){\n    cout<<s<<endl;\n    exit(1);\n}\n\ntypedef struct LNode\n{\n    ElemType data;\n    struct LNode *next;\n}LNode;\ntypedef LNode *Linklist;    //头指针\nvoid Error(char *s)           //错误指示\n{\n    std::cout << s << endl;\n    exit(1);\n}\n//创建链表,生成一个新节点作为头结点,并设其指针域为空\nVoid InitList(Linklist &L)\n{\n    L=new LNode;\n    L->next=NULL;\n}\n//销毁链表,从链表的头结点开始依次释放表中每一个结点所占用的存储空间\nVoid DestroyList(Linklist L)\n{\n    while(L){\n        LNode *p=L;\n        L=L->next;\n        delete p;\n    }\n}\n//设置单链表为空表，并释放所有结点空间\nvoid ClearList(Linklist &L)\n{\n    LNode *p = L->next;\n    L->next=NULL;\n    L.length=0;\n    while (p)\n    {\n        Linklist *q=p;\n        p = p->next;\n        delete q;\n    }\n}\n//求链表长度\nint ListLength(Linklist L)\n{\n    int length=0;\n    LNode *p = L;\n    while(p->next){\n        length++;\n        p=p->next;\n    }\n    return length;\n}\n//返回链表中第i个结点数据域的值，1<=i<=表长;若i值不合法，则给出错误信息\nElemType GetElem_L(Linklist L, int i)\n{\n    int count = 1;\n    LNode *p = L->next;\n    while (p && (count < i)) {\n        p = p->next;\n        count++;\n    }\n    if (!(p->next)||count>i)  Error(\"position Error\") ;\n    else  return  p->data;\n}\n//查找链表中第一个数据域值和x相等的结点\nLNode *LocateElem_L(Linklist L, ElemType x)\n{\n    LNode *p =L->next;              //将指针头传给指针p\n    int j = 1;\n    while (p && (p->data != x))   //向后扫描查找\n    {\n        p = p->next;\n    }\n    return p;\n}\n//向链表中第i个位置插入元素x ,1<=x<=表长+1\n//若插入位置不合理则给出相应信息\nvoid ListInsert(Linklist &L, int i, int stu)\n\n{\n    LNode *p =L;              //将指针头传给指针p\n    int j = 0;\n    while (p && (j < i - 1))   //向后扫描查找\n    {\n        p = p->next;\n        j++;\n    }\n    if (!p || (j > i - 1))     //输入参数不对，给出错误提示，并跳出\n        Error(\"Postion Eeeor!\");\n    else\n    {\n        LNode *s = new  LNode;\n        s->next = p->next;\n        p->next = s;\n    }\n}\n//删除链表L中第i个结点数据域值，并用返回,1<=x<=表长+1\n//若删除位置不合理则给出相应信息\nElemType ListDelete_L(Linklist &L, int i)\n{\n    LNode *p = L; //将指针头传给指针p\n    int j = 0;\n    while ((p ->next) && (j < i - 1))\n    {\n        p = p->next;\n        j++;\n    }\n    if (!(p->next) || (j > i - 1))\n        Error(\"Postion Eeeor!\"); // 输入参数不对，给出错误提示，并跳出\n    else\n    {\n        LNode *q = p->next;\n        ElemType x= p->data;\n        p->next = q->next;\n        delete q;\n        return x;\n    }\n}\n```\n# 单链表正标操作\n## 整表创建\n### 头插法\n```\n/**\n* 头插法\n*/\nvoid CreatListHead(LinkList *L, int n){\n\n    LinkList p;\n    int i;\n\n    srand(time(0));  // 初始化随机数种子\n\n    *L = (LinkList)malloc(sizeof(Node));\n    (*L)->next = NULL;\n\n    for (i = 0; i < n; i++) {\n\n        p = (LinkList)malloc(sizeof(Node)); // 生成新节点\n        p ->data = rand()%100 + 1;\n        p->next = (*L)->next;\n        (*L)->next = p;\n\n    }\n}\n```\n### 尾插法\n```c\n\n/**\n* 尾插法\n*/\nvoid CreatListTail(LinkList *L, int n){\n\n    LinkList p, r;\n    int i;\n\n    srand(time(0));\n    *L = (LinkList)malloc(sizeof(Node));\n    r = *L;\n\n    for (i = 0; i < n; i++) {\n\n        p = (Node *)malloc(sizeof(Node));\n        p->data = rand()%100+1;\n        r->next = p;\n        r = p;\n    }\n\n    r->next = NULL;\n}\n```\n## 整表删除\n```c\nStatus ClearList(LinkList *L){\n\n    LinkList p,q;\n\n    p = (*L)->next;\n\n    while (p) {\n        q = p->next;\n        free(p);\n        p = q;\n    }\n\n    (*L)->next = NULL;\n\n    return OK;\n}\n\n```\n","slug":"单链表","published":1,"updated":"2019-07-30T01:54:38.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izw0046homjus5hzgty","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a><a href=\"https://www.jianshu.com/p/a34924b229d9\" target=\"_blank\" rel=\"noopener\">定义</a></h1><p>数据域：存储数据元素信息的域，指针域：存储直接后继位置的域。指针域中存储的信息成为指针或链。这两部分信息组成数据元素成为存储映像，成为结点(Node)。<br>数据域|指针域<br>-|-<br>data|next</p>\n<h1 id=\"头结点与头指针\"><a href=\"#头结点与头指针\" class=\"headerlink\" title=\"头结点与头指针\"></a>头结点与头指针</h1><ul>\n<li>头结点<br>头结点是加在单链表之前附设的一个头结点。头结点的数据域一般不存储任何信息，也可以存放一些关于线性表的长度的附加信息。<br>-头指针<br>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。<a id=\"more\"></a>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Error</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> LNode *Linklist;    <span class=\"comment\">//头指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Error</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span>           <span class=\"comment\">//错误指示</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建链表,生成一个新节点作为头结点,并设其指针域为空</span></span><br><span class=\"line\"><span class=\"function\">Void <span class=\"title\">InitList</span><span class=\"params\">(Linklist &amp;L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    L=<span class=\"keyword\">new</span> LNode;</span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//销毁链表,从链表的头结点开始依次释放表中每一个结点所占用的存储空间</span></span><br><span class=\"line\"><span class=\"function\">Void <span class=\"title\">DestroyList</span><span class=\"params\">(Linklist L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L)&#123;</span><br><span class=\"line\">        LNode *p=L;</span><br><span class=\"line\">        L=L-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置单链表为空表，并释放所有结点空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ClearList</span><span class=\"params\">(Linklist &amp;L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Linklist *q=p;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//求链表长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength</span><span class=\"params\">(Linklist L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;next)&#123;</span><br><span class=\"line\">        length++;</span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回链表中第i个结点数据域的值，1&lt;=i&lt;=表长;若i值不合法，则给出错误信息</span></span><br><span class=\"line\"><span class=\"function\">ElemType <span class=\"title\">GetElem_L</span><span class=\"params\">(Linklist L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (count &lt; i)) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(p-&gt;next)||count&gt;i)  Error(<span class=\"string\">\"position Error\"</span>) ;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"keyword\">return</span>  p-&gt;data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查找链表中第一个数据域值和x相等的结点</span></span><br><span class=\"line\"><span class=\"function\">LNode *<span class=\"title\">LocateElem_L</span><span class=\"params\">(Linklist L, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p =L-&gt;next;              <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (p-&gt;data != x))   <span class=\"comment\">//向后扫描查找</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//向链表中第i个位置插入元素x ,1&lt;=x&lt;=表长+1</span></span><br><span class=\"line\"><span class=\"comment\">//若插入位置不合理则给出相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListInsert</span><span class=\"params\">(Linklist &amp;L, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> stu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p =L;              <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (j &lt; i - <span class=\"number\">1</span>))   <span class=\"comment\">//向后扫描查找</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p || (j &gt; i - <span class=\"number\">1</span>))     <span class=\"comment\">//输入参数不对，给出错误提示，并跳出</span></span><br><span class=\"line\">        Error(<span class=\"string\">\"Postion Eeeor!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *s = <span class=\"keyword\">new</span>  LNode;</span><br><span class=\"line\">        s-&gt;next = p-&gt;next;</span><br><span class=\"line\">        p-&gt;next = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除链表L中第i个结点数据域值，并用返回,1&lt;=x&lt;=表长+1</span></span><br><span class=\"line\"><span class=\"comment\">//若删除位置不合理则给出相应信息</span></span><br><span class=\"line\"><span class=\"function\">ElemType <span class=\"title\">ListDelete_L</span><span class=\"params\">(Linklist &amp;L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p = L; <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((p -&gt;next) &amp;&amp; (j &lt; i - <span class=\"number\">1</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(p-&gt;next) || (j &gt; i - <span class=\"number\">1</span>))</span><br><span class=\"line\">        Error(<span class=\"string\">\"Postion Eeeor!\"</span>); <span class=\"comment\">// 输入参数不对，给出错误提示，并跳出</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *q = p-&gt;next;</span><br><span class=\"line\">        ElemType x= p-&gt;data;</span><br><span class=\"line\">        p-&gt;next = q-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"单链表正标操作\"><a href=\"#单链表正标操作\" class=\"headerlink\" title=\"单链表正标操作\"></a>单链表正标操作</h1><h2 id=\"整表创建\"><a href=\"#整表创建\" class=\"headerlink\" title=\"整表创建\"></a>整表创建</h2><h3 id=\"头插法\"><a href=\"#头插法\" class=\"headerlink\" title=\"头插法\"></a>头插法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 头插法</span><br><span class=\"line\">*/</span><br><span class=\"line\">void CreatListHead(LinkList *L, int n)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srand(time(0));  // 初始化随机数种子</span><br><span class=\"line\"></span><br><span class=\"line\">    *L = (LinkList)malloc(sizeof(Node));</span><br><span class=\"line\">    (*L)-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (LinkList)malloc(sizeof(Node)); // 生成新节点</span><br><span class=\"line\">        p -&gt;data = rand()%100 + 1;</span><br><span class=\"line\">        p-&gt;next = (*L)-&gt;next;</span><br><span class=\"line\">        (*L)-&gt;next = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"尾插法\"><a href=\"#尾插法\" class=\"headerlink\" title=\"尾插法\"></a>尾插法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 尾插法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreatListTail</span><span class=\"params\">(LinkList *L, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p, r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srand(time(<span class=\"number\">0</span>));</span><br><span class=\"line\">    *L = (LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    r = *L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">        p-&gt;data = rand()%<span class=\"number\">100</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;next = p;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"整表删除\"><a href=\"#整表删除\" class=\"headerlink\" title=\"整表删除\"></a>整表删除</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(LinkList *L)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p,q;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = (*L)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        q = p-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    (*L)-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a><a href=\"https://www.jianshu.com/p/a34924b229d9\" target=\"_blank\" rel=\"noopener\">定义</a></h1><p>数据域：存储数据元素信息的域，指针域：存储直接后继位置的域。指针域中存储的信息成为指针或链。这两部分信息组成数据元素成为存储映像，成为结点(Node)。<br>数据域|指针域<br>-|-<br>data|next</p>\n<h1 id=\"头结点与头指针\"><a href=\"#头结点与头指针\" class=\"headerlink\" title=\"头结点与头指针\"></a>头结点与头指针</h1><ul>\n<li>头结点<br>头结点是加在单链表之前附设的一个头结点。头结点的数据域一般不存储任何信息，也可以存放一些关于线性表的长度的附加信息。<br>-头指针<br>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</li></ul>","more":"<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Error</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ElemType data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> LNode *Linklist;    <span class=\"comment\">//头指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Error</span><span class=\"params\">(<span class=\"keyword\">char</span> *s)</span>           <span class=\"comment\">//错误指示</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建链表,生成一个新节点作为头结点,并设其指针域为空</span></span><br><span class=\"line\"><span class=\"function\">Void <span class=\"title\">InitList</span><span class=\"params\">(Linklist &amp;L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    L=<span class=\"keyword\">new</span> LNode;</span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//销毁链表,从链表的头结点开始依次释放表中每一个结点所占用的存储空间</span></span><br><span class=\"line\"><span class=\"function\">Void <span class=\"title\">DestroyList</span><span class=\"params\">(Linklist L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L)&#123;</span><br><span class=\"line\">        LNode *p=L;</span><br><span class=\"line\">        L=L-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置单链表为空表，并释放所有结点空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ClearList</span><span class=\"params\">(Linklist &amp;L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Linklist *q=p;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//求链表长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength</span><span class=\"params\">(Linklist L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    LNode *p = L;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p-&gt;next)&#123;</span><br><span class=\"line\">        length++;</span><br><span class=\"line\">        p=p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//返回链表中第i个结点数据域的值，1&lt;=i&lt;=表长;若i值不合法，则给出错误信息</span></span><br><span class=\"line\"><span class=\"function\">ElemType <span class=\"title\">GetElem_L</span><span class=\"params\">(Linklist L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    LNode *p = L-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (count &lt; i)) &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(p-&gt;next)||count&gt;i)  Error(<span class=\"string\">\"position Error\"</span>) ;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  <span class=\"keyword\">return</span>  p-&gt;data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查找链表中第一个数据域值和x相等的结点</span></span><br><span class=\"line\"><span class=\"function\">LNode *<span class=\"title\">LocateElem_L</span><span class=\"params\">(Linklist L, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p =L-&gt;next;              <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (p-&gt;data != x))   <span class=\"comment\">//向后扫描查找</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//向链表中第i个位置插入元素x ,1&lt;=x&lt;=表长+1</span></span><br><span class=\"line\"><span class=\"comment\">//若插入位置不合理则给出相应信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ListInsert</span><span class=\"params\">(Linklist &amp;L, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> stu)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p =L;              <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &amp;&amp; (j &lt; i - <span class=\"number\">1</span>))   <span class=\"comment\">//向后扫描查找</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p || (j &gt; i - <span class=\"number\">1</span>))     <span class=\"comment\">//输入参数不对，给出错误提示，并跳出</span></span><br><span class=\"line\">        Error(<span class=\"string\">\"Postion Eeeor!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *s = <span class=\"keyword\">new</span>  LNode;</span><br><span class=\"line\">        s-&gt;next = p-&gt;next;</span><br><span class=\"line\">        p-&gt;next = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除链表L中第i个结点数据域值，并用返回,1&lt;=x&lt;=表长+1</span></span><br><span class=\"line\"><span class=\"comment\">//若删除位置不合理则给出相应信息</span></span><br><span class=\"line\"><span class=\"function\">ElemType <span class=\"title\">ListDelete_L</span><span class=\"params\">(Linklist &amp;L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LNode *p = L; <span class=\"comment\">//将指针头传给指针p</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((p -&gt;next) &amp;&amp; (j &lt; i - <span class=\"number\">1</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(p-&gt;next) || (j &gt; i - <span class=\"number\">1</span>))</span><br><span class=\"line\">        Error(<span class=\"string\">\"Postion Eeeor!\"</span>); <span class=\"comment\">// 输入参数不对，给出错误提示，并跳出</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        LNode *q = p-&gt;next;</span><br><span class=\"line\">        ElemType x= p-&gt;data;</span><br><span class=\"line\">        p-&gt;next = q-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> q;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"单链表正标操作\"><a href=\"#单链表正标操作\" class=\"headerlink\" title=\"单链表正标操作\"></a>单链表正标操作</h1><h2 id=\"整表创建\"><a href=\"#整表创建\" class=\"headerlink\" title=\"整表创建\"></a>整表创建</h2><h3 id=\"头插法\"><a href=\"#头插法\" class=\"headerlink\" title=\"头插法\"></a>头插法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 头插法</span><br><span class=\"line\">*/</span><br><span class=\"line\">void CreatListHead(LinkList *L, int n)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srand(time(0));  // 初始化随机数种子</span><br><span class=\"line\"></span><br><span class=\"line\">    *L = (LinkList)malloc(sizeof(Node));</span><br><span class=\"line\">    (*L)-&gt;next = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (LinkList)malloc(sizeof(Node)); // 生成新节点</span><br><span class=\"line\">        p -&gt;data = rand()%100 + 1;</span><br><span class=\"line\">        p-&gt;next = (*L)-&gt;next;</span><br><span class=\"line\">        (*L)-&gt;next = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"尾插法\"><a href=\"#尾插法\" class=\"headerlink\" title=\"尾插法\"></a>尾插法</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 尾插法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreatListTail</span><span class=\"params\">(LinkList *L, <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p, r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">    srand(time(<span class=\"number\">0</span>));</span><br><span class=\"line\">    *L = (LinkList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    r = *L;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">        p-&gt;data = rand()%<span class=\"number\">100</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;next = p;</span><br><span class=\"line\">        r = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"整表删除\"><a href=\"#整表删除\" class=\"headerlink\" title=\"整表删除\"></a>整表删除</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(LinkList *L)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p,q;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = (*L)-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        q = p-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">        p = q;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    (*L)-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"双循环链表","date":"2018-08-28T13:53:09.000Z","_content":"","source":"_posts/双循环链表.md","raw":"---\ntitle: 双循环链表\ndate: 2018-08-28 21:53:09\ntags:\n---\n","slug":"双循环链表","published":1,"updated":"2019-07-30T01:54:38.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6izz004bhomj4k8nngqj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"参数估计","date":"2017-08-15T08:46:06.000Z","_content":"\n在数理统计中，常常需要通过样本来估计总体的参数，估计可划分为两大类：点估计和区间估计。点估计就是估计总体中某个参数的值，而区间估计是估计总体的某个参数落在某个区间的概率大小。本文主要讲述点估计中的矩估计法和最大似然估计法，以及针对服从正态分布的期望和方差进行区间估计。\n\n# 参数估计定义\n- 已知一个随机变量的分布函数 $Xf_θ(x)$, 其中 $θ = (θ_1,··· ,θ_k)$ 为未知参数.\n- 样本 $X_1,··· ,X_n$\n- 利用样本对参数 $θ$ 做出估计，或者估计 $θ$ 的某个函数 $g(θ)$\n - 点估计: 用样本的一个函数 $T(X_1,··· ,X_n)$ 去估计 $g(θ)$\n - 区间估计: 用一个区间去估计 $g(θ)$\n<!--more-->\n\n# 点估计\n点估计一般解决的问题是总体 $X$ 的分布函数 $F(X,θ)$ 形式为已知，但是 $θ$ 参数未知。点估计的目的就是通过样本 $X_1,X_2,…X_n$ 构造一个适当的统计量 $θ′(X_1,X_2,…X_n)$，用于作为未知参数 $θ$ 的近似值。由于 $θ′$ 是样本的函数，因此对于不同的样本，$θ′$ 的值一般不同。\n\n点估计中一般用到的方法包括**矩估计法和最大似然估计法**。\n\n## 矩估计法\n**矩估计法的核心思想是样本矩总是收敛于相应的总体矩，因此可通过样本矩作为相应的总体矩的估计量，进而根据总体矩与待估参数的关系求出待估参数。**\n\n矩估计法的一般描述如下：\n设 $X$ 为连续型随机变量，其概率密度函数为 $f(x;\\theta_1, \\theta_2,..\\theta_n)$ ；离散型随机变量，其分布律为 $P(X=x) = p(x; \\theta_1, \\theta_2,..\\theta_n)$ ；则总体的 $n$ 阶矩分别为\n$$\\begin{align*}\nE(X^n) &= \\int_{-\\infty}^{\\infty} x^nf(x;\\theta_1, \\theta_2…\\theta_n) dx \\\\\nE(X^n) &= \\sum_{x \\in R_x} x^np(x;\\theta_1, \\theta_2….\\theta_n)\n\\end{align*}$$\n\n而样本 $X_1, X_2…X_k$ 的 $n$ 阶矩的定义为\n\n$$A_n = \\frac{1}{k} \\sum_{i=1}^{k}X_i^n$$\n由于总体的 $n$ 阶矩往往是未知参数 $θ$ 的函数，因此常常先用总体的 $n$ 阶矩 $E(X^n)$ 将参数 $θ$ 表示出来，然后用样本矩 $A_n$ 代替总体的 $n$ 阶矩 $E(X^n)$ ,进而得出估计的 $θ$ 的值。下面是一个简单的例子\n\n![](参数估计/参数估计-909cf753.png)\n\n## 最大似然估计法\n**最大似然估计的思想是既然当前取得了这组样本，那么有理由相信已取得的样本出现的概率是很大的。因此通过极大化这组样本的联合概率来估计未知参数的值。**\n\n### 离散型总体\n单总体为离散型的时候，设当前样本为 $X_1,X_2,…X_n$， 则其联合概率为 $\\prod_{i=1}^{n} p(x_i;\\theta)$, 其中 $x_i$ 是 $X_i$ 相应的观测值，则上面的联合概率实际上是参数 $θ$ 的函数，记为\n$$L(\\theta) = \\prod_{i=1}^{n} p(x_i;\\theta)$$\n\n上面的 $L(θ)$ 被称为样本的似然函数。\n\n选择 $θ$ 的值使得 $L(θ)$ 最大便是最大似然估计做的事情。一般通过对 似然函数求导便可求得其最大值对应的 $θ$。如下是一个简单的例子\n\n![](参数估计/参数估计-494bd225.png)\n\n上面最后求解的结果是 $p’ = \\overline x$ 。同时也注意到求解似然函数最大化时会先对似然函数取 $log$ , 目的是将连乘变为连加，方便运算，同时这种方法也被称为对数极大似然估计。\n\n### 连续型总体\n若总体是连续型，设其概率密度函数为 $f(x,θ)$ ，则当前样本 $X_1,X_2,…X_n$ 的联合概率密度函数为\n\n$$\\prod_{i=1}^{n}f(x_i;\\theta)$$\n\n其中 $x_1,x_2,…x_n$ 是相应于样本的一个样本值，则随机点落在 （$x_1,x_2,…x_n$）的领域（边长为 $dx_1, dx_2,…dx_n$ 的n维立方体）内的概率近似为\n\n$$\\prod_{i=1}^{n}f(x_i;\\theta)dx_i$$\n\n同样我们要让上式取到最大，但是因子 $\\prod_{i=1}^{n}dx_i$ 不随 $θ$ 改变，因此只需考虑函数 $L(\\theta) = \\prod_{i=1}^{n}f(x_i;\\theta)$ 最大即可，这里 $L(θ)$ 被称为似然函数，极大化也是通过求导来解决。\n\n下面是一个连续型总体进行极大似然估计的例子\n\n![](参数估计/参数估计-cd1a5ccf.png)\n\n## 评选标准\n对于同一参数，不同的估计方法求出的估计量可能不一样，那么如何判断不同的估计量之间的优劣，**无偏性，有效性和相合性**是常用的三个指标。\n\n- 相合性 (consistency): 当样本数量趋于无穷时，估计量收敛 于参数真实值.\n- 无偏性 (bias): 对于有限的样本，估计量所符合的分布之期 望等于参数真实值.\n- 有效性 (efficiency): 估计值所满足的分布方差越小越好.\n\n\n### 相合性\n当样本数目 $n→∞$ 时，估计量 $\\theta’(X_1，X_2…X_n)$ 收敛于真正的 $θ$ ,则称 $θ′$ 为 $θ$ 的相合估计量。即有以下式子成立\n$$\\lim_{n \\rightarrow \\infty}P(|\\theta’ - \\theta| < \\epsilon) = 1$$\n相合性是一个估计量的基本要求，如果估计量没有相合性，那么无论样本数量 n 取多大，这些估计量都无法准确估计正确参数，都是不可取的。\n\n### 无偏性\n无偏性指的是从样本中得到的估计量 $θ′$ 的期望与总体的参数 $θ$ 相等，也就是\n$$E(θ′)=θ$$\n\n此时称 $θ′$ 是 $θ$ 的无偏估计量。无偏估计量的意义是对于某些样本值，这一估计量得到的估计值比真实值要打，而对于另外一些样本则偏小，反复将这一估计量使用多次，就平均来说其偏差为零。\n\n### 有效性\n当两个估计量 $\\theta_1’, \\theta_2’$ 均是无偏估计量时，就要通过比较他们的有效性来决定选取哪个估计量。有效性指的是在样本容量 $n$ 相同的情况下，假如 $θ_1'$ 的观察值较 $θ_2'$ 的值更密集在真值 $θ$ 附近，那么认为 $θ_1'$ 比 $θ_2'$ 更为理想。\n\n实际上，上面比较的就是两个估计量的方差大小，方差越小，则越有效，因此当两个总体的样本数相同的时候，若 $D(θ_1')<D(θ_2')$ 时， 就称 $θ_1'$ 比 $θ_2'$ 更有效。\n\n# 区间估计\n**对于总体中的未知参数，我们的估计总是存在着一定的误差的，如何去衡量这个误差是一个需要考虑的事情。同时，除了上面的点估计，在实际中我们往往还希望估计出参数的一个范围，同时参数落在这个范围的概率，或者是说可信程度。**\n\n估计参数落在某个范围以及落在这个范围的可信程度就是区间估计干的事情。\n\n其严格定义如下\n\n设总体的分布中存在一个未知参数 $θ$, 对于给定的值 $α(0<α<1)$, 若通过样本 $X_1,X_2,X_3…X_n$ 估计的两个统计量 $θ_1′$ 和 $θ_2′$ 满足下面不等式时\n$$P(\\theta’_1 < \\theta < \\theta’_2) \\ge 1 - \\alpha$$\n则称区间 $(\\theta’_1, \\theta’_2)$ 是参数 $θ$ 置信水平为 $1−α$ 的置信区间, $\\theta’_1, \\theta’_2$ 分别称为置信下限和置信上限。\n\n上面式子的含义是若反复抽样多次（每次得到的样本的容量相等），每个样本值确定一个区间$(\\theta’_1, \\theta’_2)$，这个区间要么包含 $θ$ 的真值，要么不包含 $θ$ 的真值,在这么多的区间中，包含 $θ$ 真值的概率约为 $1−α$.\n\n## 正态分布均值与方差的区间估计\n由于正态分布的普遍性，下面主要讲述对正态分布的期望和方差进行区间估计的方法，而这里会用到我们前面讲到的统计量的三大分布： $χ^2$ 分布， $t$ 分布， $F$ 分布，以及对其拓展的一些定理，具体的定理及其证明可参考抽样与统计.md。\n\n下面会讲述单个正态分布的期望和方差的估计，以及两个正态分布的期望差和方差比的估计。\n\n### 单个正态分布\n下面的关于单个正态分布的讨论都是基于以下假设：给定置信水平为 $1−α$ , 设 $X_1,X_2,X_3…X_n$ 为总体 $N(μ,σ^2)$ 的样本，$\\overline X，S^2$ 分别是样本的期望和方差。\n\n#### 估计期望 $μ$ 的置信区间\n通过样本 $X_1,X_2,X_3…X_n$ 估计总体 $N(μ,σ^2)$ 的期望 $μ$ 时可以分为两种情况：\n\n1. 总体的方差 $σ^2$ 已知\n1. 总体的方差 $σ^2$ 未知\n##### 总体的方差 $σ^2$ 已知->定理一\n若已知总体的方差，则因为 $\\overline X \\sim N(\\mu , \\sigma^2/n)$ , 即 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 下面都会这样不加证明给出这些统计量服从的分布，具体的证明参考[这篇文章](样本以及抽样分布.md)。\n\n\n按照标准正态分布的上 $α$ 分位点的定义有\n$$P(|\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} | < z_{\\alpha/2}) = 1 - \\alpha$$\n\n从概率密度函数上直观看为：\n![](参数估计/参数估计-398aa4f1.png)\n\n进一步化简有\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}) = 1 - \\alpha$$\n给定 $\\alpha, z_{\\alpha/2}$ 的值可以通过查表获得。这样便得到了期望 $μ$ 的一个估计区间为 $(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}, \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2})$, 其置信度为 $1−α$。注意置信水平为 $1−α$ 的置信区间并不是唯一的，假如说给定 $α=0.05$, 则上面的式子可写为\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.025} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.025}) = 1 - \\alpha$$\n同时也可写为\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.04} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.01}) = 1 - \\alpha$$\n但是写成不对称的形式计算出来的区间长度要更长，显然，置信度相同的情况下，置信区间肯定是越小越好，所以对于正态分布的分位点往往选择对称形式。\n\n下面的求解方法与这方法类似，只是构造的统计量不同，因而服从的分布也不同。\n\n##### 总体的方差 $σ^2$ 未知->定理三\n当总体方差未知时，就无法利用上面标准正态分布。但是回忆 $t$ 分布的作用及其定理，可知\n$$\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)$$\n\n同样按照 $t$ 分布的上 $α$ 分位点的定义有\n$$P(|\\frac{\\overline X - \\mu}{S/\\sqrt{n}}| < t_{\\alpha/2}(n-1)) = 1 - \\alpha$$\n其对应的概率密度函数如下所示\n![](参数估计/参数估计-7c030c8b.png)\n进一步化简可得\n$$P(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1) < \\mu < \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1)) = 1 - \\alpha$$\n则期望 $μ$ 的一个置信水平为 $1−α$ 的置信区间为\n$$(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1), \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1))$$\n\n#### 估计方差 $σ^2$ 的置信区间\n估计方差 $σ^2$ 的置信区间也可分为两种情况\n\n1. 总体的期望 $μ$ 已知\n1. 总体的期望 $μ$ 未知\n##### 总体的期望 $μ$ 已知->定理一\n\n当期望 $μ$ 已知时，求解方差 $σ^2$ 的置信区间的方法跟上面已知方差 $σ^2$ 求解期望 $μ$ 的一样，都是利用 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$，然后写出对应未知量的区间，这里就不详细讲述已知 $μ$ 求解方差 $σ^2$ 的详细过程了。\n\n##### 总体的期望 μ 未知->定理二\n\n当期望 $μ$ 未知时，求解方差 $σ^2$ 的区间估计就再也不能利用上面的 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$。结合 $χ^2$ 分布的特性及其推导的定理可知\n\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n同样按照 $χ^2$ 分布的 $α$ 分位点的定义有\n\n$$P( \\chi^2_{1 - \\alpha/2}(n-1) < \\frac{(n-1)S^2}{\\sigma^2} < \\chi^2_{\\alpha/2}(n-1)) = 1 - \\alpha$$\n\n注意这里不能用绝对值了，原因是 $χ^2$ 分布的概率密度函数不像标准正态分布或 $t$ 分布那样是对称的。其对应的概率密度函数如下所示\n![](参数估计/参数估计-48556a99.png)\n进一步化简可得\n$$P(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)} < \\sigma^2 < \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)}) = 1 - \\alpha$$\n即给定样本，总体期望 $μ$ 未知的时候，总体方差 $σ^2$ 的一个置信水平为 $1−α$ 的置信区间为\n$$(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)})$$\n实际上， $χ^2$ 分布的一个作用就是在正态总体分布中期望未知时估计其方差的置信区间。\n\n### 两个正态分布->定理四\n下面讲述两个正态分布的期望差值的区间估计以及方差比的估计。考虑以下问题：已知产品的某一质量指标服从正态分布，但由于原料、操作人员不同，或工艺过程的改变等因素，引起总体均值、方差有所变化。我们需要知道这些变化有多大，就需要考虑两个正态分布**均值差或方差比**的估计问题。\n\n下面的讨论都是假设给定了置信水平为 $1−α$, 并设 $X_1, X_2,….X_n$ 是来自第一个总体 $N_1(\\mu_1, \\sigma_1^2)$ 的样本，$Y_1, Y_2,….Y_n$ 是来自第二个总体 $N_2(\\mu_2, \\sigma_2^2)$ 的样本，并假设 $\\overline X, \\overline Y$ 是第一、第二个样本的均值， $S_1^2, S_2^2$ 是第一、第二个样本的方差。\n\n#### 估计 $μ_1−μ_2$ 的置信区间\n估计 $μ_1−μ_2$ 的置信区间时也可以分为两种情况\n\n1. 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知\n1. 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但是知道 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）\n##### 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知->定理一\n由 $\\overline X \\sim N(\\mu_1, \\sigma_1^2/n_1), \\overline Y \\sim N(\\mu_2, \\sigma_2^2/n_2)$ 可知\n$$\\overline X - \\overline Y \\sim N(\\mu_1 - \\mu_2, \\sigma_1^2/n_1 + \\sigma_2^2/n_2) \\\\\n \\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0, 1)$$\n与上面相同，按照标准正态分布的上 $α$ 分位点的定义有\n$$P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} | < z_{\\alpha/2}) = 1 - \\alpha$$\n同样可解得 $μ_1−μ_2$ 置信度为 $1−α$ 的区间。\n\n##### 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）->定理四\n\n根据 $t$ 分布的作用及其推导的定理可知\n\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中 $S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n同样根据 $t$ 分布的上 $α$ 分位点的定义有\n$$P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}}| < t_{\\alpha/2}(n_1+n_2-2)) = 1 - \\alpha$$\n通过查表同样可以求出 $μ_1−μ_2$ 置信度为 $1−α$ 的区间，结合上面 $t$ 分布在单个正态总体分布参数估计的问题可知， $t$ 分布专门用于解决正态分布中方差未知时估计其期望的问题。\n\n#### 计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间\n估计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间同样可以分为两种情况\n\n1. 总体期望 $μ_1,μ_2$ 已知\n1. 总体期望 $μ_1,μ_2$ 未知\n\n##### 总体期望 $μ_1,μ_2$ 已知->定理一\n\n总体期望 $μ_1,μ_2$ 已知时可以先通过标准正态分布求出 $\\sigma_1^2, \\sigma_2^2$ 各自的范围, 然后求解 $\\sigma_1^2 / \\sigma_2^2$ 的范围。\n\n##### 总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围->定理四\n\n由 $F$ 分布的定义以及推导的定理可知\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n根据 $F$ 分布的 $α$ 分位点的定义有\n$$P( F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1) < \\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} < F_{\\alpha/2}(n_1 - 1, n_2 - 1)) = 1 - \\alpha$$\n化简可得\n$$P( \\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2} < \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)}) = 1 - \\alpha$$\n即 $\\sigma_1^2 / \\sigma_2^2$ 一个置信度为 $1−α$ 的置信区间为\n$$(\\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2}, \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)})$$\n\n### 小结\n在上面对正态分布总体进行参数估计中，用到了数理统计中的三大分布： $χ^2$ 分布， $t$ 分布和 $F$ 分布， 其中 $χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。\n\n## 单侧置信区间\n上面均是讨论未知参数 $θ$ 的双侧置信区间，但是在实际问题中，往往考虑的只是一个上限或下限，比如说设备、原件的寿命我们关心的是平均寿命 $θ$ 的下限。这就引出了单侧置信区间的概念。单侧置信区间跟双侧置信区间的概念非常类似。\n\n总体的参数 $θ$ 未知, 对于给定的 $α$ ,若由样本 $X_1, X_2..X_n$ 确定的统计量 $θ′$满足\n$$P(\\theta > \\theta’) = 1 - \\alpha$$\n则称 $(θ′,∞)$ 是参数 $θ$ 的置信水平为 $1−α$ 的单侧置信区间，而 $θ′$ 是单侧置信下限，将 $θ>θ′$ 变为 $θ<θ′$ 后，相应地变为单侧置信上限。\n\n单侧置信区间的计算方法与上面提到的双侧置信区间的计算方法已知，都是根据给定的 $α$ 值和统计量服从的分布去查表，找到相应的分位点后带入不等式求解目标估计量的范围即可。\n","source":"_posts/参数估计.md","raw":"---\ntitle: 参数估计\ndate: 2017-08-15 16:46:06\ntags: [人工智能,统计,参数估计]\ncategories: 数学\n---\n\n在数理统计中，常常需要通过样本来估计总体的参数，估计可划分为两大类：点估计和区间估计。点估计就是估计总体中某个参数的值，而区间估计是估计总体的某个参数落在某个区间的概率大小。本文主要讲述点估计中的矩估计法和最大似然估计法，以及针对服从正态分布的期望和方差进行区间估计。\n\n# 参数估计定义\n- 已知一个随机变量的分布函数 $Xf_θ(x)$, 其中 $θ = (θ_1,··· ,θ_k)$ 为未知参数.\n- 样本 $X_1,··· ,X_n$\n- 利用样本对参数 $θ$ 做出估计，或者估计 $θ$ 的某个函数 $g(θ)$\n - 点估计: 用样本的一个函数 $T(X_1,··· ,X_n)$ 去估计 $g(θ)$\n - 区间估计: 用一个区间去估计 $g(θ)$\n<!--more-->\n\n# 点估计\n点估计一般解决的问题是总体 $X$ 的分布函数 $F(X,θ)$ 形式为已知，但是 $θ$ 参数未知。点估计的目的就是通过样本 $X_1,X_2,…X_n$ 构造一个适当的统计量 $θ′(X_1,X_2,…X_n)$，用于作为未知参数 $θ$ 的近似值。由于 $θ′$ 是样本的函数，因此对于不同的样本，$θ′$ 的值一般不同。\n\n点估计中一般用到的方法包括**矩估计法和最大似然估计法**。\n\n## 矩估计法\n**矩估计法的核心思想是样本矩总是收敛于相应的总体矩，因此可通过样本矩作为相应的总体矩的估计量，进而根据总体矩与待估参数的关系求出待估参数。**\n\n矩估计法的一般描述如下：\n设 $X$ 为连续型随机变量，其概率密度函数为 $f(x;\\theta_1, \\theta_2,..\\theta_n)$ ；离散型随机变量，其分布律为 $P(X=x) = p(x; \\theta_1, \\theta_2,..\\theta_n)$ ；则总体的 $n$ 阶矩分别为\n$$\\begin{align*}\nE(X^n) &= \\int_{-\\infty}^{\\infty} x^nf(x;\\theta_1, \\theta_2…\\theta_n) dx \\\\\nE(X^n) &= \\sum_{x \\in R_x} x^np(x;\\theta_1, \\theta_2….\\theta_n)\n\\end{align*}$$\n\n而样本 $X_1, X_2…X_k$ 的 $n$ 阶矩的定义为\n\n$$A_n = \\frac{1}{k} \\sum_{i=1}^{k}X_i^n$$\n由于总体的 $n$ 阶矩往往是未知参数 $θ$ 的函数，因此常常先用总体的 $n$ 阶矩 $E(X^n)$ 将参数 $θ$ 表示出来，然后用样本矩 $A_n$ 代替总体的 $n$ 阶矩 $E(X^n)$ ,进而得出估计的 $θ$ 的值。下面是一个简单的例子\n\n![](参数估计/参数估计-909cf753.png)\n\n## 最大似然估计法\n**最大似然估计的思想是既然当前取得了这组样本，那么有理由相信已取得的样本出现的概率是很大的。因此通过极大化这组样本的联合概率来估计未知参数的值。**\n\n### 离散型总体\n单总体为离散型的时候，设当前样本为 $X_1,X_2,…X_n$， 则其联合概率为 $\\prod_{i=1}^{n} p(x_i;\\theta)$, 其中 $x_i$ 是 $X_i$ 相应的观测值，则上面的联合概率实际上是参数 $θ$ 的函数，记为\n$$L(\\theta) = \\prod_{i=1}^{n} p(x_i;\\theta)$$\n\n上面的 $L(θ)$ 被称为样本的似然函数。\n\n选择 $θ$ 的值使得 $L(θ)$ 最大便是最大似然估计做的事情。一般通过对 似然函数求导便可求得其最大值对应的 $θ$。如下是一个简单的例子\n\n![](参数估计/参数估计-494bd225.png)\n\n上面最后求解的结果是 $p’ = \\overline x$ 。同时也注意到求解似然函数最大化时会先对似然函数取 $log$ , 目的是将连乘变为连加，方便运算，同时这种方法也被称为对数极大似然估计。\n\n### 连续型总体\n若总体是连续型，设其概率密度函数为 $f(x,θ)$ ，则当前样本 $X_1,X_2,…X_n$ 的联合概率密度函数为\n\n$$\\prod_{i=1}^{n}f(x_i;\\theta)$$\n\n其中 $x_1,x_2,…x_n$ 是相应于样本的一个样本值，则随机点落在 （$x_1,x_2,…x_n$）的领域（边长为 $dx_1, dx_2,…dx_n$ 的n维立方体）内的概率近似为\n\n$$\\prod_{i=1}^{n}f(x_i;\\theta)dx_i$$\n\n同样我们要让上式取到最大，但是因子 $\\prod_{i=1}^{n}dx_i$ 不随 $θ$ 改变，因此只需考虑函数 $L(\\theta) = \\prod_{i=1}^{n}f(x_i;\\theta)$ 最大即可，这里 $L(θ)$ 被称为似然函数，极大化也是通过求导来解决。\n\n下面是一个连续型总体进行极大似然估计的例子\n\n![](参数估计/参数估计-cd1a5ccf.png)\n\n## 评选标准\n对于同一参数，不同的估计方法求出的估计量可能不一样，那么如何判断不同的估计量之间的优劣，**无偏性，有效性和相合性**是常用的三个指标。\n\n- 相合性 (consistency): 当样本数量趋于无穷时，估计量收敛 于参数真实值.\n- 无偏性 (bias): 对于有限的样本，估计量所符合的分布之期 望等于参数真实值.\n- 有效性 (efficiency): 估计值所满足的分布方差越小越好.\n\n\n### 相合性\n当样本数目 $n→∞$ 时，估计量 $\\theta’(X_1，X_2…X_n)$ 收敛于真正的 $θ$ ,则称 $θ′$ 为 $θ$ 的相合估计量。即有以下式子成立\n$$\\lim_{n \\rightarrow \\infty}P(|\\theta’ - \\theta| < \\epsilon) = 1$$\n相合性是一个估计量的基本要求，如果估计量没有相合性，那么无论样本数量 n 取多大，这些估计量都无法准确估计正确参数，都是不可取的。\n\n### 无偏性\n无偏性指的是从样本中得到的估计量 $θ′$ 的期望与总体的参数 $θ$ 相等，也就是\n$$E(θ′)=θ$$\n\n此时称 $θ′$ 是 $θ$ 的无偏估计量。无偏估计量的意义是对于某些样本值，这一估计量得到的估计值比真实值要打，而对于另外一些样本则偏小，反复将这一估计量使用多次，就平均来说其偏差为零。\n\n### 有效性\n当两个估计量 $\\theta_1’, \\theta_2’$ 均是无偏估计量时，就要通过比较他们的有效性来决定选取哪个估计量。有效性指的是在样本容量 $n$ 相同的情况下，假如 $θ_1'$ 的观察值较 $θ_2'$ 的值更密集在真值 $θ$ 附近，那么认为 $θ_1'$ 比 $θ_2'$ 更为理想。\n\n实际上，上面比较的就是两个估计量的方差大小，方差越小，则越有效，因此当两个总体的样本数相同的时候，若 $D(θ_1')<D(θ_2')$ 时， 就称 $θ_1'$ 比 $θ_2'$ 更有效。\n\n# 区间估计\n**对于总体中的未知参数，我们的估计总是存在着一定的误差的，如何去衡量这个误差是一个需要考虑的事情。同时，除了上面的点估计，在实际中我们往往还希望估计出参数的一个范围，同时参数落在这个范围的概率，或者是说可信程度。**\n\n估计参数落在某个范围以及落在这个范围的可信程度就是区间估计干的事情。\n\n其严格定义如下\n\n设总体的分布中存在一个未知参数 $θ$, 对于给定的值 $α(0<α<1)$, 若通过样本 $X_1,X_2,X_3…X_n$ 估计的两个统计量 $θ_1′$ 和 $θ_2′$ 满足下面不等式时\n$$P(\\theta’_1 < \\theta < \\theta’_2) \\ge 1 - \\alpha$$\n则称区间 $(\\theta’_1, \\theta’_2)$ 是参数 $θ$ 置信水平为 $1−α$ 的置信区间, $\\theta’_1, \\theta’_2$ 分别称为置信下限和置信上限。\n\n上面式子的含义是若反复抽样多次（每次得到的样本的容量相等），每个样本值确定一个区间$(\\theta’_1, \\theta’_2)$，这个区间要么包含 $θ$ 的真值，要么不包含 $θ$ 的真值,在这么多的区间中，包含 $θ$ 真值的概率约为 $1−α$.\n\n## 正态分布均值与方差的区间估计\n由于正态分布的普遍性，下面主要讲述对正态分布的期望和方差进行区间估计的方法，而这里会用到我们前面讲到的统计量的三大分布： $χ^2$ 分布， $t$ 分布， $F$ 分布，以及对其拓展的一些定理，具体的定理及其证明可参考抽样与统计.md。\n\n下面会讲述单个正态分布的期望和方差的估计，以及两个正态分布的期望差和方差比的估计。\n\n### 单个正态分布\n下面的关于单个正态分布的讨论都是基于以下假设：给定置信水平为 $1−α$ , 设 $X_1,X_2,X_3…X_n$ 为总体 $N(μ,σ^2)$ 的样本，$\\overline X，S^2$ 分别是样本的期望和方差。\n\n#### 估计期望 $μ$ 的置信区间\n通过样本 $X_1,X_2,X_3…X_n$ 估计总体 $N(μ,σ^2)$ 的期望 $μ$ 时可以分为两种情况：\n\n1. 总体的方差 $σ^2$ 已知\n1. 总体的方差 $σ^2$ 未知\n##### 总体的方差 $σ^2$ 已知->定理一\n若已知总体的方差，则因为 $\\overline X \\sim N(\\mu , \\sigma^2/n)$ , 即 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 下面都会这样不加证明给出这些统计量服从的分布，具体的证明参考[这篇文章](样本以及抽样分布.md)。\n\n\n按照标准正态分布的上 $α$ 分位点的定义有\n$$P(|\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} | < z_{\\alpha/2}) = 1 - \\alpha$$\n\n从概率密度函数上直观看为：\n![](参数估计/参数估计-398aa4f1.png)\n\n进一步化简有\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}) = 1 - \\alpha$$\n给定 $\\alpha, z_{\\alpha/2}$ 的值可以通过查表获得。这样便得到了期望 $μ$ 的一个估计区间为 $(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}, \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2})$, 其置信度为 $1−α$。注意置信水平为 $1−α$ 的置信区间并不是唯一的，假如说给定 $α=0.05$, 则上面的式子可写为\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.025} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.025}) = 1 - \\alpha$$\n同时也可写为\n$$P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.04} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.01}) = 1 - \\alpha$$\n但是写成不对称的形式计算出来的区间长度要更长，显然，置信度相同的情况下，置信区间肯定是越小越好，所以对于正态分布的分位点往往选择对称形式。\n\n下面的求解方法与这方法类似，只是构造的统计量不同，因而服从的分布也不同。\n\n##### 总体的方差 $σ^2$ 未知->定理三\n当总体方差未知时，就无法利用上面标准正态分布。但是回忆 $t$ 分布的作用及其定理，可知\n$$\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)$$\n\n同样按照 $t$ 分布的上 $α$ 分位点的定义有\n$$P(|\\frac{\\overline X - \\mu}{S/\\sqrt{n}}| < t_{\\alpha/2}(n-1)) = 1 - \\alpha$$\n其对应的概率密度函数如下所示\n![](参数估计/参数估计-7c030c8b.png)\n进一步化简可得\n$$P(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1) < \\mu < \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1)) = 1 - \\alpha$$\n则期望 $μ$ 的一个置信水平为 $1−α$ 的置信区间为\n$$(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1), \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1))$$\n\n#### 估计方差 $σ^2$ 的置信区间\n估计方差 $σ^2$ 的置信区间也可分为两种情况\n\n1. 总体的期望 $μ$ 已知\n1. 总体的期望 $μ$ 未知\n##### 总体的期望 $μ$ 已知->定理一\n\n当期望 $μ$ 已知时，求解方差 $σ^2$ 的置信区间的方法跟上面已知方差 $σ^2$ 求解期望 $μ$ 的一样，都是利用 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$，然后写出对应未知量的区间，这里就不详细讲述已知 $μ$ 求解方差 $σ^2$ 的详细过程了。\n\n##### 总体的期望 μ 未知->定理二\n\n当期望 $μ$ 未知时，求解方差 $σ^2$ 的区间估计就再也不能利用上面的 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$。结合 $χ^2$ 分布的特性及其推导的定理可知\n\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n同样按照 $χ^2$ 分布的 $α$ 分位点的定义有\n\n$$P( \\chi^2_{1 - \\alpha/2}(n-1) < \\frac{(n-1)S^2}{\\sigma^2} < \\chi^2_{\\alpha/2}(n-1)) = 1 - \\alpha$$\n\n注意这里不能用绝对值了，原因是 $χ^2$ 分布的概率密度函数不像标准正态分布或 $t$ 分布那样是对称的。其对应的概率密度函数如下所示\n![](参数估计/参数估计-48556a99.png)\n进一步化简可得\n$$P(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)} < \\sigma^2 < \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)}) = 1 - \\alpha$$\n即给定样本，总体期望 $μ$ 未知的时候，总体方差 $σ^2$ 的一个置信水平为 $1−α$ 的置信区间为\n$$(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)})$$\n实际上， $χ^2$ 分布的一个作用就是在正态总体分布中期望未知时估计其方差的置信区间。\n\n### 两个正态分布->定理四\n下面讲述两个正态分布的期望差值的区间估计以及方差比的估计。考虑以下问题：已知产品的某一质量指标服从正态分布，但由于原料、操作人员不同，或工艺过程的改变等因素，引起总体均值、方差有所变化。我们需要知道这些变化有多大，就需要考虑两个正态分布**均值差或方差比**的估计问题。\n\n下面的讨论都是假设给定了置信水平为 $1−α$, 并设 $X_1, X_2,….X_n$ 是来自第一个总体 $N_1(\\mu_1, \\sigma_1^2)$ 的样本，$Y_1, Y_2,….Y_n$ 是来自第二个总体 $N_2(\\mu_2, \\sigma_2^2)$ 的样本，并假设 $\\overline X, \\overline Y$ 是第一、第二个样本的均值， $S_1^2, S_2^2$ 是第一、第二个样本的方差。\n\n#### 估计 $μ_1−μ_2$ 的置信区间\n估计 $μ_1−μ_2$ 的置信区间时也可以分为两种情况\n\n1. 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知\n1. 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但是知道 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）\n##### 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知->定理一\n由 $\\overline X \\sim N(\\mu_1, \\sigma_1^2/n_1), \\overline Y \\sim N(\\mu_2, \\sigma_2^2/n_2)$ 可知\n$$\\overline X - \\overline Y \\sim N(\\mu_1 - \\mu_2, \\sigma_1^2/n_1 + \\sigma_2^2/n_2) \\\\\n \\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0, 1)$$\n与上面相同，按照标准正态分布的上 $α$ 分位点的定义有\n$$P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} | < z_{\\alpha/2}) = 1 - \\alpha$$\n同样可解得 $μ_1−μ_2$ 置信度为 $1−α$ 的区间。\n\n##### 总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）->定理四\n\n根据 $t$ 分布的作用及其推导的定理可知\n\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中 $S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n同样根据 $t$ 分布的上 $α$ 分位点的定义有\n$$P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}}| < t_{\\alpha/2}(n_1+n_2-2)) = 1 - \\alpha$$\n通过查表同样可以求出 $μ_1−μ_2$ 置信度为 $1−α$ 的区间，结合上面 $t$ 分布在单个正态总体分布参数估计的问题可知， $t$ 分布专门用于解决正态分布中方差未知时估计其期望的问题。\n\n#### 计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间\n估计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间同样可以分为两种情况\n\n1. 总体期望 $μ_1,μ_2$ 已知\n1. 总体期望 $μ_1,μ_2$ 未知\n\n##### 总体期望 $μ_1,μ_2$ 已知->定理一\n\n总体期望 $μ_1,μ_2$ 已知时可以先通过标准正态分布求出 $\\sigma_1^2, \\sigma_2^2$ 各自的范围, 然后求解 $\\sigma_1^2 / \\sigma_2^2$ 的范围。\n\n##### 总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围->定理四\n\n由 $F$ 分布的定义以及推导的定理可知\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n根据 $F$ 分布的 $α$ 分位点的定义有\n$$P( F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1) < \\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} < F_{\\alpha/2}(n_1 - 1, n_2 - 1)) = 1 - \\alpha$$\n化简可得\n$$P( \\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2} < \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)}) = 1 - \\alpha$$\n即 $\\sigma_1^2 / \\sigma_2^2$ 一个置信度为 $1−α$ 的置信区间为\n$$(\\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2}, \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)})$$\n\n### 小结\n在上面对正态分布总体进行参数估计中，用到了数理统计中的三大分布： $χ^2$ 分布， $t$ 分布和 $F$ 分布， 其中 $χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。\n\n## 单侧置信区间\n上面均是讨论未知参数 $θ$ 的双侧置信区间，但是在实际问题中，往往考虑的只是一个上限或下限，比如说设备、原件的寿命我们关心的是平均寿命 $θ$ 的下限。这就引出了单侧置信区间的概念。单侧置信区间跟双侧置信区间的概念非常类似。\n\n总体的参数 $θ$ 未知, 对于给定的 $α$ ,若由样本 $X_1, X_2..X_n$ 确定的统计量 $θ′$满足\n$$P(\\theta > \\theta’) = 1 - \\alpha$$\n则称 $(θ′,∞)$ 是参数 $θ$ 的置信水平为 $1−α$ 的单侧置信区间，而 $θ′$ 是单侧置信下限，将 $θ>θ′$ 变为 $θ<θ′$ 后，相应地变为单侧置信上限。\n\n单侧置信区间的计算方法与上面提到的双侧置信区间的计算方法已知，都是根据给定的 $α$ 值和统计量服从的分布去查表，找到相应的分位点后带入不等式求解目标估计量的范围即可。\n","slug":"参数估计","published":1,"updated":"2019-07-30T01:54:38.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j02004ehomjrz6id8r5","content":"<p>在数理统计中，常常需要通过样本来估计总体的参数，估计可划分为两大类：点估计和区间估计。点估计就是估计总体中某个参数的值，而区间估计是估计总体的某个参数落在某个区间的概率大小。本文主要讲述点估计中的矩估计法和最大似然估计法，以及针对服从正态分布的期望和方差进行区间估计。</p>\n<h1 id=\"参数估计定义\"><a href=\"#参数估计定义\" class=\"headerlink\" title=\"参数估计定义\"></a>参数估计定义</h1><ul>\n<li>已知一个随机变量的分布函数 $Xf_θ(x)$, 其中 $θ = (θ_1,··· ,θ_k)$ 为未知参数.</li>\n<li>样本 $X_1,··· ,X_n$</li>\n<li>利用样本对参数 $θ$ 做出估计，或者估计 $θ$ 的某个函数 $g(θ)$<ul>\n<li>点估计: 用样本的一个函数 $T(X_1,··· ,X_n)$ 去估计 $g(θ)$</li>\n<li>区间估计: 用一个区间去估计 $g(θ)$<a id=\"more\"></a>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"点估计\"><a href=\"#点估计\" class=\"headerlink\" title=\"点估计\"></a>点估计</h1><p>点估计一般解决的问题是总体 $X$ 的分布函数 $F(X,θ)$ 形式为已知，但是 $θ$ 参数未知。点估计的目的就是通过样本 $X_1,X_2,…X_n$ 构造一个适当的统计量 $θ′(X_1,X_2,…X_n)$，用于作为未知参数 $θ$ 的近似值。由于 $θ′$ 是样本的函数，因此对于不同的样本，$θ′$ 的值一般不同。</p>\n<p>点估计中一般用到的方法包括<strong>矩估计法和最大似然估计法</strong>。</p>\n<h2 id=\"矩估计法\"><a href=\"#矩估计法\" class=\"headerlink\" title=\"矩估计法\"></a>矩估计法</h2><p><strong>矩估计法的核心思想是样本矩总是收敛于相应的总体矩，因此可通过样本矩作为相应的总体矩的估计量，进而根据总体矩与待估参数的关系求出待估参数。</strong></p>\n<p>矩估计法的一般描述如下：<br>设 $X$ 为连续型随机变量，其概率密度函数为 $f(x;\\theta_1, \\theta_2,..\\theta_n)$ ；离散型随机变量，其分布律为 $P(X=x) = p(x; \\theta_1, \\theta_2,..\\theta_n)$ ；则总体的 $n$ 阶矩分别为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nE(X^n) &= \\int_{-\\infty}^{\\infty} x^nf(x;\\theta_1, \\theta_2…\\theta_n) dx \\\\\nE(X^n) &= \\sum_{x \\in R_x} x^np(x;\\theta_1, \\theta_2….\\theta_n)\n\\end{align*}</script><p>而样本 $X_1, X_2…X_k$ 的 $n$ 阶矩的定义为</p>\n<script type=\"math/tex; mode=display\">A_n = \\frac{1}{k} \\sum_{i=1}^{k}X_i^n</script><p>由于总体的 $n$ 阶矩往往是未知参数 $θ$ 的函数，因此常常先用总体的 $n$ 阶矩 $E(X^n)$ 将参数 $θ$ 表示出来，然后用样本矩 $A_n$ 代替总体的 $n$ 阶矩 $E(X^n)$ ,进而得出估计的 $θ$ 的值。下面是一个简单的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-909cf753.png\" alt=\"\"></p>\n<h2 id=\"最大似然估计法\"><a href=\"#最大似然估计法\" class=\"headerlink\" title=\"最大似然估计法\"></a>最大似然估计法</h2><p><strong>最大似然估计的思想是既然当前取得了这组样本，那么有理由相信已取得的样本出现的概率是很大的。因此通过极大化这组样本的联合概率来估计未知参数的值。</strong></p>\n<h3 id=\"离散型总体\"><a href=\"#离散型总体\" class=\"headerlink\" title=\"离散型总体\"></a>离散型总体</h3><p>单总体为离散型的时候，设当前样本为 $X_1,X_2,…X_n$， 则其联合概率为 $\\prod_{i=1}^{n} p(x_i;\\theta)$, 其中 $x_i$ 是 $X_i$ 相应的观测值，则上面的联合概率实际上是参数 $θ$ 的函数，记为</p>\n<script type=\"math/tex; mode=display\">L(\\theta) = \\prod_{i=1}^{n} p(x_i;\\theta)</script><p>上面的 $L(θ)$ 被称为样本的似然函数。</p>\n<p>选择 $θ$ 的值使得 $L(θ)$ 最大便是最大似然估计做的事情。一般通过对 似然函数求导便可求得其最大值对应的 $θ$。如下是一个简单的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-494bd225.png\" alt=\"\"></p>\n<p>上面最后求解的结果是 $p’ = \\overline x$ 。同时也注意到求解似然函数最大化时会先对似然函数取 $log$ , 目的是将连乘变为连加，方便运算，同时这种方法也被称为对数极大似然估计。</p>\n<h3 id=\"连续型总体\"><a href=\"#连续型总体\" class=\"headerlink\" title=\"连续型总体\"></a>连续型总体</h3><p>若总体是连续型，设其概率密度函数为 $f(x,θ)$ ，则当前样本 $X_1,X_2,…X_n$ 的联合概率密度函数为</p>\n<script type=\"math/tex; mode=display\">\\prod_{i=1}^{n}f(x_i;\\theta)</script><p>其中 $x_1,x_2,…x_n$ 是相应于样本的一个样本值，则随机点落在 （$x_1,x_2,…x_n$）的领域（边长为 $dx_1, dx_2,…dx_n$ 的n维立方体）内的概率近似为</p>\n<script type=\"math/tex; mode=display\">\\prod_{i=1}^{n}f(x_i;\\theta)dx_i</script><p>同样我们要让上式取到最大，但是因子 $\\prod_{i=1}^{n}dx_i$ 不随 $θ$ 改变，因此只需考虑函数 $L(\\theta) = \\prod_{i=1}^{n}f(x_i;\\theta)$ 最大即可，这里 $L(θ)$ 被称为似然函数，极大化也是通过求导来解决。</p>\n<p>下面是一个连续型总体进行极大似然估计的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-cd1a5ccf.png\" alt=\"\"></p>\n<h2 id=\"评选标准\"><a href=\"#评选标准\" class=\"headerlink\" title=\"评选标准\"></a>评选标准</h2><p>对于同一参数，不同的估计方法求出的估计量可能不一样，那么如何判断不同的估计量之间的优劣，<strong>无偏性，有效性和相合性</strong>是常用的三个指标。</p>\n<ul>\n<li>相合性 (consistency): 当样本数量趋于无穷时，估计量收敛 于参数真实值.</li>\n<li>无偏性 (bias): 对于有限的样本，估计量所符合的分布之期 望等于参数真实值.</li>\n<li>有效性 (efficiency): 估计值所满足的分布方差越小越好.</li>\n</ul>\n<h3 id=\"相合性\"><a href=\"#相合性\" class=\"headerlink\" title=\"相合性\"></a>相合性</h3><p>当样本数目 $n→∞$ 时，估计量 $\\theta’(X_1，X_2…X_n)$ 收敛于真正的 $θ$ ,则称 $θ′$ 为 $θ$ 的相合估计量。即有以下式子成立</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\rightarrow \\infty}P(|\\theta’ - \\theta| < \\epsilon) = 1</script><p>相合性是一个估计量的基本要求，如果估计量没有相合性，那么无论样本数量 n 取多大，这些估计量都无法准确估计正确参数，都是不可取的。</p>\n<h3 id=\"无偏性\"><a href=\"#无偏性\" class=\"headerlink\" title=\"无偏性\"></a>无偏性</h3><p>无偏性指的是从样本中得到的估计量 $θ′$ 的期望与总体的参数 $θ$ 相等，也就是</p>\n<script type=\"math/tex; mode=display\">E(θ′)=θ</script><p>此时称 $θ′$ 是 $θ$ 的无偏估计量。无偏估计量的意义是对于某些样本值，这一估计量得到的估计值比真实值要打，而对于另外一些样本则偏小，反复将这一估计量使用多次，就平均来说其偏差为零。</p>\n<h3 id=\"有效性\"><a href=\"#有效性\" class=\"headerlink\" title=\"有效性\"></a>有效性</h3><p>当两个估计量 $\\theta_1’, \\theta_2’$ 均是无偏估计量时，就要通过比较他们的有效性来决定选取哪个估计量。有效性指的是在样本容量 $n$ 相同的情况下，假如 $θ_1’$ 的观察值较 $θ_2’$ 的值更密集在真值 $θ$ 附近，那么认为 $θ_1’$ 比 $θ_2’$ 更为理想。</p>\n<p>实际上，上面比较的就是两个估计量的方差大小，方差越小，则越有效，因此当两个总体的样本数相同的时候，若 $D(θ_1’)&lt;D(θ_2’)$ 时， 就称 $θ_1’$ 比 $θ_2’$ 更有效。</p>\n<h1 id=\"区间估计\"><a href=\"#区间估计\" class=\"headerlink\" title=\"区间估计\"></a>区间估计</h1><p><strong>对于总体中的未知参数，我们的估计总是存在着一定的误差的，如何去衡量这个误差是一个需要考虑的事情。同时，除了上面的点估计，在实际中我们往往还希望估计出参数的一个范围，同时参数落在这个范围的概率，或者是说可信程度。</strong></p>\n<p>估计参数落在某个范围以及落在这个范围的可信程度就是区间估计干的事情。</p>\n<p>其严格定义如下</p>\n<p>设总体的分布中存在一个未知参数 $θ$, 对于给定的值 $α(0&lt;α&lt;1)$, 若通过样本 $X_1,X_2,X_3…X_n$ 估计的两个统计量 $θ_1′$ 和 $θ_2′$ 满足下面不等式时</p>\n<script type=\"math/tex; mode=display\">P(\\theta’_1 < \\theta < \\theta’_2) \\ge 1 - \\alpha</script><p>则称区间 $(\\theta’_1, \\theta’_2)$ 是参数 $θ$ 置信水平为 $1−α$ 的置信区间, $\\theta’_1, \\theta’_2$ 分别称为置信下限和置信上限。</p>\n<p>上面式子的含义是若反复抽样多次（每次得到的样本的容量相等），每个样本值确定一个区间$(\\theta’_1, \\theta’_2)$，这个区间要么包含 $θ$ 的真值，要么不包含 $θ$ 的真值,在这么多的区间中，包含 $θ$ 真值的概率约为 $1−α$.</p>\n<h2 id=\"正态分布均值与方差的区间估计\"><a href=\"#正态分布均值与方差的区间估计\" class=\"headerlink\" title=\"正态分布均值与方差的区间估计\"></a>正态分布均值与方差的区间估计</h2><p>由于正态分布的普遍性，下面主要讲述对正态分布的期望和方差进行区间估计的方法，而这里会用到我们前面讲到的统计量的三大分布： $χ^2$ 分布， $t$ 分布， $F$ 分布，以及对其拓展的一些定理，具体的定理及其证明可参考抽样与统计.md。</p>\n<p>下面会讲述单个正态分布的期望和方差的估计，以及两个正态分布的期望差和方差比的估计。</p>\n<h3 id=\"单个正态分布\"><a href=\"#单个正态分布\" class=\"headerlink\" title=\"单个正态分布\"></a>单个正态分布</h3><p>下面的关于单个正态分布的讨论都是基于以下假设：给定置信水平为 $1−α$ , 设 $X_1,X_2,X_3…X_n$ 为总体 $N(μ,σ^2)$ 的样本，$\\overline X，S^2$ 分别是样本的期望和方差。</p>\n<h4 id=\"估计期望-μ-的置信区间\"><a href=\"#估计期望-μ-的置信区间\" class=\"headerlink\" title=\"估计期望 $μ$ 的置信区间\"></a>估计期望 $μ$ 的置信区间</h4><p>通过样本 $X_1,X_2,X_3…X_n$ 估计总体 $N(μ,σ^2)$ 的期望 $μ$ 时可以分为两种情况：</p>\n<ol>\n<li>总体的方差 $σ^2$ 已知</li>\n<li>总体的方差 $σ^2$ 未知<h5 id=\"总体的方差-σ-2-已知-gt-定理一\"><a href=\"#总体的方差-σ-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体的方差 $σ^2$ 已知-&gt;定理一\"></a>总体的方差 $σ^2$ 已知-&gt;定理一</h5>若已知总体的方差，则因为 $\\overline X \\sim N(\\mu , \\sigma^2/n)$ , 即 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 下面都会这样不加证明给出这些统计量服从的分布，具体的证明参考<a href=\"样本以及抽样分布.md\">这篇文章</a>。</li>\n</ol>\n<p>按照标准正态分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} | < z_{\\alpha/2}) = 1 - \\alpha</script><p>从概率密度函数上直观看为：<br><img src=\"/2017/08/15/参数估计/参数估计-398aa4f1.png\" alt=\"\"></p>\n<p>进一步化简有</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}) = 1 - \\alpha</script><p>给定 $\\alpha, z_{\\alpha/2}$ 的值可以通过查表获得。这样便得到了期望 $μ$ 的一个估计区间为 $(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}, \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2})$, 其置信度为 $1−α$。注意置信水平为 $1−α$ 的置信区间并不是唯一的，假如说给定 $α=0.05$, 则上面的式子可写为</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.025} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.025}) = 1 - \\alpha</script><p>同时也可写为</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.04} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.01}) = 1 - \\alpha</script><p>但是写成不对称的形式计算出来的区间长度要更长，显然，置信度相同的情况下，置信区间肯定是越小越好，所以对于正态分布的分位点往往选择对称形式。</p>\n<p>下面的求解方法与这方法类似，只是构造的统计量不同，因而服从的分布也不同。</p>\n<h5 id=\"总体的方差-σ-2-未知-gt-定理三\"><a href=\"#总体的方差-σ-2-未知-gt-定理三\" class=\"headerlink\" title=\"总体的方差 $σ^2$ 未知-&gt;定理三\"></a>总体的方差 $σ^2$ 未知-&gt;定理三</h5><p>当总体方差未知时，就无法利用上面标准正态分布。但是回忆 $t$ 分布的作用及其定理，可知</p>\n<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)</script><p>同样按照 $t$ 分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{\\overline X - \\mu}{S/\\sqrt{n}}| < t_{\\alpha/2}(n-1)) = 1 - \\alpha</script><p>其对应的概率密度函数如下所示<br><img src=\"/2017/08/15/参数估计/参数估计-7c030c8b.png\" alt=\"\"><br>进一步化简可得</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1) < \\mu < \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1)) = 1 - \\alpha</script><p>则期望 $μ$ 的一个置信水平为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1), \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1))</script><h4 id=\"估计方差-σ-2-的置信区间\"><a href=\"#估计方差-σ-2-的置信区间\" class=\"headerlink\" title=\"估计方差 $σ^2$ 的置信区间\"></a>估计方差 $σ^2$ 的置信区间</h4><p>估计方差 $σ^2$ 的置信区间也可分为两种情况</p>\n<ol>\n<li>总体的期望 $μ$ 已知</li>\n<li>总体的期望 $μ$ 未知<h5 id=\"总体的期望-μ-已知-gt-定理一\"><a href=\"#总体的期望-μ-已知-gt-定理一\" class=\"headerlink\" title=\"总体的期望 $μ$ 已知-&gt;定理一\"></a>总体的期望 $μ$ 已知-&gt;定理一</h5></li>\n</ol>\n<p>当期望 $μ$ 已知时，求解方差 $σ^2$ 的置信区间的方法跟上面已知方差 $σ^2$ 求解期望 $μ$ 的一样，都是利用 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$，然后写出对应未知量的区间，这里就不详细讲述已知 $μ$ 求解方差 $σ^2$ 的详细过程了。</p>\n<h5 id=\"总体的期望-μ-未知-gt-定理二\"><a href=\"#总体的期望-μ-未知-gt-定理二\" class=\"headerlink\" title=\"总体的期望 μ 未知-&gt;定理二\"></a>总体的期望 μ 未知-&gt;定理二</h5><p>当期望 $μ$ 未知时，求解方差 $σ^2$ 的区间估计就再也不能利用上面的 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$。结合 $χ^2$ 分布的特性及其推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script><p>同样按照 $χ^2$ 分布的 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P( \\chi^2_{1 - \\alpha/2}(n-1) < \\frac{(n-1)S^2}{\\sigma^2} < \\chi^2_{\\alpha/2}(n-1)) = 1 - \\alpha</script><p>注意这里不能用绝对值了，原因是 $χ^2$ 分布的概率密度函数不像标准正态分布或 $t$ 分布那样是对称的。其对应的概率密度函数如下所示<br><img src=\"/2017/08/15/参数估计/参数估计-48556a99.png\" alt=\"\"><br>进一步化简可得</p>\n<script type=\"math/tex; mode=display\">P(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)} < \\sigma^2 < \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)}) = 1 - \\alpha</script><p>即给定样本，总体期望 $μ$ 未知的时候，总体方差 $σ^2$ 的一个置信水平为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)})</script><p>实际上， $χ^2$ 分布的一个作用就是在正态总体分布中期望未知时估计其方差的置信区间。</p>\n<h3 id=\"两个正态分布-gt-定理四\"><a href=\"#两个正态分布-gt-定理四\" class=\"headerlink\" title=\"两个正态分布-&gt;定理四\"></a>两个正态分布-&gt;定理四</h3><p>下面讲述两个正态分布的期望差值的区间估计以及方差比的估计。考虑以下问题：已知产品的某一质量指标服从正态分布，但由于原料、操作人员不同，或工艺过程的改变等因素，引起总体均值、方差有所变化。我们需要知道这些变化有多大，就需要考虑两个正态分布<strong>均值差或方差比</strong>的估计问题。</p>\n<p>下面的讨论都是假设给定了置信水平为 $1−α$, 并设 $X_1, X_2,….X_n$ 是来自第一个总体 $N_1(\\mu_1, \\sigma_1^2)$ 的样本，$Y_1, Y_2,….Y_n$ 是来自第二个总体 $N_2(\\mu_2, \\sigma_2^2)$ 的样本，并假设 $\\overline X, \\overline Y$ 是第一、第二个样本的均值， $S_1^2, S_2^2$ 是第一、第二个样本的方差。</p>\n<h4 id=\"估计-μ-1−μ-2-的置信区间\"><a href=\"#估计-μ-1−μ-2-的置信区间\" class=\"headerlink\" title=\"估计 $μ_1−μ_2$ 的置信区间\"></a>估计 $μ_1−μ_2$ 的置信区间</h4><p>估计 $μ_1−μ_2$ 的置信区间时也可以分为两种情况</p>\n<ol>\n<li>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知</li>\n<li>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但是知道 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）<h5 id=\"总体的方差-sigma-1-2-sigma-2-2-已知-gt-定理一\"><a href=\"#总体的方差-sigma-1-2-sigma-2-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知-&gt;定理一\"></a>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知-&gt;定理一</h5>由 $\\overline X \\sim N(\\mu_1, \\sigma_1^2/n_1), \\overline Y \\sim N(\\mu_2, \\sigma_2^2/n_2)$ 可知<script type=\"math/tex; mode=display\">\\overline X - \\overline Y \\sim N(\\mu_1 - \\mu_2, \\sigma_1^2/n_1 + \\sigma_2^2/n_2) \\\\\n\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0, 1)</script>与上面相同，按照标准正态分布的上 $α$ 分位点的定义有<script type=\"math/tex; mode=display\">P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} | < z_{\\alpha/2}) = 1 - \\alpha</script>同样可解得 $μ_1−μ_2$ 置信度为 $1−α$ 的区间。</li>\n</ol>\n<h5 id=\"总体的方差-sigma-1-2-sigma-2-2-未知，但-sigma-1-2-sigma-2-2-sigma-2-（-σ-未知）-gt-定理四\"><a href=\"#总体的方差-sigma-1-2-sigma-2-2-未知，但-sigma-1-2-sigma-2-2-sigma-2-（-σ-未知）-gt-定理四\" class=\"headerlink\" title=\"总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）-&gt;定理四\"></a>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）-&gt;定理四</h5><p>根据 $t$ 分布的作用及其推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script><p>其中 $S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$<br>同样根据 $t$ 分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}}| < t_{\\alpha/2}(n_1+n_2-2)) = 1 - \\alpha</script><p>通过查表同样可以求出 $μ_1−μ_2$ 置信度为 $1−α$ 的区间，结合上面 $t$ 分布在单个正态总体分布参数估计的问题可知， $t$ 分布专门用于解决正态分布中方差未知时估计其期望的问题。</p>\n<h4 id=\"计-sigma-1-2-sigma-2-2-的置信区间\"><a href=\"#计-sigma-1-2-sigma-2-2-的置信区间\" class=\"headerlink\" title=\"计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间\"></a>计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间</h4><p>估计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间同样可以分为两种情况</p>\n<ol>\n<li>总体期望 $μ_1,μ_2$ 已知</li>\n<li>总体期望 $μ_1,μ_2$ 未知</li>\n</ol>\n<h5 id=\"总体期望-μ-1-μ-2-已知-gt-定理一\"><a href=\"#总体期望-μ-1-μ-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体期望 $μ_1,μ_2$ 已知-&gt;定理一\"></a>总体期望 $μ_1,μ_2$ 已知-&gt;定理一</h5><p>总体期望 $μ_1,μ_2$ 已知时可以先通过标准正态分布求出 $\\sigma_1^2, \\sigma_2^2$ 各自的范围, 然后求解 $\\sigma_1^2 / \\sigma_2^2$ 的范围。</p>\n<h5 id=\"总体期望-μ-1-μ-2-未知时，如何估计-sigma-1-2-sigma-2-2-的范围-gt-定理四\"><a href=\"#总体期望-μ-1-μ-2-未知时，如何估计-sigma-1-2-sigma-2-2-的范围-gt-定理四\" class=\"headerlink\" title=\"总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围-&gt;定理四\"></a>总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围-&gt;定理四</h5><p>由 $F$ 分布的定义以及推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script><p>根据 $F$ 分布的 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P( F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1) < \\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} < F_{\\alpha/2}(n_1 - 1, n_2 - 1)) = 1 - \\alpha</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">P( \\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2} < \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)}) = 1 - \\alpha</script><p>即 $\\sigma_1^2 / \\sigma_2^2$ 一个置信度为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2}, \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)})</script><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在上面对正态分布总体进行参数估计中，用到了数理统计中的三大分布： $χ^2$ 分布， $t$ 分布和 $F$ 分布， 其中 $χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。</p>\n<h2 id=\"单侧置信区间\"><a href=\"#单侧置信区间\" class=\"headerlink\" title=\"单侧置信区间\"></a>单侧置信区间</h2><p>上面均是讨论未知参数 $θ$ 的双侧置信区间，但是在实际问题中，往往考虑的只是一个上限或下限，比如说设备、原件的寿命我们关心的是平均寿命 $θ$ 的下限。这就引出了单侧置信区间的概念。单侧置信区间跟双侧置信区间的概念非常类似。</p>\n<p>总体的参数 $θ$ 未知, 对于给定的 $α$ ,若由样本 $X_1, X_2..X_n$ 确定的统计量 $θ′$满足</p>\n<script type=\"math/tex; mode=display\">P(\\theta > \\theta’) = 1 - \\alpha</script><p>则称 $(θ′,∞)$ 是参数 $θ$ 的置信水平为 $1−α$ 的单侧置信区间，而 $θ′$ 是单侧置信下限，将 $θ&gt;θ′$ 变为 $θ&lt;θ′$ 后，相应地变为单侧置信上限。</p>\n<p>单侧置信区间的计算方法与上面提到的双侧置信区间的计算方法已知，都是根据给定的 $α$ 值和统计量服从的分布去查表，找到相应的分位点后带入不等式求解目标估计量的范围即可。</p>\n","site":{"data":{}},"excerpt":"<p>在数理统计中，常常需要通过样本来估计总体的参数，估计可划分为两大类：点估计和区间估计。点估计就是估计总体中某个参数的值，而区间估计是估计总体的某个参数落在某个区间的概率大小。本文主要讲述点估计中的矩估计法和最大似然估计法，以及针对服从正态分布的期望和方差进行区间估计。</p>\n<h1 id=\"参数估计定义\"><a href=\"#参数估计定义\" class=\"headerlink\" title=\"参数估计定义\"></a>参数估计定义</h1><ul>\n<li>已知一个随机变量的分布函数 $Xf_θ(x)$, 其中 $θ = (θ_1,··· ,θ_k)$ 为未知参数.</li>\n<li>样本 $X_1,··· ,X_n$</li>\n<li>利用样本对参数 $θ$ 做出估计，或者估计 $θ$ 的某个函数 $g(θ)$<ul>\n<li>点估计: 用样本的一个函数 $T(X_1,··· ,X_n)$ 去估计 $g(θ)$</li>\n<li>区间估计: 用一个区间去估计 $g(θ)$</li></ul></li></ul>","more":"\n\n\n\n<h1 id=\"点估计\"><a href=\"#点估计\" class=\"headerlink\" title=\"点估计\"></a>点估计</h1><p>点估计一般解决的问题是总体 $X$ 的分布函数 $F(X,θ)$ 形式为已知，但是 $θ$ 参数未知。点估计的目的就是通过样本 $X_1,X_2,…X_n$ 构造一个适当的统计量 $θ′(X_1,X_2,…X_n)$，用于作为未知参数 $θ$ 的近似值。由于 $θ′$ 是样本的函数，因此对于不同的样本，$θ′$ 的值一般不同。</p>\n<p>点估计中一般用到的方法包括<strong>矩估计法和最大似然估计法</strong>。</p>\n<h2 id=\"矩估计法\"><a href=\"#矩估计法\" class=\"headerlink\" title=\"矩估计法\"></a>矩估计法</h2><p><strong>矩估计法的核心思想是样本矩总是收敛于相应的总体矩，因此可通过样本矩作为相应的总体矩的估计量，进而根据总体矩与待估参数的关系求出待估参数。</strong></p>\n<p>矩估计法的一般描述如下：<br>设 $X$ 为连续型随机变量，其概率密度函数为 $f(x;\\theta_1, \\theta_2,..\\theta_n)$ ；离散型随机变量，其分布律为 $P(X=x) = p(x; \\theta_1, \\theta_2,..\\theta_n)$ ；则总体的 $n$ 阶矩分别为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nE(X^n) &= \\int_{-\\infty}^{\\infty} x^nf(x;\\theta_1, \\theta_2…\\theta_n) dx \\\\\nE(X^n) &= \\sum_{x \\in R_x} x^np(x;\\theta_1, \\theta_2….\\theta_n)\n\\end{align*}</script><p>而样本 $X_1, X_2…X_k$ 的 $n$ 阶矩的定义为</p>\n<script type=\"math/tex; mode=display\">A_n = \\frac{1}{k} \\sum_{i=1}^{k}X_i^n</script><p>由于总体的 $n$ 阶矩往往是未知参数 $θ$ 的函数，因此常常先用总体的 $n$ 阶矩 $E(X^n)$ 将参数 $θ$ 表示出来，然后用样本矩 $A_n$ 代替总体的 $n$ 阶矩 $E(X^n)$ ,进而得出估计的 $θ$ 的值。下面是一个简单的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-909cf753.png\" alt=\"\"></p>\n<h2 id=\"最大似然估计法\"><a href=\"#最大似然估计法\" class=\"headerlink\" title=\"最大似然估计法\"></a>最大似然估计法</h2><p><strong>最大似然估计的思想是既然当前取得了这组样本，那么有理由相信已取得的样本出现的概率是很大的。因此通过极大化这组样本的联合概率来估计未知参数的值。</strong></p>\n<h3 id=\"离散型总体\"><a href=\"#离散型总体\" class=\"headerlink\" title=\"离散型总体\"></a>离散型总体</h3><p>单总体为离散型的时候，设当前样本为 $X_1,X_2,…X_n$， 则其联合概率为 $\\prod_{i=1}^{n} p(x_i;\\theta)$, 其中 $x_i$ 是 $X_i$ 相应的观测值，则上面的联合概率实际上是参数 $θ$ 的函数，记为</p>\n<script type=\"math/tex; mode=display\">L(\\theta) = \\prod_{i=1}^{n} p(x_i;\\theta)</script><p>上面的 $L(θ)$ 被称为样本的似然函数。</p>\n<p>选择 $θ$ 的值使得 $L(θ)$ 最大便是最大似然估计做的事情。一般通过对 似然函数求导便可求得其最大值对应的 $θ$。如下是一个简单的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-494bd225.png\" alt=\"\"></p>\n<p>上面最后求解的结果是 $p’ = \\overline x$ 。同时也注意到求解似然函数最大化时会先对似然函数取 $log$ , 目的是将连乘变为连加，方便运算，同时这种方法也被称为对数极大似然估计。</p>\n<h3 id=\"连续型总体\"><a href=\"#连续型总体\" class=\"headerlink\" title=\"连续型总体\"></a>连续型总体</h3><p>若总体是连续型，设其概率密度函数为 $f(x,θ)$ ，则当前样本 $X_1,X_2,…X_n$ 的联合概率密度函数为</p>\n<script type=\"math/tex; mode=display\">\\prod_{i=1}^{n}f(x_i;\\theta)</script><p>其中 $x_1,x_2,…x_n$ 是相应于样本的一个样本值，则随机点落在 （$x_1,x_2,…x_n$）的领域（边长为 $dx_1, dx_2,…dx_n$ 的n维立方体）内的概率近似为</p>\n<script type=\"math/tex; mode=display\">\\prod_{i=1}^{n}f(x_i;\\theta)dx_i</script><p>同样我们要让上式取到最大，但是因子 $\\prod_{i=1}^{n}dx_i$ 不随 $θ$ 改变，因此只需考虑函数 $L(\\theta) = \\prod_{i=1}^{n}f(x_i;\\theta)$ 最大即可，这里 $L(θ)$ 被称为似然函数，极大化也是通过求导来解决。</p>\n<p>下面是一个连续型总体进行极大似然估计的例子</p>\n<p><img src=\"/2017/08/15/参数估计/参数估计-cd1a5ccf.png\" alt=\"\"></p>\n<h2 id=\"评选标准\"><a href=\"#评选标准\" class=\"headerlink\" title=\"评选标准\"></a>评选标准</h2><p>对于同一参数，不同的估计方法求出的估计量可能不一样，那么如何判断不同的估计量之间的优劣，<strong>无偏性，有效性和相合性</strong>是常用的三个指标。</p>\n<ul>\n<li>相合性 (consistency): 当样本数量趋于无穷时，估计量收敛 于参数真实值.</li>\n<li>无偏性 (bias): 对于有限的样本，估计量所符合的分布之期 望等于参数真实值.</li>\n<li>有效性 (efficiency): 估计值所满足的分布方差越小越好.</li>\n</ul>\n<h3 id=\"相合性\"><a href=\"#相合性\" class=\"headerlink\" title=\"相合性\"></a>相合性</h3><p>当样本数目 $n→∞$ 时，估计量 $\\theta’(X_1，X_2…X_n)$ 收敛于真正的 $θ$ ,则称 $θ′$ 为 $θ$ 的相合估计量。即有以下式子成立</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\rightarrow \\infty}P(|\\theta’ - \\theta| < \\epsilon) = 1</script><p>相合性是一个估计量的基本要求，如果估计量没有相合性，那么无论样本数量 n 取多大，这些估计量都无法准确估计正确参数，都是不可取的。</p>\n<h3 id=\"无偏性\"><a href=\"#无偏性\" class=\"headerlink\" title=\"无偏性\"></a>无偏性</h3><p>无偏性指的是从样本中得到的估计量 $θ′$ 的期望与总体的参数 $θ$ 相等，也就是</p>\n<script type=\"math/tex; mode=display\">E(θ′)=θ</script><p>此时称 $θ′$ 是 $θ$ 的无偏估计量。无偏估计量的意义是对于某些样本值，这一估计量得到的估计值比真实值要打，而对于另外一些样本则偏小，反复将这一估计量使用多次，就平均来说其偏差为零。</p>\n<h3 id=\"有效性\"><a href=\"#有效性\" class=\"headerlink\" title=\"有效性\"></a>有效性</h3><p>当两个估计量 $\\theta_1’, \\theta_2’$ 均是无偏估计量时，就要通过比较他们的有效性来决定选取哪个估计量。有效性指的是在样本容量 $n$ 相同的情况下，假如 $θ_1’$ 的观察值较 $θ_2’$ 的值更密集在真值 $θ$ 附近，那么认为 $θ_1’$ 比 $θ_2’$ 更为理想。</p>\n<p>实际上，上面比较的就是两个估计量的方差大小，方差越小，则越有效，因此当两个总体的样本数相同的时候，若 $D(θ_1’)&lt;D(θ_2’)$ 时， 就称 $θ_1’$ 比 $θ_2’$ 更有效。</p>\n<h1 id=\"区间估计\"><a href=\"#区间估计\" class=\"headerlink\" title=\"区间估计\"></a>区间估计</h1><p><strong>对于总体中的未知参数，我们的估计总是存在着一定的误差的，如何去衡量这个误差是一个需要考虑的事情。同时，除了上面的点估计，在实际中我们往往还希望估计出参数的一个范围，同时参数落在这个范围的概率，或者是说可信程度。</strong></p>\n<p>估计参数落在某个范围以及落在这个范围的可信程度就是区间估计干的事情。</p>\n<p>其严格定义如下</p>\n<p>设总体的分布中存在一个未知参数 $θ$, 对于给定的值 $α(0&lt;α&lt;1)$, 若通过样本 $X_1,X_2,X_3…X_n$ 估计的两个统计量 $θ_1′$ 和 $θ_2′$ 满足下面不等式时</p>\n<script type=\"math/tex; mode=display\">P(\\theta’_1 < \\theta < \\theta’_2) \\ge 1 - \\alpha</script><p>则称区间 $(\\theta’_1, \\theta’_2)$ 是参数 $θ$ 置信水平为 $1−α$ 的置信区间, $\\theta’_1, \\theta’_2$ 分别称为置信下限和置信上限。</p>\n<p>上面式子的含义是若反复抽样多次（每次得到的样本的容量相等），每个样本值确定一个区间$(\\theta’_1, \\theta’_2)$，这个区间要么包含 $θ$ 的真值，要么不包含 $θ$ 的真值,在这么多的区间中，包含 $θ$ 真值的概率约为 $1−α$.</p>\n<h2 id=\"正态分布均值与方差的区间估计\"><a href=\"#正态分布均值与方差的区间估计\" class=\"headerlink\" title=\"正态分布均值与方差的区间估计\"></a>正态分布均值与方差的区间估计</h2><p>由于正态分布的普遍性，下面主要讲述对正态分布的期望和方差进行区间估计的方法，而这里会用到我们前面讲到的统计量的三大分布： $χ^2$ 分布， $t$ 分布， $F$ 分布，以及对其拓展的一些定理，具体的定理及其证明可参考抽样与统计.md。</p>\n<p>下面会讲述单个正态分布的期望和方差的估计，以及两个正态分布的期望差和方差比的估计。</p>\n<h3 id=\"单个正态分布\"><a href=\"#单个正态分布\" class=\"headerlink\" title=\"单个正态分布\"></a>单个正态分布</h3><p>下面的关于单个正态分布的讨论都是基于以下假设：给定置信水平为 $1−α$ , 设 $X_1,X_2,X_3…X_n$ 为总体 $N(μ,σ^2)$ 的样本，$\\overline X，S^2$ 分别是样本的期望和方差。</p>\n<h4 id=\"估计期望-μ-的置信区间\"><a href=\"#估计期望-μ-的置信区间\" class=\"headerlink\" title=\"估计期望 $μ$ 的置信区间\"></a>估计期望 $μ$ 的置信区间</h4><p>通过样本 $X_1,X_2,X_3…X_n$ 估计总体 $N(μ,σ^2)$ 的期望 $μ$ 时可以分为两种情况：</p>\n<ol>\n<li>总体的方差 $σ^2$ 已知</li>\n<li>总体的方差 $σ^2$ 未知<h5 id=\"总体的方差-σ-2-已知-gt-定理一\"><a href=\"#总体的方差-σ-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体的方差 $σ^2$ 已知-&gt;定理一\"></a>总体的方差 $σ^2$ 已知-&gt;定理一</h5>若已知总体的方差，则因为 $\\overline X \\sim N(\\mu , \\sigma^2/n)$ , 即 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 下面都会这样不加证明给出这些统计量服从的分布，具体的证明参考<a href=\"样本以及抽样分布.md\">这篇文章</a>。</li>\n</ol>\n<p>按照标准正态分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} | < z_{\\alpha/2}) = 1 - \\alpha</script><p>从概率密度函数上直观看为：<br><img src=\"/2017/08/15/参数估计/参数估计-398aa4f1.png\" alt=\"\"></p>\n<p>进一步化简有</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}) = 1 - \\alpha</script><p>给定 $\\alpha, z_{\\alpha/2}$ 的值可以通过查表获得。这样便得到了期望 $μ$ 的一个估计区间为 $(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2}, \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2})$, 其置信度为 $1−α$。注意置信水平为 $1−α$ 的置信区间并不是唯一的，假如说给定 $α=0.05$, 则上面的式子可写为</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.025} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.025}) = 1 - \\alpha</script><p>同时也可写为</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{\\sigma}{\\sqrt{n}}z_{0.04} < \\mu < \\overline X + \\frac{\\sigma}{\\sqrt{n}}z_{0.01}) = 1 - \\alpha</script><p>但是写成不对称的形式计算出来的区间长度要更长，显然，置信度相同的情况下，置信区间肯定是越小越好，所以对于正态分布的分位点往往选择对称形式。</p>\n<p>下面的求解方法与这方法类似，只是构造的统计量不同，因而服从的分布也不同。</p>\n<h5 id=\"总体的方差-σ-2-未知-gt-定理三\"><a href=\"#总体的方差-σ-2-未知-gt-定理三\" class=\"headerlink\" title=\"总体的方差 $σ^2$ 未知-&gt;定理三\"></a>总体的方差 $σ^2$ 未知-&gt;定理三</h5><p>当总体方差未知时，就无法利用上面标准正态分布。但是回忆 $t$ 分布的作用及其定理，可知</p>\n<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)</script><p>同样按照 $t$ 分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{\\overline X - \\mu}{S/\\sqrt{n}}| < t_{\\alpha/2}(n-1)) = 1 - \\alpha</script><p>其对应的概率密度函数如下所示<br><img src=\"/2017/08/15/参数估计/参数估计-7c030c8b.png\" alt=\"\"><br>进一步化简可得</p>\n<script type=\"math/tex; mode=display\">P(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1) < \\mu < \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1)) = 1 - \\alpha</script><p>则期望 $μ$ 的一个置信水平为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\overline X - \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1), \\overline X + \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n - 1))</script><h4 id=\"估计方差-σ-2-的置信区间\"><a href=\"#估计方差-σ-2-的置信区间\" class=\"headerlink\" title=\"估计方差 $σ^2$ 的置信区间\"></a>估计方差 $σ^2$ 的置信区间</h4><p>估计方差 $σ^2$ 的置信区间也可分为两种情况</p>\n<ol>\n<li>总体的期望 $μ$ 已知</li>\n<li>总体的期望 $μ$ 未知<h5 id=\"总体的期望-μ-已知-gt-定理一\"><a href=\"#总体的期望-μ-已知-gt-定理一\" class=\"headerlink\" title=\"总体的期望 $μ$ 已知-&gt;定理一\"></a>总体的期望 $μ$ 已知-&gt;定理一</h5></li>\n</ol>\n<p>当期望 $μ$ 已知时，求解方差 $σ^2$ 的置信区间的方法跟上面已知方差 $σ^2$ 求解期望 $μ$ 的一样，都是利用 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$，然后写出对应未知量的区间，这里就不详细讲述已知 $μ$ 求解方差 $σ^2$ 的详细过程了。</p>\n<h5 id=\"总体的期望-μ-未知-gt-定理二\"><a href=\"#总体的期望-μ-未知-gt-定理二\" class=\"headerlink\" title=\"总体的期望 μ 未知-&gt;定理二\"></a>总体的期望 μ 未知-&gt;定理二</h5><p>当期望 $μ$ 未知时，求解方差 $σ^2$ 的区间估计就再也不能利用上面的 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$。结合 $χ^2$ 分布的特性及其推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script><p>同样按照 $χ^2$ 分布的 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P( \\chi^2_{1 - \\alpha/2}(n-1) < \\frac{(n-1)S^2}{\\sigma^2} < \\chi^2_{\\alpha/2}(n-1)) = 1 - \\alpha</script><p>注意这里不能用绝对值了，原因是 $χ^2$ 分布的概率密度函数不像标准正态分布或 $t$ 分布那样是对称的。其对应的概率密度函数如下所示<br><img src=\"/2017/08/15/参数估计/参数估计-48556a99.png\" alt=\"\"><br>进一步化简可得</p>\n<script type=\"math/tex; mode=display\">P(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)} < \\sigma^2 < \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)}) = 1 - \\alpha</script><p>即给定样本，总体期望 $μ$ 未知的时候，总体方差 $σ^2$ 的一个置信水平为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\frac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)}, \\frac{(n-1)S^2}{\\chi^2_{1 - \\alpha/2}(n-1)})</script><p>实际上， $χ^2$ 分布的一个作用就是在正态总体分布中期望未知时估计其方差的置信区间。</p>\n<h3 id=\"两个正态分布-gt-定理四\"><a href=\"#两个正态分布-gt-定理四\" class=\"headerlink\" title=\"两个正态分布-&gt;定理四\"></a>两个正态分布-&gt;定理四</h3><p>下面讲述两个正态分布的期望差值的区间估计以及方差比的估计。考虑以下问题：已知产品的某一质量指标服从正态分布，但由于原料、操作人员不同，或工艺过程的改变等因素，引起总体均值、方差有所变化。我们需要知道这些变化有多大，就需要考虑两个正态分布<strong>均值差或方差比</strong>的估计问题。</p>\n<p>下面的讨论都是假设给定了置信水平为 $1−α$, 并设 $X_1, X_2,….X_n$ 是来自第一个总体 $N_1(\\mu_1, \\sigma_1^2)$ 的样本，$Y_1, Y_2,….Y_n$ 是来自第二个总体 $N_2(\\mu_2, \\sigma_2^2)$ 的样本，并假设 $\\overline X, \\overline Y$ 是第一、第二个样本的均值， $S_1^2, S_2^2$ 是第一、第二个样本的方差。</p>\n<h4 id=\"估计-μ-1−μ-2-的置信区间\"><a href=\"#估计-μ-1−μ-2-的置信区间\" class=\"headerlink\" title=\"估计 $μ_1−μ_2$ 的置信区间\"></a>估计 $μ_1−μ_2$ 的置信区间</h4><p>估计 $μ_1−μ_2$ 的置信区间时也可以分为两种情况</p>\n<ol>\n<li>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知</li>\n<li>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但是知道 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）<h5 id=\"总体的方差-sigma-1-2-sigma-2-2-已知-gt-定理一\"><a href=\"#总体的方差-sigma-1-2-sigma-2-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知-&gt;定理一\"></a>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 已知-&gt;定理一</h5>由 $\\overline X \\sim N(\\mu_1, \\sigma_1^2/n_1), \\overline Y \\sim N(\\mu_2, \\sigma_2^2/n_2)$ 可知<script type=\"math/tex; mode=display\">\\overline X - \\overline Y \\sim N(\\mu_1 - \\mu_2, \\sigma_1^2/n_1 + \\sigma_2^2/n_2) \\\\\n\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0, 1)</script>与上面相同，按照标准正态分布的上 $α$ 分位点的定义有<script type=\"math/tex; mode=display\">P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} | < z_{\\alpha/2}) = 1 - \\alpha</script>同样可解得 $μ_1−μ_2$ 置信度为 $1−α$ 的区间。</li>\n</ol>\n<h5 id=\"总体的方差-sigma-1-2-sigma-2-2-未知，但-sigma-1-2-sigma-2-2-sigma-2-（-σ-未知）-gt-定理四\"><a href=\"#总体的方差-sigma-1-2-sigma-2-2-未知，但-sigma-1-2-sigma-2-2-sigma-2-（-σ-未知）-gt-定理四\" class=\"headerlink\" title=\"总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）-&gt;定理四\"></a>总体的方差 $\\sigma_1^2, \\sigma_2^2$ 未知，但 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$（$σ$未知）-&gt;定理四</h5><p>根据 $t$ 分布的作用及其推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script><p>其中 $S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$<br>同样根据 $t$ 分布的上 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P(|\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}}| < t_{\\alpha/2}(n_1+n_2-2)) = 1 - \\alpha</script><p>通过查表同样可以求出 $μ_1−μ_2$ 置信度为 $1−α$ 的区间，结合上面 $t$ 分布在单个正态总体分布参数估计的问题可知， $t$ 分布专门用于解决正态分布中方差未知时估计其期望的问题。</p>\n<h4 id=\"计-sigma-1-2-sigma-2-2-的置信区间\"><a href=\"#计-sigma-1-2-sigma-2-2-的置信区间\" class=\"headerlink\" title=\"计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间\"></a>计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间</h4><p>估计 $\\sigma_1^2 / \\sigma_2^2$ 的置信区间同样可以分为两种情况</p>\n<ol>\n<li>总体期望 $μ_1,μ_2$ 已知</li>\n<li>总体期望 $μ_1,μ_2$ 未知</li>\n</ol>\n<h5 id=\"总体期望-μ-1-μ-2-已知-gt-定理一\"><a href=\"#总体期望-μ-1-μ-2-已知-gt-定理一\" class=\"headerlink\" title=\"总体期望 $μ_1,μ_2$ 已知-&gt;定理一\"></a>总体期望 $μ_1,μ_2$ 已知-&gt;定理一</h5><p>总体期望 $μ_1,μ_2$ 已知时可以先通过标准正态分布求出 $\\sigma_1^2, \\sigma_2^2$ 各自的范围, 然后求解 $\\sigma_1^2 / \\sigma_2^2$ 的范围。</p>\n<h5 id=\"总体期望-μ-1-μ-2-未知时，如何估计-sigma-1-2-sigma-2-2-的范围-gt-定理四\"><a href=\"#总体期望-μ-1-μ-2-未知时，如何估计-sigma-1-2-sigma-2-2-的范围-gt-定理四\" class=\"headerlink\" title=\"总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围-&gt;定理四\"></a>总体期望 $μ_1,μ_2$ 未知时，如何估计 $\\sigma_1^2 / \\sigma_2^2$ 的范围-&gt;定理四</h5><p>由 $F$ 分布的定义以及推导的定理可知</p>\n<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script><p>根据 $F$ 分布的 $α$ 分位点的定义有</p>\n<script type=\"math/tex; mode=display\">P( F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1) < \\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} < F_{\\alpha/2}(n_1 - 1, n_2 - 1)) = 1 - \\alpha</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">P( \\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2} < \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)}) = 1 - \\alpha</script><p>即 $\\sigma_1^2 / \\sigma_2^2$ 一个置信度为 $1−α$ 的置信区间为</p>\n<script type=\"math/tex; mode=display\">(\\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1 - 1, n_2 - 1)} < \\frac{\\sigma_1^2}{ \\sigma_2^2}, \\frac{S_1^2}{S_2^2}\\frac{1}{F_{1 - \\alpha/2}(n_1 - 1, n_2 - 1)})</script><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在上面对正态分布总体进行参数估计中，用到了数理统计中的三大分布： $χ^2$ 分布， $t$ 分布和 $F$ 分布， 其中 $χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。</p>\n<h2 id=\"单侧置信区间\"><a href=\"#单侧置信区间\" class=\"headerlink\" title=\"单侧置信区间\"></a>单侧置信区间</h2><p>上面均是讨论未知参数 $θ$ 的双侧置信区间，但是在实际问题中，往往考虑的只是一个上限或下限，比如说设备、原件的寿命我们关心的是平均寿命 $θ$ 的下限。这就引出了单侧置信区间的概念。单侧置信区间跟双侧置信区间的概念非常类似。</p>\n<p>总体的参数 $θ$ 未知, 对于给定的 $α$ ,若由样本 $X_1, X_2..X_n$ 确定的统计量 $θ′$满足</p>\n<script type=\"math/tex; mode=display\">P(\\theta > \\theta’) = 1 - \\alpha</script><p>则称 $(θ′,∞)$ 是参数 $θ$ 的置信水平为 $1−α$ 的单侧置信区间，而 $θ′$ 是单侧置信下限，将 $θ&gt;θ′$ 变为 $θ&lt;θ′$ 后，相应地变为单侧置信上限。</p>\n<p>单侧置信区间的计算方法与上面提到的双侧置信区间的计算方法已知，都是根据给定的 $α$ 值和统计量服从的分布去查表，找到相应的分位点后带入不等式求解目标估计量的范围即可。</p>"},{"title":"CART","date":"2017-07-21T03:07:40.000Z","_content":"# 简介\n决策树的生成就是递归地构建二叉决策树的过程。对回归树用**平方误差最小化准则**，对分类树用**基尼指数（Gini index）**最小化准则，进行特征选择，生成二叉树。CART算法有两步：**决策树生成和剪枝。**\n<!--more-->\n\n# 回归树的生成\n一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c$,$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$\n- 输入：训练数据集$D{(x_1,y_1),...,(x_N,y_N)}$；\n- 输出：回归树$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$\n在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树\n 1. 当输入空间的划分确定时，可以用平方误差$\\sum _{x_i\\in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，选择最优切分变量$j$与切分点$s$，使得预测误差最小，求解\n $$\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2]$$\n 1. 用选定的对$（j,s）$划分区域并决定相应的输出值：\n $$R_1(j,s)=\\{x|x^{(j)}\\leqslant s\\},R_1(j,s)=\\{x|x^{(j)}> s\\}\\\\\n\\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i \\in R_m(j,s)}y_i ,\\; \\; x\\in R_m ,\\, \\, m=1,2$$\n 1. 继续对两个子区域调用以上两个步骤，直至满足停止条件。\n 1. 将输入空间划分为$M$个区域$R_1,R_2,…R_m$，生成决策树\n $$f(x)=\\sum _{m=1}^M\\hat{c}_mI(x \\in R_m)$$\n\n## 计算实例\n训练数据见下表，x的取值范围为区间[0.5,10.5],y的取值范围为区间[5.0,10.0],学习这个回归问题的最小二叉回归树\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n\n### 根结点$T_1(x)$\n求训练数据的切分点，根据所给数据，求取使得预测误差最小的切分点：\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n切分点|1.5 | 2.5 | 3.5 | 4.5 | 5.5 |  6.5 |  7.5 |  8.5 |  9.5\n\n- 例如当 $s=1.5$ 时，$R_1 = \\lbrace 1\\rbrace$ , $R_2 = \\lbrace 2, 3 , \\ldots , 10\\rbrace$ , $c_1=5.56$ , $c_2=7.50$ ,\n$$m(s)=\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2] = 0+15.72 = 15.72$$\n由上表可知，当$x=6.5$的时候达到最小值，此时$R_1 = \\lbrace 1 ,2 , \\ldots , 6\\rbrace$ , $R_2 = \\lbrace 7 ,8 ,9 ,10 ,\\rbrace$ , $c_1=6.24$ , $c_2=8.9$ , 所以回归树$T_1(x)$为：\n$$T_1(x) =\n\\begin{cases}\n6.24, & x\\lt 6.5 \\\\\n8.91, & x \\ge 6.5 \\\\\n\\end{cases}$$\n$$f_1(x) = T_1(x)$$\n\n- 用$f_1(x)$拟合训练数据的平方误差：\n$$L(y,f_1(x)) = \\sum_{i=1}^{10}(y_i-f_1(x_i))^2 = 1.93$$\n\n### 次结点$T_2(x)$\n用$f_1(x)$拟合训练数据的残差见下表，表中$r_{2i} = y_i - f_1(x_i),i=1,2,\\ldots , 10$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n$r_{2i}$ | -0.68 | -0.54 | -0.33 | 0.16 | 0.56 | 0.81 | -0.01 | -0.21 | 0.09 | 0.14\n\n求$T_2(x)$.方法与求$T_1(x)$一样，只是拟合的数据是上表的残差，可以得到\n$$T_2(x) =\n\\begin{cases}\n-0.52, & x\\lt 3.5 \\\\\n0.22, & x \\ge 3.5 \\\\\n\\end{cases}$$\n$$f_2(x) = f_1(x) + T_2(x)=\n\\begin{cases}\n5.72, & x\\lt 3.5 \\\\\n6.46, & 3.5\\le x \\lt 6.5 \\\\\n9.13, & x\\ge 6.5 \\\\\n\\end{cases}$$\n\n- 用$f_2(x)$拟合训练数据的平方误差是：\n$$L(y,f_2(x)) = \\sum_{i=1}^{10}(y_i-f_2(x_i))^2 = 0.79$$\n\n### 结果\n继续求得\n$$T_3(x) =\n\\begin{cases}\n0.15, & x\\lt 6.5 \\\\\n-0.22, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.47 ,$$\n$$T_4(x) =\n\\begin{cases}\n-0.16, & x\\lt 4.5 \\\\\n0.11, & x \\ge 4.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.30 ,$$\n$$T_5(x) =\n\\begin{cases}\n0.07, & x\\lt 6.5 \\\\\n-0.11, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.23 ,$$\n$$T_6(x) =\n\\begin{cases}\n-0.15, & x\\lt 2.5 \\\\\n0.04, & x \\ge 2.5 \\\\\n\\end{cases}$$\n$$f_6(x) = f_5(x)+T_6(x) =T_1(x)+ \\ldots + T_5(x) + T_6(x)=\n\\begin{cases}\n5.63, & x\\lt 2.5 \\\\\n5.82, & 2.5 \\le x\\lt 3.5 \\\\\n6.56, & 3.5 \\le x\\lt 4.5 \\\\\n6.83, & 4.5 \\le x\\lt 6.5 \\\\\n8.95, & x\\ge 6.5 \\\\\n\\end{cases}$$\n- 用$f_6(x)$拟合训练数据的平方损失误差是\n$$L(y,f_6(x)) = \\sum_{i=1}^{10}(y_i-f_6(x_i))^2 = 0.71$$\n假设此时已经满足误差要求，那么$f(x)=f_6(x)$即为所求的回归树。\n\n** 综可知平方差函数越来越小**\n\n# 分类树的生成\n- 输入：训练数据集$D$，停止计算的条件；\n- 输出：CART决策树。根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：\n 1. 设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A＝a$的测试为“是”或“否”将$D$分割成$D1$和$D2$两部分，利用式$Gini(D)=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2$计算$A＝a$时的基尼指数。\n 2. 在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。\n 3. 对两个子结点递归地调用以上两个步骤，直至满足停止条件。\n 4. 生成CART决策树。\n\n\n ## 基尼指数\n 分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为\n $$\\begin{align*}\n Gini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\n Gini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n \\end{align*}$$\n 如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为\n $$Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)$$\n 基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强\n\n## 计算实例\n![](回归树/回归树-d82a16be.png)\n分别以$A_1，A_2，A_3，A_4$表示年龄、有工作、有自己的房子和信贷情况4个特征，并以$1，2，3$表示年龄的值为青年、中年和老年，以$1，2$表示有工作和有自己的房子的值为是和否，以$1，2，3$表示信贷情况的值为非常好、好和一般。\n$$Gini( D,A_1=1 )=\\frac{5}{15}\\left ( \\frac{2}{5}(1-\\frac{2}{5})+\\frac{3}{5}(1-\\frac{3}{5}) \\right )+\\frac{10}{15}\\left ( \\frac{7}{10}(1-\\frac{7}{10})+\\frac{3}{10}(1-\\frac{3}{10}) \\right )$$\n![](回归树/回归树-eb149128.png)\n![](回归树/回归树-ce859c9e.png)\n![](回归树/回归树-ae6f77ba.png)\n在$A_1，A_2，A_3，A_4$几个特征中，$Gini(D，A_3＝1)＝0.27$最小，所以选择特征 $A_3$ 为最优特征，$A_3＝1$为其最优切分点。于是根结点生成两个子结点，一个是叶结点。对另一个结点继续使用以上方法在$A_1，A_2，A_4$中选择最优特征及其最优切分点，结果是 $A_2＝1$。依此计算得知，所得结点都是叶结点。\n\n# CART剪枝\n### CART决策树剪枝\nCART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：\n- 首先从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到T0的根结点，形成一个子树序列$\\{T_0，T_1,…,T_n\\}$；\n- 然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。\n\n那么问题来了，参数$α$给定的？谁来给？领域专家给？这是一种行之有效的办法，但却需要领域知识。理想化的模型都希望参数由data决定，也就是$α$也由数据决定。那么我们能想到的就是拿测试数据去测试在给定$α$下生成的子树。\n**ID3与C4.5使用的$α$由人为决定，CART的$α$有算法决定**下面主要介绍如何确定$α$\n\n#### $α$的算法\n剪枝过程中计算子树的损失函数\n$$C_{\\alpha}(T) = C(T)+\\alpha \\left | T \\right |$$\n\n其中，$T$为任意子树，$ C(T)$为对训练数据的预测误差（如基尼指数），$\\left | T \\right |$为子树的叶结点个数，$\\alpha \\geqslant 0$为参数，$C_\\alpha (T)$为参数是$\\alpha $时的子树$T$的整体损失，参数$\\alpha $权衡训练数据的拟合程度与模型的复杂度\n\n具体地，从整体树$T_0$开始剪枝，对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是\n\n$$C_{\\alpha}(t) = C(t)+\\alpha $$\n\n以$t$为为根结点的子树$T_t$为单结点树的损失函数是\n\n$$C_{\\alpha }(T_t) = C(T_t)+\\alpha \\left | T_t \\right |$$\n\n- 当$\\alpha =0$及$\\alpha $充分小时，有不等式\n\n$$C_\\alpha(T_t)<C_\\alpha(t)$$\n\n- 当$\\alpha $增大时，有某一$\\alpha $有\n\n$$C_\\alpha(T_t)=C_\\alpha(t)$$\n\n- 当$\\alpha $继续增大时\n\n$$C_\\alpha(T_t)>C_\\alpha(t)$$\n\n所以我们只要取$\\alpha_1 = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$时，当且仅当$α≥α_1$时，剪枝必然发生。$α$必须满足上述条件，否则前提假设将失去意义。所以说，我们通过假设剪枝必然发生就能找到对应的$α$\n\n这个 $α$ 的值有什么意义，刚才我们高能预警的地方，$0=\\alpha_0<\\alpha_1<...<\\alpha_n<+\\infty$ ，在每个区间 $[α_i,α_{i+1})$ 中，子树 $T_i$ 是这个区间里最优的。为什么呢？原因就在刚才的推导，对于当前这个结点，只要 $α$ 大于这个值时，一定有$C_{\\alpha}(t)<C_{\\alpha}(T_t)$ ，也就是剪掉这个结点后都比不剪要更优。所以每个最优子树对应的是一个区间，在这个区间内都是最优的。\n\n##### $g(t)$为什么是最小的\n$$g(t) = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$$\n\n![](回归树/回归树-23c9f784.png)\n\n当$α$较小时，结点不修剪的误差要小于修剪之后的误差，此时不剪为好，但当$α$增大时，修剪前后的误差先减小后增大，对应每个结点都有一个临界值 $g(t)$ 。\n为什么要选择最小的$ g(t)$ 呢？以图中两个点为例，结点1和结点2，$g(t)_2$ 大于$g(t)_1$, 假设在所有结点中$g(t)_1$最小，$g(t)_2$最大，两种选择方法：当选择最大值$g(t)_2$，即结点2进行剪枝，但此时结点1的不修剪的误差大于修剪之后的误差，即如果不修剪的话，误差变大，依次类推，对其它所有的结点的$g(t)$都是如此，从而造成整体的累计误差更大。反之，如果选择最小值$g(t)_1$，即结点1进行剪枝，则其余结点不剪的误差要小于剪后的误差，不修剪为好，且整体的误差最小。从而以最小$g(t)$剪枝获得的子树是该$α$值下的最优子树！\n\n\n### 剪枝流程\n![](回归树/回归树-7ea432c5.png)\n","source":"_posts/回归树.md","raw":"---\ntitle: CART\ndate: 2017-07-21 11:07:40\ntags: [人工智能,模型,树模型]\ncategories: 机器学习\n---\n# 简介\n决策树的生成就是递归地构建二叉决策树的过程。对回归树用**平方误差最小化准则**，对分类树用**基尼指数（Gini index）**最小化准则，进行特征选择，生成二叉树。CART算法有两步：**决策树生成和剪枝。**\n<!--more-->\n\n# 回归树的生成\n一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c$,$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$\n- 输入：训练数据集$D{(x_1,y_1),...,(x_N,y_N)}$；\n- 输出：回归树$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$\n在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树\n 1. 当输入空间的划分确定时，可以用平方误差$\\sum _{x_i\\in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，选择最优切分变量$j$与切分点$s$，使得预测误差最小，求解\n $$\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2]$$\n 1. 用选定的对$（j,s）$划分区域并决定相应的输出值：\n $$R_1(j,s)=\\{x|x^{(j)}\\leqslant s\\},R_1(j,s)=\\{x|x^{(j)}> s\\}\\\\\n\\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i \\in R_m(j,s)}y_i ,\\; \\; x\\in R_m ,\\, \\, m=1,2$$\n 1. 继续对两个子区域调用以上两个步骤，直至满足停止条件。\n 1. 将输入空间划分为$M$个区域$R_1,R_2,…R_m$，生成决策树\n $$f(x)=\\sum _{m=1}^M\\hat{c}_mI(x \\in R_m)$$\n\n## 计算实例\n训练数据见下表，x的取值范围为区间[0.5,10.5],y的取值范围为区间[5.0,10.0],学习这个回归问题的最小二叉回归树\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n\n### 根结点$T_1(x)$\n求训练数据的切分点，根据所给数据，求取使得预测误差最小的切分点：\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n切分点|1.5 | 2.5 | 3.5 | 4.5 | 5.5 |  6.5 |  7.5 |  8.5 |  9.5\n\n- 例如当 $s=1.5$ 时，$R_1 = \\lbrace 1\\rbrace$ , $R_2 = \\lbrace 2, 3 , \\ldots , 10\\rbrace$ , $c_1=5.56$ , $c_2=7.50$ ,\n$$m(s)=\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2] = 0+15.72 = 15.72$$\n由上表可知，当$x=6.5$的时候达到最小值，此时$R_1 = \\lbrace 1 ,2 , \\ldots , 6\\rbrace$ , $R_2 = \\lbrace 7 ,8 ,9 ,10 ,\\rbrace$ , $c_1=6.24$ , $c_2=8.9$ , 所以回归树$T_1(x)$为：\n$$T_1(x) =\n\\begin{cases}\n6.24, & x\\lt 6.5 \\\\\n8.91, & x \\ge 6.5 \\\\\n\\end{cases}$$\n$$f_1(x) = T_1(x)$$\n\n- 用$f_1(x)$拟合训练数据的平方误差：\n$$L(y,f_1(x)) = \\sum_{i=1}^{10}(y_i-f_1(x_i))^2 = 1.93$$\n\n### 次结点$T_2(x)$\n用$f_1(x)$拟合训练数据的残差见下表，表中$r_{2i} = y_i - f_1(x_i),i=1,2,\\ldots , 10$\n\n$x_i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n-|-|-|-|-|-|-|-|-|-|-\n$y_i$ | 5.56 | 5.70 | 5.91 | 6.40 | 6.80 | 7.05 | 8.90 |8.70 | 9.00 | 9.05\n$r_{2i}$ | -0.68 | -0.54 | -0.33 | 0.16 | 0.56 | 0.81 | -0.01 | -0.21 | 0.09 | 0.14\n\n求$T_2(x)$.方法与求$T_1(x)$一样，只是拟合的数据是上表的残差，可以得到\n$$T_2(x) =\n\\begin{cases}\n-0.52, & x\\lt 3.5 \\\\\n0.22, & x \\ge 3.5 \\\\\n\\end{cases}$$\n$$f_2(x) = f_1(x) + T_2(x)=\n\\begin{cases}\n5.72, & x\\lt 3.5 \\\\\n6.46, & 3.5\\le x \\lt 6.5 \\\\\n9.13, & x\\ge 6.5 \\\\\n\\end{cases}$$\n\n- 用$f_2(x)$拟合训练数据的平方误差是：\n$$L(y,f_2(x)) = \\sum_{i=1}^{10}(y_i-f_2(x_i))^2 = 0.79$$\n\n### 结果\n继续求得\n$$T_3(x) =\n\\begin{cases}\n0.15, & x\\lt 6.5 \\\\\n-0.22, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.47 ,$$\n$$T_4(x) =\n\\begin{cases}\n-0.16, & x\\lt 4.5 \\\\\n0.11, & x \\ge 4.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.30 ,$$\n$$T_5(x) =\n\\begin{cases}\n0.07, & x\\lt 6.5 \\\\\n-0.11, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.23 ,$$\n$$T_6(x) =\n\\begin{cases}\n-0.15, & x\\lt 2.5 \\\\\n0.04, & x \\ge 2.5 \\\\\n\\end{cases}$$\n$$f_6(x) = f_5(x)+T_6(x) =T_1(x)+ \\ldots + T_5(x) + T_6(x)=\n\\begin{cases}\n5.63, & x\\lt 2.5 \\\\\n5.82, & 2.5 \\le x\\lt 3.5 \\\\\n6.56, & 3.5 \\le x\\lt 4.5 \\\\\n6.83, & 4.5 \\le x\\lt 6.5 \\\\\n8.95, & x\\ge 6.5 \\\\\n\\end{cases}$$\n- 用$f_6(x)$拟合训练数据的平方损失误差是\n$$L(y,f_6(x)) = \\sum_{i=1}^{10}(y_i-f_6(x_i))^2 = 0.71$$\n假设此时已经满足误差要求，那么$f(x)=f_6(x)$即为所求的回归树。\n\n** 综可知平方差函数越来越小**\n\n# 分类树的生成\n- 输入：训练数据集$D$，停止计算的条件；\n- 输出：CART决策树。根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：\n 1. 设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A＝a$的测试为“是”或“否”将$D$分割成$D1$和$D2$两部分，利用式$Gini(D)=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2$计算$A＝a$时的基尼指数。\n 2. 在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。\n 3. 对两个子结点递归地调用以上两个步骤，直至满足停止条件。\n 4. 生成CART决策树。\n\n\n ## 基尼指数\n 分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为\n $$\\begin{align*}\n Gini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\n Gini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n \\end{align*}$$\n 如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为\n $$Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)$$\n 基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强\n\n## 计算实例\n![](回归树/回归树-d82a16be.png)\n分别以$A_1，A_2，A_3，A_4$表示年龄、有工作、有自己的房子和信贷情况4个特征，并以$1，2，3$表示年龄的值为青年、中年和老年，以$1，2$表示有工作和有自己的房子的值为是和否，以$1，2，3$表示信贷情况的值为非常好、好和一般。\n$$Gini( D,A_1=1 )=\\frac{5}{15}\\left ( \\frac{2}{5}(1-\\frac{2}{5})+\\frac{3}{5}(1-\\frac{3}{5}) \\right )+\\frac{10}{15}\\left ( \\frac{7}{10}(1-\\frac{7}{10})+\\frac{3}{10}(1-\\frac{3}{10}) \\right )$$\n![](回归树/回归树-eb149128.png)\n![](回归树/回归树-ce859c9e.png)\n![](回归树/回归树-ae6f77ba.png)\n在$A_1，A_2，A_3，A_4$几个特征中，$Gini(D，A_3＝1)＝0.27$最小，所以选择特征 $A_3$ 为最优特征，$A_3＝1$为其最优切分点。于是根结点生成两个子结点，一个是叶结点。对另一个结点继续使用以上方法在$A_1，A_2，A_4$中选择最优特征及其最优切分点，结果是 $A_2＝1$。依此计算得知，所得结点都是叶结点。\n\n# CART剪枝\n### CART决策树剪枝\nCART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：\n- 首先从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到T0的根结点，形成一个子树序列$\\{T_0，T_1,…,T_n\\}$；\n- 然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。\n\n那么问题来了，参数$α$给定的？谁来给？领域专家给？这是一种行之有效的办法，但却需要领域知识。理想化的模型都希望参数由data决定，也就是$α$也由数据决定。那么我们能想到的就是拿测试数据去测试在给定$α$下生成的子树。\n**ID3与C4.5使用的$α$由人为决定，CART的$α$有算法决定**下面主要介绍如何确定$α$\n\n#### $α$的算法\n剪枝过程中计算子树的损失函数\n$$C_{\\alpha}(T) = C(T)+\\alpha \\left | T \\right |$$\n\n其中，$T$为任意子树，$ C(T)$为对训练数据的预测误差（如基尼指数），$\\left | T \\right |$为子树的叶结点个数，$\\alpha \\geqslant 0$为参数，$C_\\alpha (T)$为参数是$\\alpha $时的子树$T$的整体损失，参数$\\alpha $权衡训练数据的拟合程度与模型的复杂度\n\n具体地，从整体树$T_0$开始剪枝，对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是\n\n$$C_{\\alpha}(t) = C(t)+\\alpha $$\n\n以$t$为为根结点的子树$T_t$为单结点树的损失函数是\n\n$$C_{\\alpha }(T_t) = C(T_t)+\\alpha \\left | T_t \\right |$$\n\n- 当$\\alpha =0$及$\\alpha $充分小时，有不等式\n\n$$C_\\alpha(T_t)<C_\\alpha(t)$$\n\n- 当$\\alpha $增大时，有某一$\\alpha $有\n\n$$C_\\alpha(T_t)=C_\\alpha(t)$$\n\n- 当$\\alpha $继续增大时\n\n$$C_\\alpha(T_t)>C_\\alpha(t)$$\n\n所以我们只要取$\\alpha_1 = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$时，当且仅当$α≥α_1$时，剪枝必然发生。$α$必须满足上述条件，否则前提假设将失去意义。所以说，我们通过假设剪枝必然发生就能找到对应的$α$\n\n这个 $α$ 的值有什么意义，刚才我们高能预警的地方，$0=\\alpha_0<\\alpha_1<...<\\alpha_n<+\\infty$ ，在每个区间 $[α_i,α_{i+1})$ 中，子树 $T_i$ 是这个区间里最优的。为什么呢？原因就在刚才的推导，对于当前这个结点，只要 $α$ 大于这个值时，一定有$C_{\\alpha}(t)<C_{\\alpha}(T_t)$ ，也就是剪掉这个结点后都比不剪要更优。所以每个最优子树对应的是一个区间，在这个区间内都是最优的。\n\n##### $g(t)$为什么是最小的\n$$g(t) = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$$\n\n![](回归树/回归树-23c9f784.png)\n\n当$α$较小时，结点不修剪的误差要小于修剪之后的误差，此时不剪为好，但当$α$增大时，修剪前后的误差先减小后增大，对应每个结点都有一个临界值 $g(t)$ 。\n为什么要选择最小的$ g(t)$ 呢？以图中两个点为例，结点1和结点2，$g(t)_2$ 大于$g(t)_1$, 假设在所有结点中$g(t)_1$最小，$g(t)_2$最大，两种选择方法：当选择最大值$g(t)_2$，即结点2进行剪枝，但此时结点1的不修剪的误差大于修剪之后的误差，即如果不修剪的话，误差变大，依次类推，对其它所有的结点的$g(t)$都是如此，从而造成整体的累计误差更大。反之，如果选择最小值$g(t)_1$，即结点1进行剪枝，则其余结点不剪的误差要小于剪后的误差，不修剪为好，且整体的误差最小。从而以最小$g(t)$剪枝获得的子树是该$α$值下的最优子树！\n\n\n### 剪枝流程\n![](回归树/回归树-7ea432c5.png)\n","slug":"回归树","published":1,"updated":"2019-07-30T01:54:38.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j04004ihomjrloyczew","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>决策树的生成就是递归地构建二叉决策树的过程。对回归树用<strong>平方误差最小化准则</strong>，对分类树用<strong>基尼指数（Gini index）</strong>最小化准则，进行特征选择，生成二叉树。CART算法有两步：<strong>决策树生成和剪枝。</strong><br><a id=\"more\"></a></p>\n<h1 id=\"回归树的生成\"><a href=\"#回归树的生成\" class=\"headerlink\" title=\"回归树的生成\"></a>回归树的生成</h1><p>一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c$,$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$</p>\n<ul>\n<li>输入：训练数据集$D{(x_1,y_1),…,(x_N,y_N)}$；</li>\n<li>输出：回归树$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$<br>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树<ol>\n<li>当输入空间的划分确定时，可以用平方误差$\\sum _{x_i\\in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，选择最优切分变量$j$与切分点$s$，使得预测误差最小，求解<script type=\"math/tex; mode=display\">\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2]</script></li>\n<li>用选定的对$（j,s）$划分区域并决定相应的输出值：<script type=\"math/tex; mode=display\">R_1(j,s)=\\{x|x^{(j)}\\leqslant s\\},R_1(j,s)=\\{x|x^{(j)}> s\\}\\\\\n\\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i \\in R_m(j,s)}y_i ,\\; \\; x\\in R_m ,\\, \\, m=1,2</script></li>\n<li>继续对两个子区域调用以上两个步骤，直至满足停止条件。</li>\n<li>将输入空间划分为$M$个区域$R_1,R_2,…R_m$，生成决策树<script type=\"math/tex; mode=display\">f(x)=\\sum _{m=1}^M\\hat{c}_mI(x \\in R_m)</script></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"计算实例\"><a href=\"#计算实例\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h2><p>训练数据见下表，x的取值范围为区间[0.5,10.5],y的取值范围为区间[5.0,10.0],学习这个回归问题的最小二叉回归树</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"根结点-T-1-x\"><a href=\"#根结点-T-1-x\" class=\"headerlink\" title=\"根结点$T_1(x)$\"></a>根结点$T_1(x)$</h3><p>求训练数据的切分点，根据所给数据，求取使得预测误差最小的切分点：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n<tr>\n<td>切分点</td>\n<td>1.5</td>\n<td>2.5</td>\n<td>3.5</td>\n<td>4.5</td>\n<td>5.5</td>\n<td>6.5</td>\n<td>7.5</td>\n<td>8.5</td>\n<td>9.5</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>例如当 $s=1.5$ 时，$R_1 = \\lbrace 1\\rbrace$ , $R_2 = \\lbrace 2, 3 , \\ldots , 10\\rbrace$ , $c_1=5.56$ , $c_2=7.50$ ,</p>\n<script type=\"math/tex; mode=display\">m(s)=\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2] = 0+15.72 = 15.72</script><p>由上表可知，当$x=6.5$的时候达到最小值，此时$R_1 = \\lbrace 1 ,2 , \\ldots , 6\\rbrace$ , $R_2 = \\lbrace 7 ,8 ,9 ,10 ,\\rbrace$ , $c_1=6.24$ , $c_2=8.9$ , 所以回归树$T_1(x)$为：</p>\n<script type=\"math/tex; mode=display\">T_1(x) =\n\\begin{cases}\n6.24, & x\\lt 6.5 \\\\\n8.91, & x \\ge 6.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_1(x) = T_1(x)</script></li>\n<li><p>用$f_1(x)$拟合训练数据的平方误差：</p>\n<script type=\"math/tex; mode=display\">L(y,f_1(x)) = \\sum_{i=1}^{10}(y_i-f_1(x_i))^2 = 1.93</script></li>\n</ul>\n<h3 id=\"次结点-T-2-x\"><a href=\"#次结点-T-2-x\" class=\"headerlink\" title=\"次结点$T_2(x)$\"></a>次结点$T_2(x)$</h3><p>用$f_1(x)$拟合训练数据的残差见下表，表中$r_{2i} = y_i - f_1(x_i),i=1,2,\\ldots , 10$</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n<tr>\n<td>$r_{2i}$</td>\n<td>-0.68</td>\n<td>-0.54</td>\n<td>-0.33</td>\n<td>0.16</td>\n<td>0.56</td>\n<td>0.81</td>\n<td>-0.01</td>\n<td>-0.21</td>\n<td>0.09</td>\n<td>0.14</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>求$T_2(x)$.方法与求$T_1(x)$一样，只是拟合的数据是上表的残差，可以得到</p>\n<script type=\"math/tex; mode=display\">T_2(x) =\n\\begin{cases}\n-0.52, & x\\lt 3.5 \\\\\n0.22, & x \\ge 3.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_2(x) = f_1(x) + T_2(x)=\n\\begin{cases}\n5.72, & x\\lt 3.5 \\\\\n6.46, & 3.5\\le x \\lt 6.5 \\\\\n9.13, & x\\ge 6.5 \\\\\n\\end{cases}</script><ul>\n<li>用$f_2(x)$拟合训练数据的平方误差是：<script type=\"math/tex; mode=display\">L(y,f_2(x)) = \\sum_{i=1}^{10}(y_i-f_2(x_i))^2 = 0.79</script></li>\n</ul>\n<h3 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h3><p>继续求得</p>\n<script type=\"math/tex; mode=display\">T_3(x) =\n\\begin{cases}\n0.15, & x\\lt 6.5 \\\\\n-0.22, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.47 ,</script><script type=\"math/tex; mode=display\">T_4(x) =\n\\begin{cases}\n-0.16, & x\\lt 4.5 \\\\\n0.11, & x \\ge 4.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.30 ,</script><script type=\"math/tex; mode=display\">T_5(x) =\n\\begin{cases}\n0.07, & x\\lt 6.5 \\\\\n-0.11, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.23 ,</script><script type=\"math/tex; mode=display\">T_6(x) =\n\\begin{cases}\n-0.15, & x\\lt 2.5 \\\\\n0.04, & x \\ge 2.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_6(x) = f_5(x)+T_6(x) =T_1(x)+ \\ldots + T_5(x) + T_6(x)=\n\\begin{cases}\n5.63, & x\\lt 2.5 \\\\\n5.82, & 2.5 \\le x\\lt 3.5 \\\\\n6.56, & 3.5 \\le x\\lt 4.5 \\\\\n6.83, & 4.5 \\le x\\lt 6.5 \\\\\n8.95, & x\\ge 6.5 \\\\\n\\end{cases}</script><ul>\n<li>用$f_6(x)$拟合训练数据的平方损失误差是<script type=\"math/tex; mode=display\">L(y,f_6(x)) = \\sum_{i=1}^{10}(y_i-f_6(x_i))^2 = 0.71</script>假设此时已经满足误差要求，那么$f(x)=f_6(x)$即为所求的回归树。</li>\n</ul>\n<p><strong> 综可知平方差函数越来越小</strong></p>\n<h1 id=\"分类树的生成\"><a href=\"#分类树的生成\" class=\"headerlink\" title=\"分类树的生成\"></a>分类树的生成</h1><ul>\n<li>输入：训练数据集$D$，停止计算的条件；</li>\n<li>输出：CART决策树。根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：<ol>\n<li>设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A＝a$的测试为“是”或“否”将$D$分割成$D1$和$D2$两部分，利用式$Gini(D)=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2$计算$A＝a$时的基尼指数。</li>\n<li>在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</li>\n<li>对两个子结点递归地调用以上两个步骤，直至满足停止条件。</li>\n<li>生成CART决策树。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h2><p> 分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n Gini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\n Gini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n \\end{align*}</script><p> 如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)</script><p> 基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强</p>\n<h2 id=\"计算实例-1\"><a href=\"#计算实例-1\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h2><p><img src=\"/2017/07/21/回归树/回归树-d82a16be.png\" alt=\"\"><br>分别以$A_1，A_2，A_3，A_4$表示年龄、有工作、有自己的房子和信贷情况4个特征，并以$1，2，3$表示年龄的值为青年、中年和老年，以$1，2$表示有工作和有自己的房子的值为是和否，以$1，2，3$表示信贷情况的值为非常好、好和一般。</p>\n<script type=\"math/tex; mode=display\">Gini( D,A_1=1 )=\\frac{5}{15}\\left ( \\frac{2}{5}(1-\\frac{2}{5})+\\frac{3}{5}(1-\\frac{3}{5}) \\right )+\\frac{10}{15}\\left ( \\frac{7}{10}(1-\\frac{7}{10})+\\frac{3}{10}(1-\\frac{3}{10}) \\right )</script><p><img src=\"/2017/07/21/回归树/回归树-eb149128.png\" alt=\"\"><br><img src=\"/2017/07/21/回归树/回归树-ce859c9e.png\" alt=\"\"><br><img src=\"/2017/07/21/回归树/回归树-ae6f77ba.png\" alt=\"\"><br>在$A_1，A_2，A_3，A_4$几个特征中，$Gini(D，A_3＝1)＝0.27$最小，所以选择特征 $A_3$ 为最优特征，$A_3＝1$为其最优切分点。于是根结点生成两个子结点，一个是叶结点。对另一个结点继续使用以上方法在$A_1，A_2，A_4$中选择最优特征及其最优切分点，结果是 $A_2＝1$。依此计算得知，所得结点都是叶结点。</p>\n<h1 id=\"CART剪枝\"><a href=\"#CART剪枝\" class=\"headerlink\" title=\"CART剪枝\"></a>CART剪枝</h1><h3 id=\"CART决策树剪枝\"><a href=\"#CART决策树剪枝\" class=\"headerlink\" title=\"CART决策树剪枝\"></a>CART决策树剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：</p>\n<ul>\n<li>首先从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到T0的根结点，形成一个子树序列$\\{T_0，T_1,…,T_n\\}$；</li>\n<li>然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</li>\n</ul>\n<p>那么问题来了，参数$α$给定的？谁来给？领域专家给？这是一种行之有效的办法，但却需要领域知识。理想化的模型都希望参数由data决定，也就是$α$也由数据决定。那么我们能想到的就是拿测试数据去测试在给定$α$下生成的子树。<br><strong>ID3与C4.5使用的$α$由人为决定，CART的$α$有算法决定</strong>下面主要介绍如何确定$α$</p>\n<h4 id=\"α-的算法\"><a href=\"#α-的算法\" class=\"headerlink\" title=\"$α$的算法\"></a>$α$的算法</h4><p>剪枝过程中计算子树的损失函数</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha}(T) = C(T)+\\alpha \\left | T \\right |</script><p>其中，$T$为任意子树，$ C(T)$为对训练数据的预测误差（如基尼指数），$\\left | T \\right |$为子树的叶结点个数，$\\alpha \\geqslant 0$为参数，$C_\\alpha (T)$为参数是$\\alpha $时的子树$T$的整体损失，参数$\\alpha $权衡训练数据的拟合程度与模型的复杂度</p>\n<p>具体地，从整体树$T_0$开始剪枝，对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha}(t) = C(t)+\\alpha</script><p>以$t$为为根结点的子树$T_t$为单结点树的损失函数是</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha }(T_t) = C(T_t)+\\alpha \\left | T_t \\right |</script><ul>\n<li>当$\\alpha =0$及$\\alpha $充分小时，有不等式</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)<C_\\alpha(t)</script><ul>\n<li>当$\\alpha $增大时，有某一$\\alpha $有</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)=C_\\alpha(t)</script><ul>\n<li>当$\\alpha $继续增大时</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)>C_\\alpha(t)</script><p>所以我们只要取$\\alpha_1 = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$时，当且仅当$α≥α_1$时，剪枝必然发生。$α$必须满足上述条件，否则前提假设将失去意义。所以说，我们通过假设剪枝必然发生就能找到对应的$α$</p>\n<p>这个 $α$ 的值有什么意义，刚才我们高能预警的地方，$0=\\alpha_0&lt;\\alpha_1&lt;…&lt;\\alpha_n&lt;+\\infty$ ，在每个区间 $[α_i,α_{i+1})$ 中，子树 $T_i$ 是这个区间里最优的。为什么呢？原因就在刚才的推导，对于当前这个结点，只要 $α$ 大于这个值时，一定有$C_{\\alpha}(t)&lt;C_{\\alpha}(T_t)$ ，也就是剪掉这个结点后都比不剪要更优。所以每个最优子树对应的是一个区间，在这个区间内都是最优的。</p>\n<h5 id=\"g-t-为什么是最小的\"><a href=\"#g-t-为什么是最小的\" class=\"headerlink\" title=\"$g(t)$为什么是最小的\"></a>$g(t)$为什么是最小的</h5><script type=\"math/tex; mode=display\">g(t) = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}</script><p><img src=\"/2017/07/21/回归树/回归树-23c9f784.png\" alt=\"\"></p>\n<p>当$α$较小时，结点不修剪的误差要小于修剪之后的误差，此时不剪为好，但当$α$增大时，修剪前后的误差先减小后增大，对应每个结点都有一个临界值 $g(t)$ 。<br>为什么要选择最小的$ g(t)$ 呢？以图中两个点为例，结点1和结点2，$g(t)_2$ 大于$g(t)_1$, 假设在所有结点中$g(t)_1$最小，$g(t)_2$最大，两种选择方法：当选择最大值$g(t)_2$，即结点2进行剪枝，但此时结点1的不修剪的误差大于修剪之后的误差，即如果不修剪的话，误差变大，依次类推，对其它所有的结点的$g(t)$都是如此，从而造成整体的累计误差更大。反之，如果选择最小值$g(t)_1$，即结点1进行剪枝，则其余结点不剪的误差要小于剪后的误差，不修剪为好，且整体的误差最小。从而以最小$g(t)$剪枝获得的子树是该$α$值下的最优子树！</p>\n<h3 id=\"剪枝流程\"><a href=\"#剪枝流程\" class=\"headerlink\" title=\"剪枝流程\"></a>剪枝流程</h3><p><img src=\"/2017/07/21/回归树/回归树-7ea432c5.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>决策树的生成就是递归地构建二叉决策树的过程。对回归树用<strong>平方误差最小化准则</strong>，对分类树用<strong>基尼指数（Gini index）</strong>最小化准则，进行特征选择，生成二叉树。CART算法有两步：<strong>决策树生成和剪枝。</strong><br></p>","more":"<p></p>\n<h1 id=\"回归树的生成\"><a href=\"#回归树的生成\" class=\"headerlink\" title=\"回归树的生成\"></a>回归树的生成</h1><p>一个回归树对应着输入空间（即特征空间）的一个划分以及在划分的单元上的输出值。假设已将输入空间划分为$M$个单元$R_1,R_2,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c$,$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$</p>\n<ul>\n<li>输入：训练数据集$D{(x_1,y_1),…,(x_N,y_N)}$；</li>\n<li>输出：回归树$f(x)=\\sum _{i=1}^M c_mI(x \\in R_m)$<br>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树<ol>\n<li>当输入空间的划分确定时，可以用平方误差$\\sum _{x_i\\in R_m}(y_i-f(x_i))^2$来表示回归树对于训练数据的预测误差，选择最优切分变量$j$与切分点$s$，使得预测误差最小，求解<script type=\"math/tex; mode=display\">\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2]</script></li>\n<li>用选定的对$（j,s）$划分区域并决定相应的输出值：<script type=\"math/tex; mode=display\">R_1(j,s)=\\{x|x^{(j)}\\leqslant s\\},R_1(j,s)=\\{x|x^{(j)}> s\\}\\\\\n\\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i \\in R_m(j,s)}y_i ,\\; \\; x\\in R_m ,\\, \\, m=1,2</script></li>\n<li>继续对两个子区域调用以上两个步骤，直至满足停止条件。</li>\n<li>将输入空间划分为$M$个区域$R_1,R_2,…R_m$，生成决策树<script type=\"math/tex; mode=display\">f(x)=\\sum _{m=1}^M\\hat{c}_mI(x \\in R_m)</script></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"计算实例\"><a href=\"#计算实例\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h2><p>训练数据见下表，x的取值范围为区间[0.5,10.5],y的取值范围为区间[5.0,10.0],学习这个回归问题的最小二叉回归树</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"根结点-T-1-x\"><a href=\"#根结点-T-1-x\" class=\"headerlink\" title=\"根结点$T_1(x)$\"></a>根结点$T_1(x)$</h3><p>求训练数据的切分点，根据所给数据，求取使得预测误差最小的切分点：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n<tr>\n<td>切分点</td>\n<td>1.5</td>\n<td>2.5</td>\n<td>3.5</td>\n<td>4.5</td>\n<td>5.5</td>\n<td>6.5</td>\n<td>7.5</td>\n<td>8.5</td>\n<td>9.5</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>例如当 $s=1.5$ 时，$R_1 = \\lbrace 1\\rbrace$ , $R_2 = \\lbrace 2, 3 , \\ldots , 10\\rbrace$ , $c_1=5.56$ , $c_2=7.50$ ,</p>\n<script type=\"math/tex; mode=display\">m(s)=\\min_{j,s}[\\min_{c_1} \\sum_{x_i\\in R_1(j,s)}(y_i-c_1)^2 + \\min_{c_2} \\sum_{x_i\\in R_2(j,s)}(y_i-c_2)^2] = 0+15.72 = 15.72</script><p>由上表可知，当$x=6.5$的时候达到最小值，此时$R_1 = \\lbrace 1 ,2 , \\ldots , 6\\rbrace$ , $R_2 = \\lbrace 7 ,8 ,9 ,10 ,\\rbrace$ , $c_1=6.24$ , $c_2=8.9$ , 所以回归树$T_1(x)$为：</p>\n<script type=\"math/tex; mode=display\">T_1(x) =\n\\begin{cases}\n6.24, & x\\lt 6.5 \\\\\n8.91, & x \\ge 6.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_1(x) = T_1(x)</script></li>\n<li><p>用$f_1(x)$拟合训练数据的平方误差：</p>\n<script type=\"math/tex; mode=display\">L(y,f_1(x)) = \\sum_{i=1}^{10}(y_i-f_1(x_i))^2 = 1.93</script></li>\n</ul>\n<h3 id=\"次结点-T-2-x\"><a href=\"#次结点-T-2-x\" class=\"headerlink\" title=\"次结点$T_2(x)$\"></a>次结点$T_2(x)$</h3><p>用$f_1(x)$拟合训练数据的残差见下表，表中$r_{2i} = y_i - f_1(x_i),i=1,2,\\ldots , 10$</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$x_i$</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$y_i$</td>\n<td>5.56</td>\n<td>5.70</td>\n<td>5.91</td>\n<td>6.40</td>\n<td>6.80</td>\n<td>7.05</td>\n<td>8.90</td>\n<td>8.70</td>\n<td>9.00</td>\n<td>9.05</td>\n</tr>\n<tr>\n<td>$r_{2i}$</td>\n<td>-0.68</td>\n<td>-0.54</td>\n<td>-0.33</td>\n<td>0.16</td>\n<td>0.56</td>\n<td>0.81</td>\n<td>-0.01</td>\n<td>-0.21</td>\n<td>0.09</td>\n<td>0.14</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>求$T_2(x)$.方法与求$T_1(x)$一样，只是拟合的数据是上表的残差，可以得到</p>\n<script type=\"math/tex; mode=display\">T_2(x) =\n\\begin{cases}\n-0.52, & x\\lt 3.5 \\\\\n0.22, & x \\ge 3.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_2(x) = f_1(x) + T_2(x)=\n\\begin{cases}\n5.72, & x\\lt 3.5 \\\\\n6.46, & 3.5\\le x \\lt 6.5 \\\\\n9.13, & x\\ge 6.5 \\\\\n\\end{cases}</script><ul>\n<li>用$f_2(x)$拟合训练数据的平方误差是：<script type=\"math/tex; mode=display\">L(y,f_2(x)) = \\sum_{i=1}^{10}(y_i-f_2(x_i))^2 = 0.79</script></li>\n</ul>\n<h3 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h3><p>继续求得</p>\n<script type=\"math/tex; mode=display\">T_3(x) =\n\\begin{cases}\n0.15, & x\\lt 6.5 \\\\\n-0.22, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.47 ,</script><script type=\"math/tex; mode=display\">T_4(x) =\n\\begin{cases}\n-0.16, & x\\lt 4.5 \\\\\n0.11, & x \\ge 4.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.30 ,</script><script type=\"math/tex; mode=display\">T_5(x) =\n\\begin{cases}\n0.07, & x\\lt 6.5 \\\\\n-0.11, & x \\ge 6.5 \\\\\n\\end{cases}\n\\quad L(y,f_3(x)) = 0.23 ,</script><script type=\"math/tex; mode=display\">T_6(x) =\n\\begin{cases}\n-0.15, & x\\lt 2.5 \\\\\n0.04, & x \\ge 2.5 \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">f_6(x) = f_5(x)+T_6(x) =T_1(x)+ \\ldots + T_5(x) + T_6(x)=\n\\begin{cases}\n5.63, & x\\lt 2.5 \\\\\n5.82, & 2.5 \\le x\\lt 3.5 \\\\\n6.56, & 3.5 \\le x\\lt 4.5 \\\\\n6.83, & 4.5 \\le x\\lt 6.5 \\\\\n8.95, & x\\ge 6.5 \\\\\n\\end{cases}</script><ul>\n<li>用$f_6(x)$拟合训练数据的平方损失误差是<script type=\"math/tex; mode=display\">L(y,f_6(x)) = \\sum_{i=1}^{10}(y_i-f_6(x_i))^2 = 0.71</script>假设此时已经满足误差要求，那么$f(x)=f_6(x)$即为所求的回归树。</li>\n</ul>\n<p><strong> 综可知平方差函数越来越小</strong></p>\n<h1 id=\"分类树的生成\"><a href=\"#分类树的生成\" class=\"headerlink\" title=\"分类树的生成\"></a>分类树的生成</h1><ul>\n<li>输入：训练数据集$D$，停止计算的条件；</li>\n<li>输出：CART决策树。根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树：<ol>\n<li>设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征$A$，对其可能取的每个值$a$，根据样本点对$A＝a$的测试为“是”或“否”将$D$分割成$D1$和$D2$两部分，利用式$Gini(D)=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2$计算$A＝a$时的基尼指数。</li>\n<li>在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</li>\n<li>对两个子结点递归地调用以上两个步骤，直至满足停止条件。</li>\n<li>生成CART决策树。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"基尼指数\"><a href=\"#基尼指数\" class=\"headerlink\" title=\"基尼指数\"></a>基尼指数</h2><p> 分类问题中，假设有 $K$ 个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n Gini(p)&=\\sum_{k=1}^{K}p_k(1-p_k)=1-\\sum_{k=1}^{K}p_k^2\\\\\n Gini(D)&=1-\\sum_{k=1}^{K}\\left ( \\frac{|c_k|}{D} \\right )^2\n \\end{align*}</script><p> 如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为</p>\n<script type=\"math/tex; mode=display\">Gini(D,A)=\\frac{|D_1|}{D}Gini(D_1)+\\frac{|D_2|}{D}Gini(D_2)</script><p> 基尼指数 $Gini(D,A)$ 表示集合 $D$ 的不确定性，基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。基尼指数值越大，样本集合的不确定性也就越强</p>\n<h2 id=\"计算实例-1\"><a href=\"#计算实例-1\" class=\"headerlink\" title=\"计算实例\"></a>计算实例</h2><p><img src=\"/2017/07/21/回归树/回归树-d82a16be.png\" alt=\"\"><br>分别以$A_1，A_2，A_3，A_4$表示年龄、有工作、有自己的房子和信贷情况4个特征，并以$1，2，3$表示年龄的值为青年、中年和老年，以$1，2$表示有工作和有自己的房子的值为是和否，以$1，2，3$表示信贷情况的值为非常好、好和一般。</p>\n<script type=\"math/tex; mode=display\">Gini( D,A_1=1 )=\\frac{5}{15}\\left ( \\frac{2}{5}(1-\\frac{2}{5})+\\frac{3}{5}(1-\\frac{3}{5}) \\right )+\\frac{10}{15}\\left ( \\frac{7}{10}(1-\\frac{7}{10})+\\frac{3}{10}(1-\\frac{3}{10}) \\right )</script><p><img src=\"/2017/07/21/回归树/回归树-eb149128.png\" alt=\"\"><br><img src=\"/2017/07/21/回归树/回归树-ce859c9e.png\" alt=\"\"><br><img src=\"/2017/07/21/回归树/回归树-ae6f77ba.png\" alt=\"\"><br>在$A_1，A_2，A_3，A_4$几个特征中，$Gini(D，A_3＝1)＝0.27$最小，所以选择特征 $A_3$ 为最优特征，$A_3＝1$为其最优切分点。于是根结点生成两个子结点，一个是叶结点。对另一个结点继续使用以上方法在$A_1，A_2，A_4$中选择最优特征及其最优切分点，结果是 $A_2＝1$。依此计算得知，所得结点都是叶结点。</p>\n<h1 id=\"CART剪枝\"><a href=\"#CART剪枝\" class=\"headerlink\" title=\"CART剪枝\"></a>CART剪枝</h1><h3 id=\"CART决策树剪枝\"><a href=\"#CART决策树剪枝\" class=\"headerlink\" title=\"CART决策树剪枝\"></a>CART决策树剪枝</h3><p>CART剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。CART剪枝算法由两步组成：</p>\n<ul>\n<li>首先从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到T0的根结点，形成一个子树序列$\\{T_0，T_1,…,T_n\\}$；</li>\n<li>然后通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树。</li>\n</ul>\n<p>那么问题来了，参数$α$给定的？谁来给？领域专家给？这是一种行之有效的办法，但却需要领域知识。理想化的模型都希望参数由data决定，也就是$α$也由数据决定。那么我们能想到的就是拿测试数据去测试在给定$α$下生成的子树。<br><strong>ID3与C4.5使用的$α$由人为决定，CART的$α$有算法决定</strong>下面主要介绍如何确定$α$</p>\n<h4 id=\"α-的算法\"><a href=\"#α-的算法\" class=\"headerlink\" title=\"$α$的算法\"></a>$α$的算法</h4><p>剪枝过程中计算子树的损失函数</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha}(T) = C(T)+\\alpha \\left | T \\right |</script><p>其中，$T$为任意子树，$ C(T)$为对训练数据的预测误差（如基尼指数），$\\left | T \\right |$为子树的叶结点个数，$\\alpha \\geqslant 0$为参数，$C_\\alpha (T)$为参数是$\\alpha $时的子树$T$的整体损失，参数$\\alpha $权衡训练数据的拟合程度与模型的复杂度</p>\n<p>具体地，从整体树$T_0$开始剪枝，对$T_0$的任意内部结点$t$，以$t$为单结点树的损失函数是</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha}(t) = C(t)+\\alpha</script><p>以$t$为为根结点的子树$T_t$为单结点树的损失函数是</p>\n<script type=\"math/tex; mode=display\">C_{\\alpha }(T_t) = C(T_t)+\\alpha \\left | T_t \\right |</script><ul>\n<li>当$\\alpha =0$及$\\alpha $充分小时，有不等式</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)<C_\\alpha(t)</script><ul>\n<li>当$\\alpha $增大时，有某一$\\alpha $有</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)=C_\\alpha(t)</script><ul>\n<li>当$\\alpha $继续增大时</li>\n</ul>\n<script type=\"math/tex; mode=display\">C_\\alpha(T_t)>C_\\alpha(t)</script><p>所以我们只要取$\\alpha_1 = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}$时，当且仅当$α≥α_1$时，剪枝必然发生。$α$必须满足上述条件，否则前提假设将失去意义。所以说，我们通过假设剪枝必然发生就能找到对应的$α$</p>\n<p>这个 $α$ 的值有什么意义，刚才我们高能预警的地方，$0=\\alpha_0&lt;\\alpha_1&lt;…&lt;\\alpha_n&lt;+\\infty$ ，在每个区间 $[α_i,α_{i+1})$ 中，子树 $T_i$ 是这个区间里最优的。为什么呢？原因就在刚才的推导，对于当前这个结点，只要 $α$ 大于这个值时，一定有$C_{\\alpha}(t)&lt;C_{\\alpha}(T_t)$ ，也就是剪掉这个结点后都比不剪要更优。所以每个最优子树对应的是一个区间，在这个区间内都是最优的。</p>\n<h5 id=\"g-t-为什么是最小的\"><a href=\"#g-t-为什么是最小的\" class=\"headerlink\" title=\"$g(t)$为什么是最小的\"></a>$g(t)$为什么是最小的</h5><script type=\"math/tex; mode=display\">g(t) = \\frac{C(t)-C(T_t)}{\\vert T_t\\vert-1}</script><p><img src=\"/2017/07/21/回归树/回归树-23c9f784.png\" alt=\"\"></p>\n<p>当$α$较小时，结点不修剪的误差要小于修剪之后的误差，此时不剪为好，但当$α$增大时，修剪前后的误差先减小后增大，对应每个结点都有一个临界值 $g(t)$ 。<br>为什么要选择最小的$ g(t)$ 呢？以图中两个点为例，结点1和结点2，$g(t)_2$ 大于$g(t)_1$, 假设在所有结点中$g(t)_1$最小，$g(t)_2$最大，两种选择方法：当选择最大值$g(t)_2$，即结点2进行剪枝，但此时结点1的不修剪的误差大于修剪之后的误差，即如果不修剪的话，误差变大，依次类推，对其它所有的结点的$g(t)$都是如此，从而造成整体的累计误差更大。反之，如果选择最小值$g(t)_1$，即结点1进行剪枝，则其余结点不剪的误差要小于剪后的误差，不修剪为好，且整体的误差最小。从而以最小$g(t)$剪枝获得的子树是该$α$值下的最优子树！</p>\n<h3 id=\"剪枝流程\"><a href=\"#剪枝流程\" class=\"headerlink\" title=\"剪枝流程\"></a>剪枝流程</h3><p><img src=\"/2017/07/21/回归树/回归树-7ea432c5.png\" alt=\"\"></p>"},{"title":"常见分布","date":"2017-08-15T11:37:33.000Z","_content":"\n\n本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。三大抽样分布\n<!--more-->\n\n# 离散型随机变量的分布\n## 伯努利分布\n伯努利分布又名**两点分布**或者**0-1分布**，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为\n$$P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)$$\n如果试验E只有两种结果，则称试验E为**伯努利试验**。如果独立的进行 n 次试验E，则称为**n重伯努利试验**。\n\n## 二项分布\n以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：\n\n$$P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n$$\n其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。\n\n## 泊松分布\n随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为\n\n$$P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….$$\n则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$\n其分布规律通过图像直观表示为\n\n![](常见分布/常见分布-42feaec2.png)\n\n泊松分布适合于描述**单位时间内随机事件发生的次数的概率分布**。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。\n\n下面介绍用**泊松分布来逼近二项分布的定理，也就是泊松定理**。\n\n泊松定理：设 $λ>0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有\n$$\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}$$\n即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。\n\n# 连续型随机变量的分布\n\n## 均匀分布\n若随机变量 $X$ 的概率密度函数为\n$$f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}$$\n则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$\n## 指数分布\n若随机变量 $X$ 的概率密度函数为\n\n$$f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n则称 $X$ 服从参数为 $θ$ 的指数分布。\n\n其图像如下所示:\n\n![](常见分布/一维随机变量-e5379494.png)\n\n其分布函数为\n$$F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里\n\n关于指数分布的一个有趣的性质为：\n\n$$P(X>s+t | X>s) = P(X>t)$$\n该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。\n\n## 正态分布\n正态分布也叫高斯分布，其概率密度函数为\n\n$$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$\n则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示\n\n![](常见分布/一维随机变量-a7f11452.png)\n\n从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望\n\n# 抽样分布\n## 统计量\n样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是**针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。**\n\n当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。\n\n样本平均值：\n$$\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i$$\n样本方差：\n$$S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2$$\n样本标准差：\n$$S = \\sqrt {S^2}$$\n样本 k 阶原点矩：\n$$A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)$$\n样本 k 阶中心矩:\n$$B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)$$\n这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）\n\n![](常见分布/样本以及抽样分布-7688d0c8.png)\n\n## 统计量的分布\n使用统计量进行统计推断时，常常需要知道其分布，**统计量的分布也称为抽样分布**，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。\n\n### $χ^2$ 分布\n$χ^2$ 分布的定义如下\n\n设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量\n$$\\chi^2 = X_1^2 + X_2^2 +….X_n^2$$\n为服从自由度为 $n$ 的 $χ^2$ 分布\n\n上面的自由度指的是右端独立变量的个数。\n\n$χ^2(n)$ 的概率密度函数为\n\n$$f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n上式的 $Γ$ 函数定义为\n\n$$\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt$$\n\n$f(y)$ 的图像如下所示\n\n![卡方分布的概率密度函数](常见分布/样本以及抽样分布-bc11bcfe.png)\n\n\n关于 $χ^2(n)$ 有以下几个有用的结论：\n\n- 可加性\n设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有\n$$\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)$$\n- 期望和方差\n若$\\chi^2(n)$，则χ2的期望和方差如下所示\n$$E(\\chi^2) = n, D(\\chi^2)=2n$$\n- 分位点\n分位点的定义如下，给定正数 $a,0<a<1$, 称满足下面条件\n\n$$P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a$$\n\n的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示\n\n![](常见分布/样本以及抽样分布-3e85fbb1.png)\n\n由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。\n\n### $t$ 分布\nt分布的定义如下：\n\n设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量\n$$t = \\frac{X}{\\sqrt{Y/n}}$$\n服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$\n其概率密度函数和对应的图像如下所示：\n![t分布的概率密度函数和图像](常见分布/样本以及抽样分布-80c1cca7.png)\n\n\n其分位点的定义与上面讲述的一样，\n\n$$P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a$$\n\n![](常见分布/样本以及抽样分布-79d1c781.png)\n\n且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$\n### $F$ 分布\n$F$ 分布的定义如下\n\n设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量\n$$F = \\frac{U/n_1}{V/n_2}$$\n服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$\n其概率密度函数为：\n\n$$\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n概率密度函数的图像如下所示\n![F分布的概率密度函数](常见分布/样本以及抽样分布-35e6599e.png)\n\n\n其分位点定义同上\n$$P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a$$\n\n![F分布的分为点](常见分布/样本以及抽样分布-0a6c68e5.png)\n\n且具有以下性质\n\n$$F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}$$\n\n上面只是简单地介绍了三大抽样分布，并未介绍其作用，**实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用**。更详细的作用会在区间估计中进一步体现。\n","source":"_posts/常见分布.md","raw":"---\ntitle: 常见分布\ndate: 2017-08-15 19:37:33\ntags: [人工智能,概率,分布,统计]\ncategories: 数学\n---\n\n\n本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。三大抽样分布\n<!--more-->\n\n# 离散型随机变量的分布\n## 伯努利分布\n伯努利分布又名**两点分布**或者**0-1分布**，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为\n$$P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)$$\n如果试验E只有两种结果，则称试验E为**伯努利试验**。如果独立的进行 n 次试验E，则称为**n重伯努利试验**。\n\n## 二项分布\n以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：\n\n$$P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n$$\n其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。\n\n## 泊松分布\n随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为\n\n$$P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….$$\n则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$\n其分布规律通过图像直观表示为\n\n![](常见分布/常见分布-42feaec2.png)\n\n泊松分布适合于描述**单位时间内随机事件发生的次数的概率分布**。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。\n\n下面介绍用**泊松分布来逼近二项分布的定理，也就是泊松定理**。\n\n泊松定理：设 $λ>0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有\n$$\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}$$\n即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。\n\n# 连续型随机变量的分布\n\n## 均匀分布\n若随机变量 $X$ 的概率密度函数为\n$$f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}$$\n则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$\n## 指数分布\n若随机变量 $X$ 的概率密度函数为\n\n$$f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n则称 $X$ 服从参数为 $θ$ 的指数分布。\n\n其图像如下所示:\n\n![](常见分布/一维随机变量-e5379494.png)\n\n其分布函数为\n$$F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}$$\n如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里\n\n关于指数分布的一个有趣的性质为：\n\n$$P(X>s+t | X>s) = P(X>t)$$\n该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。\n\n## 正态分布\n正态分布也叫高斯分布，其概率密度函数为\n\n$$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$\n则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示\n\n![](常见分布/一维随机变量-a7f11452.png)\n\n从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望\n\n# 抽样分布\n## 统计量\n样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是**针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。**\n\n当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。\n\n样本平均值：\n$$\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i$$\n样本方差：\n$$S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2$$\n样本标准差：\n$$S = \\sqrt {S^2}$$\n样本 k 阶原点矩：\n$$A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)$$\n样本 k 阶中心矩:\n$$B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)$$\n这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）\n\n![](常见分布/样本以及抽样分布-7688d0c8.png)\n\n## 统计量的分布\n使用统计量进行统计推断时，常常需要知道其分布，**统计量的分布也称为抽样分布**，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。\n\n### $χ^2$ 分布\n$χ^2$ 分布的定义如下\n\n设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量\n$$\\chi^2 = X_1^2 + X_2^2 +….X_n^2$$\n为服从自由度为 $n$ 的 $χ^2$ 分布\n\n上面的自由度指的是右端独立变量的个数。\n\n$χ^2(n)$ 的概率密度函数为\n\n$$f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n上式的 $Γ$ 函数定义为\n\n$$\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt$$\n\n$f(y)$ 的图像如下所示\n\n![卡方分布的概率密度函数](常见分布/样本以及抽样分布-bc11bcfe.png)\n\n\n关于 $χ^2(n)$ 有以下几个有用的结论：\n\n- 可加性\n设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有\n$$\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)$$\n- 期望和方差\n若$\\chi^2(n)$，则χ2的期望和方差如下所示\n$$E(\\chi^2) = n, D(\\chi^2)=2n$$\n- 分位点\n分位点的定义如下，给定正数 $a,0<a<1$, 称满足下面条件\n\n$$P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a$$\n\n的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示\n\n![](常见分布/样本以及抽样分布-3e85fbb1.png)\n\n由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。\n\n### $t$ 分布\nt分布的定义如下：\n\n设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量\n$$t = \\frac{X}{\\sqrt{Y/n}}$$\n服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$\n其概率密度函数和对应的图像如下所示：\n![t分布的概率密度函数和图像](常见分布/样本以及抽样分布-80c1cca7.png)\n\n\n其分位点的定义与上面讲述的一样，\n\n$$P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a$$\n\n![](常见分布/样本以及抽样分布-79d1c781.png)\n\n且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$\n### $F$ 分布\n$F$ 分布的定义如下\n\n设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量\n$$F = \\frac{U/n_1}{V/n_2}$$\n服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$\n其概率密度函数为：\n\n$$\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n概率密度函数的图像如下所示\n![F分布的概率密度函数](常见分布/样本以及抽样分布-35e6599e.png)\n\n\n其分位点定义同上\n$$P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a$$\n\n![F分布的分为点](常见分布/样本以及抽样分布-0a6c68e5.png)\n\n且具有以下性质\n\n$$F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}$$\n\n上面只是简单地介绍了三大抽样分布，并未介绍其作用，**实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用**。更详细的作用会在区间估计中进一步体现。\n","slug":"常见分布","published":1,"updated":"2019-07-30T01:54:38.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j06004mhomjmyk3fhll","content":"<p>本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。三大抽样分布<br><a id=\"more\"></a></p>\n<h1 id=\"离散型随机变量的分布\"><a href=\"#离散型随机变量的分布\" class=\"headerlink\" title=\"离散型随机变量的分布\"></a>离散型随机变量的分布</h1><h2 id=\"伯努利分布\"><a href=\"#伯努利分布\" class=\"headerlink\" title=\"伯努利分布\"></a>伯努利分布</h2><p>伯努利分布又名<strong>两点分布</strong>或者<strong>0-1分布</strong>，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)</script><p>如果试验E只有两种结果，则称试验E为<strong>伯努利试验</strong>。如果独立的进行 n 次试验E，则称为<strong>n重伯努利试验</strong>。</p>\n<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><p>以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：</p>\n<script type=\"math/tex; mode=display\">P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n</script><p>其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><p>随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….</script><p>则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$<br>其分布规律通过图像直观表示为</p>\n<p><img src=\"/2017/08/15/常见分布/常见分布-42feaec2.png\" alt=\"\"></p>\n<p>泊松分布适合于描述<strong>单位时间内随机事件发生的次数的概率分布</strong>。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。</p>\n<p>下面介绍用<strong>泊松分布来逼近二项分布的定理，也就是泊松定理</strong>。</p>\n<p>泊松定理：设 $λ&gt;0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}</script><p>即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。</p>\n<h1 id=\"连续型随机变量的分布\"><a href=\"#连续型随机变量的分布\" class=\"headerlink\" title=\"连续型随机变量的分布\"></a>连续型随机变量的分布</h1><h2 id=\"均匀分布\"><a href=\"#均匀分布\" class=\"headerlink\" title=\"均匀分布\"></a>均匀分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}</script><p>则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$</p>\n<h2 id=\"指数分布\"><a href=\"#指数分布\" class=\"headerlink\" title=\"指数分布\"></a>指数分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>则称 $X$ 服从参数为 $θ$ 的指数分布。</p>\n<p>其图像如下所示:</p>\n<p><img src=\"/2017/08/15/常见分布/一维随机变量-e5379494.png\" alt=\"\"></p>\n<p>其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里</p>\n<p>关于指数分布的一个有趣的性质为：</p>\n<script type=\"math/tex; mode=display\">P(X>s+t | X>s) = P(X>t)</script><p>该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布也叫高斯分布，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</script><p>则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/一维随机变量-a7f11452.png\" alt=\"\"></p>\n<p>从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望</p>\n<h1 id=\"抽样分布\"><a href=\"#抽样分布\" class=\"headerlink\" title=\"抽样分布\"></a>抽样分布</h1><h2 id=\"统计量\"><a href=\"#统计量\" class=\"headerlink\" title=\"统计量\"></a>统计量</h2><p>样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是<strong>针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。</strong></p>\n<p>当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。</p>\n<p>样本平均值：</p>\n<script type=\"math/tex; mode=display\">\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i</script><p>样本方差：</p>\n<script type=\"math/tex; mode=display\">S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2</script><p>样本标准差：</p>\n<script type=\"math/tex; mode=display\">S = \\sqrt {S^2}</script><p>样本 k 阶原点矩：</p>\n<script type=\"math/tex; mode=display\">A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)</script><p>样本 k 阶中心矩:</p>\n<script type=\"math/tex; mode=display\">B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)</script><p>这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-7688d0c8.png\" alt=\"\"></p>\n<h2 id=\"统计量的分布\"><a href=\"#统计量的分布\" class=\"headerlink\" title=\"统计量的分布\"></a>统计量的分布</h2><p>使用统计量进行统计推断时，常常需要知道其分布，<strong>统计量的分布也称为抽样分布</strong>，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。</p>\n<h3 id=\"χ-2-分布\"><a href=\"#χ-2-分布\" class=\"headerlink\" title=\"$χ^2$ 分布\"></a>$χ^2$ 分布</h3><p>$χ^2$ 分布的定义如下</p>\n<p>设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量</p>\n<script type=\"math/tex; mode=display\">\\chi^2 = X_1^2 + X_2^2 +….X_n^2</script><p>为服从自由度为 $n$ 的 $χ^2$ 分布</p>\n<p>上面的自由度指的是右端独立变量的个数。</p>\n<p>$χ^2(n)$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>上式的 $Γ$ 函数定义为</p>\n<script type=\"math/tex; mode=display\">\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt</script><p>$f(y)$ 的图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-bc11bcfe.png\" alt=\"卡方分布的概率密度函数\"></p>\n<p>关于 $χ^2(n)$ 有以下几个有用的结论：</p>\n<ul>\n<li>可加性<br>设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有<script type=\"math/tex; mode=display\">\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)</script></li>\n<li>期望和方差<br>若$\\chi^2(n)$，则χ2的期望和方差如下所示<script type=\"math/tex; mode=display\">E(\\chi^2) = n, D(\\chi^2)=2n</script></li>\n<li>分位点<br>分位点的定义如下，给定正数 $a,0&lt;a&lt;1$, 称满足下面条件</li>\n</ul>\n<script type=\"math/tex; mode=display\">P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a</script><p>的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-3e85fbb1.png\" alt=\"\"></p>\n<p>由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。</p>\n<h3 id=\"t-分布\"><a href=\"#t-分布\" class=\"headerlink\" title=\"$t$ 分布\"></a>$t$ 分布</h3><p>t分布的定义如下：</p>\n<p>设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">t = \\frac{X}{\\sqrt{Y/n}}</script><p>服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$<br>其概率密度函数和对应的图像如下所示：<br><img src=\"/2017/08/15/常见分布/样本以及抽样分布-80c1cca7.png\" alt=\"t分布的概率密度函数和图像\"></p>\n<p>其分位点的定义与上面讲述的一样，</p>\n<script type=\"math/tex; mode=display\">P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a</script><p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-79d1c781.png\" alt=\"\"></p>\n<p>且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$</p>\n<h3 id=\"F-分布\"><a href=\"#F-分布\" class=\"headerlink\" title=\"$F$ 分布\"></a>$F$ 分布</h3><p>$F$ 分布的定义如下</p>\n<p>设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">F = \\frac{U/n_1}{V/n_2}</script><p>服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$<br>其概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>概率密度函数的图像如下所示<br><img src=\"/2017/08/15/常见分布/样本以及抽样分布-35e6599e.png\" alt=\"F分布的概率密度函数\"></p>\n<p>其分位点定义同上</p>\n<script type=\"math/tex; mode=display\">P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a</script><p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-0a6c68e5.png\" alt=\"F分布的分为点\"></p>\n<p>且具有以下性质</p>\n<script type=\"math/tex; mode=display\">F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}</script><p>上面只是简单地介绍了三大抽样分布，并未介绍其作用，<strong>实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用</strong>。更详细的作用会在区间估计中进一步体现。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述三种离散型随机变量的分布(伯努利分布,二项分布,泊松分布)和三种连续型随机变量的分布(均匀分布,指数分布,正态分布)。三大抽样分布<br></p>","more":"<p></p>\n<h1 id=\"离散型随机变量的分布\"><a href=\"#离散型随机变量的分布\" class=\"headerlink\" title=\"离散型随机变量的分布\"></a>离散型随机变量的分布</h1><h2 id=\"伯努利分布\"><a href=\"#伯努利分布\" class=\"headerlink\" title=\"伯努利分布\"></a>伯努利分布</h2><p>伯努利分布又名<strong>两点分布</strong>或者<strong>0-1分布</strong>，只能取两种结果，一般记为0或1。设取1的概率为$p$，其分布规律为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = p^k(1-p)^{1-k}, k = 0,1 (1<p<1)</script><p>如果试验E只有两种结果，则称试验E为<strong>伯努利试验</strong>。如果独立的进行 n 次试验E，则称为<strong>n重伯努利试验</strong>。</p>\n<h2 id=\"二项分布\"><a href=\"#二项分布\" class=\"headerlink\" title=\"二项分布\"></a>二项分布</h2><p>以 $X$ 表示 n 重伯努利试验中事件 $A$ 出现的次数，则 $X$ 为一个随机变量，令 $p$ 为事件 A 出现的概率，则事件 $X$ 服从以下分布：</p>\n<script type=\"math/tex; mode=display\">P(X=k) = C_n^k p^k q^{n-k}, k = 0,1,2,…,n</script><p>其中 $q=1−p$,则我们称 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X~b(n,p)$。</p>\n<h2 id=\"泊松分布\"><a href=\"#泊松分布\" class=\"headerlink\" title=\"泊松分布\"></a>泊松分布</h2><p>随机变量 $X$ 的所有可能取值为 0,1,2,3….,且各个取值的概率为</p>\n<script type=\"math/tex; mode=display\">P(X=k) = \\frac {\\lambda^ke^{-\\lambda}}{k!}, k=0,1,2….</script><p>则我们称 $X$ 服从参数为 $λ$ 的泊松分布，记为 $X~π(λ)$ 其中 $λ$ 为 $X$ 的期望，即 $E(X)$<br>其分布规律通过图像直观表示为</p>\n<p><img src=\"/2017/08/15/常见分布/常见分布-42feaec2.png\" alt=\"\"></p>\n<p>泊松分布适合于描述<strong>单位时间内随机事件发生的次数的概率分布</strong>。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。从上面的图像也可以看出，对于给定泊松分布的强度 λ ,其在单位时间内发生的次数的概率有一个峰值，也就是说发生的次数很多或很少的可能性都不大，且当强度越大，其最大可能发生的次数的值也越大。</p>\n<p>下面介绍用<strong>泊松分布来逼近二项分布的定理，也就是泊松定理</strong>。</p>\n<p>泊松定理：设 $λ&gt;0$ 是一个常数，$n$ 是任意正整数，设 $np=λ$ ,则对于任一非负整数 $k$，有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} C_n^kp^k(1-p)^{n-k} = \\frac{\\lambda^ke^{-\\lambda}}{k!}</script><p>即当 $n$ 很大且 $p$ 很小的时候，我们可以使用上面公式等号右边部分来逼近左边部分，从而简化计算。</p>\n<h1 id=\"连续型随机变量的分布\"><a href=\"#连续型随机变量的分布\" class=\"headerlink\" title=\"连续型随机变量的分布\"></a>连续型随机变量的分布</h1><h2 id=\"均匀分布\"><a href=\"#均匀分布\" class=\"headerlink\" title=\"均匀分布\"></a>均匀分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{b-a} &{a<x<b} \\\\ 0&{其他}\\end{cases}</script><p>则称X在区间 (a,b) 上服从均匀分布，记为 $X~U(a,b)$</p>\n<h2 id=\"指数分布\"><a href=\"#指数分布\" class=\"headerlink\" title=\"指数分布\"></a>指数分布</h2><p>若随机变量 $X$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\begin{cases}  \\frac{1}{\\theta}e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>则称 $X$ 服从参数为 $θ$ 的指数分布。</p>\n<p>其图像如下所示:</p>\n<p><img src=\"/2017/08/15/常见分布/一维随机变量-e5379494.png\" alt=\"\"></p>\n<p>其分布函数为</p>\n<script type=\"math/tex; mode=display\">F(x) = \\begin{cases}  1-e^{-x / \\theta} &{x>0} \\\\ 0&{其他}\\end{cases}</script><p>如果说上面的泊松分布是描述某个时间段内事件发生次数的概率分布，那么指数分布描述的就是事件发生的时间间隔的概率分布。指数分布是连续的分布，反映在其实际意义上就是时间是连续的。更详细的描述可查看这里</p>\n<p>关于指数分布的一个有趣的性质为：</p>\n<script type=\"math/tex; mode=display\">P(X>s+t | X>s) = P(X>t)</script><p>该性质也称为无记忆性，假设 $X$ 是某一原件的寿命，上面的式子表示的就是该元件在使用了 s 个小时后，至少还能使用 t 个小时的条件概率。而这一条件概率又等于该元件从刚开始使用的算起至少能使用 t 个小时的概率。也就是说原件对使用过的s个小时无记忆性，这个特性与随机过程中的平稳过程非常相似，而这个特性也是指数分布有广泛应用的重要原因。</p>\n<h2 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h2><p>正态分布也叫高斯分布，其概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</script><p>则称 $X$ 服从参数为 $μ,σ$ 的正态分布，记为$N(\\mu,\\sigma^2)$，而且 $μ,σ$ 分别是正态分布的期望和标准差。其图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/一维随机变量-a7f11452.png\" alt=\"\"></p>\n<p>从图像可知，当$X=μ$时，取值最大，也就是说随机变量落在这个值附近的概率最大，而这个值也就是正态分布的期望</p>\n<h1 id=\"抽样分布\"><a href=\"#抽样分布\" class=\"headerlink\" title=\"抽样分布\"></a>抽样分布</h1><h2 id=\"统计量\"><a href=\"#统计量\" class=\"headerlink\" title=\"统计量\"></a>统计量</h2><p>样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是<strong>针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。</strong></p>\n<p>当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。</p>\n<p>样本平均值：</p>\n<script type=\"math/tex; mode=display\">\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i</script><p>样本方差：</p>\n<script type=\"math/tex; mode=display\">S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2</script><p>样本标准差：</p>\n<script type=\"math/tex; mode=display\">S = \\sqrt {S^2}</script><p>样本 k 阶原点矩：</p>\n<script type=\"math/tex; mode=display\">A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)</script><p>样本 k 阶中心矩:</p>\n<script type=\"math/tex; mode=display\">B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)</script><p>这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-7688d0c8.png\" alt=\"\"></p>\n<h2 id=\"统计量的分布\"><a href=\"#统计量的分布\" class=\"headerlink\" title=\"统计量的分布\"></a>统计量的分布</h2><p>使用统计量进行统计推断时，常常需要知道其分布，<strong>统计量的分布也称为抽样分布</strong>，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。</p>\n<h3 id=\"χ-2-分布\"><a href=\"#χ-2-分布\" class=\"headerlink\" title=\"$χ^2$ 分布\"></a>$χ^2$ 分布</h3><p>$χ^2$ 分布的定义如下</p>\n<p>设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量</p>\n<script type=\"math/tex; mode=display\">\\chi^2 = X_1^2 + X_2^2 +….X_n^2</script><p>为服从自由度为 $n$ 的 $χ^2$ 分布</p>\n<p>上面的自由度指的是右端独立变量的个数。</p>\n<p>$χ^2(n)$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>上式的 $Γ$ 函数定义为</p>\n<script type=\"math/tex; mode=display\">\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt</script><p>$f(y)$ 的图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-bc11bcfe.png\" alt=\"卡方分布的概率密度函数\"></p>\n<p>关于 $χ^2(n)$ 有以下几个有用的结论：</p>\n<ul>\n<li>可加性<br>设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有<script type=\"math/tex; mode=display\">\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)</script></li>\n<li>期望和方差<br>若$\\chi^2(n)$，则χ2的期望和方差如下所示<script type=\"math/tex; mode=display\">E(\\chi^2) = n, D(\\chi^2)=2n</script></li>\n<li>分位点<br>分位点的定义如下，给定正数 $a,0&lt;a&lt;1$, 称满足下面条件</li>\n</ul>\n<script type=\"math/tex; mode=display\">P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a</script><p>的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示</p>\n<p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-3e85fbb1.png\" alt=\"\"></p>\n<p>由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。</p>\n<h3 id=\"t-分布\"><a href=\"#t-分布\" class=\"headerlink\" title=\"$t$ 分布\"></a>$t$ 分布</h3><p>t分布的定义如下：</p>\n<p>设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">t = \\frac{X}{\\sqrt{Y/n}}</script><p>服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$<br>其概率密度函数和对应的图像如下所示：<br><img src=\"/2017/08/15/常见分布/样本以及抽样分布-80c1cca7.png\" alt=\"t分布的概率密度函数和图像\"></p>\n<p>其分位点的定义与上面讲述的一样，</p>\n<script type=\"math/tex; mode=display\">P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a</script><p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-79d1c781.png\" alt=\"\"></p>\n<p>且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$</p>\n<h3 id=\"F-分布\"><a href=\"#F-分布\" class=\"headerlink\" title=\"$F$ 分布\"></a>$F$ 分布</h3><p>$F$ 分布的定义如下</p>\n<p>设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">F = \\frac{U/n_1}{V/n_2}</script><p>服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$<br>其概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>概率密度函数的图像如下所示<br><img src=\"/2017/08/15/常见分布/样本以及抽样分布-35e6599e.png\" alt=\"F分布的概率密度函数\"></p>\n<p>其分位点定义同上</p>\n<script type=\"math/tex; mode=display\">P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a</script><p><img src=\"/2017/08/15/常见分布/样本以及抽样分布-0a6c68e5.png\" alt=\"F分布的分为点\"></p>\n<p>且具有以下性质</p>\n<script type=\"math/tex; mode=display\">F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}</script><p>上面只是简单地介绍了三大抽样分布，并未介绍其作用，<strong>实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用</strong>。更详细的作用会在区间估计中进一步体现。</p>"},{"title":"微积分","date":"2017-08-14T04:03:49.000Z","_content":"\n# 极限\n## 定义\n函数 $f$ 在 $x_0$ 处的极限为 $L$\n\n$$\\lim_{x\\rightarrow 0} f(x) = L$$\n\n<!--more-->\n\n## 如何比较无穷小\n无穷也分大小，如何描述与比较无穷大和无穷小 。**通过相除比较无穷小**。例如：\n\n$$\\lim_{x\\rightarrow 0} \\frac{sin (x)}{tan (x)} = \\lim_{x\\rightarrow x_0} cos(x) = cos(0) = 1$$\n\n所以当 $x\\rightarrow x_0$ 的时候，$sin(x)$ 与 $tan(x)$ 是同样级别的无穷小.\n\n### 无穷小阶数\n- 定义\n当 $x\\rightarrow 0$ 时，\n - 如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} = 0$那么此时 $f(x)$ 为\n$n$ 阶以上无穷小，记为\n$$f(x) = o(x^n),x → 0$$\n - 如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} $ 存在且不等于零，那么 此时 $f(x)$ 为 $n$ 阶无穷小，记为\n$$f(x) = O(x^n),x → 0 $$\n\n为了方便，在不至于引起误解的时候我们回省略掉 $x → 0.$\n\n### Proposition (三明治/两边夹/夹逼原理)\n如果三个函数满足 $f(x) ≤ g(x) ≤ h(x)$, 而且他们都在 $x_0$ 处有极 限，那么\n$$\\lim_{x\\rightarrow x_0} f(x) ≤ \\lim_{x\\rightarrow x_0} g(x) ≤ \\lim_{x\\rightarrow x_0} h(x)$$\n\n## 重要极限\n$$ \\begin{align*}\n&\\lim_{x\\rightarrow 0} sin(x)/x = 1 \\\\\n&\\lim_{x\\rightarrow ∞}  x^α/e^x = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} ln(x)/x^α = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} (1 + 1/x)^x = e\n\\end{align*}$$\n\n# 微积分\n## 函数的导数定义\n如果一个函数 $f(x)$ 在 $x_0$ 附近有定义，而且存在极限\n\n$$L=\\lim_{x\\rightarrow x_0} \\frac{f (x)-f(x_0)}{x-x_0}$$\n\n那么 $f(x)$ 在 $x_0$ 处可导且导数 $f′(x_0) = L.$\n\n### 函数的高阶导数\n\n如果函数的导数函数仍然可导，那么导数函数的导数是二阶导数，二阶导数函数的导数是三阶导数. 一般地记为\n\n$$f^{(n)}(x) =  \\frac{d}{dx} f^{(n−1)}(x)$$\n\n或者进一步\n$$f^{(n)}(x) =  \\frac{d^n}{dx^n} f(x)$$\n### 多元函数 - 偏导数\n$f(x,y) = ln(x+y^2)$,则\n$$\\frac{\\partial }{\\partial x} f(x,y) = \\frac{1}{x+y^2},\\;\\;\\;\\;\\frac{\\partial }{\\partial x} f(x,y) = \\frac{2y}{x+y^2}$$\n## 初等函数的导数\n$$ \\begin{align*}\n&\\frac{d}{dx}  sin(x)=cos(x) \\\\\n&\\frac{d}{dx}  cos(x)=sin(x)\\\\\n&\\frac{d}{dx}  sinh(x)=cosh(x) \\\\\n&\\frac{d}{dx}  cosh(x)=sinh(x) \\\\\n&\\frac{d}{dx}  x^n = nx^{n-1} \\\\\n&\\frac{d^n}{dx^n}  x^n = n! \\\\\n&\\frac{d}{dx}  e^x = e^x \\\\\n&\\frac{d}{dx}  ln(x) = \\frac{1}{x}\n\\end{align*}$$\n## 求导法则\n- 链式法则: $\\frac{d}{dx}  (g \\circ  f) = \\frac{d}{dx}  (f)· \\frac{d}{dx}  $\n- 加法法则:  $\\frac{d}{dx} (g + f) =  \\frac{dg}{dx} +  \\frac{df}{dx} $\n- 乘法法则:  $\\frac{d}{dx} (g·f) =  \\frac{g}{dx} ·f + g·  \\frac{df}{dx} $\n- 除法法则:  $\\frac{d}{dx} (\\frac{g}{f} ) = \\frac{\\frac{g}{dx}·f-\\frac{f}{dx}·g}{f^2}$\n- 反函数求导： $\\frac{d}{dx} (f^{−1}) = \\frac{1}{\\frac{df}{dx} (f^{−1})} $\n\n求$f(x)=x^x=exp(ln(x))^x =exp(ln(x)·x). $的导数\n$g(x) = exp(x),h(x) = xln(x)$, 则$ f(x) = (g \\circ  h)(x) $\n$$\\begin{align*}\n f'(x) &= g'(h(x))\\cdot h'(x) = g(h(x))·h'(x) \\\\\n &= f(x)·(ln(x) + x·\\frac{1}{x}) \\\\\n &= f(x)·(ln(x) + 1) \\\\\n &= x^x(ln(x) + 1)\n\\end{align*}$$\n\n# 泰勒级数\n## 定义：泰勒/迈克劳林级数: 多项式逼近\n如果 $f(x)$ 是一个无限次可导的函数，那么在任何一点 $x_0$ 附近 我们可以对 $f(x)$ 做多项式逼近:\n$f(x_0 + ∆x) =f(x_0) + f'(x_0)∆x +\\frac{f''(x_0)}{2}∆_x^2 +\\cdots +\\frac{f^{(n)}(x_0)}{n!}∆_x^n + o(∆^n_x)$\n在本课中我们不关注对于尾巴上的余项 $o(∆^n_x)$ 的大小估计\n\n### 一元函数在点$x_k$处的泰勒展开式为：\n$$f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n$$\n### 二元函数在点$(x_k,y_k)$处的泰勒展开式为：\n$$f(x,y)=f(x_k,y_k)+(x-x_k)f'_x(x_k,y_k)+(y-y_k)f'_y(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)^2f''_{xx}(x_k,y_k)+\\frac1{2!}(x-x_k)(y-y_k)f''_{xy}(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)(y-y_k)f''_{yx}(x_k,y_k)+\\frac1{2!}(y-y_k)^2f''_{yy}(x_k,y_k)+o^n$$\n### 多元函数(n)在点$x_k$处的泰勒展开式为：\n$$f(x^1,x^2,\\ldots,x^n)=f(x^1_k,x^2_k,\\ldots,x^n_k)+\\sum_{i=1}^n(x^i-x_k^i)f'_{x^i}(x^1_k,x^2_k,\\ldots,x^n_k)\\\\\n+\\frac1{2!}\\sum_{i,j=1}^n(x^i-x_k^i)(x^j-x_k^j)f''_{ij}(x^1_k,x^2_k,\\ldots,x^n_k)+o^n$$\n\n## 一般的泰勒级数\n$$\\begin{align*}\n&e^x = 1 + x + x^2/2 +\\cdots + x^n/n! + o(x^n) \\\\\n&ln(1 + x) = x-x^2/2 + x^3/3 +\\cdots +(-1)^{n−1} x^n/n + o(x^n)\\\\\n&sin(x) = x-x^3/6 +\\cdots +(-1)^nx^{2n+1}/(2n + 1)! + o(x^{2n+1}) \\\\\n&cos(x) = 1-x^2/2 + x^4/24 +\\cdots + (-1)^nx^{2n}/(2n)! + o(x^{2n+1})\n\\end{align*}$$\n\n## 罗比塔法则\n如果 $f,g$ 是两个无穷阶可导的函数，而且 $f(x_0) = g(x_0) = 0, g'(x_0) \\neq  0$, 则 $\\lim_{x→x_0} f(x)/g(x) = lim x→x0 f'(x)/g'(x)$.\n\n - 推导\n![](微积分/微积分-ce2b007e.png)\n\n# 牛顿法与梯度下降法\n数学原理：牛顿法使用二阶逼近，梯度下降法使用一阶逼近\n- 牛顿法对局部凸的函数找到极小值，对局部凹的函数找到极 大值，对局部不凸不凹的可能会找到鞍点.\n$$x_n = x_{n-1}-\\frac{f'(x_{n-1})}{ f''(x_{n-1})}$$\n- 梯度下降法一般不会找到最大值，但是同样可能会找到鞍点.\n$$x_n = x_{n−1} −γ_{n−1}∇f(x_{n−1})$$\n\n## 极值点条件\n- 全局极小值: 如果对于任何 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗$ 就是全局极小值点.\n- 局部极小值: 如果存在一个正数 $δ$使得，对于任何满足$ | \\tilde{x}−x_∗| < δ $的 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗ $就是局部极 小值点.（方圆$ δ$ 内的极小值点）\n\n不论是全局极小值还是局部极小值一定满足一阶导数/梯度 为零，$f′ = 0 $或者$ ∇f = 0.$\n","source":"_posts/微积分.md","raw":"---\ntitle: 微积分\ndate: 2017-08-14 12:03:49\ntags: [人工智能,高数]\ncategories: 数学\n---\n\n# 极限\n## 定义\n函数 $f$ 在 $x_0$ 处的极限为 $L$\n\n$$\\lim_{x\\rightarrow 0} f(x) = L$$\n\n<!--more-->\n\n## 如何比较无穷小\n无穷也分大小，如何描述与比较无穷大和无穷小 。**通过相除比较无穷小**。例如：\n\n$$\\lim_{x\\rightarrow 0} \\frac{sin (x)}{tan (x)} = \\lim_{x\\rightarrow x_0} cos(x) = cos(0) = 1$$\n\n所以当 $x\\rightarrow x_0$ 的时候，$sin(x)$ 与 $tan(x)$ 是同样级别的无穷小.\n\n### 无穷小阶数\n- 定义\n当 $x\\rightarrow 0$ 时，\n - 如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} = 0$那么此时 $f(x)$ 为\n$n$ 阶以上无穷小，记为\n$$f(x) = o(x^n),x → 0$$\n - 如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} $ 存在且不等于零，那么 此时 $f(x)$ 为 $n$ 阶无穷小，记为\n$$f(x) = O(x^n),x → 0 $$\n\n为了方便，在不至于引起误解的时候我们回省略掉 $x → 0.$\n\n### Proposition (三明治/两边夹/夹逼原理)\n如果三个函数满足 $f(x) ≤ g(x) ≤ h(x)$, 而且他们都在 $x_0$ 处有极 限，那么\n$$\\lim_{x\\rightarrow x_0} f(x) ≤ \\lim_{x\\rightarrow x_0} g(x) ≤ \\lim_{x\\rightarrow x_0} h(x)$$\n\n## 重要极限\n$$ \\begin{align*}\n&\\lim_{x\\rightarrow 0} sin(x)/x = 1 \\\\\n&\\lim_{x\\rightarrow ∞}  x^α/e^x = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} ln(x)/x^α = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} (1 + 1/x)^x = e\n\\end{align*}$$\n\n# 微积分\n## 函数的导数定义\n如果一个函数 $f(x)$ 在 $x_0$ 附近有定义，而且存在极限\n\n$$L=\\lim_{x\\rightarrow x_0} \\frac{f (x)-f(x_0)}{x-x_0}$$\n\n那么 $f(x)$ 在 $x_0$ 处可导且导数 $f′(x_0) = L.$\n\n### 函数的高阶导数\n\n如果函数的导数函数仍然可导，那么导数函数的导数是二阶导数，二阶导数函数的导数是三阶导数. 一般地记为\n\n$$f^{(n)}(x) =  \\frac{d}{dx} f^{(n−1)}(x)$$\n\n或者进一步\n$$f^{(n)}(x) =  \\frac{d^n}{dx^n} f(x)$$\n### 多元函数 - 偏导数\n$f(x,y) = ln(x+y^2)$,则\n$$\\frac{\\partial }{\\partial x} f(x,y) = \\frac{1}{x+y^2},\\;\\;\\;\\;\\frac{\\partial }{\\partial x} f(x,y) = \\frac{2y}{x+y^2}$$\n## 初等函数的导数\n$$ \\begin{align*}\n&\\frac{d}{dx}  sin(x)=cos(x) \\\\\n&\\frac{d}{dx}  cos(x)=sin(x)\\\\\n&\\frac{d}{dx}  sinh(x)=cosh(x) \\\\\n&\\frac{d}{dx}  cosh(x)=sinh(x) \\\\\n&\\frac{d}{dx}  x^n = nx^{n-1} \\\\\n&\\frac{d^n}{dx^n}  x^n = n! \\\\\n&\\frac{d}{dx}  e^x = e^x \\\\\n&\\frac{d}{dx}  ln(x) = \\frac{1}{x}\n\\end{align*}$$\n## 求导法则\n- 链式法则: $\\frac{d}{dx}  (g \\circ  f) = \\frac{d}{dx}  (f)· \\frac{d}{dx}  $\n- 加法法则:  $\\frac{d}{dx} (g + f) =  \\frac{dg}{dx} +  \\frac{df}{dx} $\n- 乘法法则:  $\\frac{d}{dx} (g·f) =  \\frac{g}{dx} ·f + g·  \\frac{df}{dx} $\n- 除法法则:  $\\frac{d}{dx} (\\frac{g}{f} ) = \\frac{\\frac{g}{dx}·f-\\frac{f}{dx}·g}{f^2}$\n- 反函数求导： $\\frac{d}{dx} (f^{−1}) = \\frac{1}{\\frac{df}{dx} (f^{−1})} $\n\n求$f(x)=x^x=exp(ln(x))^x =exp(ln(x)·x). $的导数\n$g(x) = exp(x),h(x) = xln(x)$, 则$ f(x) = (g \\circ  h)(x) $\n$$\\begin{align*}\n f'(x) &= g'(h(x))\\cdot h'(x) = g(h(x))·h'(x) \\\\\n &= f(x)·(ln(x) + x·\\frac{1}{x}) \\\\\n &= f(x)·(ln(x) + 1) \\\\\n &= x^x(ln(x) + 1)\n\\end{align*}$$\n\n# 泰勒级数\n## 定义：泰勒/迈克劳林级数: 多项式逼近\n如果 $f(x)$ 是一个无限次可导的函数，那么在任何一点 $x_0$ 附近 我们可以对 $f(x)$ 做多项式逼近:\n$f(x_0 + ∆x) =f(x_0) + f'(x_0)∆x +\\frac{f''(x_0)}{2}∆_x^2 +\\cdots +\\frac{f^{(n)}(x_0)}{n!}∆_x^n + o(∆^n_x)$\n在本课中我们不关注对于尾巴上的余项 $o(∆^n_x)$ 的大小估计\n\n### 一元函数在点$x_k$处的泰勒展开式为：\n$$f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n$$\n### 二元函数在点$(x_k,y_k)$处的泰勒展开式为：\n$$f(x,y)=f(x_k,y_k)+(x-x_k)f'_x(x_k,y_k)+(y-y_k)f'_y(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)^2f''_{xx}(x_k,y_k)+\\frac1{2!}(x-x_k)(y-y_k)f''_{xy}(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)(y-y_k)f''_{yx}(x_k,y_k)+\\frac1{2!}(y-y_k)^2f''_{yy}(x_k,y_k)+o^n$$\n### 多元函数(n)在点$x_k$处的泰勒展开式为：\n$$f(x^1,x^2,\\ldots,x^n)=f(x^1_k,x^2_k,\\ldots,x^n_k)+\\sum_{i=1}^n(x^i-x_k^i)f'_{x^i}(x^1_k,x^2_k,\\ldots,x^n_k)\\\\\n+\\frac1{2!}\\sum_{i,j=1}^n(x^i-x_k^i)(x^j-x_k^j)f''_{ij}(x^1_k,x^2_k,\\ldots,x^n_k)+o^n$$\n\n## 一般的泰勒级数\n$$\\begin{align*}\n&e^x = 1 + x + x^2/2 +\\cdots + x^n/n! + o(x^n) \\\\\n&ln(1 + x) = x-x^2/2 + x^3/3 +\\cdots +(-1)^{n−1} x^n/n + o(x^n)\\\\\n&sin(x) = x-x^3/6 +\\cdots +(-1)^nx^{2n+1}/(2n + 1)! + o(x^{2n+1}) \\\\\n&cos(x) = 1-x^2/2 + x^4/24 +\\cdots + (-1)^nx^{2n}/(2n)! + o(x^{2n+1})\n\\end{align*}$$\n\n## 罗比塔法则\n如果 $f,g$ 是两个无穷阶可导的函数，而且 $f(x_0) = g(x_0) = 0, g'(x_0) \\neq  0$, 则 $\\lim_{x→x_0} f(x)/g(x) = lim x→x0 f'(x)/g'(x)$.\n\n - 推导\n![](微积分/微积分-ce2b007e.png)\n\n# 牛顿法与梯度下降法\n数学原理：牛顿法使用二阶逼近，梯度下降法使用一阶逼近\n- 牛顿法对局部凸的函数找到极小值，对局部凹的函数找到极 大值，对局部不凸不凹的可能会找到鞍点.\n$$x_n = x_{n-1}-\\frac{f'(x_{n-1})}{ f''(x_{n-1})}$$\n- 梯度下降法一般不会找到最大值，但是同样可能会找到鞍点.\n$$x_n = x_{n−1} −γ_{n−1}∇f(x_{n−1})$$\n\n## 极值点条件\n- 全局极小值: 如果对于任何 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗$ 就是全局极小值点.\n- 局部极小值: 如果存在一个正数 $δ$使得，对于任何满足$ | \\tilde{x}−x_∗| < δ $的 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗ $就是局部极 小值点.（方圆$ δ$ 内的极小值点）\n\n不论是全局极小值还是局部极小值一定满足一阶导数/梯度 为零，$f′ = 0 $或者$ ∇f = 0.$\n","slug":"微积分","published":1,"updated":"2019-07-30T01:54:38.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j08004qhomjsg966bv0","content":"<h1 id=\"极限\"><a href=\"#极限\" class=\"headerlink\" title=\"极限\"></a>极限</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>函数 $f$ 在 $x_0$ 处的极限为 $L$</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow 0} f(x) = L</script><a id=\"more\"></a>\n<h2 id=\"如何比较无穷小\"><a href=\"#如何比较无穷小\" class=\"headerlink\" title=\"如何比较无穷小\"></a>如何比较无穷小</h2><p>无穷也分大小，如何描述与比较无穷大和无穷小 。<strong>通过相除比较无穷小</strong>。例如：</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow 0} \\frac{sin (x)}{tan (x)} = \\lim_{x\\rightarrow x_0} cos(x) = cos(0) = 1</script><p>所以当 $x\\rightarrow x_0$ 的时候，$sin(x)$ 与 $tan(x)$ 是同样级别的无穷小.</p>\n<h3 id=\"无穷小阶数\"><a href=\"#无穷小阶数\" class=\"headerlink\" title=\"无穷小阶数\"></a>无穷小阶数</h3><ul>\n<li>定义<br>当 $x\\rightarrow 0$ 时，<ul>\n<li>如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} = 0$那么此时 $f(x)$ 为<br>$n$ 阶以上无穷小，记为<script type=\"math/tex; mode=display\">f(x) = o(x^n),x → 0</script></li>\n<li>如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} $ 存在且不等于零，那么 此时 $f(x)$ 为 $n$ 阶无穷小，记为<script type=\"math/tex; mode=display\">f(x) = O(x^n),x → 0</script></li>\n</ul>\n</li>\n</ul>\n<p>为了方便，在不至于引起误解的时候我们回省略掉 $x → 0.$</p>\n<h3 id=\"Proposition-三明治-两边夹-夹逼原理\"><a href=\"#Proposition-三明治-两边夹-夹逼原理\" class=\"headerlink\" title=\"Proposition (三明治/两边夹/夹逼原理)\"></a>Proposition (三明治/两边夹/夹逼原理)</h3><p>如果三个函数满足 $f(x) ≤ g(x) ≤ h(x)$, 而且他们都在 $x_0$ 处有极 限，那么</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow x_0} f(x) ≤ \\lim_{x\\rightarrow x_0} g(x) ≤ \\lim_{x\\rightarrow x_0} h(x)</script><h2 id=\"重要极限\"><a href=\"#重要极限\" class=\"headerlink\" title=\"重要极限\"></a>重要极限</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\lim_{x\\rightarrow 0} sin(x)/x = 1 \\\\\n&\\lim_{x\\rightarrow ∞}  x^α/e^x = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} ln(x)/x^α = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} (1 + 1/x)^x = e\n\\end{align*}</script><h1 id=\"微积分\"><a href=\"#微积分\" class=\"headerlink\" title=\"微积分\"></a>微积分</h1><h2 id=\"函数的导数定义\"><a href=\"#函数的导数定义\" class=\"headerlink\" title=\"函数的导数定义\"></a>函数的导数定义</h2><p>如果一个函数 $f(x)$ 在 $x_0$ 附近有定义，而且存在极限</p>\n<script type=\"math/tex; mode=display\">L=\\lim_{x\\rightarrow x_0} \\frac{f (x)-f(x_0)}{x-x_0}</script><p>那么 $f(x)$ 在 $x_0$ 处可导且导数 $f′(x_0) = L.$</p>\n<h3 id=\"函数的高阶导数\"><a href=\"#函数的高阶导数\" class=\"headerlink\" title=\"函数的高阶导数\"></a>函数的高阶导数</h3><p>如果函数的导数函数仍然可导，那么导数函数的导数是二阶导数，二阶导数函数的导数是三阶导数. 一般地记为</p>\n<script type=\"math/tex; mode=display\">f^{(n)}(x) =  \\frac{d}{dx} f^{(n−1)}(x)</script><p>或者进一步</p>\n<script type=\"math/tex; mode=display\">f^{(n)}(x) =  \\frac{d^n}{dx^n} f(x)</script><h3 id=\"多元函数-偏导数\"><a href=\"#多元函数-偏导数\" class=\"headerlink\" title=\"多元函数 - 偏导数\"></a>多元函数 - 偏导数</h3><p>$f(x,y) = ln(x+y^2)$,则</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial }{\\partial x} f(x,y) = \\frac{1}{x+y^2},\\;\\;\\;\\;\\frac{\\partial }{\\partial x} f(x,y) = \\frac{2y}{x+y^2}</script><h2 id=\"初等函数的导数\"><a href=\"#初等函数的导数\" class=\"headerlink\" title=\"初等函数的导数\"></a>初等函数的导数</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\frac{d}{dx}  sin(x)=cos(x) \\\\\n&\\frac{d}{dx}  cos(x)=sin(x)\\\\\n&\\frac{d}{dx}  sinh(x)=cosh(x) \\\\\n&\\frac{d}{dx}  cosh(x)=sinh(x) \\\\\n&\\frac{d}{dx}  x^n = nx^{n-1} \\\\\n&\\frac{d^n}{dx^n}  x^n = n! \\\\\n&\\frac{d}{dx}  e^x = e^x \\\\\n&\\frac{d}{dx}  ln(x) = \\frac{1}{x}\n\\end{align*}</script><h2 id=\"求导法则\"><a href=\"#求导法则\" class=\"headerlink\" title=\"求导法则\"></a>求导法则</h2><ul>\n<li>链式法则: $\\frac{d}{dx}  (g \\circ  f) = \\frac{d}{dx}  (f)· \\frac{d}{dx}  $</li>\n<li>加法法则:  $\\frac{d}{dx} (g + f) =  \\frac{dg}{dx} +  \\frac{df}{dx} $</li>\n<li>乘法法则:  $\\frac{d}{dx} (g·f) =  \\frac{g}{dx} ·f + g·  \\frac{df}{dx} $</li>\n<li>除法法则:  $\\frac{d}{dx} (\\frac{g}{f} ) = \\frac{\\frac{g}{dx}·f-\\frac{f}{dx}·g}{f^2}$</li>\n<li>反函数求导： $\\frac{d}{dx} (f^{−1}) = \\frac{1}{\\frac{df}{dx} (f^{−1})} $</li>\n</ul>\n<p>求$f(x)=x^x=exp(ln(x))^x =exp(ln(x)·x). $的导数<br>$g(x) = exp(x),h(x) = xln(x)$, 则$ f(x) = (g \\circ  h)(x) $</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n f'(x) &= g'(h(x))\\cdot h'(x) = g(h(x))·h'(x) \\\\\n &= f(x)·(ln(x) + x·\\frac{1}{x}) \\\\\n &= f(x)·(ln(x) + 1) \\\\\n &= x^x(ln(x) + 1)\n\\end{align*}</script><h1 id=\"泰勒级数\"><a href=\"#泰勒级数\" class=\"headerlink\" title=\"泰勒级数\"></a>泰勒级数</h1><h2 id=\"定义：泰勒-迈克劳林级数-多项式逼近\"><a href=\"#定义：泰勒-迈克劳林级数-多项式逼近\" class=\"headerlink\" title=\"定义：泰勒/迈克劳林级数: 多项式逼近\"></a>定义：泰勒/迈克劳林级数: 多项式逼近</h2><p>如果 $f(x)$ 是一个无限次可导的函数，那么在任何一点 $x_0$ 附近 我们可以对 $f(x)$ 做多项式逼近:<br>$f(x_0 + ∆x) =f(x_0) + f’(x_0)∆x +\\frac{f’’(x_0)}{2}∆_x^2 +\\cdots +\\frac{f^{(n)}(x_0)}{n!}∆_x^n + o(∆^n_x)$<br>在本课中我们不关注对于尾巴上的余项 $o(∆^n_x)$ 的大小估计</p>\n<h3 id=\"一元函数在点-x-k-处的泰勒展开式为：\"><a href=\"#一元函数在点-x-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"一元函数在点$x_k$处的泰勒展开式为：\"></a>一元函数在点$x_k$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n</script><h3 id=\"二元函数在点-x-k-y-k-处的泰勒展开式为：\"><a href=\"#二元函数在点-x-k-y-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"二元函数在点$(x_k,y_k)$处的泰勒展开式为：\"></a>二元函数在点$(x_k,y_k)$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x,y)=f(x_k,y_k)+(x-x_k)f'_x(x_k,y_k)+(y-y_k)f'_y(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)^2f''_{xx}(x_k,y_k)+\\frac1{2!}(x-x_k)(y-y_k)f''_{xy}(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)(y-y_k)f''_{yx}(x_k,y_k)+\\frac1{2!}(y-y_k)^2f''_{yy}(x_k,y_k)+o^n</script><h3 id=\"多元函数-n-在点-x-k-处的泰勒展开式为：\"><a href=\"#多元函数-n-在点-x-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"多元函数(n)在点$x_k$处的泰勒展开式为：\"></a>多元函数(n)在点$x_k$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x^1,x^2,\\ldots,x^n)=f(x^1_k,x^2_k,\\ldots,x^n_k)+\\sum_{i=1}^n(x^i-x_k^i)f'_{x^i}(x^1_k,x^2_k,\\ldots,x^n_k)\\\\\n+\\frac1{2!}\\sum_{i,j=1}^n(x^i-x_k^i)(x^j-x_k^j)f''_{ij}(x^1_k,x^2_k,\\ldots,x^n_k)+o^n</script><h2 id=\"一般的泰勒级数\"><a href=\"#一般的泰勒级数\" class=\"headerlink\" title=\"一般的泰勒级数\"></a>一般的泰勒级数</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&e^x = 1 + x + x^2/2 +\\cdots + x^n/n! + o(x^n) \\\\\n&ln(1 + x) = x-x^2/2 + x^3/3 +\\cdots +(-1)^{n−1} x^n/n + o(x^n)\\\\\n&sin(x) = x-x^3/6 +\\cdots +(-1)^nx^{2n+1}/(2n + 1)! + o(x^{2n+1}) \\\\\n&cos(x) = 1-x^2/2 + x^4/24 +\\cdots + (-1)^nx^{2n}/(2n)! + o(x^{2n+1})\n\\end{align*}</script><h2 id=\"罗比塔法则\"><a href=\"#罗比塔法则\" class=\"headerlink\" title=\"罗比塔法则\"></a>罗比塔法则</h2><p>如果 $f,g$ 是两个无穷阶可导的函数，而且 $f(x_0) = g(x_0) = 0, g’(x_0) \\neq  0$, 则 $\\lim_{x→x_0} f(x)/g(x) = lim x→x0 f’(x)/g’(x)$.</p>\n<ul>\n<li>推导<br><img src=\"/2017/08/14/微积分/微积分-ce2b007e.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"牛顿法与梯度下降法\"><a href=\"#牛顿法与梯度下降法\" class=\"headerlink\" title=\"牛顿法与梯度下降法\"></a>牛顿法与梯度下降法</h1><p>数学原理：牛顿法使用二阶逼近，梯度下降法使用一阶逼近</p>\n<ul>\n<li>牛顿法对局部凸的函数找到极小值，对局部凹的函数找到极 大值，对局部不凸不凹的可能会找到鞍点.<script type=\"math/tex; mode=display\">x_n = x_{n-1}-\\frac{f'(x_{n-1})}{ f''(x_{n-1})}</script></li>\n<li>梯度下降法一般不会找到最大值，但是同样可能会找到鞍点.<script type=\"math/tex; mode=display\">x_n = x_{n−1} −γ_{n−1}∇f(x_{n−1})</script></li>\n</ul>\n<h2 id=\"极值点条件\"><a href=\"#极值点条件\" class=\"headerlink\" title=\"极值点条件\"></a>极值点条件</h2><ul>\n<li>全局极小值: 如果对于任何 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗$ 就是全局极小值点.</li>\n<li>局部极小值: 如果存在一个正数 $δ$使得，对于任何满足$ | \\tilde{x}−x_∗| &lt; δ $的 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗ $就是局部极 小值点.（方圆$ δ$ 内的极小值点）</li>\n</ul>\n<p>不论是全局极小值还是局部极小值一定满足一阶导数/梯度 为零，$f′ = 0 $或者$ ∇f = 0.$</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"极限\"><a href=\"#极限\" class=\"headerlink\" title=\"极限\"></a>极限</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>函数 $f$ 在 $x_0$ 处的极限为 $L$</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow 0} f(x) = L</script>","more":"<h2 id=\"如何比较无穷小\"><a href=\"#如何比较无穷小\" class=\"headerlink\" title=\"如何比较无穷小\"></a>如何比较无穷小</h2><p>无穷也分大小，如何描述与比较无穷大和无穷小 。<strong>通过相除比较无穷小</strong>。例如：</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow 0} \\frac{sin (x)}{tan (x)} = \\lim_{x\\rightarrow x_0} cos(x) = cos(0) = 1</script><p>所以当 $x\\rightarrow x_0$ 的时候，$sin(x)$ 与 $tan(x)$ 是同样级别的无穷小.</p>\n<h3 id=\"无穷小阶数\"><a href=\"#无穷小阶数\" class=\"headerlink\" title=\"无穷小阶数\"></a>无穷小阶数</h3><ul>\n<li>定义<br>当 $x\\rightarrow 0$ 时，<ul>\n<li>如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} = 0$那么此时 $f(x)$ 为<br>$n$ 阶以上无穷小，记为<script type=\"math/tex; mode=display\">f(x) = o(x^n),x → 0</script></li>\n<li>如果 $\\lim_{x\\rightarrow 0} f(x) = 0$ 而且 $\\lim_{x\\rightarrow 0} \\frac{f (x)}{x^n} $ 存在且不等于零，那么 此时 $f(x)$ 为 $n$ 阶无穷小，记为<script type=\"math/tex; mode=display\">f(x) = O(x^n),x → 0</script></li>\n</ul>\n</li>\n</ul>\n<p>为了方便，在不至于引起误解的时候我们回省略掉 $x → 0.$</p>\n<h3 id=\"Proposition-三明治-两边夹-夹逼原理\"><a href=\"#Proposition-三明治-两边夹-夹逼原理\" class=\"headerlink\" title=\"Proposition (三明治/两边夹/夹逼原理)\"></a>Proposition (三明治/两边夹/夹逼原理)</h3><p>如果三个函数满足 $f(x) ≤ g(x) ≤ h(x)$, 而且他们都在 $x_0$ 处有极 限，那么</p>\n<script type=\"math/tex; mode=display\">\\lim_{x\\rightarrow x_0} f(x) ≤ \\lim_{x\\rightarrow x_0} g(x) ≤ \\lim_{x\\rightarrow x_0} h(x)</script><h2 id=\"重要极限\"><a href=\"#重要极限\" class=\"headerlink\" title=\"重要极限\"></a>重要极限</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\lim_{x\\rightarrow 0} sin(x)/x = 1 \\\\\n&\\lim_{x\\rightarrow ∞}  x^α/e^x = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} ln(x)/x^α = 0, 对于任意正数 α \\\\\n&\\lim_{x\\rightarrow ∞} (1 + 1/x)^x = e\n\\end{align*}</script><h1 id=\"微积分\"><a href=\"#微积分\" class=\"headerlink\" title=\"微积分\"></a>微积分</h1><h2 id=\"函数的导数定义\"><a href=\"#函数的导数定义\" class=\"headerlink\" title=\"函数的导数定义\"></a>函数的导数定义</h2><p>如果一个函数 $f(x)$ 在 $x_0$ 附近有定义，而且存在极限</p>\n<script type=\"math/tex; mode=display\">L=\\lim_{x\\rightarrow x_0} \\frac{f (x)-f(x_0)}{x-x_0}</script><p>那么 $f(x)$ 在 $x_0$ 处可导且导数 $f′(x_0) = L.$</p>\n<h3 id=\"函数的高阶导数\"><a href=\"#函数的高阶导数\" class=\"headerlink\" title=\"函数的高阶导数\"></a>函数的高阶导数</h3><p>如果函数的导数函数仍然可导，那么导数函数的导数是二阶导数，二阶导数函数的导数是三阶导数. 一般地记为</p>\n<script type=\"math/tex; mode=display\">f^{(n)}(x) =  \\frac{d}{dx} f^{(n−1)}(x)</script><p>或者进一步</p>\n<script type=\"math/tex; mode=display\">f^{(n)}(x) =  \\frac{d^n}{dx^n} f(x)</script><h3 id=\"多元函数-偏导数\"><a href=\"#多元函数-偏导数\" class=\"headerlink\" title=\"多元函数 - 偏导数\"></a>多元函数 - 偏导数</h3><p>$f(x,y) = ln(x+y^2)$,则</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial }{\\partial x} f(x,y) = \\frac{1}{x+y^2},\\;\\;\\;\\;\\frac{\\partial }{\\partial x} f(x,y) = \\frac{2y}{x+y^2}</script><h2 id=\"初等函数的导数\"><a href=\"#初等函数的导数\" class=\"headerlink\" title=\"初等函数的导数\"></a>初等函数的导数</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&\\frac{d}{dx}  sin(x)=cos(x) \\\\\n&\\frac{d}{dx}  cos(x)=sin(x)\\\\\n&\\frac{d}{dx}  sinh(x)=cosh(x) \\\\\n&\\frac{d}{dx}  cosh(x)=sinh(x) \\\\\n&\\frac{d}{dx}  x^n = nx^{n-1} \\\\\n&\\frac{d^n}{dx^n}  x^n = n! \\\\\n&\\frac{d}{dx}  e^x = e^x \\\\\n&\\frac{d}{dx}  ln(x) = \\frac{1}{x}\n\\end{align*}</script><h2 id=\"求导法则\"><a href=\"#求导法则\" class=\"headerlink\" title=\"求导法则\"></a>求导法则</h2><ul>\n<li>链式法则: $\\frac{d}{dx}  (g \\circ  f) = \\frac{d}{dx}  (f)· \\frac{d}{dx}  $</li>\n<li>加法法则:  $\\frac{d}{dx} (g + f) =  \\frac{dg}{dx} +  \\frac{df}{dx} $</li>\n<li>乘法法则:  $\\frac{d}{dx} (g·f) =  \\frac{g}{dx} ·f + g·  \\frac{df}{dx} $</li>\n<li>除法法则:  $\\frac{d}{dx} (\\frac{g}{f} ) = \\frac{\\frac{g}{dx}·f-\\frac{f}{dx}·g}{f^2}$</li>\n<li>反函数求导： $\\frac{d}{dx} (f^{−1}) = \\frac{1}{\\frac{df}{dx} (f^{−1})} $</li>\n</ul>\n<p>求$f(x)=x^x=exp(ln(x))^x =exp(ln(x)·x). $的导数<br>$g(x) = exp(x),h(x) = xln(x)$, 则$ f(x) = (g \\circ  h)(x) $</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n f'(x) &= g'(h(x))\\cdot h'(x) = g(h(x))·h'(x) \\\\\n &= f(x)·(ln(x) + x·\\frac{1}{x}) \\\\\n &= f(x)·(ln(x) + 1) \\\\\n &= x^x(ln(x) + 1)\n\\end{align*}</script><h1 id=\"泰勒级数\"><a href=\"#泰勒级数\" class=\"headerlink\" title=\"泰勒级数\"></a>泰勒级数</h1><h2 id=\"定义：泰勒-迈克劳林级数-多项式逼近\"><a href=\"#定义：泰勒-迈克劳林级数-多项式逼近\" class=\"headerlink\" title=\"定义：泰勒/迈克劳林级数: 多项式逼近\"></a>定义：泰勒/迈克劳林级数: 多项式逼近</h2><p>如果 $f(x)$ 是一个无限次可导的函数，那么在任何一点 $x_0$ 附近 我们可以对 $f(x)$ 做多项式逼近:<br>$f(x_0 + ∆x) =f(x_0) + f’(x_0)∆x +\\frac{f’’(x_0)}{2}∆_x^2 +\\cdots +\\frac{f^{(n)}(x_0)}{n!}∆_x^n + o(∆^n_x)$<br>在本课中我们不关注对于尾巴上的余项 $o(∆^n_x)$ 的大小估计</p>\n<h3 id=\"一元函数在点-x-k-处的泰勒展开式为：\"><a href=\"#一元函数在点-x-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"一元函数在点$x_k$处的泰勒展开式为：\"></a>一元函数在点$x_k$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x) = f(x_k)+(x-x_k)f'(x_k)+\\frac{1}{2!}(x-x_k)^2f''(x_k)+o^n</script><h3 id=\"二元函数在点-x-k-y-k-处的泰勒展开式为：\"><a href=\"#二元函数在点-x-k-y-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"二元函数在点$(x_k,y_k)$处的泰勒展开式为：\"></a>二元函数在点$(x_k,y_k)$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x,y)=f(x_k,y_k)+(x-x_k)f'_x(x_k,y_k)+(y-y_k)f'_y(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)^2f''_{xx}(x_k,y_k)+\\frac1{2!}(x-x_k)(y-y_k)f''_{xy}(x_k,y_k)\\\\\n+\\frac1{2!}(x-x_k)(y-y_k)f''_{yx}(x_k,y_k)+\\frac1{2!}(y-y_k)^2f''_{yy}(x_k,y_k)+o^n</script><h3 id=\"多元函数-n-在点-x-k-处的泰勒展开式为：\"><a href=\"#多元函数-n-在点-x-k-处的泰勒展开式为：\" class=\"headerlink\" title=\"多元函数(n)在点$x_k$处的泰勒展开式为：\"></a>多元函数(n)在点$x_k$处的泰勒展开式为：</h3><script type=\"math/tex; mode=display\">f(x^1,x^2,\\ldots,x^n)=f(x^1_k,x^2_k,\\ldots,x^n_k)+\\sum_{i=1}^n(x^i-x_k^i)f'_{x^i}(x^1_k,x^2_k,\\ldots,x^n_k)\\\\\n+\\frac1{2!}\\sum_{i,j=1}^n(x^i-x_k^i)(x^j-x_k^j)f''_{ij}(x^1_k,x^2_k,\\ldots,x^n_k)+o^n</script><h2 id=\"一般的泰勒级数\"><a href=\"#一般的泰勒级数\" class=\"headerlink\" title=\"一般的泰勒级数\"></a>一般的泰勒级数</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n&e^x = 1 + x + x^2/2 +\\cdots + x^n/n! + o(x^n) \\\\\n&ln(1 + x) = x-x^2/2 + x^3/3 +\\cdots +(-1)^{n−1} x^n/n + o(x^n)\\\\\n&sin(x) = x-x^3/6 +\\cdots +(-1)^nx^{2n+1}/(2n + 1)! + o(x^{2n+1}) \\\\\n&cos(x) = 1-x^2/2 + x^4/24 +\\cdots + (-1)^nx^{2n}/(2n)! + o(x^{2n+1})\n\\end{align*}</script><h2 id=\"罗比塔法则\"><a href=\"#罗比塔法则\" class=\"headerlink\" title=\"罗比塔法则\"></a>罗比塔法则</h2><p>如果 $f,g$ 是两个无穷阶可导的函数，而且 $f(x_0) = g(x_0) = 0, g’(x_0) \\neq  0$, 则 $\\lim_{x→x_0} f(x)/g(x) = lim x→x0 f’(x)/g’(x)$.</p>\n<ul>\n<li>推导<br><img src=\"/2017/08/14/微积分/微积分-ce2b007e.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"牛顿法与梯度下降法\"><a href=\"#牛顿法与梯度下降法\" class=\"headerlink\" title=\"牛顿法与梯度下降法\"></a>牛顿法与梯度下降法</h1><p>数学原理：牛顿法使用二阶逼近，梯度下降法使用一阶逼近</p>\n<ul>\n<li>牛顿法对局部凸的函数找到极小值，对局部凹的函数找到极 大值，对局部不凸不凹的可能会找到鞍点.<script type=\"math/tex; mode=display\">x_n = x_{n-1}-\\frac{f'(x_{n-1})}{ f''(x_{n-1})}</script></li>\n<li>梯度下降法一般不会找到最大值，但是同样可能会找到鞍点.<script type=\"math/tex; mode=display\">x_n = x_{n−1} −γ_{n−1}∇f(x_{n−1})</script></li>\n</ul>\n<h2 id=\"极值点条件\"><a href=\"#极值点条件\" class=\"headerlink\" title=\"极值点条件\"></a>极值点条件</h2><ul>\n<li>全局极小值: 如果对于任何 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗$ 就是全局极小值点.</li>\n<li>局部极小值: 如果存在一个正数 $δ$使得，对于任何满足$ | \\tilde{x}−x_∗| &lt; δ $的 $\\tilde{x}$, 都有$ f(x_∗) ≤ f(\\tilde{x})$，那么$ x_∗ $就是局部极 小值点.（方圆$ δ$ 内的极小值点）</li>\n</ul>\n<p>不论是全局极小值还是局部极小值一定满足一阶导数/梯度 为零，$f′ = 0 $或者$ ∇f = 0.$</p>"},{"title":"循环链表","date":"2017-08-28T13:52:59.000Z","_content":"# [定义](https://www.jianshu.com/p/8f536664fa38)\n将单链表中终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称单链表(circle linked list)\n\n但是循环链表进过改造，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便。\n\n![](循环链表/循环链表-30ed5658.png)\n<!--more-->\n# 代码\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/*链式存储结构的定义*/\ntypedef struct CLinkList{\n\n    int data;\n    struct CLinkList * next;\n\n}node;\n\n/**\n* 1.初始化循环链表\n*/\nvoid ds_init(node **pNode){\n\n    int item;\n    node * temp;\n    node * target;\n\n    printf(\"输入结点的值，输入0完成初始化\\n\");\n\n    while (1) {\n\n        scanf(\"%d\", &item);\n\n        fflush(stdin);  // 清空输入缓存区\n\n        if (item == 0) return;\n\n        if ((*pNode) == NULL) {\n\n            // 链表中只有一个结点\n            *pNode = (node *)malloc(sizeof(struct CLinkList));\n\n            if (!(*pNode)) exit(0);\n\n            (*pNode)->data = item;\n            (*pNode)->next = *pNode;\n\n        }else{\n\n            //找到next指向第一个结点的结点\n            for (target = (*pNode); target->next != (*pNode); target = target->next);\n\n            // 生成一个新的结点\n            temp = (node *)malloc(sizeof(struct CLinkList));\n\n            if (!temp) exit(0);\n\n            temp->data = item;\n            temp->next = *pNode;\n            target->next = temp;\n        }\n\n    }\n}\n\n/**\n* 2.插入结点\n* @param  pNode 链表的第一个结点\n* @param  i 插入的位置\n*/\nvoid ds_insert(node **pNode, int i){\n\n    node * temp;\n    node * target;\n    node * p;\n    int item;\n    int j = 1;\n\n    printf(\"输入要插入加点的值:\");\n    scanf(\"%d\", &item);\n\n    if (i == 1) { // 插入到第一个位置\n\n        // 新插入的结点作为第一个结点\n        temp = (node *)malloc(sizeof(struct CLinkList));\n\n        if (!temp) exit(0);\n\n        temp->data = item;\n\n        //找到最后一个结点\n        for (target = (*pNode); target->next != (*pNode); target = target->next);\n\n        temp->next = (*pNode);\n        target->next = temp;\n        *pNode = temp;\n\n    }else{  // 插入到其他位置\n\n        target = *pNode;\n\n        for (; j<(i-1); j++) {\n            target = target->next;\n        }\n\n        temp = (node *)malloc(sizeof(struct CLinkList));\n\n        if (!temp) exit(0);\n\n        temp->data = item;\n        p = target->next;\n        target->next = temp;\n        temp->next = p;\n    }\n}\n\n/**\n* 3.删除结点\n* @param  pNode 链表的第一个结点\n* @param  i 删除的位置\n*/\nvoid ds_delete(node **pNode, int i){\n\n    node * target;\n    node * temp;\n    int j = 1;\n\n    if (i ==1) { // 删除的是第一个结点\n\n        // 找到最后一个结点\n        for (target = *pNode; target->next != *pNode; target = target->next);\n\n        temp = *pNode;\n        *pNode = (*pNode)->next;\n        target->next = *pNode;\n        free(temp);\n    }else{  // 删除其他结点\n\n        target = *pNode;\n\n        for (; j<i-1 ; j++) {\n            target = target->next;\n        }\n\n        temp = target->next;\n        target->next = temp->next;\n        free(temp);\n    }\n}\n\n/**\n* 4.返回结点所在位置\n* @param  pNode 链表的第一个结点\n* @param  elem 结点所在位置\n*/\nint ds_search(node *pNode, int elem){\n\n    node * target;\n    int i = 1;\n\n    for (target = pNode; target->data != elem && target->next != pNode; i++) {\n        target = target->next;\n    }\n\n    if (target->next == pNode) return 0; // 表中不存在该元素\n\n    else\n        return i;\n}\n\n/**\n* 5.遍历\n*/\nvoid ds_traverse(node *pNode){\n\n    node * temp;\n    temp = pNode;\n\n    printf(\"*************链表中的元素**********\\n\");\n\n    do {\n        printf(\"%4d \", temp->data);\n    } while ((temp = temp->next) != pNode);\n\n    printf(\"\\n\");\n}\n\n/**\n* 5.合并链表\n*/\nLinkList Connect(LinkList A, LinkList B){\n\n    LinkList p = A->next;  // 保存A表的头结点\n\n    A->next = B->next->next; // 将B表的开始结点链接到A表尾部\n\n    free(B);  // 释放B表的头结点\n\n    B->next = p;\n\n    return B;  // 返回新循环链表的尾指针\n}\n```\n","source":"_posts/循环链表.md","raw":"---\ntitle: 循环链表\ndate: 2017-08-28 21:52:59\ntags: [线性表]\ncategories: 数据结构\n---\n# [定义](https://www.jianshu.com/p/8f536664fa38)\n将单链表中终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称单链表(circle linked list)\n\n但是循环链表进过改造，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便。\n\n![](循环链表/循环链表-30ed5658.png)\n<!--more-->\n# 代码\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/*链式存储结构的定义*/\ntypedef struct CLinkList{\n\n    int data;\n    struct CLinkList * next;\n\n}node;\n\n/**\n* 1.初始化循环链表\n*/\nvoid ds_init(node **pNode){\n\n    int item;\n    node * temp;\n    node * target;\n\n    printf(\"输入结点的值，输入0完成初始化\\n\");\n\n    while (1) {\n\n        scanf(\"%d\", &item);\n\n        fflush(stdin);  // 清空输入缓存区\n\n        if (item == 0) return;\n\n        if ((*pNode) == NULL) {\n\n            // 链表中只有一个结点\n            *pNode = (node *)malloc(sizeof(struct CLinkList));\n\n            if (!(*pNode)) exit(0);\n\n            (*pNode)->data = item;\n            (*pNode)->next = *pNode;\n\n        }else{\n\n            //找到next指向第一个结点的结点\n            for (target = (*pNode); target->next != (*pNode); target = target->next);\n\n            // 生成一个新的结点\n            temp = (node *)malloc(sizeof(struct CLinkList));\n\n            if (!temp) exit(0);\n\n            temp->data = item;\n            temp->next = *pNode;\n            target->next = temp;\n        }\n\n    }\n}\n\n/**\n* 2.插入结点\n* @param  pNode 链表的第一个结点\n* @param  i 插入的位置\n*/\nvoid ds_insert(node **pNode, int i){\n\n    node * temp;\n    node * target;\n    node * p;\n    int item;\n    int j = 1;\n\n    printf(\"输入要插入加点的值:\");\n    scanf(\"%d\", &item);\n\n    if (i == 1) { // 插入到第一个位置\n\n        // 新插入的结点作为第一个结点\n        temp = (node *)malloc(sizeof(struct CLinkList));\n\n        if (!temp) exit(0);\n\n        temp->data = item;\n\n        //找到最后一个结点\n        for (target = (*pNode); target->next != (*pNode); target = target->next);\n\n        temp->next = (*pNode);\n        target->next = temp;\n        *pNode = temp;\n\n    }else{  // 插入到其他位置\n\n        target = *pNode;\n\n        for (; j<(i-1); j++) {\n            target = target->next;\n        }\n\n        temp = (node *)malloc(sizeof(struct CLinkList));\n\n        if (!temp) exit(0);\n\n        temp->data = item;\n        p = target->next;\n        target->next = temp;\n        temp->next = p;\n    }\n}\n\n/**\n* 3.删除结点\n* @param  pNode 链表的第一个结点\n* @param  i 删除的位置\n*/\nvoid ds_delete(node **pNode, int i){\n\n    node * target;\n    node * temp;\n    int j = 1;\n\n    if (i ==1) { // 删除的是第一个结点\n\n        // 找到最后一个结点\n        for (target = *pNode; target->next != *pNode; target = target->next);\n\n        temp = *pNode;\n        *pNode = (*pNode)->next;\n        target->next = *pNode;\n        free(temp);\n    }else{  // 删除其他结点\n\n        target = *pNode;\n\n        for (; j<i-1 ; j++) {\n            target = target->next;\n        }\n\n        temp = target->next;\n        target->next = temp->next;\n        free(temp);\n    }\n}\n\n/**\n* 4.返回结点所在位置\n* @param  pNode 链表的第一个结点\n* @param  elem 结点所在位置\n*/\nint ds_search(node *pNode, int elem){\n\n    node * target;\n    int i = 1;\n\n    for (target = pNode; target->data != elem && target->next != pNode; i++) {\n        target = target->next;\n    }\n\n    if (target->next == pNode) return 0; // 表中不存在该元素\n\n    else\n        return i;\n}\n\n/**\n* 5.遍历\n*/\nvoid ds_traverse(node *pNode){\n\n    node * temp;\n    temp = pNode;\n\n    printf(\"*************链表中的元素**********\\n\");\n\n    do {\n        printf(\"%4d \", temp->data);\n    } while ((temp = temp->next) != pNode);\n\n    printf(\"\\n\");\n}\n\n/**\n* 5.合并链表\n*/\nLinkList Connect(LinkList A, LinkList B){\n\n    LinkList p = A->next;  // 保存A表的头结点\n\n    A->next = B->next->next; // 将B表的开始结点链接到A表尾部\n\n    free(B);  // 释放B表的头结点\n\n    B->next = p;\n\n    return B;  // 返回新循环链表的尾指针\n}\n```\n","slug":"循环链表","published":1,"updated":"2019-07-30T01:54:38.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0a004thomjrakviz9z","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a><a href=\"https://www.jianshu.com/p/8f536664fa38\" target=\"_blank\" rel=\"noopener\">定义</a></h1><p>将单链表中终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称单链表(circle linked list)</p>\n<p>但是循环链表进过改造，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便。</p>\n<p><img src=\"/2017/08/28/循环链表/循环链表-30ed5658.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*链式存储结构的定义*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CLinkList</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CLinkList</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 1.初始化循环链表</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_init</span><span class=\"params\">(node **pNode)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    node * target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入结点的值，输入0完成初始化\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;item);</span><br><span class=\"line\"></span><br><span class=\"line\">        fflush(<span class=\"built_in\">stdin</span>);  <span class=\"comment\">// 清空输入缓存区</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*pNode) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 链表中只有一个结点</span></span><br><span class=\"line\">            *pNode = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(*pNode)) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            (*pNode)-&gt;data = item;</span><br><span class=\"line\">            (*pNode)-&gt;next = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//找到next指向第一个结点的结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (target = (*pNode); target-&gt;next != (*pNode); target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个新的结点</span></span><br><span class=\"line\">            temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            temp-&gt;data = item;</span><br><span class=\"line\">            temp-&gt;next = *pNode;</span><br><span class=\"line\">            target-&gt;next = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 2.插入结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  i 插入的位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_insert</span><span class=\"params\">(node **pNode, <span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    node * p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入要插入加点的值:\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;item);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 插入到第一个位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新插入的结点作为第一个结点</span></span><br><span class=\"line\">        temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;data = item;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到最后一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (target = (*pNode); target-&gt;next != (*pNode); target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;next = (*pNode);</span><br><span class=\"line\">        target-&gt;next = temp;</span><br><span class=\"line\">        *pNode = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 插入到其他位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        target = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;(i<span class=\"number\">-1</span>); j++) &#123;</span><br><span class=\"line\">            target = target-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;data = item;</span><br><span class=\"line\">        p = target-&gt;next;</span><br><span class=\"line\">        target-&gt;next = temp;</span><br><span class=\"line\">        temp-&gt;next = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 3.删除结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  i 删除的位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_delete</span><span class=\"params\">(node **pNode, <span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i ==<span class=\"number\">1</span>) &#123; <span class=\"comment\">// 删除的是第一个结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 找到最后一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (target = *pNode; target-&gt;next != *pNode; target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = *pNode;</span><br><span class=\"line\">        *pNode = (*pNode)-&gt;next;</span><br><span class=\"line\">        target-&gt;next = *pNode;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(temp);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 删除其他结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        target = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;i<span class=\"number\">-1</span> ; j++) &#123;</span><br><span class=\"line\">            target = target-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = target-&gt;next;</span><br><span class=\"line\">        target-&gt;next = temp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 4.返回结点所在位置</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  elem 结点所在位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ds_search</span><span class=\"params\">(node *pNode, <span class=\"keyword\">int</span> elem)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (target = pNode; target-&gt;data != elem &amp;&amp; target-&gt;next != pNode; i++) &#123;</span><br><span class=\"line\">        target = target-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target-&gt;next == pNode) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 表中不存在该元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_traverse</span><span class=\"params\">(node *pNode)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    temp = pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*************链表中的元素**********\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d \"</span>, temp-&gt;data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((temp = temp-&gt;next) != pNode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.合并链表</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">Connect</span><span class=\"params\">(LinkList A, LinkList B)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p = A-&gt;next;  <span class=\"comment\">// 保存A表的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    A-&gt;next = B-&gt;next-&gt;next; <span class=\"comment\">// 将B表的开始结点链接到A表尾部</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(B);  <span class=\"comment\">// 释放B表的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B-&gt;next = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;  <span class=\"comment\">// 返回新循环链表的尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a><a href=\"https://www.jianshu.com/p/8f536664fa38\" target=\"_blank\" rel=\"noopener\">定义</a></h1><p>将单链表中终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为单循环链表，简称单链表(circle linked list)</p>\n<p>但是循环链表进过改造，不用头指针，而是用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便。</p>\n<p><img src=\"/2017/08/28/循环链表/循环链表-30ed5658.png\" alt=\"\"><br></p>","more":"<p></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*链式存储结构的定义*/</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CLinkList</span>&#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CLinkList</span> * <span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;node;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 1.初始化循环链表</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_init</span><span class=\"params\">(node **pNode)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    node * target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入结点的值，输入0完成初始化\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;item);</span><br><span class=\"line\"></span><br><span class=\"line\">        fflush(<span class=\"built_in\">stdin</span>);  <span class=\"comment\">// 清空输入缓存区</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*pNode) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 链表中只有一个结点</span></span><br><span class=\"line\">            *pNode = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(*pNode)) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            (*pNode)-&gt;data = item;</span><br><span class=\"line\">            (*pNode)-&gt;next = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//找到next指向第一个结点的结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (target = (*pNode); target-&gt;next != (*pNode); target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成一个新的结点</span></span><br><span class=\"line\">            temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            temp-&gt;data = item;</span><br><span class=\"line\">            temp-&gt;next = *pNode;</span><br><span class=\"line\">            target-&gt;next = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 2.插入结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  i 插入的位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_insert</span><span class=\"params\">(node **pNode, <span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    node * p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入要插入加点的值:\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;item);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 插入到第一个位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新插入的结点作为第一个结点</span></span><br><span class=\"line\">        temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;data = item;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到最后一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (target = (*pNode); target-&gt;next != (*pNode); target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;next = (*pNode);</span><br><span class=\"line\">        target-&gt;next = temp;</span><br><span class=\"line\">        *pNode = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 插入到其他位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">        target = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;(i<span class=\"number\">-1</span>); j++) &#123;</span><br><span class=\"line\">            target = target-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = (node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct CLinkList));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp) <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp-&gt;data = item;</span><br><span class=\"line\">        p = target-&gt;next;</span><br><span class=\"line\">        target-&gt;next = temp;</span><br><span class=\"line\">        temp-&gt;next = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 3.删除结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  i 删除的位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_delete</span><span class=\"params\">(node **pNode, <span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i ==<span class=\"number\">1</span>) &#123; <span class=\"comment\">// 删除的是第一个结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 找到最后一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (target = *pNode; target-&gt;next != *pNode; target = target-&gt;next);</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = *pNode;</span><br><span class=\"line\">        *pNode = (*pNode)-&gt;next;</span><br><span class=\"line\">        target-&gt;next = *pNode;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(temp);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;  <span class=\"comment\">// 删除其他结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        target = *pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;i<span class=\"number\">-1</span> ; j++) &#123;</span><br><span class=\"line\">            target = target-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        temp = target-&gt;next;</span><br><span class=\"line\">        target-&gt;next = temp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 4.返回结点所在位置</span></span><br><span class=\"line\"><span class=\"comment\">* @param  pNode 链表的第一个结点</span></span><br><span class=\"line\"><span class=\"comment\">* @param  elem 结点所在位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ds_search</span><span class=\"params\">(node *pNode, <span class=\"keyword\">int</span> elem)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * target;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (target = pNode; target-&gt;data != elem &amp;&amp; target-&gt;next != pNode; i++) &#123;</span><br><span class=\"line\">        target = target-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target-&gt;next == pNode) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 表中不存在该元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ds_traverse</span><span class=\"params\">(node *pNode)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    node * temp;</span><br><span class=\"line\">    temp = pNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*************链表中的元素**********\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d \"</span>, temp-&gt;data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((temp = temp-&gt;next) != pNode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 5.合并链表</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">LinkList <span class=\"title\">Connect</span><span class=\"params\">(LinkList A, LinkList B)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkList p = A-&gt;next;  <span class=\"comment\">// 保存A表的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    A-&gt;next = B-&gt;next-&gt;next; <span class=\"comment\">// 将B表的开始结点链接到A表尾部</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(B);  <span class=\"comment\">// 释放B表的头结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    B-&gt;next = p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> B;  <span class=\"comment\">// 返回新循环链表的尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"神经元-感知器梯度下降","date":"2017-09-04T15:08:52.000Z","_content":"## [感知器-神经元](https://www.zybuluo.com/hanbingtao/note/433855)\n![](assets/感知器梯度下降-ecffbab1.png)\n- **输入权值** 一个感知器可以接收多个输$(x_1, x_2,...,x_n\\mid x_i\\in R)$(特征)，每个输入上有一个**权值**$w_i\\in R$。此外还有一个**偏置项**$b$,就是上图中的$w_0$\n- **激活函数** 感知器的激活函数可以有很多选择，比如我们可以选择下面这个**阶跃函数**$f$来作为激活函数：\n$$f(z)=\\left\\{\\begin{matrix}\n1&\\: \\, z>0\\\\\n0&\\: \\,otherwise\n\\end{matrix}\\right.$$\n- **输出** 感知器的输出由下面这个公式来计算\n$$y=f(\\mathrm{w}\\bullet\\mathrm{x}+b)\\qquad $$\n偏置项$b$,就是上图中的$w_0$\n$$y=f(\\mathrm{w}\\bullet\\mathrm{x})$$\n## [线性单元和梯度下降](https://www.zybuluo.com/hanbingtao/note/448086)\n当感知器为线性函数时候\n$$y=\\mathrm{w}\\bullet\\mathrm{x}+b$$\n偏置项$b$,就是上图中的$w_0$，$y=\\mathrm{w}\\bullet\\mathrm{x}$其优化如下所示\n### 梯度下降法\n在监督学习下，对于一个样本，我们知道它的特征$x$，以及标记$y$。同时，我们还可以根据模型 $y=\\mathrm{w}\\bullet\\mathrm{x}+b$ 计算得到输出 $\\bar{y}$。注意这里面我们用$y$表示训练样本里面的**标记**，也就是**实际值**；用带上划线的 $\\bar{y}$ 表示模型计算的出来的**预测值**。我们当然希望模型计算出来的和越接近越好。则损失函数为\n$$loss = \\frac{1}{2}\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})^2$$\n\n$$\\frac{\\partial loss}{\\partial w}=\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}$$\n\n$$\\mathrm{w}_{new}=\\mathrm{w}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)} $$\n\n$$\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{new}=\n\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\n\\begin{bmatrix}\n1 \\\\\nx_1^{(i)} \\\\\nx_2^{(i)} \\\\\n... \\\\\nx_m^{(i)} \\\\\n\\end{bmatrix}$$\n","source":"_posts/感知器梯度下降.md","raw":"---\ntitle: 神经元-感知器梯度下降\ndate: 2017-09-04 23:08:52\ntags: [人工智能,感知器,凸优化]\ncategories: 深度学习\n---\n## [感知器-神经元](https://www.zybuluo.com/hanbingtao/note/433855)\n![](assets/感知器梯度下降-ecffbab1.png)\n- **输入权值** 一个感知器可以接收多个输$(x_1, x_2,...,x_n\\mid x_i\\in R)$(特征)，每个输入上有一个**权值**$w_i\\in R$。此外还有一个**偏置项**$b$,就是上图中的$w_0$\n- **激活函数** 感知器的激活函数可以有很多选择，比如我们可以选择下面这个**阶跃函数**$f$来作为激活函数：\n$$f(z)=\\left\\{\\begin{matrix}\n1&\\: \\, z>0\\\\\n0&\\: \\,otherwise\n\\end{matrix}\\right.$$\n- **输出** 感知器的输出由下面这个公式来计算\n$$y=f(\\mathrm{w}\\bullet\\mathrm{x}+b)\\qquad $$\n偏置项$b$,就是上图中的$w_0$\n$$y=f(\\mathrm{w}\\bullet\\mathrm{x})$$\n## [线性单元和梯度下降](https://www.zybuluo.com/hanbingtao/note/448086)\n当感知器为线性函数时候\n$$y=\\mathrm{w}\\bullet\\mathrm{x}+b$$\n偏置项$b$,就是上图中的$w_0$，$y=\\mathrm{w}\\bullet\\mathrm{x}$其优化如下所示\n### 梯度下降法\n在监督学习下，对于一个样本，我们知道它的特征$x$，以及标记$y$。同时，我们还可以根据模型 $y=\\mathrm{w}\\bullet\\mathrm{x}+b$ 计算得到输出 $\\bar{y}$。注意这里面我们用$y$表示训练样本里面的**标记**，也就是**实际值**；用带上划线的 $\\bar{y}$ 表示模型计算的出来的**预测值**。我们当然希望模型计算出来的和越接近越好。则损失函数为\n$$loss = \\frac{1}{2}\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})^2$$\n\n$$\\frac{\\partial loss}{\\partial w}=\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}$$\n\n$$\\mathrm{w}_{new}=\\mathrm{w}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)} $$\n\n$$\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{new}=\n\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\n\\begin{bmatrix}\n1 \\\\\nx_1^{(i)} \\\\\nx_2^{(i)} \\\\\n... \\\\\nx_m^{(i)} \\\\\n\\end{bmatrix}$$\n","slug":"感知器梯度下降","published":1,"updated":"2019-07-30T01:54:38.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0c004xhomjv890246w","content":"<h2 id=\"感知器-神经元\"><a href=\"#感知器-神经元\" class=\"headerlink\" title=\"感知器-神经元\"></a><a href=\"https://www.zybuluo.com/hanbingtao/note/433855\" target=\"_blank\" rel=\"noopener\">感知器-神经元</a></h2><p><img src=\"/2017/09/04/感知器梯度下降/感知器梯度下降-ecffbab1.png\" alt=\"\"></p>\n<ul>\n<li><strong>输入权值</strong> 一个感知器可以接收多个输$(x_1, x_2,…,x_n\\mid x_i\\in R)$(特征)，每个输入上有一个<strong>权值</strong>$w_i\\in R$。此外还有一个<strong>偏置项</strong>$b$,就是上图中的$w_0$</li>\n<li><strong>激活函数</strong> 感知器的激活函数可以有很多选择，比如我们可以选择下面这个<strong>阶跃函数</strong>$f$来作为激活函数：<script type=\"math/tex; mode=display\">f(z)=\\left\\{\\begin{matrix}\n1&\\: \\, z>0\\\\\n0&\\: \\,otherwise\n\\end{matrix}\\right.</script></li>\n<li><strong>输出</strong> 感知器的输出由下面这个公式来计算<script type=\"math/tex; mode=display\">y=f(\\mathrm{w}\\bullet\\mathrm{x}+b)\\qquad</script>偏置项$b$,就是上图中的$w_0$<script type=\"math/tex; mode=display\">y=f(\\mathrm{w}\\bullet\\mathrm{x})</script><h2 id=\"线性单元和梯度下降\"><a href=\"#线性单元和梯度下降\" class=\"headerlink\" title=\"线性单元和梯度下降\"></a><a href=\"https://www.zybuluo.com/hanbingtao/note/448086\" target=\"_blank\" rel=\"noopener\">线性单元和梯度下降</a></h2>当感知器为线性函数时候<script type=\"math/tex; mode=display\">y=\\mathrm{w}\\bullet\\mathrm{x}+b</script>偏置项$b$,就是上图中的$w_0$，$y=\\mathrm{w}\\bullet\\mathrm{x}$其优化如下所示<h3 id=\"梯度下降法\"><a href=\"#梯度下降法\" class=\"headerlink\" title=\"梯度下降法\"></a>梯度下降法</h3>在监督学习下，对于一个样本，我们知道它的特征$x$，以及标记$y$。同时，我们还可以根据模型 $y=\\mathrm{w}\\bullet\\mathrm{x}+b$ 计算得到输出 $\\bar{y}$。注意这里面我们用$y$表示训练样本里面的<strong>标记</strong>，也就是<strong>实际值</strong>；用带上划线的 $\\bar{y}$ 表示模型计算的出来的<strong>预测值</strong>。我们当然希望模型计算出来的和越接近越好。则损失函数为<script type=\"math/tex; mode=display\">loss = \\frac{1}{2}\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})^2</script></li>\n</ul>\n<script type=\"math/tex; mode=display\">\\frac{\\partial loss}{\\partial w}=\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}</script><script type=\"math/tex; mode=display\">\\mathrm{w}_{new}=\\mathrm{w}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}</script><script type=\"math/tex; mode=display\">\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{new}=\n\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\n\\begin{bmatrix}\n1 \\\\\nx_1^{(i)} \\\\\nx_2^{(i)} \\\\\n... \\\\\nx_m^{(i)} \\\\\n\\end{bmatrix}</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"感知器-神经元\"><a href=\"#感知器-神经元\" class=\"headerlink\" title=\"感知器-神经元\"></a><a href=\"https://www.zybuluo.com/hanbingtao/note/433855\" target=\"_blank\" rel=\"noopener\">感知器-神经元</a></h2><p><img src=\"/2017/09/04/感知器梯度下降/感知器梯度下降-ecffbab1.png\" alt=\"\"></p>\n<ul>\n<li><strong>输入权值</strong> 一个感知器可以接收多个输$(x_1, x_2,…,x_n\\mid x_i\\in R)$(特征)，每个输入上有一个<strong>权值</strong>$w_i\\in R$。此外还有一个<strong>偏置项</strong>$b$,就是上图中的$w_0$</li>\n<li><strong>激活函数</strong> 感知器的激活函数可以有很多选择，比如我们可以选择下面这个<strong>阶跃函数</strong>$f$来作为激活函数：<script type=\"math/tex; mode=display\">f(z)=\\left\\{\\begin{matrix}\n1&\\: \\, z>0\\\\\n0&\\: \\,otherwise\n\\end{matrix}\\right.</script></li>\n<li><strong>输出</strong> 感知器的输出由下面这个公式来计算<script type=\"math/tex; mode=display\">y=f(\\mathrm{w}\\bullet\\mathrm{x}+b)\\qquad</script>偏置项$b$,就是上图中的$w_0$<script type=\"math/tex; mode=display\">y=f(\\mathrm{w}\\bullet\\mathrm{x})</script><h2 id=\"线性单元和梯度下降\"><a href=\"#线性单元和梯度下降\" class=\"headerlink\" title=\"线性单元和梯度下降\"></a><a href=\"https://www.zybuluo.com/hanbingtao/note/448086\" target=\"_blank\" rel=\"noopener\">线性单元和梯度下降</a></h2>当感知器为线性函数时候<script type=\"math/tex; mode=display\">y=\\mathrm{w}\\bullet\\mathrm{x}+b</script>偏置项$b$,就是上图中的$w_0$，$y=\\mathrm{w}\\bullet\\mathrm{x}$其优化如下所示<h3 id=\"梯度下降法\"><a href=\"#梯度下降法\" class=\"headerlink\" title=\"梯度下降法\"></a>梯度下降法</h3>在监督学习下，对于一个样本，我们知道它的特征$x$，以及标记$y$。同时，我们还可以根据模型 $y=\\mathrm{w}\\bullet\\mathrm{x}+b$ 计算得到输出 $\\bar{y}$。注意这里面我们用$y$表示训练样本里面的<strong>标记</strong>，也就是<strong>实际值</strong>；用带上划线的 $\\bar{y}$ 表示模型计算的出来的<strong>预测值</strong>。我们当然希望模型计算出来的和越接近越好。则损失函数为<script type=\"math/tex; mode=display\">loss = \\frac{1}{2}\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})^2</script></li>\n</ul>\n<script type=\"math/tex; mode=display\">\\frac{\\partial loss}{\\partial w}=\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}</script><script type=\"math/tex; mode=display\">\\mathrm{w}_{new}=\\mathrm{w}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\\mathrm{x}^{(i)}</script><script type=\"math/tex; mode=display\">\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{new}=\n\\begin{bmatrix}\nw_0 \\\\\nw_1 \\\\\nw_2 \\\\\n... \\\\\nw_m \\\\\n\\end{bmatrix}_{old}+\\eta\\sum_{i=1}^{n}(y^{(i)}-\\bar{y}^{(i)})\n\\begin{bmatrix}\n1 \\\\\nx_1^{(i)} \\\\\nx_2^{(i)} \\\\\n... \\\\\nx_m^{(i)} \\\\\n\\end{bmatrix}</script>"},{"title":"拉格朗日","date":"2017-09-02T02:57:07.000Z","_content":"拉格朗日对偶性是**解决带约束的最优化问题**的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机，最大熵模型。\n\n# 原始问题\n\n假设$f(x)，c_i(x),h_j(x)$是定义在$\\mathbb{R}^{n}$上的连续可微函数。我们需要求解约束最优化问题：\n\n$$\\underset{x\\in \\mathbb{R}^n}{min} f(x)$$\n\n\n$$\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l\n\\end{align} $$\n\n# 广义拉格朗日函数\n为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：\n$$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}$$\n其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$\n\n\n# 原始问题的等价转换：极小极大问题\n\n如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即$$\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5$$\n\n确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数\n\n- 如果$x$ 满足原始问题中约束，\n由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0\n- 如果 $x$ 不满足原始问题中的约束，那么 $θ(x)=+∞$。若某个$i$使约束$c_i(x)>0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。\n\n综上：\n\n$$\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.$$\n\n\n**求解原问题的最小值**与原始问题等价\n$$\\color{red}{\\underset{x\\in \\mathbb{R}^n}{min}\\; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) }$$\n\n\n# 原始问题和对偶问题的关系\n\n- 弱对偶关系：弱对偶关系一定存在，\n若原始问题和对偶问题都有最优值，则\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}$$\n\n\n- 强对偶关系\n设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta)$和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$的可行解，并且\n$$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) = \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)$$\n$$\\color{red}{\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) = \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta)={min}\\; f(x^\\ast )} $$\n则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。\n\n\n## 弱对偶关系\n若原始问题和对偶问题都有最优值，则\n$$\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $$\n\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}$$\n**推论**：设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta) $和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $的可行解，并且$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $，则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。\n\n\n## 强对偶关系\n- 定理1：判断强对偶关系\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，即存在$x$,对所有$i$有$c_i(x)<0$，则存在$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解,并且满足\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) =L(x^\\ast,\\alpha^\\ast ,\\beta^\\ast )= \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta) ={min}\\; f(x^\\ast )}$$\n\n- 定理2：KKT条件(求最优解)\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解的充分必要条件是$x^\\ast,a^\\ast,β^\\ast$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）\n$$\\begin{align*}\n\\nabla_xL(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\\\\\n\\nabla_{\\alpha}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast) &=0 \\\\\n\\nabla_{\\beta}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\n\\end{align*}$$\n$$\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}$$\n**当原问题是凸优化问题时，满足KKT条件的点也是原、对偶问题的最优解。**\n - 仿射函数\n$$f(x)=A\\cdot x+b$$\n仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。\n","source":"_posts/拉格朗日.md","raw":"---\ntitle: 拉格朗日\ndate: 2017-09-02 10:57:07\ntags: [优化,凸优化,人工智能]\ncategories: 机器学习\n---\n拉格朗日对偶性是**解决带约束的最优化问题**的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机，最大熵模型。\n\n# 原始问题\n\n假设$f(x)，c_i(x),h_j(x)$是定义在$\\mathbb{R}^{n}$上的连续可微函数。我们需要求解约束最优化问题：\n\n$$\\underset{x\\in \\mathbb{R}^n}{min} f(x)$$\n\n\n$$\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l\n\\end{align} $$\n\n# 广义拉格朗日函数\n为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：\n$$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}$$\n其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$\n\n\n# 原始问题的等价转换：极小极大问题\n\n如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即$$\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5$$\n\n确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数\n\n- 如果$x$ 满足原始问题中约束，\n由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0\n- 如果 $x$ 不满足原始问题中的约束，那么 $θ(x)=+∞$。若某个$i$使约束$c_i(x)>0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。\n\n综上：\n\n$$\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.$$\n\n\n**求解原问题的最小值**与原始问题等价\n$$\\color{red}{\\underset{x\\in \\mathbb{R}^n}{min}\\; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) }$$\n\n\n# 原始问题和对偶问题的关系\n\n- 弱对偶关系：弱对偶关系一定存在，\n若原始问题和对偶问题都有最优值，则\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}$$\n\n\n- 强对偶关系\n设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta)$和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$的可行解，并且\n$$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) = \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)$$\n$$\\color{red}{\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) = \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta)={min}\\; f(x^\\ast )} $$\n则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。\n\n\n## 弱对偶关系\n若原始问题和对偶问题都有最优值，则\n$$\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $$\n\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}$$\n**推论**：设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta) $和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $的可行解，并且$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $，则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。\n\n\n## 强对偶关系\n- 定理1：判断强对偶关系\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，即存在$x$,对所有$i$有$c_i(x)<0$，则存在$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解,并且满足\n$$\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) =L(x^\\ast,\\alpha^\\ast ,\\beta^\\ast )= \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta) ={min}\\; f(x^\\ast )}$$\n\n- 定理2：KKT条件(求最优解)\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解的充分必要条件是$x^\\ast,a^\\ast,β^\\ast$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）\n$$\\begin{align*}\n\\nabla_xL(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\\\\\n\\nabla_{\\alpha}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast) &=0 \\\\\n\\nabla_{\\beta}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\n\\end{align*}$$\n$$\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}$$\n**当原问题是凸优化问题时，满足KKT条件的点也是原、对偶问题的最优解。**\n - 仿射函数\n$$f(x)=A\\cdot x+b$$\n仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。\n","slug":"拉格朗日","published":1,"updated":"2019-07-30T01:54:38.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0e0051homjup5t4c8d","content":"<p>拉格朗日对偶性是<strong>解决带约束的最优化问题</strong>的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机，最大熵模型。</p>\n<h1 id=\"原始问题\"><a href=\"#原始问题\" class=\"headerlink\" title=\"原始问题\"></a>原始问题</h1><p>假设$f(x)，c_i(x),h_j(x)$是定义在$\\mathbb{R}^{n}$上的连续可微函数。我们需要求解约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min} f(x)</script><script type=\"math/tex; mode=display\">\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l\n\\end{align}</script><h1 id=\"广义拉格朗日函数\"><a href=\"#广义拉格朗日函数\" class=\"headerlink\" title=\"广义拉格朗日函数\"></a>广义拉格朗日函数</h1><p>为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：</p>\n<script type=\"math/tex; mode=display\">L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}</script><p>其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$</p>\n<h1 id=\"原始问题的等价转换：极小极大问题\"><a href=\"#原始问题的等价转换：极小极大问题\" class=\"headerlink\" title=\"原始问题的等价转换：极小极大问题\"></a>原始问题的等价转换：极小极大问题</h1><p>如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即<script type=\"math/tex\">\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5</script></p>\n<p>确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数</p>\n<ul>\n<li>如果$x$ 满足原始问题中约束，<br>由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0</li>\n<li>如果 $x$ 不满足原始问题中的约束，那么 $θ(x)=+∞$。若某个$i$使约束$c_i(x)&gt;0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。</li>\n</ul>\n<p>综上：</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.</script><p><strong>求解原问题的最小值</strong>与原始问题等价</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\underset{x\\in \\mathbb{R}^n}{min}\\; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) }</script><h1 id=\"原始问题和对偶问题的关系\"><a href=\"#原始问题和对偶问题的关系\" class=\"headerlink\" title=\"原始问题和对偶问题的关系\"></a>原始问题和对偶问题的关系</h1><ul>\n<li>弱对偶关系：弱对偶关系一定存在，<br>若原始问题和对偶问题都有最优值，则<script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}</script></li>\n</ul>\n<ul>\n<li>强对偶关系<br>设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta)$和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$的可行解，并且<script type=\"math/tex; mode=display\">\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) = \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)</script><script type=\"math/tex; mode=display\">\\color{red}{\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) = \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta)={min}\\; f(x^\\ast )}</script>则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。</li>\n</ul>\n<h2 id=\"弱对偶关系\"><a href=\"#弱对偶关系\" class=\"headerlink\" title=\"弱对偶关系\"></a>弱对偶关系</h2><p>若原始问题和对偶问题都有最优值，则</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}</script><p><strong>推论</strong>：设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta) $和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $的可行解，并且$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $，则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。</p>\n<h2 id=\"强对偶关系\"><a href=\"#强对偶关系\" class=\"headerlink\" title=\"强对偶关系\"></a>强对偶关系</h2><ul>\n<li><p>定理1：判断强对偶关系<br>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，即存在$x$,对所有$i$有$c_i(x)&lt;0$，则存在$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解,并且满足</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) =L(x^\\ast,\\alpha^\\ast ,\\beta^\\ast )= \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta) ={min}\\; f(x^\\ast )}</script></li>\n<li><p>定理2：KKT条件(求最优解)<br>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解的充分必要条件是$x^\\ast,a^\\ast,β^\\ast$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\nabla_xL(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\\\\\n\\nabla_{\\alpha}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast) &=0 \\\\\n\\nabla_{\\beta}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\n\\end{align*}</script><script type=\"math/tex; mode=display\">\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}</script><p><strong>当原问题是凸优化问题时，满足KKT条件的点也是原、对偶问题的最优解。</strong></p>\n<ul>\n<li>仿射函数<script type=\"math/tex; mode=display\">f(x)=A\\cdot x+b</script>仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>拉格朗日对偶性是<strong>解决带约束的最优化问题</strong>的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机，最大熵模型。</p>\n<h1 id=\"原始问题\"><a href=\"#原始问题\" class=\"headerlink\" title=\"原始问题\"></a>原始问题</h1><p>假设$f(x)，c_i(x),h_j(x)$是定义在$\\mathbb{R}^{n}$上的连续可微函数。我们需要求解约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min} f(x)</script><script type=\"math/tex; mode=display\">\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l\n\\end{align}</script><h1 id=\"广义拉格朗日函数\"><a href=\"#广义拉格朗日函数\" class=\"headerlink\" title=\"广义拉格朗日函数\"></a>广义拉格朗日函数</h1><p>为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：</p>\n<script type=\"math/tex; mode=display\">L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}</script><p>其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$</p>\n<h1 id=\"原始问题的等价转换：极小极大问题\"><a href=\"#原始问题的等价转换：极小极大问题\" class=\"headerlink\" title=\"原始问题的等价转换：极小极大问题\"></a>原始问题的等价转换：极小极大问题</h1><p>如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即<script type=\"math/tex\">\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5</script></p>\n<p>确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数</p>\n<ul>\n<li>如果$x$ 满足原始问题中约束，<br>由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0</li>\n<li>如果 $x$ 不满足原始问题中的约束，那么 $θ(x)=+∞$。若某个$i$使约束$c_i(x)&gt;0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。</li>\n</ul>\n<p>综上：</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.</script><p><strong>求解原问题的最小值</strong>与原始问题等价</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\underset{x\\in \\mathbb{R}^n}{min}\\; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) }</script><h1 id=\"原始问题和对偶问题的关系\"><a href=\"#原始问题和对偶问题的关系\" class=\"headerlink\" title=\"原始问题和对偶问题的关系\"></a>原始问题和对偶问题的关系</h1><ul>\n<li>弱对偶关系：弱对偶关系一定存在，<br>若原始问题和对偶问题都有最优值，则<script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}</script></li>\n</ul>\n<ul>\n<li>强对偶关系<br>设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta)$和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$的可行解，并且<script type=\"math/tex; mode=display\">\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) = \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)</script><script type=\"math/tex; mode=display\">\\color{red}{\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) = \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta)={min}\\; f(x^\\ast )}</script>则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。</li>\n</ul>\n<h2 id=\"弱对偶关系\"><a href=\"#弱对偶关系\" class=\"headerlink\" title=\"弱对偶关系\"></a>弱对偶关系</h2><p>若原始问题和对偶问题都有最优值，则</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)}</script><p><strong>推论</strong>：设$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; L(x,\\alpha,\\beta) $和对偶问题$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $的可行解，并且$\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $，则$x^\\ast$和$a^\\ast$,$β^\\ast$分别是原始问题和对偶问题的最优解。</p>\n<h2 id=\"强对偶关系\"><a href=\"#强对偶关系\" class=\"headerlink\" title=\"强对偶关系\"></a>强对偶关系</h2><ul>\n<li><p>定理1：判断强对偶关系<br>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，即存在$x$,对所有$i$有$c_i(x)&lt;0$，则存在$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解,并且满足</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha^\\ast ,\\beta^\\ast ) =L(x^\\ast,\\alpha^\\ast ,\\beta^\\ast )= \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x^\\ast ,\\alpha,\\beta) ={min}\\; f(x^\\ast )}</script></li>\n<li><p>定理2：KKT条件(求最优解)<br>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^\\ast$和$a^\\ast,β^\\ast$分别是原始问题和对偶问题的解的充分必要条件是$x^\\ast,a^\\ast,β^\\ast$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\nabla_xL(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\\\\\n\\nabla_{\\alpha}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast) &=0 \\\\\n\\nabla_{\\beta}L(x^\\ast,\\alpha^\\ast,\\beta^\\ast)&=0\n\\end{align*}</script><script type=\"math/tex; mode=display\">\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}</script><p><strong>当原问题是凸优化问题时，满足KKT条件的点也是原、对偶问题的最优解。</strong></p>\n<ul>\n<li>仿射函数<script type=\"math/tex; mode=display\">f(x)=A\\cdot x+b</script>仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"数据结构目录","date":"2017-08-28T13:50:27.000Z","_content":"\n# 一、绪论\n\n# 二、抽象数据类型ADT\n```c\nADT 抽象数据类型名称{\n      数据对象(Data):<数据对象的定义>\n      数据关系      :<数据关系的定义>\n      基本操作(Operation):<基本操作的定义>\n}ADT抽象数据类型名称\n```\n\n## 线性表\n```c\nADT 线性表（List）\n\nData\n    线性表的数据对象集合为{a1,a2,…,an}，每个元素的类型均为DataType。\n    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。\n    数据元素之间的关系是一对一的关系。\n\nOperation\n    InitList(): 初始化操作，建立一个空的线性表L。\n    DestroyList():线性表已经存在，释放该线性表所占用的存储空间\n    ClearList(): 线性表已经存在，重置线性表为空表，将线性表清空。\n    ListLength(): 线性表已经存在返回线性表L的元素个数。\n    GetElem(): 求线性表L中的第i个位置元素值。\n        初始条件：线性表已存在\n        输入参数：元素序号i，1<=i<=ListLength(L)\n        实现功能：取线性表中序号为i的元素值\n        输出数据：如果序号不合理，则给出错误信息；否则返回序号为i的元素序号值\n        操作结果：线性表不变\n    LocateElem(): 在线性表L中查找与给定值x相等的元素，如果查找成功，返回线性表中第1个值等于x的元素序号;否则返回0。\n        初始条件：线性表已存在\n        输入参数：元素x\n        实现功能：查找线性表中第1个值等于x的元素\n        输出数据：如果查找成功，返回线性表中第1个值等于x的元素序号；否则返回0\n        操作结果：线性表不变\n    ListInsert(): 在线性表L中第i个位置插入新元素e。\n        初始条件：线性表已存在\n        输入参数：插入位置i,1<=i<=ListLength(L)+1,ListLength(L)表示插入前的表长;待插入元素x\n        实现功能：插入x到线性表的第i个位置上\n        输出数据：如果插入不成功，则给出错误信息\n        操作结果：当插入成功时，线性表中增加了一个元素x，且表长增1\n    ListDelete(): 删除线性表L中第i个位置元素，并用e返回其值。\n        初始条件：线性表已存在\n        输入参数：删除位置i,1<=i<=ListLength(L)+1,ListLength(L)表示插入前的表长\n        实现功能：删除线性表中的第i个元素\n        输出数据：如果删除不成功，则给出错误信息。否则返回第i个元素值\n        操作结果：当删除成功时，线性表中减少了一个元素，且表长减1\nendADT\n```\n[顺序表](/2017/08/28/顺序表/)\n[单链表](/2017/08/28/单链表/)\n静态链表.md   没有审核代码\n[循环链表](/2017/08/28/循环链表/)\n双向链表.md   没有审核代码\n\n## 特殊线性表-栈、队列和串\n### 栈：后进先出\n```c\nADT Stack{\n    Data：\n        栈中元素具有相同类型及后进先出特性，相邻元素具有前驱和后继关系\n    Operation：\n        InitStack()：初始化栈，构造一个空栈\n        DestroyStack()：销毁栈，释放栈所占用的存储空间\n        StackLength()：求栈的长度\n        GetTop()：\n              实现功能：读取当前栈顶元素\n              输出数据：如果栈空，则给出错误信息；否则返回当前栈顶元素值\n        Push()：\n              输入参数：待插入元素\n              实现功能：插入元素到栈顶\n              输出数据：如果插入不成功，则给出错误信息\n              操作结果：当插入成功时，栈顶增加了一个元素\n        Pop()：\n              输入参数：无\n              实现功能：删除栈顶元素\n              输出数据：如果栈为空，则给出错误信息；否则返回栈顶元素\n              操作结果：当删除成功时，栈顶减少了一个元素\n}\n```\n栈的顺序储结构栈.md\n栈的链式存储结构.md\n### 队列：先进先出\n```c\nADT Queue{\n    Data：\n        队列中元素具有相同类型及先进先出特性，相邻元素具有前驱和后继关系\n    Operation：\n        InitQueue()：初始化队列，构造一个空队列\n        DestroyQueue()：销毁队列，释放队列所占用的存储空间\n        QueueLength()：求队列的长度\n        GetHead()：\n              实现功能：读取当前队列头元素\n              输出数据：如果队列空，则给出错误信息；否则返回当前队列头元素值\n       EnQueue()：\n              输入参数：待插入元素\n              实现功能：插入元素到队列尾\n              输出数据：如果插入不成功，则给出错误信息\n              操作结果：当插入成功时，队列尾增加了一个元素\n       DeQueue()：\n              输入参数：无\n              实现功能：删除队列头元素\n              输出数据：如果队列为空，则给出错误信息；否则返回队列头元素\n              操作结果：当删除成功时，队列尾减少了一个元素\n}\n```\n队列的顺序存储结构.md\n队列链式存储结构.md\n### 串\n```c\nADT 串(string)\n{\n    Data\n        串中元素仅由一个字符组成,相邻元素具有前驱和后继关系.\n\n    Operation\n        StrAssign(T,*chars):生成一个其值等于字符常量chars的串T.\n        StrCopy(T,S):串S存在,由S复制得到T.\n        ClearString(S):串S存在,将串清空.\n        StringEmpty(S):  若串为空,返回true,否则返回false.\n        StrLentgth(S) :返回串S的元素个数,即串的长度.\n        StrCompare(S,L):比较S和T,若S>T,返回>0,S==T返回0, S<T返回<0\n        SubString(Sub, S, pos, len): 串S存在,1<=pos<=StrLentgth(S),且 0<=len<=StrLentgth(S)-pos+1,用Sub返回串S的第pos个起,长度为len的子串.\n        Index(S,T,pos)\n        Replace(S,T,V)串S,T,V存在,T是非空串,用V替换S中出现的所有与T相等的不重叠的子串.\n        StrInsert(S,T,pos): 在串S的第pos个字符之前插入串T.\n        StrDelete(S,pos,len):从串S中删除第pos个字符起的长度为len的子串.\n}endADT\n```\n串的顺序存储结构.md\n\n## 数组和广义表\n### 数组：由一组类型相同、下标不同的变量构成。\n**根据数组中存储的数据元素之间的逻辑关系，可以将数组分为 : 一维数组、二维数组、…、n维数组。**\n```c\nADT Array {\n\nData:\n\n    相同类型元素有序集合，每个元素受n(n>=1)个线性关系的约束并由一组下标唯一标识\n\nOperation:\n\n    InitArray():  //构造一个空数组,数组的维数和各维的长度\n\n    DestroyArray()：//销毁数组,释放数组所占用的存储空间\n\n    GetValue(A,&e,index1,…,indexn) //求值函数,求某个下标元素的值\n\n        初始条件:A是维数组,e为元素变量,随后是n个下标值.\n\n        操作结果:若各下标不超界,则e赋值为所指定的A的元素值,并返回OK.\n\n    Assign(&A,e,index1,…,indexn)//赋值函数,给下具体的下标的元素赋值\n\n        初始条件:A是n维数组,e为元素变量,随后是n个下标值.\n\n        操作结果:若下标不超界,则将e的值赋给所指定的A的元素,并返回OK.\n\n}ADT Array\n\n```\n\n## 树\n```c\nADT Tree{\n    Data:\n        树\n    Operation：\n        InitTree(&T):构造空树\n        DestroyTree(&T)：销毁树\n        CreateTree(&T,dfinition):\n            初始条件:defination给出树T的定义\n            操作结果：按defination构造树T\n        ClearTree(&T):将树清为空树\n        TreeEmpty(T):若树为空树，则返回TRUE,否则FALSE\n        TreeDepth(T)：返回树的深度\n        Root(T):返回T的根\n        Value(T,node):树T存在，node是T中的某一个结点，返回node的值\n        Assign(T,node,value):树T存在，node是T中的某一个结点，结点node赋值为value\n        Parent(T,node):若node是T的非根结点,返回它的双亲，否则函数值为空\n        LeftChild(T,node):若node是T的非叶子结点,返回它的最左孩子，否则函数值为空\n        RightSiblingChild(T,node):若node右兄弟,返回它的右兄弟，否则函数值为空\n        InsertChild(&T,&p,i,c):树T存在，p指向是T中某一个结点，插入c为T中p所指节点的第i颗子树\n        DeleteChild(&T,&p,i,c):树T存在，p指向是T中某一个结点，删除T中p所指节点的第i颗子树\n        TraveseTree():遍历树\n}ADT Tree\n```\n树与森林.md\n树的存储结构.md    [java版](https://www.cnblogs.com/sun-haiyu/p/7494171.html)\n二叉树.md\n线索二叉树.md\n哈赫夫曼树.md\n## [图](https://www.zybuluo.com/guoxs/note/249812#31-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5)\n```c\nADT 图(Graph)\nData\n    顶点的有穷非空集合和边的集合。\nOperation\n    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。\n    DestroyGraph(*G):      图G存在则销毁。\n    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。\n    GetVex(G, v):          返回图G中顶点v的值。\n    PutVex(G, v, value):    将图G中顶点v赋值value。\n    FirstAdjVex(G, *v):    返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。\n    NextAdjVex(G, v, *w):  返回顶点v相对于顶点w的下一个邻接顶点，\n                            若w是v的最后一个邻接点则返回“空”。\n    InsertVex(*G, v):      在图G中增添新顶点v。\n    DeleteVex(*G, v):      删除图G中顶点v及其相关的弧。\n    InsertArc(*G, v, w):    在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>。\n    DeleteArc(*G, v, w):    在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。\n    DFSTraverse(G):        对图G中进行深度优先遍历，在遍历过程对每个顶点调用。\n    HFSTraverse(G):        对图G中进行广度优先遍历，在遍历过程对每个顶点调用。\nendADT\n```\n\n图的术语与定义.md\n图的抽象结构与存储结构.md(无向图采用多重邻接表，有向图采用十字链表)\n图的遍历.md\n最小生成树.md\n最短路径问题.md\n拓扑排序.md\n关键路径.md\n## 区别.md\n# 查找\n- 静态查找(Static Search Table)：只作查找操作的查找表。主要操作有：\n - 查询某个“特定的”数据元素是否在查找表中。\n - 检索某个“特定的”数据元素和各种属性。\n线性表的查找.md\n- 动态查找表(Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个特定的数据元素。主要操作有两个：\n - 查找时插入数据元素；\n - 查找时删除数据元素。\n查找树.md\n平衡二叉树.md\n2-3树.md\nB树\n红黑树\n- 哈希表\n散列查找.md\n\n# [排序](http://www.atool.org/sort.php)\n- 排序基础代码\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 100\n#define TRUE 1\n#define FALSE 0\n\ntypedef struct {\n\n    int r[MAXSIZE + 1]; // 用于存储要排序的数组， r[0]用作哨兵或者临时变量\n    int length;  // 用于记录顺序表的长度\n}SqList;\n\n/**\n* 交换数组r中下标i和j的值\n*/\nvoid swap(SqList *L, int i, int j){\n    int temp = L->r[i];\n    L->r[i] = L->r[j];\n    L->r[j] = temp;\n}\n```\n\n插入排序.md  (直接插入排序，希尔排序。希尔排序根据直接插入排序而来)\n选择排序.md\n交换排序.md\n归并排序.md(从0开始)\n\n排序代码集合(从0开始).md\n### 性能比较\n排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性\n-|-|-|-|-|-\n冒泡排序| $O(n^2)$| $O(n)$ | $O(n^2)$| $O(1)$ |稳定\n简单选择排序| $O(n^2)$| $O(n^2)$ | $O(n^2)$| $O(1)$ |稳定\n直接插入排序| $O(n^2)$| $O(n)$ | $O(n^2)$| $O(1)$ |稳定\n希尔排序| $O(nlogn)~O(n^2)$| $O(n^{1.3})$ | $O(n^2)$| $O(1)$ |不稳定\n堆排序| $O(nlogn)$| $O(nlogn)$ | $O(nlogn)$| $O(1)$ |不稳定\n归并排序| $O(nlogn)$| $O(nlogn)$ | $O(nlogn)$| $O(n)$ |稳定\n快速排序| $O(nlogn)$| $O(nlogn)$ | $O(n^2)$| $O(nlogn)~O(n)$ |不稳定\n# 附录\n图-邻接矩阵代码.md\n邻接表代码.md\n邻接矩阵与邻接表深度遍历.md\n邻接矩阵与邻接表的广度优先遍历算法.md\n普里姆（Prim）算法代码.md\n克鲁斯卡尔（Kruskal）算法代码.md\n迪杰斯特拉（Dijkstra）算法代码.md\n","source":"_posts/数据结构目录.md","raw":"---\ntitle: 数据结构目录\ndate: 2017-08-28 21:50:27\ntags: [目录]\ncategories: 数据结构\n---\n\n# 一、绪论\n\n# 二、抽象数据类型ADT\n```c\nADT 抽象数据类型名称{\n      数据对象(Data):<数据对象的定义>\n      数据关系      :<数据关系的定义>\n      基本操作(Operation):<基本操作的定义>\n}ADT抽象数据类型名称\n```\n\n## 线性表\n```c\nADT 线性表（List）\n\nData\n    线性表的数据对象集合为{a1,a2,…,an}，每个元素的类型均为DataType。\n    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。\n    数据元素之间的关系是一对一的关系。\n\nOperation\n    InitList(): 初始化操作，建立一个空的线性表L。\n    DestroyList():线性表已经存在，释放该线性表所占用的存储空间\n    ClearList(): 线性表已经存在，重置线性表为空表，将线性表清空。\n    ListLength(): 线性表已经存在返回线性表L的元素个数。\n    GetElem(): 求线性表L中的第i个位置元素值。\n        初始条件：线性表已存在\n        输入参数：元素序号i，1<=i<=ListLength(L)\n        实现功能：取线性表中序号为i的元素值\n        输出数据：如果序号不合理，则给出错误信息；否则返回序号为i的元素序号值\n        操作结果：线性表不变\n    LocateElem(): 在线性表L中查找与给定值x相等的元素，如果查找成功，返回线性表中第1个值等于x的元素序号;否则返回0。\n        初始条件：线性表已存在\n        输入参数：元素x\n        实现功能：查找线性表中第1个值等于x的元素\n        输出数据：如果查找成功，返回线性表中第1个值等于x的元素序号；否则返回0\n        操作结果：线性表不变\n    ListInsert(): 在线性表L中第i个位置插入新元素e。\n        初始条件：线性表已存在\n        输入参数：插入位置i,1<=i<=ListLength(L)+1,ListLength(L)表示插入前的表长;待插入元素x\n        实现功能：插入x到线性表的第i个位置上\n        输出数据：如果插入不成功，则给出错误信息\n        操作结果：当插入成功时，线性表中增加了一个元素x，且表长增1\n    ListDelete(): 删除线性表L中第i个位置元素，并用e返回其值。\n        初始条件：线性表已存在\n        输入参数：删除位置i,1<=i<=ListLength(L)+1,ListLength(L)表示插入前的表长\n        实现功能：删除线性表中的第i个元素\n        输出数据：如果删除不成功，则给出错误信息。否则返回第i个元素值\n        操作结果：当删除成功时，线性表中减少了一个元素，且表长减1\nendADT\n```\n[顺序表](/2017/08/28/顺序表/)\n[单链表](/2017/08/28/单链表/)\n静态链表.md   没有审核代码\n[循环链表](/2017/08/28/循环链表/)\n双向链表.md   没有审核代码\n\n## 特殊线性表-栈、队列和串\n### 栈：后进先出\n```c\nADT Stack{\n    Data：\n        栈中元素具有相同类型及后进先出特性，相邻元素具有前驱和后继关系\n    Operation：\n        InitStack()：初始化栈，构造一个空栈\n        DestroyStack()：销毁栈，释放栈所占用的存储空间\n        StackLength()：求栈的长度\n        GetTop()：\n              实现功能：读取当前栈顶元素\n              输出数据：如果栈空，则给出错误信息；否则返回当前栈顶元素值\n        Push()：\n              输入参数：待插入元素\n              实现功能：插入元素到栈顶\n              输出数据：如果插入不成功，则给出错误信息\n              操作结果：当插入成功时，栈顶增加了一个元素\n        Pop()：\n              输入参数：无\n              实现功能：删除栈顶元素\n              输出数据：如果栈为空，则给出错误信息；否则返回栈顶元素\n              操作结果：当删除成功时，栈顶减少了一个元素\n}\n```\n栈的顺序储结构栈.md\n栈的链式存储结构.md\n### 队列：先进先出\n```c\nADT Queue{\n    Data：\n        队列中元素具有相同类型及先进先出特性，相邻元素具有前驱和后继关系\n    Operation：\n        InitQueue()：初始化队列，构造一个空队列\n        DestroyQueue()：销毁队列，释放队列所占用的存储空间\n        QueueLength()：求队列的长度\n        GetHead()：\n              实现功能：读取当前队列头元素\n              输出数据：如果队列空，则给出错误信息；否则返回当前队列头元素值\n       EnQueue()：\n              输入参数：待插入元素\n              实现功能：插入元素到队列尾\n              输出数据：如果插入不成功，则给出错误信息\n              操作结果：当插入成功时，队列尾增加了一个元素\n       DeQueue()：\n              输入参数：无\n              实现功能：删除队列头元素\n              输出数据：如果队列为空，则给出错误信息；否则返回队列头元素\n              操作结果：当删除成功时，队列尾减少了一个元素\n}\n```\n队列的顺序存储结构.md\n队列链式存储结构.md\n### 串\n```c\nADT 串(string)\n{\n    Data\n        串中元素仅由一个字符组成,相邻元素具有前驱和后继关系.\n\n    Operation\n        StrAssign(T,*chars):生成一个其值等于字符常量chars的串T.\n        StrCopy(T,S):串S存在,由S复制得到T.\n        ClearString(S):串S存在,将串清空.\n        StringEmpty(S):  若串为空,返回true,否则返回false.\n        StrLentgth(S) :返回串S的元素个数,即串的长度.\n        StrCompare(S,L):比较S和T,若S>T,返回>0,S==T返回0, S<T返回<0\n        SubString(Sub, S, pos, len): 串S存在,1<=pos<=StrLentgth(S),且 0<=len<=StrLentgth(S)-pos+1,用Sub返回串S的第pos个起,长度为len的子串.\n        Index(S,T,pos)\n        Replace(S,T,V)串S,T,V存在,T是非空串,用V替换S中出现的所有与T相等的不重叠的子串.\n        StrInsert(S,T,pos): 在串S的第pos个字符之前插入串T.\n        StrDelete(S,pos,len):从串S中删除第pos个字符起的长度为len的子串.\n}endADT\n```\n串的顺序存储结构.md\n\n## 数组和广义表\n### 数组：由一组类型相同、下标不同的变量构成。\n**根据数组中存储的数据元素之间的逻辑关系，可以将数组分为 : 一维数组、二维数组、…、n维数组。**\n```c\nADT Array {\n\nData:\n\n    相同类型元素有序集合，每个元素受n(n>=1)个线性关系的约束并由一组下标唯一标识\n\nOperation:\n\n    InitArray():  //构造一个空数组,数组的维数和各维的长度\n\n    DestroyArray()：//销毁数组,释放数组所占用的存储空间\n\n    GetValue(A,&e,index1,…,indexn) //求值函数,求某个下标元素的值\n\n        初始条件:A是维数组,e为元素变量,随后是n个下标值.\n\n        操作结果:若各下标不超界,则e赋值为所指定的A的元素值,并返回OK.\n\n    Assign(&A,e,index1,…,indexn)//赋值函数,给下具体的下标的元素赋值\n\n        初始条件:A是n维数组,e为元素变量,随后是n个下标值.\n\n        操作结果:若下标不超界,则将e的值赋给所指定的A的元素,并返回OK.\n\n}ADT Array\n\n```\n\n## 树\n```c\nADT Tree{\n    Data:\n        树\n    Operation：\n        InitTree(&T):构造空树\n        DestroyTree(&T)：销毁树\n        CreateTree(&T,dfinition):\n            初始条件:defination给出树T的定义\n            操作结果：按defination构造树T\n        ClearTree(&T):将树清为空树\n        TreeEmpty(T):若树为空树，则返回TRUE,否则FALSE\n        TreeDepth(T)：返回树的深度\n        Root(T):返回T的根\n        Value(T,node):树T存在，node是T中的某一个结点，返回node的值\n        Assign(T,node,value):树T存在，node是T中的某一个结点，结点node赋值为value\n        Parent(T,node):若node是T的非根结点,返回它的双亲，否则函数值为空\n        LeftChild(T,node):若node是T的非叶子结点,返回它的最左孩子，否则函数值为空\n        RightSiblingChild(T,node):若node右兄弟,返回它的右兄弟，否则函数值为空\n        InsertChild(&T,&p,i,c):树T存在，p指向是T中某一个结点，插入c为T中p所指节点的第i颗子树\n        DeleteChild(&T,&p,i,c):树T存在，p指向是T中某一个结点，删除T中p所指节点的第i颗子树\n        TraveseTree():遍历树\n}ADT Tree\n```\n树与森林.md\n树的存储结构.md    [java版](https://www.cnblogs.com/sun-haiyu/p/7494171.html)\n二叉树.md\n线索二叉树.md\n哈赫夫曼树.md\n## [图](https://www.zybuluo.com/guoxs/note/249812#31-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5)\n```c\nADT 图(Graph)\nData\n    顶点的有穷非空集合和边的集合。\nOperation\n    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。\n    DestroyGraph(*G):      图G存在则销毁。\n    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。\n    GetVex(G, v):          返回图G中顶点v的值。\n    PutVex(G, v, value):    将图G中顶点v赋值value。\n    FirstAdjVex(G, *v):    返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。\n    NextAdjVex(G, v, *w):  返回顶点v相对于顶点w的下一个邻接顶点，\n                            若w是v的最后一个邻接点则返回“空”。\n    InsertVex(*G, v):      在图G中增添新顶点v。\n    DeleteVex(*G, v):      删除图G中顶点v及其相关的弧。\n    InsertArc(*G, v, w):    在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>。\n    DeleteArc(*G, v, w):    在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。\n    DFSTraverse(G):        对图G中进行深度优先遍历，在遍历过程对每个顶点调用。\n    HFSTraverse(G):        对图G中进行广度优先遍历，在遍历过程对每个顶点调用。\nendADT\n```\n\n图的术语与定义.md\n图的抽象结构与存储结构.md(无向图采用多重邻接表，有向图采用十字链表)\n图的遍历.md\n最小生成树.md\n最短路径问题.md\n拓扑排序.md\n关键路径.md\n## 区别.md\n# 查找\n- 静态查找(Static Search Table)：只作查找操作的查找表。主要操作有：\n - 查询某个“特定的”数据元素是否在查找表中。\n - 检索某个“特定的”数据元素和各种属性。\n线性表的查找.md\n- 动态查找表(Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个特定的数据元素。主要操作有两个：\n - 查找时插入数据元素；\n - 查找时删除数据元素。\n查找树.md\n平衡二叉树.md\n2-3树.md\nB树\n红黑树\n- 哈希表\n散列查找.md\n\n# [排序](http://www.atool.org/sort.php)\n- 排序基础代码\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 100\n#define TRUE 1\n#define FALSE 0\n\ntypedef struct {\n\n    int r[MAXSIZE + 1]; // 用于存储要排序的数组， r[0]用作哨兵或者临时变量\n    int length;  // 用于记录顺序表的长度\n}SqList;\n\n/**\n* 交换数组r中下标i和j的值\n*/\nvoid swap(SqList *L, int i, int j){\n    int temp = L->r[i];\n    L->r[i] = L->r[j];\n    L->r[j] = temp;\n}\n```\n\n插入排序.md  (直接插入排序，希尔排序。希尔排序根据直接插入排序而来)\n选择排序.md\n交换排序.md\n归并排序.md(从0开始)\n\n排序代码集合(从0开始).md\n### 性能比较\n排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性\n-|-|-|-|-|-\n冒泡排序| $O(n^2)$| $O(n)$ | $O(n^2)$| $O(1)$ |稳定\n简单选择排序| $O(n^2)$| $O(n^2)$ | $O(n^2)$| $O(1)$ |稳定\n直接插入排序| $O(n^2)$| $O(n)$ | $O(n^2)$| $O(1)$ |稳定\n希尔排序| $O(nlogn)~O(n^2)$| $O(n^{1.3})$ | $O(n^2)$| $O(1)$ |不稳定\n堆排序| $O(nlogn)$| $O(nlogn)$ | $O(nlogn)$| $O(1)$ |不稳定\n归并排序| $O(nlogn)$| $O(nlogn)$ | $O(nlogn)$| $O(n)$ |稳定\n快速排序| $O(nlogn)$| $O(nlogn)$ | $O(n^2)$| $O(nlogn)~O(n)$ |不稳定\n# 附录\n图-邻接矩阵代码.md\n邻接表代码.md\n邻接矩阵与邻接表深度遍历.md\n邻接矩阵与邻接表的广度优先遍历算法.md\n普里姆（Prim）算法代码.md\n克鲁斯卡尔（Kruskal）算法代码.md\n迪杰斯特拉（Dijkstra）算法代码.md\n","slug":"数据结构目录","published":1,"updated":"2019-07-30T01:54:38.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0h0055homjq6341jtr","content":"<h1 id=\"一、绪论\"><a href=\"#一、绪论\" class=\"headerlink\" title=\"一、绪论\"></a>一、绪论</h1><h1 id=\"二、抽象数据类型ADT\"><a href=\"#二、抽象数据类型ADT\" class=\"headerlink\" title=\"二、抽象数据类型ADT\"></a>二、抽象数据类型ADT</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名称&#123;</span><br><span class=\"line\">      数据对象(Data):&lt;数据对象的定义&gt;</span><br><span class=\"line\">      数据关系      :&lt;数据关系的定义&gt;</span><br><span class=\"line\">      基本操作(Operation):&lt;基本操作的定义&gt;</span><br><span class=\"line\">&#125;ADT抽象数据类型名称</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 线性表（List）</span><br><span class=\"line\"></span><br><span class=\"line\">Data</span><br><span class=\"line\">    线性表的数据对象集合为&#123;a1,a2,…,an&#125;，每个元素的类型均为DataType。</span><br><span class=\"line\">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class=\"line\">    数据元素之间的关系是一对一的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">Operation</span><br><span class=\"line\">    InitList(): 初始化操作，建立一个空的线性表L。</span><br><span class=\"line\">    DestroyList():线性表已经存在，释放该线性表所占用的存储空间</span><br><span class=\"line\">    ClearList(): 线性表已经存在，重置线性表为空表，将线性表清空。</span><br><span class=\"line\">    ListLength(): 线性表已经存在返回线性表L的元素个数。</span><br><span class=\"line\">    GetElem(): 求线性表L中的第i个位置元素值。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：元素序号i，<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)</span><br><span class=\"line\">        实现功能：取线性表中序号为i的元素值</span><br><span class=\"line\">        输出数据：如果序号不合理，则给出错误信息；否则返回序号为i的元素序号值</span><br><span class=\"line\">        操作结果：线性表不变</span><br><span class=\"line\">    LocateElem(): 在线性表L中查找与给定值x相等的元素，如果查找成功，返回线性表中第<span class=\"number\">1</span>个值等于x的元素序号;否则返回<span class=\"number\">0</span>。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：元素x</span><br><span class=\"line\">        实现功能：查找线性表中第<span class=\"number\">1</span>个值等于x的元素</span><br><span class=\"line\">        输出数据：如果查找成功，返回线性表中第<span class=\"number\">1</span>个值等于x的元素序号；否则返回<span class=\"number\">0</span></span><br><span class=\"line\">        操作结果：线性表不变</span><br><span class=\"line\">    ListInsert(): 在线性表L中第i个位置插入新元素e。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：插入位置i,<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)+<span class=\"number\">1</span>,ListLength(L)表示插入前的表长;待插入元素x</span><br><span class=\"line\">        实现功能：插入x到线性表的第i个位置上</span><br><span class=\"line\">        输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">        操作结果：当插入成功时，线性表中增加了一个元素x，且表长增<span class=\"number\">1</span></span><br><span class=\"line\">    ListDelete(): 删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：删除位置i,<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)+<span class=\"number\">1</span>,ListLength(L)表示插入前的表长</span><br><span class=\"line\">        实现功能：删除线性表中的第i个元素</span><br><span class=\"line\">        输出数据：如果删除不成功，则给出错误信息。否则返回第i个元素值</span><br><span class=\"line\">        操作结果：当删除成功时，线性表中减少了一个元素，且表长减<span class=\"number\">1</span></span><br><span class=\"line\">endADT</span><br></pre></td></tr></table></figure>\n<p><a href=\"/2017/08/28/顺序表/\">顺序表</a><br><a href=\"/2017/08/28/单链表/\">单链表</a><br>静态链表.md   没有审核代码<br><a href=\"/2017/08/28/循环链表/\">循环链表</a><br>双向链表.md   没有审核代码</p>\n<h2 id=\"特殊线性表-栈、队列和串\"><a href=\"#特殊线性表-栈、队列和串\" class=\"headerlink\" title=\"特殊线性表-栈、队列和串\"></a>特殊线性表-栈、队列和串</h2><h3 id=\"栈：后进先出\"><a href=\"#栈：后进先出\" class=\"headerlink\" title=\"栈：后进先出\"></a>栈：后进先出</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Stack&#123;</span><br><span class=\"line\">    Data：</span><br><span class=\"line\">        栈中元素具有相同类型及后进先出特性，相邻元素具有前驱和后继关系</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitStack()：初始化栈，构造一个空栈</span><br><span class=\"line\">        DestroyStack()：销毁栈，释放栈所占用的存储空间</span><br><span class=\"line\">        StackLength()：求栈的长度</span><br><span class=\"line\">        GetTop()：</span><br><span class=\"line\">              实现功能：读取当前栈顶元素</span><br><span class=\"line\">              输出数据：如果栈空，则给出错误信息；否则返回当前栈顶元素值</span><br><span class=\"line\">        Push()：</span><br><span class=\"line\">              输入参数：待插入元素</span><br><span class=\"line\">              实现功能：插入元素到栈顶</span><br><span class=\"line\">              输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">              操作结果：当插入成功时，栈顶增加了一个元素</span><br><span class=\"line\">        Pop()：</span><br><span class=\"line\">              输入参数：无</span><br><span class=\"line\">              实现功能：删除栈顶元素</span><br><span class=\"line\">              输出数据：如果栈为空，则给出错误信息；否则返回栈顶元素</span><br><span class=\"line\">              操作结果：当删除成功时，栈顶减少了一个元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>栈的顺序储结构栈.md<br>栈的链式存储结构.md</p>\n<h3 id=\"队列：先进先出\"><a href=\"#队列：先进先出\" class=\"headerlink\" title=\"队列：先进先出\"></a>队列：先进先出</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Queue&#123;</span><br><span class=\"line\">    Data：</span><br><span class=\"line\">        队列中元素具有相同类型及先进先出特性，相邻元素具有前驱和后继关系</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitQueue()：初始化队列，构造一个空队列</span><br><span class=\"line\">        DestroyQueue()：销毁队列，释放队列所占用的存储空间</span><br><span class=\"line\">        QueueLength()：求队列的长度</span><br><span class=\"line\">        GetHead()：</span><br><span class=\"line\">              实现功能：读取当前队列头元素</span><br><span class=\"line\">              输出数据：如果队列空，则给出错误信息；否则返回当前队列头元素值</span><br><span class=\"line\">       EnQueue()：</span><br><span class=\"line\">              输入参数：待插入元素</span><br><span class=\"line\">              实现功能：插入元素到队列尾</span><br><span class=\"line\">              输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">              操作结果：当插入成功时，队列尾增加了一个元素</span><br><span class=\"line\">       DeQueue()：</span><br><span class=\"line\">              输入参数：无</span><br><span class=\"line\">              实现功能：删除队列头元素</span><br><span class=\"line\">              输出数据：如果队列为空，则给出错误信息；否则返回队列头元素</span><br><span class=\"line\">              操作结果：当删除成功时，队列尾减少了一个元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>队列的顺序存储结构.md<br>队列链式存储结构.md</p>\n<h3 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 串(<span class=\"built_in\">string</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Data</span><br><span class=\"line\">        串中元素仅由一个字符组成,相邻元素具有前驱和后继关系.</span><br><span class=\"line\"></span><br><span class=\"line\">    Operation</span><br><span class=\"line\">        StrAssign(T,*chars):生成一个其值等于字符常量chars的串T.</span><br><span class=\"line\">        StrCopy(T,S):串S存在,由S复制得到T.</span><br><span class=\"line\">        ClearString(S):串S存在,将串清空.</span><br><span class=\"line\">        StringEmpty(S):  若串为空,返回<span class=\"literal\">true</span>,否则返回<span class=\"literal\">false</span>.</span><br><span class=\"line\">        StrLentgth(S) :返回串S的元素个数,即串的长度.</span><br><span class=\"line\">        StrCompare(S,L):比较S和T,若S&gt;T,返回&gt;<span class=\"number\">0</span>,S==T返回<span class=\"number\">0</span>, S&lt;T返回&lt;<span class=\"number\">0</span></span><br><span class=\"line\">        SubString(Sub, S, pos, len): 串S存在,<span class=\"number\">1</span>&lt;=pos&lt;=StrLentgth(S),且 <span class=\"number\">0</span>&lt;=len&lt;=StrLentgth(S)-pos+<span class=\"number\">1</span>,用Sub返回串S的第pos个起,长度为len的子串.</span><br><span class=\"line\">        Index(S,T,pos)</span><br><span class=\"line\">        Replace(S,T,V)串S,T,V存在,T是非空串,用V替换S中出现的所有与T相等的不重叠的子串.</span><br><span class=\"line\">        StrInsert(S,T,pos): 在串S的第pos个字符之前插入串T.</span><br><span class=\"line\">        StrDelete(S,pos,len):从串S中删除第pos个字符起的长度为len的子串.</span><br><span class=\"line\">&#125;endADT</span><br></pre></td></tr></table></figure>\n<p>串的顺序存储结构.md</p>\n<h2 id=\"数组和广义表\"><a href=\"#数组和广义表\" class=\"headerlink\" title=\"数组和广义表\"></a>数组和广义表</h2><h3 id=\"数组：由一组类型相同、下标不同的变量构成。\"><a href=\"#数组：由一组类型相同、下标不同的变量构成。\" class=\"headerlink\" title=\"数组：由一组类型相同、下标不同的变量构成。\"></a>数组：由一组类型相同、下标不同的变量构成。</h3><p><strong>根据数组中存储的数据元素之间的逻辑关系，可以将数组分为 : 一维数组、二维数组、…、n维数组。</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Array &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">Data:</span><br><span class=\"line\"></span><br><span class=\"line\">    相同类型元素有序集合，每个元素受n(n&gt;=<span class=\"number\">1</span>)个线性关系的约束并由一组下标唯一标识</span><br><span class=\"line\"></span><br><span class=\"line\">Operation:</span><br><span class=\"line\"></span><br><span class=\"line\">    InitArray():  <span class=\"comment\">//构造一个空数组,数组的维数和各维的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DestroyArray()：<span class=\"comment\">//销毁数组,释放数组所占用的存储空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetValue(A,&amp;e,index1,…,indexn) <span class=\"comment\">//求值函数,求某个下标元素的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        初始条件:A是维数组,e为元素变量,随后是n个下标值.</span><br><span class=\"line\"></span><br><span class=\"line\">        操作结果:若各下标不超界,则e赋值为所指定的A的元素值,并返回OK.</span><br><span class=\"line\"></span><br><span class=\"line\">    Assign(&amp;A,e,index1,…,indexn)<span class=\"comment\">//赋值函数,给下具体的下标的元素赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        初始条件:A是n维数组,e为元素变量,随后是n个下标值.</span><br><span class=\"line\"></span><br><span class=\"line\">        操作结果:若下标不超界,则将e的值赋给所指定的A的元素,并返回OK.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;ADT Array</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Tree&#123;</span><br><span class=\"line\">    Data:</span><br><span class=\"line\">        树</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitTree(&amp;T):构造空树</span><br><span class=\"line\">        DestroyTree(&amp;T)：销毁树</span><br><span class=\"line\">        CreateTree(&amp;T,dfinition):</span><br><span class=\"line\">            初始条件:defination给出树T的定义</span><br><span class=\"line\">            操作结果：按defination构造树T</span><br><span class=\"line\">        ClearTree(&amp;T):将树清为空树</span><br><span class=\"line\">        TreeEmpty(T):若树为空树，则返回TRUE,否则FALSE</span><br><span class=\"line\">        TreeDepth(T)：返回树的深度</span><br><span class=\"line\">        Root(T):返回T的根</span><br><span class=\"line\">        Value(T,node):树T存在，node是T中的某一个结点，返回node的值</span><br><span class=\"line\">        Assign(T,node,value):树T存在，node是T中的某一个结点，结点node赋值为value</span><br><span class=\"line\">        Parent(T,node):若node是T的非根结点,返回它的双亲，否则函数值为空</span><br><span class=\"line\">        LeftChild(T,node):若node是T的非叶子结点,返回它的最左孩子，否则函数值为空</span><br><span class=\"line\">        RightSiblingChild(T,node):若node右兄弟,返回它的右兄弟，否则函数值为空</span><br><span class=\"line\">        InsertChild(&amp;T,&amp;p,i,c):树T存在，p指向是T中某一个结点，插入c为T中p所指节点的第i颗子树</span><br><span class=\"line\">        DeleteChild(&amp;T,&amp;p,i,c):树T存在，p指向是T中某一个结点，删除T中p所指节点的第i颗子树</span><br><span class=\"line\">        TraveseTree():遍历树</span><br><span class=\"line\">&#125;ADT Tree</span><br></pre></td></tr></table></figure>\n<p>树与森林.md<br>树的存储结构.md    <a href=\"https://www.cnblogs.com/sun-haiyu/p/7494171.html\" target=\"_blank\" rel=\"noopener\">java版</a><br>二叉树.md<br>线索二叉树.md<br>哈赫夫曼树.md</p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a><a href=\"https://www.zybuluo.com/guoxs/note/249812#31-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">图</a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 图(Graph)</span><br><span class=\"line\">Data</span><br><span class=\"line\">    顶点的有穷非空集合和边的集合。</span><br><span class=\"line\">Operation</span><br><span class=\"line\">    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。</span><br><span class=\"line\">    DestroyGraph(*G):      图G存在则销毁。</span><br><span class=\"line\">    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。</span><br><span class=\"line\">    GetVex(G, v):          返回图G中顶点v的值。</span><br><span class=\"line\">    PutVex(G, v, value):    将图G中顶点v赋值value。</span><br><span class=\"line\">    FirstAdjVex(G, *v):    返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。</span><br><span class=\"line\">    NextAdjVex(G, v, *w):  返回顶点v相对于顶点w的下一个邻接顶点，</span><br><span class=\"line\">                            若w是v的最后一个邻接点则返回“空”。</span><br><span class=\"line\">    InsertVex(*G, v):      在图G中增添新顶点v。</span><br><span class=\"line\">    DeleteVex(*G, v):      删除图G中顶点v及其相关的弧。</span><br><span class=\"line\">    InsertArc(*G, v, w):    在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。</span><br><span class=\"line\">    DeleteArc(*G, v, w):    在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。</span><br><span class=\"line\">    DFSTraverse(G):        对图G中进行深度优先遍历，在遍历过程对每个顶点调用。</span><br><span class=\"line\">    HFSTraverse(G):        对图G中进行广度优先遍历，在遍历过程对每个顶点调用。</span><br><span class=\"line\">endADT</span><br></pre></td></tr></table></figure>\n<p>图的术语与定义.md<br>图的抽象结构与存储结构.md(无向图采用多重邻接表，有向图采用十字链表)<br>图的遍历.md<br>最小生成树.md<br>最短路径问题.md<br>拓扑排序.md<br>关键路径.md</p>\n<h2 id=\"区别-md\"><a href=\"#区别-md\" class=\"headerlink\" title=\"区别.md\"></a>区别.md</h2><h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><ul>\n<li>静态查找(Static Search Table)：只作查找操作的查找表。主要操作有：<ul>\n<li>查询某个“特定的”数据元素是否在查找表中。</li>\n<li>检索某个“特定的”数据元素和各种属性。<br>线性表的查找.md</li>\n</ul>\n</li>\n<li>动态查找表(Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个特定的数据元素。主要操作有两个：<ul>\n<li>查找时插入数据元素；</li>\n<li>查找时删除数据元素。<br>查找树.md<br>平衡二叉树.md<br>2-3树.md<br>B树<br>红黑树</li>\n</ul>\n</li>\n<li>哈希表<br>散列查找.md</li>\n</ul>\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a><a href=\"http://www.atool.org/sort.php\" target=\"_blank\" rel=\"noopener\">排序</a></h1><ul>\n<li>排序基础代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r[MAXSIZE + <span class=\"number\">1</span>]; <span class=\"comment\">// 用于存储要排序的数组， r[0]用作哨兵或者临时变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;  <span class=\"comment\">// 用于记录顺序表的长度</span></span><br><span class=\"line\">&#125;SqList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 交换数组r中下标i和j的值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(SqList *L, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = L-&gt;r[i];</span><br><span class=\"line\">    L-&gt;r[i] = L-&gt;r[j];</span><br><span class=\"line\">    L-&gt;r[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>插入排序.md  (直接插入排序，希尔排序。希尔排序根据直接插入排序而来)<br>选择排序.md<br>交换排序.md<br>归并排序.md(从0开始)</p>\n<p>排序代码集合(从0开始).md</p>\n<h3 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>简单选择排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>$O(nlogn)~O(n^2)$</td>\n<td>$O(n^{1.3})$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(1)$</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(n)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(n^2)$</td>\n<td>$O(nlogn)~O(n)$</td>\n<td>不稳定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><p>图-邻接矩阵代码.md<br>邻接表代码.md<br>邻接矩阵与邻接表深度遍历.md<br>邻接矩阵与邻接表的广度优先遍历算法.md<br>普里姆（Prim）算法代码.md<br>克鲁斯卡尔（Kruskal）算法代码.md<br>迪杰斯特拉（Dijkstra）算法代码.md</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、绪论\"><a href=\"#一、绪论\" class=\"headerlink\" title=\"一、绪论\"></a>一、绪论</h1><h1 id=\"二、抽象数据类型ADT\"><a href=\"#二、抽象数据类型ADT\" class=\"headerlink\" title=\"二、抽象数据类型ADT\"></a>二、抽象数据类型ADT</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 抽象数据类型名称&#123;</span><br><span class=\"line\">      数据对象(Data):&lt;数据对象的定义&gt;</span><br><span class=\"line\">      数据关系      :&lt;数据关系的定义&gt;</span><br><span class=\"line\">      基本操作(Operation):&lt;基本操作的定义&gt;</span><br><span class=\"line\">&#125;ADT抽象数据类型名称</span><br></pre></td></tr></table></figure>\n<h2 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 线性表（List）</span><br><span class=\"line\"></span><br><span class=\"line\">Data</span><br><span class=\"line\">    线性表的数据对象集合为&#123;a1,a2,…,an&#125;，每个元素的类型均为DataType。</span><br><span class=\"line\">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class=\"line\">    数据元素之间的关系是一对一的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">Operation</span><br><span class=\"line\">    InitList(): 初始化操作，建立一个空的线性表L。</span><br><span class=\"line\">    DestroyList():线性表已经存在，释放该线性表所占用的存储空间</span><br><span class=\"line\">    ClearList(): 线性表已经存在，重置线性表为空表，将线性表清空。</span><br><span class=\"line\">    ListLength(): 线性表已经存在返回线性表L的元素个数。</span><br><span class=\"line\">    GetElem(): 求线性表L中的第i个位置元素值。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：元素序号i，<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)</span><br><span class=\"line\">        实现功能：取线性表中序号为i的元素值</span><br><span class=\"line\">        输出数据：如果序号不合理，则给出错误信息；否则返回序号为i的元素序号值</span><br><span class=\"line\">        操作结果：线性表不变</span><br><span class=\"line\">    LocateElem(): 在线性表L中查找与给定值x相等的元素，如果查找成功，返回线性表中第<span class=\"number\">1</span>个值等于x的元素序号;否则返回<span class=\"number\">0</span>。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：元素x</span><br><span class=\"line\">        实现功能：查找线性表中第<span class=\"number\">1</span>个值等于x的元素</span><br><span class=\"line\">        输出数据：如果查找成功，返回线性表中第<span class=\"number\">1</span>个值等于x的元素序号；否则返回<span class=\"number\">0</span></span><br><span class=\"line\">        操作结果：线性表不变</span><br><span class=\"line\">    ListInsert(): 在线性表L中第i个位置插入新元素e。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：插入位置i,<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)+<span class=\"number\">1</span>,ListLength(L)表示插入前的表长;待插入元素x</span><br><span class=\"line\">        实现功能：插入x到线性表的第i个位置上</span><br><span class=\"line\">        输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">        操作结果：当插入成功时，线性表中增加了一个元素x，且表长增<span class=\"number\">1</span></span><br><span class=\"line\">    ListDelete(): 删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class=\"line\">        初始条件：线性表已存在</span><br><span class=\"line\">        输入参数：删除位置i,<span class=\"number\">1</span>&lt;=i&lt;=ListLength(L)+<span class=\"number\">1</span>,ListLength(L)表示插入前的表长</span><br><span class=\"line\">        实现功能：删除线性表中的第i个元素</span><br><span class=\"line\">        输出数据：如果删除不成功，则给出错误信息。否则返回第i个元素值</span><br><span class=\"line\">        操作结果：当删除成功时，线性表中减少了一个元素，且表长减<span class=\"number\">1</span></span><br><span class=\"line\">endADT</span><br></pre></td></tr></table></figure>\n<p><a href=\"/2017/08/28/顺序表/\">顺序表</a><br><a href=\"/2017/08/28/单链表/\">单链表</a><br>静态链表.md   没有审核代码<br><a href=\"/2017/08/28/循环链表/\">循环链表</a><br>双向链表.md   没有审核代码</p>\n<h2 id=\"特殊线性表-栈、队列和串\"><a href=\"#特殊线性表-栈、队列和串\" class=\"headerlink\" title=\"特殊线性表-栈、队列和串\"></a>特殊线性表-栈、队列和串</h2><h3 id=\"栈：后进先出\"><a href=\"#栈：后进先出\" class=\"headerlink\" title=\"栈：后进先出\"></a>栈：后进先出</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Stack&#123;</span><br><span class=\"line\">    Data：</span><br><span class=\"line\">        栈中元素具有相同类型及后进先出特性，相邻元素具有前驱和后继关系</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitStack()：初始化栈，构造一个空栈</span><br><span class=\"line\">        DestroyStack()：销毁栈，释放栈所占用的存储空间</span><br><span class=\"line\">        StackLength()：求栈的长度</span><br><span class=\"line\">        GetTop()：</span><br><span class=\"line\">              实现功能：读取当前栈顶元素</span><br><span class=\"line\">              输出数据：如果栈空，则给出错误信息；否则返回当前栈顶元素值</span><br><span class=\"line\">        Push()：</span><br><span class=\"line\">              输入参数：待插入元素</span><br><span class=\"line\">              实现功能：插入元素到栈顶</span><br><span class=\"line\">              输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">              操作结果：当插入成功时，栈顶增加了一个元素</span><br><span class=\"line\">        Pop()：</span><br><span class=\"line\">              输入参数：无</span><br><span class=\"line\">              实现功能：删除栈顶元素</span><br><span class=\"line\">              输出数据：如果栈为空，则给出错误信息；否则返回栈顶元素</span><br><span class=\"line\">              操作结果：当删除成功时，栈顶减少了一个元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>栈的顺序储结构栈.md<br>栈的链式存储结构.md</p>\n<h3 id=\"队列：先进先出\"><a href=\"#队列：先进先出\" class=\"headerlink\" title=\"队列：先进先出\"></a>队列：先进先出</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Queue&#123;</span><br><span class=\"line\">    Data：</span><br><span class=\"line\">        队列中元素具有相同类型及先进先出特性，相邻元素具有前驱和后继关系</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitQueue()：初始化队列，构造一个空队列</span><br><span class=\"line\">        DestroyQueue()：销毁队列，释放队列所占用的存储空间</span><br><span class=\"line\">        QueueLength()：求队列的长度</span><br><span class=\"line\">        GetHead()：</span><br><span class=\"line\">              实现功能：读取当前队列头元素</span><br><span class=\"line\">              输出数据：如果队列空，则给出错误信息；否则返回当前队列头元素值</span><br><span class=\"line\">       EnQueue()：</span><br><span class=\"line\">              输入参数：待插入元素</span><br><span class=\"line\">              实现功能：插入元素到队列尾</span><br><span class=\"line\">              输出数据：如果插入不成功，则给出错误信息</span><br><span class=\"line\">              操作结果：当插入成功时，队列尾增加了一个元素</span><br><span class=\"line\">       DeQueue()：</span><br><span class=\"line\">              输入参数：无</span><br><span class=\"line\">              实现功能：删除队列头元素</span><br><span class=\"line\">              输出数据：如果队列为空，则给出错误信息；否则返回队列头元素</span><br><span class=\"line\">              操作结果：当删除成功时，队列尾减少了一个元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>队列的顺序存储结构.md<br>队列链式存储结构.md</p>\n<h3 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 串(<span class=\"built_in\">string</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Data</span><br><span class=\"line\">        串中元素仅由一个字符组成,相邻元素具有前驱和后继关系.</span><br><span class=\"line\"></span><br><span class=\"line\">    Operation</span><br><span class=\"line\">        StrAssign(T,*chars):生成一个其值等于字符常量chars的串T.</span><br><span class=\"line\">        StrCopy(T,S):串S存在,由S复制得到T.</span><br><span class=\"line\">        ClearString(S):串S存在,将串清空.</span><br><span class=\"line\">        StringEmpty(S):  若串为空,返回<span class=\"literal\">true</span>,否则返回<span class=\"literal\">false</span>.</span><br><span class=\"line\">        StrLentgth(S) :返回串S的元素个数,即串的长度.</span><br><span class=\"line\">        StrCompare(S,L):比较S和T,若S&gt;T,返回&gt;<span class=\"number\">0</span>,S==T返回<span class=\"number\">0</span>, S&lt;T返回&lt;<span class=\"number\">0</span></span><br><span class=\"line\">        SubString(Sub, S, pos, len): 串S存在,<span class=\"number\">1</span>&lt;=pos&lt;=StrLentgth(S),且 <span class=\"number\">0</span>&lt;=len&lt;=StrLentgth(S)-pos+<span class=\"number\">1</span>,用Sub返回串S的第pos个起,长度为len的子串.</span><br><span class=\"line\">        Index(S,T,pos)</span><br><span class=\"line\">        Replace(S,T,V)串S,T,V存在,T是非空串,用V替换S中出现的所有与T相等的不重叠的子串.</span><br><span class=\"line\">        StrInsert(S,T,pos): 在串S的第pos个字符之前插入串T.</span><br><span class=\"line\">        StrDelete(S,pos,len):从串S中删除第pos个字符起的长度为len的子串.</span><br><span class=\"line\">&#125;endADT</span><br></pre></td></tr></table></figure>\n<p>串的顺序存储结构.md</p>\n<h2 id=\"数组和广义表\"><a href=\"#数组和广义表\" class=\"headerlink\" title=\"数组和广义表\"></a>数组和广义表</h2><h3 id=\"数组：由一组类型相同、下标不同的变量构成。\"><a href=\"#数组：由一组类型相同、下标不同的变量构成。\" class=\"headerlink\" title=\"数组：由一组类型相同、下标不同的变量构成。\"></a>数组：由一组类型相同、下标不同的变量构成。</h3><p><strong>根据数组中存储的数据元素之间的逻辑关系，可以将数组分为 : 一维数组、二维数组、…、n维数组。</strong><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Array &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">Data:</span><br><span class=\"line\"></span><br><span class=\"line\">    相同类型元素有序集合，每个元素受n(n&gt;=<span class=\"number\">1</span>)个线性关系的约束并由一组下标唯一标识</span><br><span class=\"line\"></span><br><span class=\"line\">Operation:</span><br><span class=\"line\"></span><br><span class=\"line\">    InitArray():  <span class=\"comment\">//构造一个空数组,数组的维数和各维的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    DestroyArray()：<span class=\"comment\">//销毁数组,释放数组所占用的存储空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetValue(A,&amp;e,index1,…,indexn) <span class=\"comment\">//求值函数,求某个下标元素的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        初始条件:A是维数组,e为元素变量,随后是n个下标值.</span><br><span class=\"line\"></span><br><span class=\"line\">        操作结果:若各下标不超界,则e赋值为所指定的A的元素值,并返回OK.</span><br><span class=\"line\"></span><br><span class=\"line\">    Assign(&amp;A,e,index1,…,indexn)<span class=\"comment\">//赋值函数,给下具体的下标的元素赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">        初始条件:A是n维数组,e为元素变量,随后是n个下标值.</span><br><span class=\"line\"></span><br><span class=\"line\">        操作结果:若下标不超界,则将e的值赋给所指定的A的元素,并返回OK.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;ADT Array</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT Tree&#123;</span><br><span class=\"line\">    Data:</span><br><span class=\"line\">        树</span><br><span class=\"line\">    Operation：</span><br><span class=\"line\">        InitTree(&amp;T):构造空树</span><br><span class=\"line\">        DestroyTree(&amp;T)：销毁树</span><br><span class=\"line\">        CreateTree(&amp;T,dfinition):</span><br><span class=\"line\">            初始条件:defination给出树T的定义</span><br><span class=\"line\">            操作结果：按defination构造树T</span><br><span class=\"line\">        ClearTree(&amp;T):将树清为空树</span><br><span class=\"line\">        TreeEmpty(T):若树为空树，则返回TRUE,否则FALSE</span><br><span class=\"line\">        TreeDepth(T)：返回树的深度</span><br><span class=\"line\">        Root(T):返回T的根</span><br><span class=\"line\">        Value(T,node):树T存在，node是T中的某一个结点，返回node的值</span><br><span class=\"line\">        Assign(T,node,value):树T存在，node是T中的某一个结点，结点node赋值为value</span><br><span class=\"line\">        Parent(T,node):若node是T的非根结点,返回它的双亲，否则函数值为空</span><br><span class=\"line\">        LeftChild(T,node):若node是T的非叶子结点,返回它的最左孩子，否则函数值为空</span><br><span class=\"line\">        RightSiblingChild(T,node):若node右兄弟,返回它的右兄弟，否则函数值为空</span><br><span class=\"line\">        InsertChild(&amp;T,&amp;p,i,c):树T存在，p指向是T中某一个结点，插入c为T中p所指节点的第i颗子树</span><br><span class=\"line\">        DeleteChild(&amp;T,&amp;p,i,c):树T存在，p指向是T中某一个结点，删除T中p所指节点的第i颗子树</span><br><span class=\"line\">        TraveseTree():遍历树</span><br><span class=\"line\">&#125;ADT Tree</span><br></pre></td></tr></table></figure>\n<p>树与森林.md<br>树的存储结构.md    <a href=\"https://www.cnblogs.com/sun-haiyu/p/7494171.html\" target=\"_blank\" rel=\"noopener\">java版</a><br>二叉树.md<br>线索二叉树.md<br>哈赫夫曼树.md</p>\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a><a href=\"https://www.zybuluo.com/guoxs/note/249812#31-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5\" target=\"_blank\" rel=\"noopener\">图</a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 图(Graph)</span><br><span class=\"line\">Data</span><br><span class=\"line\">    顶点的有穷非空集合和边的集合。</span><br><span class=\"line\">Operation</span><br><span class=\"line\">    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。</span><br><span class=\"line\">    DestroyGraph(*G):      图G存在则销毁。</span><br><span class=\"line\">    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。</span><br><span class=\"line\">    GetVex(G, v):          返回图G中顶点v的值。</span><br><span class=\"line\">    PutVex(G, v, value):    将图G中顶点v赋值value。</span><br><span class=\"line\">    FirstAdjVex(G, *v):    返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。</span><br><span class=\"line\">    NextAdjVex(G, v, *w):  返回顶点v相对于顶点w的下一个邻接顶点，</span><br><span class=\"line\">                            若w是v的最后一个邻接点则返回“空”。</span><br><span class=\"line\">    InsertVex(*G, v):      在图G中增添新顶点v。</span><br><span class=\"line\">    DeleteVex(*G, v):      删除图G中顶点v及其相关的弧。</span><br><span class=\"line\">    InsertArc(*G, v, w):    在图G中增添弧&lt;v,w&gt;，若G是无向图，还需要增添对称弧&lt;w,v&gt;。</span><br><span class=\"line\">    DeleteArc(*G, v, w):    在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。</span><br><span class=\"line\">    DFSTraverse(G):        对图G中进行深度优先遍历，在遍历过程对每个顶点调用。</span><br><span class=\"line\">    HFSTraverse(G):        对图G中进行广度优先遍历，在遍历过程对每个顶点调用。</span><br><span class=\"line\">endADT</span><br></pre></td></tr></table></figure>\n<p>图的术语与定义.md<br>图的抽象结构与存储结构.md(无向图采用多重邻接表，有向图采用十字链表)<br>图的遍历.md<br>最小生成树.md<br>最短路径问题.md<br>拓扑排序.md<br>关键路径.md</p>\n<h2 id=\"区别-md\"><a href=\"#区别-md\" class=\"headerlink\" title=\"区别.md\"></a>区别.md</h2><h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><ul>\n<li>静态查找(Static Search Table)：只作查找操作的查找表。主要操作有：<ul>\n<li>查询某个“特定的”数据元素是否在查找表中。</li>\n<li>检索某个“特定的”数据元素和各种属性。<br>线性表的查找.md</li>\n</ul>\n</li>\n<li>动态查找表(Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个特定的数据元素。主要操作有两个：<ul>\n<li>查找时插入数据元素；</li>\n<li>查找时删除数据元素。<br>查找树.md<br>平衡二叉树.md<br>2-3树.md<br>B树<br>红黑树</li>\n</ul>\n</li>\n<li>哈希表<br>散列查找.md</li>\n</ul>\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a><a href=\"http://www.atool.org/sort.php\" target=\"_blank\" rel=\"noopener\">排序</a></h1><ul>\n<li>排序基础代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r[MAXSIZE + <span class=\"number\">1</span>]; <span class=\"comment\">// 用于存储要排序的数组， r[0]用作哨兵或者临时变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;  <span class=\"comment\">// 用于记录顺序表的长度</span></span><br><span class=\"line\">&#125;SqList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 交换数组r中下标i和j的值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(SqList *L, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = L-&gt;r[i];</span><br><span class=\"line\">    L-&gt;r[i] = L-&gt;r[j];</span><br><span class=\"line\">    L-&gt;r[j] = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>插入排序.md  (直接插入排序，希尔排序。希尔排序根据直接插入排序而来)<br>选择排序.md<br>交换排序.md<br>归并排序.md(从0开始)</p>\n<p>排序代码集合(从0开始).md</p>\n<h3 id=\"性能比较\"><a href=\"#性能比较\" class=\"headerlink\" title=\"性能比较\"></a>性能比较</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>排序方法</th>\n<th>平均情况</th>\n<th>最好情况</th>\n<th>最坏情况</th>\n<th>辅助空间</th>\n<th>稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>简单选择排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>$O(nlogn)~O(n^2)$</td>\n<td>$O(n^{1.3})$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(1)$</td>\n<td>不稳定</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(n)$</td>\n<td>稳定</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>$O(nlogn)$</td>\n<td>$O(nlogn)$</td>\n<td>$O(n^2)$</td>\n<td>$O(nlogn)~O(n)$</td>\n<td>不稳定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><p>图-邻接矩阵代码.md<br>邻接表代码.md<br>邻接矩阵与邻接表深度遍历.md<br>邻接矩阵与邻接表的广度优先遍历算法.md<br>普里姆（Prim）算法代码.md<br>克鲁斯卡尔（Kruskal）算法代码.md<br>迪杰斯特拉（Dijkstra）算法代码.md</p>\n"},{"title":"样本以及抽样分布","date":"2017-08-15T11:41:01.000Z","_content":"\n**概率论与数理统计的主要区别为**，在**概率论**中所研究的随机变量，其**分布都是假设已知的**，在这一前提下去研究它的性质（数字特征，分布函数等）；而在**数理统计**中研究的随机变量其**分布是未知的**，通过对所研究的随机变量进行**重复独立的试验和观察**，得到许多观察值，再对观察值进行分析，从而**对所研究的随机变量的分布做出各种推断**\n\n因此数理统计的主要内容包括两部分，一是如何收集，整理数据资料，二是如何对得到的数据资料进行分析和研究，从而对所研究的对象的性质和特点做出推断。第二部分其实就是统计推断的问题，也是后面主要讲述的内容。本文主要讲述数理统计中的两个基本概念：**样本和抽样分布**。\n\n<!--more-->\n\n# 样本\n从前面可知，数理统计就是通过数据来推断变量的分布，比如说现在要求求出全国成年男人的身高的一个分布，那只需要测出每个成年男人的身高后进行统计即可。\n\n但是在实际中，受限于人力物力和测试的难度，我们往往不会对每个成年男人进行身高的测试，而是在全国男人中选择部分的男人进行测试(如根据每个地区的人口数量按比例测试)，然后用这部分男人的身高分布来推断全国男人的分布，这样的推断肯定会存在误差，但是通过增加样本的数量，可以减少这种误差(大数定理)。\n\n上面其实就是一个很简单的数理统计过程，当中有几个概念需要注意，例子中的全国男人的身高是一个**总体**，选择出来实际测试身高的男人是一个**样本**，测试得到的身高称为**样本值（观测值）**，总体和样本中的数目分别称为他们的**容量**。\n\n其严格定义如下：\n\n设 $X$ 是具有分布函数 $F$ 的随机变量, 若 $X_1, X_2, …,X_n$ 是具有同一分布函数 $F$ 的相互独立的随机变量，则称 $X_1, X_2, …,X_n$ 为从分布函数 $F$ 得到的容量为 $n$ 的简单随机样本，简称样本，他们的观测值 $x_1, x_2,…x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观测值。\n\n由定义可知样本 $X_1,X_2,…,X_n$ 相互独立，且他们的分布函数均为 $F$ , 所以 ( $X_1,X_2,…,X_n$ )的分布函数为\n\n$$F^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nF(x_i)$$\n同样,(X1,X2,…,Xn)的概率密度函数为：\n\n$$f^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nf(x_i)$$\n\n# 抽样分布\n## 统计量\n样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是**针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。**\n\n当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。\n\n样本平均值：\n$$\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i$$\n样本方差：\n$$S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2$$\n样本标准差：\n$$S = \\sqrt {S^2}$$\n样本 k 阶原点矩：\n$$A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)$$\n样本 k 阶中心矩:\n$$B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)$$\n这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）\n\n![](样本以及抽样分布/样本以及抽样分布-7688d0c8.png)\n\n## 统计量的分布\n使用统计量进行统计推断时，常常需要知道其分布，**统计量的分布也称为抽样分布**，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。\n\n### $χ^2$ 分布\n$χ^2$ 分布的定义如下\n\n设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量\n$$\\chi^2 = X_1^2 + X_2^2 +….X_n^2$$\n为服从自由度为 $n$ 的 $χ^2$ 分布\n\n上面的自由度指的是右端独立变量的个数。\n\n$χ^2(n)$ 的概率密度函数为\n\n$$f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n上式的 $Γ$ 函数定义为\n\n$$\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt$$\n\n$f(y)$ 的图像如下所示\n\n![卡方分布的概率密度函数](样本以及抽样分布/样本以及抽样分布-bc11bcfe.png)\n\n\n关于 $χ^2(n)$ 有以下几个有用的结论：\n\n- 可加性\n设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有\n$$\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)$$\n- 期望和方差\n若$\\chi^2(n)$，则χ2的期望和方差如下所示\n$$E(\\chi^2) = n, D(\\chi^2)=2n$$\n- 分位点\n分位点的定义如下，给定正数 $a,0<a<1$, 称满足下面条件\n\n$$P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a$$\n\n的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示\n\n![](样本以及抽样分布/样本以及抽样分布-3e85fbb1.png)\n\n由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。\n\n### $t$ 分布\nt分布的定义如下：\n\n设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量\n$$t = \\frac{X}{\\sqrt{Y/n}}$$\n服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$\n其概率密度函数和对应的图像如下所示：\n![t分布的概率密度函数和图像](样本以及抽样分布/样本以及抽样分布-80c1cca7.png)\n\n\n其分位点的定义与上面讲述的一样，\n\n$$P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a$$\n\n![](样本以及抽样分布/样本以及抽样分布-79d1c781.png)\n\n且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$\n### $F$ 分布\n$F$ 分布的定义如下\n\n设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量\n$$F = \\frac{U/n_1}{V/n_2}$$\n服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$\n其概率密度函数为：\n\n$$\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n概率密度函数的图像如下所示\n![F分布的概率密度函数](样本以及抽样分布/样本以及抽样分布-35e6599e.png)\n\n\n其分位点定义同上\n$$P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a$$\n\n![F分布的分为点](样本以及抽样分布/样本以及抽样分布-0a6c68e5.png)\n\n且具有以下性质\n\n$$F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}$$\n\n上面只是简单地介绍了三大抽样分布，并未介绍其作用，**实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用**。更详细的作用会在区间估计中进一步体现。\n\n### 正态总体的样本均值与样本方差的分布(统计量的应用)\n\n由于正态分布的普遍性，这里特意指出从服从正态分布的总体中抽取出的样本的所服从的分布。\n\n假设上面的 $X$ 服从正态分布 $N(μ,σ^2)$, 则有以下几条定理，这几条定理在数理统计的区间估计中起了重要作用。\n\n#### 定理一\n- 定理一： 设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，则有\n$$\\overline X \\sim N(\\mu,\\sigma^2/n)$$\n\n证明如下：\n$$E(\\overline X) = E(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n}E(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n E(X) = \\mu$$\n$$D(\\overline X) = D(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n^2}D(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n D(X) = \\sigma^2/n$$\n\n**定理一通常用于区间估计中已知总体（服从正态分布）的期望$μ$来估计其未知的方差 $σ^2$ ,或已知方差 $σ^2$ 来估计未知的期望 $μ$。**\n\n#### 定理二\n- 定理二 ：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则 $\\overline X$ 和 $S^2$ 相互独立，且有\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n由于该定理的证明部分较为冗长，这里略去证明过程，感兴趣的读者可参考相关书籍。**定理二主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其方差的范围，这也是 $χ^2$ 分布的作用之一。**\n\n#### 定理三\n- 定理三：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则\n$$\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)$$\n\n**定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。**\n\n证明：\n根据定理一，易知 $\\overline X - \\mu \\sim N(0, \\sigma^2/n)$ , 则 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 从定理二可知\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n则根据t分布的定义有\n$$\\frac{\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}}} {\\sqrt{\\frac{(n-1)S^2}{\\sigma^2(n-1)}}} \\sim t(n-1)$$\n化简可得\n$$\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim t(n-1)$$\n**定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。**\n\n#### 定理四\n- 定理四：设 $X_1, X_2…X_n$ 与 $Y_1,Y_2,…Y_n$ 分别是来自正态总体 $N(\\mu_1, \\sigma_1^2)$ 和 $N(\\mu_2, \\sigma_2^2)$ 的样本, $\\overline X, \\overline Y$ 分别是其样本均值，$S_1^2, S_2^2$ 分别是其样本方差。则有\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n且当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时，\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n\n**定理四的作用是在区间估计时估计两个均服从正态分布的总体的方差的比值（期望未知）以及两者期望的差距（方差未知）**\n证明如下:\n由定理二可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)$$\n由 $F$ 分布的定义可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2(n_1-1)} / \\frac{(n_2-1)S_2^2}{\\sigma_2^2(n_2-1)} \\sim F(n_1-1, n_2-1)$$\n化简可得\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时,\n\n易知 $$(\\overline X - \\overline Y) \\sim N(\\mu_1 - \\mu_2,\\sigma_1^2/n_1 + \\sigma_2^2/n_2)$$\n则 $\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0,1)$\n由定理二可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)$$\n, 由 $χ^2$ 分布的可加性可知：\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_1+n_2-2)$$\n由t分布的定义可知：\n$$\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} / (\\sqrt{(\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2})/(n_1+n_2-2)}) \\sim t(n_1+n_2-2)$$\n将 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 代入到上式化简即可得到\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n\n\n# 小结\n\n$χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。需要注意的是上面估计的前提是总体服从正态分布\n","source":"_posts/样本以及抽样分布.md","raw":"---\ntitle: 样本以及抽样分布\ndate: 2017-08-15 19:41:01\ntags: [人工智能,统计,抽样分布]\ncategories: 数学\n---\n\n**概率论与数理统计的主要区别为**，在**概率论**中所研究的随机变量，其**分布都是假设已知的**，在这一前提下去研究它的性质（数字特征，分布函数等）；而在**数理统计**中研究的随机变量其**分布是未知的**，通过对所研究的随机变量进行**重复独立的试验和观察**，得到许多观察值，再对观察值进行分析，从而**对所研究的随机变量的分布做出各种推断**\n\n因此数理统计的主要内容包括两部分，一是如何收集，整理数据资料，二是如何对得到的数据资料进行分析和研究，从而对所研究的对象的性质和特点做出推断。第二部分其实就是统计推断的问题，也是后面主要讲述的内容。本文主要讲述数理统计中的两个基本概念：**样本和抽样分布**。\n\n<!--more-->\n\n# 样本\n从前面可知，数理统计就是通过数据来推断变量的分布，比如说现在要求求出全国成年男人的身高的一个分布，那只需要测出每个成年男人的身高后进行统计即可。\n\n但是在实际中，受限于人力物力和测试的难度，我们往往不会对每个成年男人进行身高的测试，而是在全国男人中选择部分的男人进行测试(如根据每个地区的人口数量按比例测试)，然后用这部分男人的身高分布来推断全国男人的分布，这样的推断肯定会存在误差，但是通过增加样本的数量，可以减少这种误差(大数定理)。\n\n上面其实就是一个很简单的数理统计过程，当中有几个概念需要注意，例子中的全国男人的身高是一个**总体**，选择出来实际测试身高的男人是一个**样本**，测试得到的身高称为**样本值（观测值）**，总体和样本中的数目分别称为他们的**容量**。\n\n其严格定义如下：\n\n设 $X$ 是具有分布函数 $F$ 的随机变量, 若 $X_1, X_2, …,X_n$ 是具有同一分布函数 $F$ 的相互独立的随机变量，则称 $X_1, X_2, …,X_n$ 为从分布函数 $F$ 得到的容量为 $n$ 的简单随机样本，简称样本，他们的观测值 $x_1, x_2,…x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观测值。\n\n由定义可知样本 $X_1,X_2,…,X_n$ 相互独立，且他们的分布函数均为 $F$ , 所以 ( $X_1,X_2,…,X_n$ )的分布函数为\n\n$$F^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nF(x_i)$$\n同样,(X1,X2,…,Xn)的概率密度函数为：\n\n$$f^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nf(x_i)$$\n\n# 抽样分布\n## 统计量\n样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是**针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。**\n\n当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。\n\n样本平均值：\n$$\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i$$\n样本方差：\n$$S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2$$\n样本标准差：\n$$S = \\sqrt {S^2}$$\n样本 k 阶原点矩：\n$$A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)$$\n样本 k 阶中心矩:\n$$B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)$$\n这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）\n\n![](样本以及抽样分布/样本以及抽样分布-7688d0c8.png)\n\n## 统计量的分布\n使用统计量进行统计推断时，常常需要知道其分布，**统计量的分布也称为抽样分布**，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。\n\n### $χ^2$ 分布\n$χ^2$ 分布的定义如下\n\n设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量\n$$\\chi^2 = X_1^2 + X_2^2 +….X_n^2$$\n为服从自由度为 $n$ 的 $χ^2$ 分布\n\n上面的自由度指的是右端独立变量的个数。\n\n$χ^2(n)$ 的概率密度函数为\n\n$$f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n上式的 $Γ$ 函数定义为\n\n$$\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt$$\n\n$f(y)$ 的图像如下所示\n\n![卡方分布的概率密度函数](样本以及抽样分布/样本以及抽样分布-bc11bcfe.png)\n\n\n关于 $χ^2(n)$ 有以下几个有用的结论：\n\n- 可加性\n设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有\n$$\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)$$\n- 期望和方差\n若$\\chi^2(n)$，则χ2的期望和方差如下所示\n$$E(\\chi^2) = n, D(\\chi^2)=2n$$\n- 分位点\n分位点的定义如下，给定正数 $a,0<a<1$, 称满足下面条件\n\n$$P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a$$\n\n的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示\n\n![](样本以及抽样分布/样本以及抽样分布-3e85fbb1.png)\n\n由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。\n\n### $t$ 分布\nt分布的定义如下：\n\n设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量\n$$t = \\frac{X}{\\sqrt{Y/n}}$$\n服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$\n其概率密度函数和对应的图像如下所示：\n![t分布的概率密度函数和图像](样本以及抽样分布/样本以及抽样分布-80c1cca7.png)\n\n\n其分位点的定义与上面讲述的一样，\n\n$$P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a$$\n\n![](样本以及抽样分布/样本以及抽样分布-79d1c781.png)\n\n且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$\n### $F$ 分布\n$F$ 分布的定义如下\n\n设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量\n$$F = \\frac{U/n_1}{V/n_2}$$\n服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$\n其概率密度函数为：\n\n$$\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}$$\n\n概率密度函数的图像如下所示\n![F分布的概率密度函数](样本以及抽样分布/样本以及抽样分布-35e6599e.png)\n\n\n其分位点定义同上\n$$P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a$$\n\n![F分布的分为点](样本以及抽样分布/样本以及抽样分布-0a6c68e5.png)\n\n且具有以下性质\n\n$$F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}$$\n\n上面只是简单地介绍了三大抽样分布，并未介绍其作用，**实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用**。更详细的作用会在区间估计中进一步体现。\n\n### 正态总体的样本均值与样本方差的分布(统计量的应用)\n\n由于正态分布的普遍性，这里特意指出从服从正态分布的总体中抽取出的样本的所服从的分布。\n\n假设上面的 $X$ 服从正态分布 $N(μ,σ^2)$, 则有以下几条定理，这几条定理在数理统计的区间估计中起了重要作用。\n\n#### 定理一\n- 定理一： 设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，则有\n$$\\overline X \\sim N(\\mu,\\sigma^2/n)$$\n\n证明如下：\n$$E(\\overline X) = E(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n}E(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n E(X) = \\mu$$\n$$D(\\overline X) = D(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n^2}D(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n D(X) = \\sigma^2/n$$\n\n**定理一通常用于区间估计中已知总体（服从正态分布）的期望$μ$来估计其未知的方差 $σ^2$ ,或已知方差 $σ^2$ 来估计未知的期望 $μ$。**\n\n#### 定理二\n- 定理二 ：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则 $\\overline X$ 和 $S^2$ 相互独立，且有\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n由于该定理的证明部分较为冗长，这里略去证明过程，感兴趣的读者可参考相关书籍。**定理二主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其方差的范围，这也是 $χ^2$ 分布的作用之一。**\n\n#### 定理三\n- 定理三：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则\n$$\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)$$\n\n**定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。**\n\n证明：\n根据定理一，易知 $\\overline X - \\mu \\sim N(0, \\sigma^2/n)$ , 则 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 从定理二可知\n$$\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)$$\n\n则根据t分布的定义有\n$$\\frac{\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}}} {\\sqrt{\\frac{(n-1)S^2}{\\sigma^2(n-1)}}} \\sim t(n-1)$$\n化简可得\n$$\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim t(n-1)$$\n**定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。**\n\n#### 定理四\n- 定理四：设 $X_1, X_2…X_n$ 与 $Y_1,Y_2,…Y_n$ 分别是来自正态总体 $N(\\mu_1, \\sigma_1^2)$ 和 $N(\\mu_2, \\sigma_2^2)$ 的样本, $\\overline X, \\overline Y$ 分别是其样本均值，$S_1^2, S_2^2$ 分别是其样本方差。则有\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n且当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时，\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n\n**定理四的作用是在区间估计时估计两个均服从正态分布的总体的方差的比值（期望未知）以及两者期望的差距（方差未知）**\n证明如下:\n由定理二可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)$$\n由 $F$ 分布的定义可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2(n_1-1)} / \\frac{(n_2-1)S_2^2}{\\sigma_2^2(n_2-1)} \\sim F(n_1-1, n_2-1)$$\n化简可得\n$$\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)$$\n当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时,\n\n易知 $$(\\overline X - \\overline Y) \\sim N(\\mu_1 - \\mu_2,\\sigma_1^2/n_1 + \\sigma_2^2/n_2)$$\n则 $\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0,1)$\n由定理二可知\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)$$\n, 由 $χ^2$ 分布的可加性可知：\n$$\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_1+n_2-2)$$\n由t分布的定义可知：\n$$\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} / (\\sqrt{(\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2})/(n_1+n_2-2)}) \\sim t(n_1+n_2-2)$$\n将 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 代入到上式化简即可得到\n$$\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)$$\n其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$\n\n\n# 小结\n\n$χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。需要注意的是上面估计的前提是总体服从正态分布\n","slug":"样本以及抽样分布","published":1,"updated":"2019-07-30T01:54:38.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0j0057homj5nfajqab","content":"<p><strong>概率论与数理统计的主要区别为</strong>，在<strong>概率论</strong>中所研究的随机变量，其<strong>分布都是假设已知的</strong>，在这一前提下去研究它的性质（数字特征，分布函数等）；而在<strong>数理统计</strong>中研究的随机变量其<strong>分布是未知的</strong>，通过对所研究的随机变量进行<strong>重复独立的试验和观察</strong>，得到许多观察值，再对观察值进行分析，从而<strong>对所研究的随机变量的分布做出各种推断</strong></p>\n<p>因此数理统计的主要内容包括两部分，一是如何收集，整理数据资料，二是如何对得到的数据资料进行分析和研究，从而对所研究的对象的性质和特点做出推断。第二部分其实就是统计推断的问题，也是后面主要讲述的内容。本文主要讲述数理统计中的两个基本概念：<strong>样本和抽样分布</strong>。</p>\n<a id=\"more\"></a>\n<h1 id=\"样本\"><a href=\"#样本\" class=\"headerlink\" title=\"样本\"></a>样本</h1><p>从前面可知，数理统计就是通过数据来推断变量的分布，比如说现在要求求出全国成年男人的身高的一个分布，那只需要测出每个成年男人的身高后进行统计即可。</p>\n<p>但是在实际中，受限于人力物力和测试的难度，我们往往不会对每个成年男人进行身高的测试，而是在全国男人中选择部分的男人进行测试(如根据每个地区的人口数量按比例测试)，然后用这部分男人的身高分布来推断全国男人的分布，这样的推断肯定会存在误差，但是通过增加样本的数量，可以减少这种误差(大数定理)。</p>\n<p>上面其实就是一个很简单的数理统计过程，当中有几个概念需要注意，例子中的全国男人的身高是一个<strong>总体</strong>，选择出来实际测试身高的男人是一个<strong>样本</strong>，测试得到的身高称为<strong>样本值（观测值）</strong>，总体和样本中的数目分别称为他们的<strong>容量</strong>。</p>\n<p>其严格定义如下：</p>\n<p>设 $X$ 是具有分布函数 $F$ 的随机变量, 若 $X_1, X_2, …,X_n$ 是具有同一分布函数 $F$ 的相互独立的随机变量，则称 $X_1, X_2, …,X_n$ 为从分布函数 $F$ 得到的容量为 $n$ 的简单随机样本，简称样本，他们的观测值 $x_1, x_2,…x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观测值。</p>\n<p>由定义可知样本 $X_1,X_2,…,X_n$ 相互独立，且他们的分布函数均为 $F$ , 所以 ( $X_1,X_2,…,X_n$ )的分布函数为</p>\n<script type=\"math/tex; mode=display\">F^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nF(x_i)</script><p>同样,(X1,X2,…,Xn)的概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">f^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nf(x_i)</script><h1 id=\"抽样分布\"><a href=\"#抽样分布\" class=\"headerlink\" title=\"抽样分布\"></a>抽样分布</h1><h2 id=\"统计量\"><a href=\"#统计量\" class=\"headerlink\" title=\"统计量\"></a>统计量</h2><p>样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是<strong>针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。</strong></p>\n<p>当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。</p>\n<p>样本平均值：</p>\n<script type=\"math/tex; mode=display\">\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i</script><p>样本方差：</p>\n<script type=\"math/tex; mode=display\">S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2</script><p>样本标准差：</p>\n<script type=\"math/tex; mode=display\">S = \\sqrt {S^2}</script><p>样本 k 阶原点矩：</p>\n<script type=\"math/tex; mode=display\">A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)</script><p>样本 k 阶中心矩:</p>\n<script type=\"math/tex; mode=display\">B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)</script><p>这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-7688d0c8.png\" alt=\"\"></p>\n<h2 id=\"统计量的分布\"><a href=\"#统计量的分布\" class=\"headerlink\" title=\"统计量的分布\"></a>统计量的分布</h2><p>使用统计量进行统计推断时，常常需要知道其分布，<strong>统计量的分布也称为抽样分布</strong>，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。</p>\n<h3 id=\"χ-2-分布\"><a href=\"#χ-2-分布\" class=\"headerlink\" title=\"$χ^2$ 分布\"></a>$χ^2$ 分布</h3><p>$χ^2$ 分布的定义如下</p>\n<p>设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量</p>\n<script type=\"math/tex; mode=display\">\\chi^2 = X_1^2 + X_2^2 +….X_n^2</script><p>为服从自由度为 $n$ 的 $χ^2$ 分布</p>\n<p>上面的自由度指的是右端独立变量的个数。</p>\n<p>$χ^2(n)$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>上式的 $Γ$ 函数定义为</p>\n<script type=\"math/tex; mode=display\">\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt</script><p>$f(y)$ 的图像如下所示</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-bc11bcfe.png\" alt=\"卡方分布的概率密度函数\"></p>\n<p>关于 $χ^2(n)$ 有以下几个有用的结论：</p>\n<ul>\n<li>可加性<br>设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有<script type=\"math/tex; mode=display\">\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)</script></li>\n<li>期望和方差<br>若$\\chi^2(n)$，则χ2的期望和方差如下所示<script type=\"math/tex; mode=display\">E(\\chi^2) = n, D(\\chi^2)=2n</script></li>\n<li>分位点<br>分位点的定义如下，给定正数 $a,0&lt;a&lt;1$, 称满足下面条件</li>\n</ul>\n<script type=\"math/tex; mode=display\">P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a</script><p>的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-3e85fbb1.png\" alt=\"\"></p>\n<p>由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。</p>\n<h3 id=\"t-分布\"><a href=\"#t-分布\" class=\"headerlink\" title=\"$t$ 分布\"></a>$t$ 分布</h3><p>t分布的定义如下：</p>\n<p>设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">t = \\frac{X}{\\sqrt{Y/n}}</script><p>服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$<br>其概率密度函数和对应的图像如下所示：<br><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-80c1cca7.png\" alt=\"t分布的概率密度函数和图像\"></p>\n<p>其分位点的定义与上面讲述的一样，</p>\n<script type=\"math/tex; mode=display\">P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a</script><p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-79d1c781.png\" alt=\"\"></p>\n<p>且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$</p>\n<h3 id=\"F-分布\"><a href=\"#F-分布\" class=\"headerlink\" title=\"$F$ 分布\"></a>$F$ 分布</h3><p>$F$ 分布的定义如下</p>\n<p>设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">F = \\frac{U/n_1}{V/n_2}</script><p>服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$<br>其概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>概率密度函数的图像如下所示<br><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-35e6599e.png\" alt=\"F分布的概率密度函数\"></p>\n<p>其分位点定义同上</p>\n<script type=\"math/tex; mode=display\">P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a</script><p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-0a6c68e5.png\" alt=\"F分布的分为点\"></p>\n<p>且具有以下性质</p>\n<script type=\"math/tex; mode=display\">F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}</script><p>上面只是简单地介绍了三大抽样分布，并未介绍其作用，<strong>实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用</strong>。更详细的作用会在区间估计中进一步体现。</p>\n<h3 id=\"正态总体的样本均值与样本方差的分布-统计量的应用\"><a href=\"#正态总体的样本均值与样本方差的分布-统计量的应用\" class=\"headerlink\" title=\"正态总体的样本均值与样本方差的分布(统计量的应用)\"></a>正态总体的样本均值与样本方差的分布(统计量的应用)</h3><p>由于正态分布的普遍性，这里特意指出从服从正态分布的总体中抽取出的样本的所服从的分布。</p>\n<p>假设上面的 $X$ 服从正态分布 $N(μ,σ^2)$, 则有以下几条定理，这几条定理在数理统计的区间估计中起了重要作用。</p>\n<h4 id=\"定理一\"><a href=\"#定理一\" class=\"headerlink\" title=\"定理一\"></a>定理一</h4><ul>\n<li>定理一： 设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，则有<script type=\"math/tex; mode=display\">\\overline X \\sim N(\\mu,\\sigma^2/n)</script></li>\n</ul>\n<p>证明如下：</p>\n<script type=\"math/tex; mode=display\">E(\\overline X) = E(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n}E(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n E(X) = \\mu</script><script type=\"math/tex; mode=display\">D(\\overline X) = D(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n^2}D(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n D(X) = \\sigma^2/n</script><p><strong>定理一通常用于区间估计中已知总体（服从正态分布）的期望$μ$来估计其未知的方差 $σ^2$ ,或已知方差 $σ^2$ 来估计未知的期望 $μ$。</strong></p>\n<h4 id=\"定理二\"><a href=\"#定理二\" class=\"headerlink\" title=\"定理二\"></a>定理二</h4><ul>\n<li>定理二 ：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则 $\\overline X$ 和 $S^2$ 相互独立，且有<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script></li>\n</ul>\n<p>由于该定理的证明部分较为冗长，这里略去证明过程，感兴趣的读者可参考相关书籍。<strong>定理二主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其方差的范围，这也是 $χ^2$ 分布的作用之一。</strong></p>\n<h4 id=\"定理三\"><a href=\"#定理三\" class=\"headerlink\" title=\"定理三\"></a>定理三</h4><ul>\n<li>定理三：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)</script></li>\n</ul>\n<p><strong>定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。</strong></p>\n<p>证明：<br>根据定理一，易知 $\\overline X - \\mu \\sim N(0, \\sigma^2/n)$ , 则 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 从定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script><p>则根据t分布的定义有</p>\n<script type=\"math/tex; mode=display\">\\frac{\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}}} {\\sqrt{\\frac{(n-1)S^2}{\\sigma^2(n-1)}}} \\sim t(n-1)</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim t(n-1)</script><p><strong>定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。</strong></p>\n<h4 id=\"定理四\"><a href=\"#定理四\" class=\"headerlink\" title=\"定理四\"></a>定理四</h4><ul>\n<li>定理四：设 $X_1, X_2…X_n$ 与 $Y_1,Y_2,…Y_n$ 分别是来自正态总体 $N(\\mu_1, \\sigma_1^2)$ 和 $N(\\mu_2, \\sigma_2^2)$ 的样本, $\\overline X, \\overline Y$ 分别是其样本均值，$S_1^2, S_2^2$ 分别是其样本方差。则有<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script>且当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时，<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script>其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$</li>\n</ul>\n<p><strong>定理四的作用是在区间估计时估计两个均服从正态分布的总体的方差的比值（期望未知）以及两者期望的差距（方差未知）</strong><br>证明如下:<br>由定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)</script><p>由 $F$ 分布的定义可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2(n_1-1)} / \\frac{(n_2-1)S_2^2}{\\sigma_2^2(n_2-1)} \\sim F(n_1-1, n_2-1)</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script><p>当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时,</p>\n<p>易知 <script type=\"math/tex\">(\\overline X - \\overline Y) \\sim N(\\mu_1 - \\mu_2,\\sigma_1^2/n_1 + \\sigma_2^2/n_2)</script><br>则 $\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0,1)$<br>由定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)</script><p>, 由 $χ^2$ 分布的可加性可知：</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_1+n_2-2)</script><p>由t分布的定义可知：</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} / (\\sqrt{(\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2})/(n_1+n_2-2)}) \\sim t(n_1+n_2-2)</script><p>将 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 代入到上式化简即可得到</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script><p>其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>$χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。需要注意的是上面估计的前提是总体服从正态分布</p>\n","site":{"data":{}},"excerpt":"<p><strong>概率论与数理统计的主要区别为</strong>，在<strong>概率论</strong>中所研究的随机变量，其<strong>分布都是假设已知的</strong>，在这一前提下去研究它的性质（数字特征，分布函数等）；而在<strong>数理统计</strong>中研究的随机变量其<strong>分布是未知的</strong>，通过对所研究的随机变量进行<strong>重复独立的试验和观察</strong>，得到许多观察值，再对观察值进行分析，从而<strong>对所研究的随机变量的分布做出各种推断</strong></p>\n<p>因此数理统计的主要内容包括两部分，一是如何收集，整理数据资料，二是如何对得到的数据资料进行分析和研究，从而对所研究的对象的性质和特点做出推断。第二部分其实就是统计推断的问题，也是后面主要讲述的内容。本文主要讲述数理统计中的两个基本概念：<strong>样本和抽样分布</strong>。</p>","more":"<h1 id=\"样本\"><a href=\"#样本\" class=\"headerlink\" title=\"样本\"></a>样本</h1><p>从前面可知，数理统计就是通过数据来推断变量的分布，比如说现在要求求出全国成年男人的身高的一个分布，那只需要测出每个成年男人的身高后进行统计即可。</p>\n<p>但是在实际中，受限于人力物力和测试的难度，我们往往不会对每个成年男人进行身高的测试，而是在全国男人中选择部分的男人进行测试(如根据每个地区的人口数量按比例测试)，然后用这部分男人的身高分布来推断全国男人的分布，这样的推断肯定会存在误差，但是通过增加样本的数量，可以减少这种误差(大数定理)。</p>\n<p>上面其实就是一个很简单的数理统计过程，当中有几个概念需要注意，例子中的全国男人的身高是一个<strong>总体</strong>，选择出来实际测试身高的男人是一个<strong>样本</strong>，测试得到的身高称为<strong>样本值（观测值）</strong>，总体和样本中的数目分别称为他们的<strong>容量</strong>。</p>\n<p>其严格定义如下：</p>\n<p>设 $X$ 是具有分布函数 $F$ 的随机变量, 若 $X_1, X_2, …,X_n$ 是具有同一分布函数 $F$ 的相互独立的随机变量，则称 $X_1, X_2, …,X_n$ 为从分布函数 $F$ 得到的容量为 $n$ 的简单随机样本，简称样本，他们的观测值 $x_1, x_2,…x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观测值。</p>\n<p>由定义可知样本 $X_1,X_2,…,X_n$ 相互独立，且他们的分布函数均为 $F$ , 所以 ( $X_1,X_2,…,X_n$ )的分布函数为</p>\n<script type=\"math/tex; mode=display\">F^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nF(x_i)</script><p>同样,(X1,X2,…,Xn)的概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">f^*(x_1,x_2,…,x_n) = \\prod_{i=1}^nf(x_i)</script><h1 id=\"抽样分布\"><a href=\"#抽样分布\" class=\"headerlink\" title=\"抽样分布\"></a>抽样分布</h1><h2 id=\"统计量\"><a href=\"#统计量\" class=\"headerlink\" title=\"统计量\"></a>统计量</h2><p>样本是进行统计推断的依据，但是在应用中，往往不是直接使用样本本身，而是<strong>针对不同问题构造适当的样本的函数，利用这些样本的函数进行统计推断。</strong></p>\n<p>当这些样本的函数中不含未知变量时，我们称其为统计量，如下面就是几个常用的统计量，其中 $X_1,X_2,….,X_n$ 为总体的一个样本。</p>\n<p>样本平均值：</p>\n<script type=\"math/tex; mode=display\">\\overline X = \\frac{1}{n} \\sum_{i=1}^{n} X_i</script><p>样本方差：</p>\n<script type=\"math/tex; mode=display\">S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\overline X)^2</script><p>样本标准差：</p>\n<script type=\"math/tex; mode=display\">S = \\sqrt {S^2}</script><p>样本 k 阶原点矩：</p>\n<script type=\"math/tex; mode=display\">A_k = \\frac{1}{n} \\sum_{i=1}^{n} X_i^k (k=1,2,…)</script><p>样本 k 阶中心矩:</p>\n<script type=\"math/tex; mode=display\">B_k = \\frac{1}{n} \\sum_{i=1}^{n}(X_i - \\overline X)^k (k=2,3,4…..)</script><p>这些统计量的定义与概率论中的基本相似，唯一比较奇怪的是为什么样本方差的分母是 $n−1$ 而不是 $n$，原因是通过数学证明可以得到只有当分母取n-1时，用样本来估计总体才是无偏的(无偏指的是估计量的期望与总体的参数一致)，下面是分母取n时得到的有偏估计的证明过程（$S^2_1$为样本方差）</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-7688d0c8.png\" alt=\"\"></p>\n<h2 id=\"统计量的分布\"><a href=\"#统计量的分布\" class=\"headerlink\" title=\"统计量的分布\"></a>统计量的分布</h2><p>使用统计量进行统计推断时，常常需要知道其分布，<strong>统计量的分布也称为抽样分布</strong>，下面介绍三种来自正态分布的抽样分布： $χ^2$ 分布，$t$ 分布和 $F$ 分布。</p>\n<h3 id=\"χ-2-分布\"><a href=\"#χ-2-分布\" class=\"headerlink\" title=\"$χ^2$ 分布\"></a>$χ^2$ 分布</h3><p>$χ^2$ 分布的定义如下</p>\n<p>设 $X_1, X_2,…X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量</p>\n<script type=\"math/tex; mode=display\">\\chi^2 = X_1^2 + X_2^2 +….X_n^2</script><p>为服从自由度为 $n$ 的 $χ^2$ 分布</p>\n<p>上面的自由度指的是右端独立变量的个数。</p>\n<p>$χ^2(n)$ 的概率密度函数为</p>\n<script type=\"math/tex; mode=display\">f(y) = \\begin{cases}  \\frac{1}{2^{\\frac{n}{2}}\\Gamma(n/2)}y^{n/2-1}e^{-y/2} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>上式的 $Γ$ 函数定义为</p>\n<script type=\"math/tex; mode=display\">\\Gamma = \\int_{0}^{\\infty} \\frac{t^z - 1}{e^t} dt</script><p>$f(y)$ 的图像如下所示</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-bc11bcfe.png\" alt=\"卡方分布的概率密度函数\"></p>\n<p>关于 $χ^2(n)$ 有以下几个有用的结论：</p>\n<ul>\n<li>可加性<br>设 $\\chi_1^2$~$\\chi^2(n_1), \\chi_2^2$ ~ $\\chi_2^2$ , 并且 $\\chi_1^2, \\chi_2^2$ 相互独立，则有<script type=\"math/tex; mode=display\">\\chi_1^2 + \\chi_2^2 \\sim \\chi^2(n_1 + n_2)</script></li>\n<li>期望和方差<br>若$\\chi^2(n)$，则χ2的期望和方差如下所示<script type=\"math/tex; mode=display\">E(\\chi^2) = n, D(\\chi^2)=2n</script></li>\n<li>分位点<br>分位点的定义如下，给定正数 $a,0&lt;a&lt;1$, 称满足下面条件</li>\n</ul>\n<script type=\"math/tex; mode=display\">P(\\chi^2 \\gt \\chi_a^2(n)) = \\int_{\\chi_a^2(n)}^{\\infty}f(y)dy= a</script><p>的 $\\chi_a^2(n)$ 为 $\\chi^2(n)$ 上的 $a$ 分位点，其图像如下所示</p>\n<p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-3e85fbb1.png\" alt=\"\"></p>\n<p>由定义可知，分位点由 $a,n$ 共同决定，因此对于不同的 $a，n$ 可以查阅表格得到其 $a$ 分位点。</p>\n<h3 id=\"t-分布\"><a href=\"#t-分布\" class=\"headerlink\" title=\"$t$ 分布\"></a>$t$ 分布</h3><p>t分布的定义如下：</p>\n<p>设 $X \\sim N(0,1), Y \\sim \\chi^2(n)$, 且 X,Y 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">t = \\frac{X}{\\sqrt{Y/n}}</script><p>服从自由度为 $n$ 的 $t$ 分布, 记为 $t∼t(n)$<br>其概率密度函数和对应的图像如下所示：<br><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-80c1cca7.png\" alt=\"t分布的概率密度函数和图像\"></p>\n<p>其分位点的定义与上面讲述的一样，</p>\n<script type=\"math/tex; mode=display\">P(t \\gt t_a(n)) = \\int_{t_a(n)}^{\\infty}h(t)dt= a</script><p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-79d1c781.png\" alt=\"\"></p>\n<p>且由于其概率密度函数的对称性可知,总是存在这样对称的两个分位点 ： $t_{1-a}(n) = -t_a(n)$</p>\n<h3 id=\"F-分布\"><a href=\"#F-分布\" class=\"headerlink\" title=\"$F$ 分布\"></a>$F$ 分布</h3><p>$F$ 分布的定义如下</p>\n<p>设 $U∼χ^2(n_1),V∼χ^2(n_2$， 且 $U,V$ 相互独立，则称随机变量</p>\n<script type=\"math/tex; mode=display\">F = \\frac{U/n_1}{V/n_2}</script><p>服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为$F∼F(n_1,n_2)$<br>其概率密度函数为：</p>\n<script type=\"math/tex; mode=display\">\\psi(y) = \\begin{cases}  \\frac{\\Gamma((n_1+n_2)/2)(n_1/n_2)^{n_1/2}y^{n_1/2-1}}{\\Gamma(n_1/2)\\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2/)2}} &{y>0} \\\\ 0&{其他}\\end{cases}</script><p>概率密度函数的图像如下所示<br><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-35e6599e.png\" alt=\"F分布的概率密度函数\"></p>\n<p>其分位点定义同上</p>\n<script type=\"math/tex; mode=display\">P(F \\gt F_a(n_1,n_2)) = \\int_{F_a(n_1,n_2)}^{\\infty}\\psi(y)dy= a</script><p><img src=\"/2017/08/15/样本以及抽样分布/样本以及抽样分布-0a6c68e5.png\" alt=\"F分布的分为点\"></p>\n<p>且具有以下性质</p>\n<script type=\"math/tex; mode=display\">F_{1-a}(n_1,n_2) = \\frac{1}{F_a(n_2,n_1)}</script><p>上面只是简单地介绍了三大抽样分布，并未介绍其作用，<strong>实际上三大抽样分布主要用于参数的区间估计中，而这主要基于从正态分布中抽取的样本所构造的统计量服从这三大分布这一事实，从下面要介绍的定理中可以看到了这三大抽样分布的作用</strong>。更详细的作用会在区间估计中进一步体现。</p>\n<h3 id=\"正态总体的样本均值与样本方差的分布-统计量的应用\"><a href=\"#正态总体的样本均值与样本方差的分布-统计量的应用\" class=\"headerlink\" title=\"正态总体的样本均值与样本方差的分布(统计量的应用)\"></a>正态总体的样本均值与样本方差的分布(统计量的应用)</h3><p>由于正态分布的普遍性，这里特意指出从服从正态分布的总体中抽取出的样本的所服从的分布。</p>\n<p>假设上面的 $X$ 服从正态分布 $N(μ,σ^2)$, 则有以下几条定理，这几条定理在数理统计的区间估计中起了重要作用。</p>\n<h4 id=\"定理一\"><a href=\"#定理一\" class=\"headerlink\" title=\"定理一\"></a>定理一</h4><ul>\n<li>定理一： 设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，则有<script type=\"math/tex; mode=display\">\\overline X \\sim N(\\mu,\\sigma^2/n)</script></li>\n</ul>\n<p>证明如下：</p>\n<script type=\"math/tex; mode=display\">E(\\overline X) = E(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n}E(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n E(X) = \\mu</script><script type=\"math/tex; mode=display\">D(\\overline X) = D(\\frac{1}{n}\\sum_{i=1}^{n} X_i) = \\frac{1}{n^2}D(\\sum_{i=1}^{n} X_i) = \\frac{1}{n}n D(X) = \\sigma^2/n</script><p><strong>定理一通常用于区间估计中已知总体（服从正态分布）的期望$μ$来估计其未知的方差 $σ^2$ ,或已知方差 $σ^2$ 来估计未知的期望 $μ$。</strong></p>\n<h4 id=\"定理二\"><a href=\"#定理二\" class=\"headerlink\" title=\"定理二\"></a>定理二</h4><ul>\n<li>定理二 ：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则 $\\overline X$ 和 $S^2$ 相互独立，且有<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script></li>\n</ul>\n<p>由于该定理的证明部分较为冗长，这里略去证明过程，感兴趣的读者可参考相关书籍。<strong>定理二主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其方差的范围，这也是 $χ^2$ 分布的作用之一。</strong></p>\n<h4 id=\"定理三\"><a href=\"#定理三\" class=\"headerlink\" title=\"定理三\"></a>定理三</h4><ul>\n<li>定理三：设 $X_1, X_2,….X_n$ 服从 $N(μ,σ^2)$，$\\overline X$是样本均值，$S^2$ 是样本的方差，则<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{S/\\sqrt{n}} \\sim t(n-1)</script></li>\n</ul>\n<p><strong>定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。</strong></p>\n<p>证明：<br>根据定理一，易知 $\\overline X - \\mu \\sim N(0, \\sigma^2/n)$ , 则 $\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim N(0,1)$ , 从定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n-1)S^2}{\\sigma^2} \\sim \\chi^2(n-1)</script><p>则根据t分布的定义有</p>\n<script type=\"math/tex; mode=display\">\\frac{\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}}} {\\sqrt{\\frac{(n-1)S^2}{\\sigma^2(n-1)}}} \\sim t(n-1)</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">\\frac{\\overline X - \\mu}{\\sqrt{\\sigma^2/n}} \\sim t(n-1)</script><p><strong>定理三主要用于区间估计中总体（服从正态分布）的期望、方差均未知时，估计其期望的范围，这也是 $t$ 分布的作用之一,注意前面讲到的 $χ^2$ 分布估计的是方差。</strong></p>\n<h4 id=\"定理四\"><a href=\"#定理四\" class=\"headerlink\" title=\"定理四\"></a>定理四</h4><ul>\n<li>定理四：设 $X_1, X_2…X_n$ 与 $Y_1,Y_2,…Y_n$ 分别是来自正态总体 $N(\\mu_1, \\sigma_1^2)$ 和 $N(\\mu_2, \\sigma_2^2)$ 的样本, $\\overline X, \\overline Y$ 分别是其样本均值，$S_1^2, S_2^2$ 分别是其样本方差。则有<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script>且当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时，<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script>其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$</li>\n</ul>\n<p><strong>定理四的作用是在区间估计时估计两个均服从正态分布的总体的方差的比值（期望未知）以及两者期望的差距（方差未知）</strong><br>证明如下:<br>由定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)</script><p>由 $F$ 分布的定义可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2(n_1-1)} / \\frac{(n_2-1)S_2^2}{\\sigma_2^2(n_2-1)} \\sim F(n_1-1, n_2-1)</script><p>化简可得</p>\n<script type=\"math/tex; mode=display\">\\frac{S_1^2/S_2^2}{\\sigma_1^2/ \\sigma_2^2} \\sim F(n_1 - 1, n_2 - 1)</script><p>当 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 时,</p>\n<p>易知 <script type=\"math/tex\">(\\overline X - \\overline Y) \\sim N(\\mu_1 - \\mu_2,\\sigma_1^2/n_1 + \\sigma_2^2/n_2)</script><br>则 $\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} \\sim N(0,1)$<br>由定理二可知</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} \\sim \\chi^2(n_1-1), \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_2-1)</script><p>, 由 $χ^2$ 分布的可加性可知：</p>\n<script type=\"math/tex; mode=display\">\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2} \\sim \\chi^2(n_1+n_2-2)</script><p>由t分布的定义可知：</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y)- (\\mu_1 - \\mu_2)}{\\sqrt{\\sigma_1^2/n_1 + \\sigma_2^2/n_2}} / (\\sqrt{(\\frac{(n_1-1)S_1^2}{\\sigma_1^2} + \\frac{(n_2-1)S_2^2}{\\sigma_2^2})/(n_1+n_2-2)}) \\sim t(n_1+n_2-2)</script><p>将 $\\sigma_1^2 = \\sigma_2^2 = \\sigma^2$ 代入到上式化简即可得到</p>\n<script type=\"math/tex; mode=display\">\\frac{(\\overline X - \\overline Y) - (\\mu_1 - \\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}} \\sim t(n_1+n_2-2)</script><p>其中，$S_w = \\sqrt{\\frac{(n_1 -1)S_1^2+(n_2 -1)S_2^2}{n_1+n_2-2}}$</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>$χ^2$ 分布主要解决总体期望未知时估计其方差的问题， $t$ 分布主要解决总体方差未知时估计其期望的问题，$F$ 主要解决期望未知时两个正态分布的方差比值问题。需要注意的是上面估计的前提是总体服从正态分布</p>"},{"title":"核函数","date":"2017-09-01T16:12:57.000Z","_content":"\n之前分析的感知机、主成分分析（Principle component analysis, PCA）包括后面看的支撑向量机（Support vector machines, SVM），都有用到核函数。核函数是将信号映射到高维，而PCA一般用来降维。这里简单梳理一下核函数的知识：\n\n# 核函数基本概念\n## 定义\n设$\\chi $是输入空间(欧氏空间$\\mathbb{R}^{n}$的子集或离散集合)，又设$\\mathbb{R}^{H}$为特征空间(希尔伯特空间)，如果存在一个从$\\chi $到$\\mathbb{R}^{H}$的映射$$\\phi  (x):\\chi \\rightarrow \\mathbb{H}$$使得对所有$x,z\\in \\chi $，函数$K(x,z)$满足条件$$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$$则称$K(x,z)$为核函数，$\\phi  (x)$为映射函数，式中$\\phi  (x) \\cdot \\phi  (z)$为$\\phi  (x)$和$\\phi  (z)$的内积\n\n核函数：是映射关系$\\phi  (x)$的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数，这通常是我们希望的。\n## 核函数的作用\n- 聚类、分类\n\n![](核函数/核函数-e3fe62f2.png)\n二维映射到三维，区分就更容易了，这是聚类、分类常用核函数的原因。为什么PCA这样一个降维算法也用核函数呢？\n- 降维\n![](核函数/核函数-f46521d0.png)\n\n左图为原数据，右图为映射到三维的数据，可以看出：同样是降到1维，先通过Kernel映射到（Kernel是映射的内积，不要弄乱了）三维，再投影到1维，就容易分离开，这就是Kernel在PCA降维中的应用，本质还是对原有数据增加维度。\n\n# 核函数为什么可以映射到高维\n## 为什么实现数据映射到高维\n\n![](核函数/核函数-7d4cb2e5.png)\n\n- 设原空间数据点$a_1=(x_1,x_2)；a_2=(x_1',x_2')$；\n- 设高维空间的数据点为$A_1 =\\phi (a_1)=(z_1,z_2,z_3)；A_2=\\phi (a_1)=(z_1',z_2',z_3')$\n\n$\\left \\langle a_1,a_2 \\right \\rangle$为两点之间的内积$\\left \\langle a_1,a_2 \\right \\rangle = \\left \\langle (x_1,x_2),(x_1',x_2') \\right \\rangle =x_1x_1'+x_2x_2'$\n\n\n$<\\phi (a_1),\\phi (a_2)>=<\\phi (x_1,x_2),\\phi (x_1',x_2')>=<(z_1,z_2,z_3),(z_1',z_2',z_3')>=<(x_1^2,\\sqrt{2}x_1x_2,x_2^2),({x}_1'^2,\\sqrt{2}x_1'x_2',{x}_2'^2)>=x_1^2x_1'^2+2x_1x_2x_1'x_2'+x_2^2x_2'^2=(x_1x_1'+x_2x_2')^2=(<a_1,a_2'>)^2=k(a_1,a_2)$\n\n## 为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？\n因为$(x,z)$一起出现的时候，$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$有许多固定的形式可以调用，而不必求解或者关心$\\phi  (x)$的具体形式，这大大简化了求解。\n## 核函数的用法\n1. 两点之间的距离\n$$\\begin{align*}\n\\left \\| \\phi (x)-  \\phi (x')\\right \\|^2\n&=(\\phi (x)-  \\phi (x'))^T(\\phi (x)-  \\phi (x'))\\\\\n&=\\phi (x)^T\\phi (x)-2\\phi (x)^T\\phi (x')+\\phi (x')^T\\phi (x')\\\\\n&=<\\phi (x),\\phi (x)>-2<\\phi (x),\\phi (x')>+<\\phi (x'),\\phi (x')>\\\\\n&=K(x,x)-2K(x,x')+K(x',x')\n\\end{align*}$$\n\n1. 两点之间的角度\n$$<\\phi (x),\\phi (x')>=\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|cos\\theta \\\\\n\\Rightarrow cos\\theta =\\frac{<\\phi (x),\\phi (x')>}{\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|}=\\frac{<\\phi (x),\\phi (x')>}{\\sqrt{<\\phi (x),\\phi (x)>}\\sqrt{<\\phi (x'),\\phi (x')>}}$$\n\n## 什么样的函数才可以叫做核函数？\n对称函数$K(x,z)$为正定核的充要条件如下：对任意$x_i\\in \\chi ,i=1,2,\\cdots ,m$,任意正整数$m$,对称函数$K(x,z)$对应的Gram矩阵是半正定。\n$$Gram = \\begin{bmatrix}\nK(x_1,x_1) & \\cdots  & K(x_1,x_n)\\\\\n\\vdots  & \\ddots  & \\vdots \\\\\nK(x_n,x_1) & \\cdots  & K(x_n,x_n)\n\\end{bmatrix}$$\n半正定：$x^T\\: Gram\\; x\\geqslant 0$\n\n## 常用核函数\n核函数 | 英文 | 公式\n- | - | -\n线性核函数 | Linear Kernel | $K(x, z) = x \\cdot z$\n多项式核函数 | Polynomial Kernel | $K(x, z) = （\\gamma x \\cdot z  + r)^d$\n高斯核函数 | Gaussian Kernel | $K(x, z) = exp(-\\gamma$&#124;&#124;$x-z$&#124;&#124;$^2)$\nSigmoid核函数 | Sigmoid Kernel | $K(x, z) = tanh（\\gamma x \\cdot z  + r)$\n\n\n\n- 线性核函数\n线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：$$K(x, z) = x \\cdot z$$也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n- 多项式核函数\n多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：$$K(x, z) = （\\gamma x \\cdot z  + r)^d$$其中，$γ,r,d$都需要自己调参定义。\n- 高斯核函数\n高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：$$K(x, z) = exp(-\\gamma||x-z||^2)$$其中，$γ$大于0，需要自己调参定义。\n- Sigmoid核函数\nSigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：$$K(x, z) = tanh（\\gamma x \\cdot z  + r)$$其中，$γ,r$都需要自己调参定义。\n","source":"_posts/核函数.md","raw":"---\ntitle: 核函数\ndate: 2017-09-02 00:12:57\ntags: [人工智能,数学]\ncategories: 机器学习\n---\n\n之前分析的感知机、主成分分析（Principle component analysis, PCA）包括后面看的支撑向量机（Support vector machines, SVM），都有用到核函数。核函数是将信号映射到高维，而PCA一般用来降维。这里简单梳理一下核函数的知识：\n\n# 核函数基本概念\n## 定义\n设$\\chi $是输入空间(欧氏空间$\\mathbb{R}^{n}$的子集或离散集合)，又设$\\mathbb{R}^{H}$为特征空间(希尔伯特空间)，如果存在一个从$\\chi $到$\\mathbb{R}^{H}$的映射$$\\phi  (x):\\chi \\rightarrow \\mathbb{H}$$使得对所有$x,z\\in \\chi $，函数$K(x,z)$满足条件$$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$$则称$K(x,z)$为核函数，$\\phi  (x)$为映射函数，式中$\\phi  (x) \\cdot \\phi  (z)$为$\\phi  (x)$和$\\phi  (z)$的内积\n\n核函数：是映射关系$\\phi  (x)$的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数，这通常是我们希望的。\n## 核函数的作用\n- 聚类、分类\n\n![](核函数/核函数-e3fe62f2.png)\n二维映射到三维，区分就更容易了，这是聚类、分类常用核函数的原因。为什么PCA这样一个降维算法也用核函数呢？\n- 降维\n![](核函数/核函数-f46521d0.png)\n\n左图为原数据，右图为映射到三维的数据，可以看出：同样是降到1维，先通过Kernel映射到（Kernel是映射的内积，不要弄乱了）三维，再投影到1维，就容易分离开，这就是Kernel在PCA降维中的应用，本质还是对原有数据增加维度。\n\n# 核函数为什么可以映射到高维\n## 为什么实现数据映射到高维\n\n![](核函数/核函数-7d4cb2e5.png)\n\n- 设原空间数据点$a_1=(x_1,x_2)；a_2=(x_1',x_2')$；\n- 设高维空间的数据点为$A_1 =\\phi (a_1)=(z_1,z_2,z_3)；A_2=\\phi (a_1)=(z_1',z_2',z_3')$\n\n$\\left \\langle a_1,a_2 \\right \\rangle$为两点之间的内积$\\left \\langle a_1,a_2 \\right \\rangle = \\left \\langle (x_1,x_2),(x_1',x_2') \\right \\rangle =x_1x_1'+x_2x_2'$\n\n\n$<\\phi (a_1),\\phi (a_2)>=<\\phi (x_1,x_2),\\phi (x_1',x_2')>=<(z_1,z_2,z_3),(z_1',z_2',z_3')>=<(x_1^2,\\sqrt{2}x_1x_2,x_2^2),({x}_1'^2,\\sqrt{2}x_1'x_2',{x}_2'^2)>=x_1^2x_1'^2+2x_1x_2x_1'x_2'+x_2^2x_2'^2=(x_1x_1'+x_2x_2')^2=(<a_1,a_2'>)^2=k(a_1,a_2)$\n\n## 为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？\n因为$(x,z)$一起出现的时候，$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$有许多固定的形式可以调用，而不必求解或者关心$\\phi  (x)$的具体形式，这大大简化了求解。\n## 核函数的用法\n1. 两点之间的距离\n$$\\begin{align*}\n\\left \\| \\phi (x)-  \\phi (x')\\right \\|^2\n&=(\\phi (x)-  \\phi (x'))^T(\\phi (x)-  \\phi (x'))\\\\\n&=\\phi (x)^T\\phi (x)-2\\phi (x)^T\\phi (x')+\\phi (x')^T\\phi (x')\\\\\n&=<\\phi (x),\\phi (x)>-2<\\phi (x),\\phi (x')>+<\\phi (x'),\\phi (x')>\\\\\n&=K(x,x)-2K(x,x')+K(x',x')\n\\end{align*}$$\n\n1. 两点之间的角度\n$$<\\phi (x),\\phi (x')>=\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|cos\\theta \\\\\n\\Rightarrow cos\\theta =\\frac{<\\phi (x),\\phi (x')>}{\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|}=\\frac{<\\phi (x),\\phi (x')>}{\\sqrt{<\\phi (x),\\phi (x)>}\\sqrt{<\\phi (x'),\\phi (x')>}}$$\n\n## 什么样的函数才可以叫做核函数？\n对称函数$K(x,z)$为正定核的充要条件如下：对任意$x_i\\in \\chi ,i=1,2,\\cdots ,m$,任意正整数$m$,对称函数$K(x,z)$对应的Gram矩阵是半正定。\n$$Gram = \\begin{bmatrix}\nK(x_1,x_1) & \\cdots  & K(x_1,x_n)\\\\\n\\vdots  & \\ddots  & \\vdots \\\\\nK(x_n,x_1) & \\cdots  & K(x_n,x_n)\n\\end{bmatrix}$$\n半正定：$x^T\\: Gram\\; x\\geqslant 0$\n\n## 常用核函数\n核函数 | 英文 | 公式\n- | - | -\n线性核函数 | Linear Kernel | $K(x, z) = x \\cdot z$\n多项式核函数 | Polynomial Kernel | $K(x, z) = （\\gamma x \\cdot z  + r)^d$\n高斯核函数 | Gaussian Kernel | $K(x, z) = exp(-\\gamma$&#124;&#124;$x-z$&#124;&#124;$^2)$\nSigmoid核函数 | Sigmoid Kernel | $K(x, z) = tanh（\\gamma x \\cdot z  + r)$\n\n\n\n- 线性核函数\n线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：$$K(x, z) = x \\cdot z$$也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。\n- 多项式核函数\n多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：$$K(x, z) = （\\gamma x \\cdot z  + r)^d$$其中，$γ,r,d$都需要自己调参定义。\n- 高斯核函数\n高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：$$K(x, z) = exp(-\\gamma||x-z||^2)$$其中，$γ$大于0，需要自己调参定义。\n- Sigmoid核函数\nSigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：$$K(x, z) = tanh（\\gamma x \\cdot z  + r)$$其中，$γ,r$都需要自己调参定义。\n","slug":"核函数","published":1,"updated":"2019-07-30T01:54:38.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0l005ahomjvkkrntak","content":"<p>之前分析的感知机、主成分分析（Principle component analysis, PCA）包括后面看的支撑向量机（Support vector machines, SVM），都有用到核函数。核函数是将信号映射到高维，而PCA一般用来降维。这里简单梳理一下核函数的知识：</p>\n<h1 id=\"核函数基本概念\"><a href=\"#核函数基本概念\" class=\"headerlink\" title=\"核函数基本概念\"></a>核函数基本概念</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>设$\\chi $是输入空间(欧氏空间$\\mathbb{R}^{n}$的子集或离散集合)，又设$\\mathbb{R}^{H}$为特征空间(希尔伯特空间)，如果存在一个从$\\chi $到$\\mathbb{R}^{H}$的映射<script type=\"math/tex\">\\phi  (x):\\chi \\rightarrow \\mathbb{H}</script>使得对所有$x,z\\in \\chi $，函数$K(x,z)$满足条件<script type=\"math/tex\">K(x,z)=\\phi  (x) \\cdot \\phi  (z)</script>则称$K(x,z)$为核函数，$\\phi  (x)$为映射函数，式中$\\phi  (x) \\cdot \\phi  (z)$为$\\phi  (x)$和$\\phi  (z)$的内积</p>\n<p>核函数：是映射关系$\\phi  (x)$的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数，这通常是我们希望的。</p>\n<h2 id=\"核函数的作用\"><a href=\"#核函数的作用\" class=\"headerlink\" title=\"核函数的作用\"></a>核函数的作用</h2><ul>\n<li>聚类、分类</li>\n</ul>\n<p><img src=\"/2017/09/02/核函数/核函数-e3fe62f2.png\" alt=\"\"><br>二维映射到三维，区分就更容易了，这是聚类、分类常用核函数的原因。为什么PCA这样一个降维算法也用核函数呢？</p>\n<ul>\n<li>降维<br><img src=\"/2017/09/02/核函数/核函数-f46521d0.png\" alt=\"\"></li>\n</ul>\n<p>左图为原数据，右图为映射到三维的数据，可以看出：同样是降到1维，先通过Kernel映射到（Kernel是映射的内积，不要弄乱了）三维，再投影到1维，就容易分离开，这就是Kernel在PCA降维中的应用，本质还是对原有数据增加维度。</p>\n<h1 id=\"核函数为什么可以映射到高维\"><a href=\"#核函数为什么可以映射到高维\" class=\"headerlink\" title=\"核函数为什么可以映射到高维\"></a>核函数为什么可以映射到高维</h1><h2 id=\"为什么实现数据映射到高维\"><a href=\"#为什么实现数据映射到高维\" class=\"headerlink\" title=\"为什么实现数据映射到高维\"></a>为什么实现数据映射到高维</h2><p><img src=\"/2017/09/02/核函数/核函数-7d4cb2e5.png\" alt=\"\"></p>\n<ul>\n<li>设原空间数据点$a_1=(x_1,x_2)；a_2=(x_1’,x_2’)$；</li>\n<li>设高维空间的数据点为$A_1 =\\phi (a_1)=(z_1,z_2,z_3)；A_2=\\phi (a_1)=(z_1’,z_2’,z_3’)$</li>\n</ul>\n<p>$\\left \\langle a_1,a_2 \\right \\rangle$为两点之间的内积$\\left \\langle a_1,a_2 \\right \\rangle = \\left \\langle (x_1,x_2),(x_1’,x_2’) \\right \\rangle =x_1x_1’+x_2x_2’$</p>\n<p>$&lt;\\phi (a_1),\\phi (a_2)&gt;=&lt;\\phi (x_1,x_2),\\phi (x_1’,x_2’)&gt;=&lt;(z_1,z_2,z_3),(z_1’,z_2’,z_3’)&gt;=&lt;(x_1^2,\\sqrt{2}x_1x_2,x_2^2),({x}_1’^2,\\sqrt{2}x_1’x_2’,{x}_2’^2)&gt;=x_1^2x_1’^2+2x_1x_2x_1’x_2’+x_2^2x_2’^2=(x_1x_1’+x_2x_2’)^2=(&lt;a_1,a_2’&gt;)^2=k(a_1,a_2)$</p>\n<h2 id=\"为什么不用映射函数-phi-x-，而用他们的内积形式-K-x-z-，即Kernel函数？\"><a href=\"#为什么不用映射函数-phi-x-，而用他们的内积形式-K-x-z-，即Kernel函数？\" class=\"headerlink\" title=\"为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？\"></a>为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？</h2><p>因为$(x,z)$一起出现的时候，$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$有许多固定的形式可以调用，而不必求解或者关心$\\phi  (x)$的具体形式，这大大简化了求解。</p>\n<h2 id=\"核函数的用法\"><a href=\"#核函数的用法\" class=\"headerlink\" title=\"核函数的用法\"></a>核函数的用法</h2><ol>\n<li><p>两点之间的距离</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\left \\| \\phi (x)-  \\phi (x')\\right \\|^2\n&=(\\phi (x)-  \\phi (x'))^T(\\phi (x)-  \\phi (x'))\\\\\n&=\\phi (x)^T\\phi (x)-2\\phi (x)^T\\phi (x')+\\phi (x')^T\\phi (x')\\\\\n&=<\\phi (x),\\phi (x)>-2<\\phi (x),\\phi (x')>+<\\phi (x'),\\phi (x')>\\\\\n&=K(x,x)-2K(x,x')+K(x',x')\n\\end{align*}</script></li>\n<li><p>两点之间的角度</p>\n<script type=\"math/tex; mode=display\"><\\phi (x),\\phi (x')>=\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|cos\\theta \\\\\n\\Rightarrow cos\\theta =\\frac{<\\phi (x),\\phi (x')>}{\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|}=\\frac{<\\phi (x),\\phi (x')>}{\\sqrt{<\\phi (x),\\phi (x)>}\\sqrt{<\\phi (x'),\\phi (x')>}}</script></li>\n</ol>\n<h2 id=\"什么样的函数才可以叫做核函数？\"><a href=\"#什么样的函数才可以叫做核函数？\" class=\"headerlink\" title=\"什么样的函数才可以叫做核函数？\"></a>什么样的函数才可以叫做核函数？</h2><p>对称函数$K(x,z)$为正定核的充要条件如下：对任意$x_i\\in \\chi ,i=1,2,\\cdots ,m$,任意正整数$m$,对称函数$K(x,z)$对应的Gram矩阵是半正定。</p>\n<script type=\"math/tex; mode=display\">Gram = \\begin{bmatrix}\nK(x_1,x_1) & \\cdots  & K(x_1,x_n)\\\\\n\\vdots  & \\ddots  & \\vdots \\\\\nK(x_n,x_1) & \\cdots  & K(x_n,x_n)\n\\end{bmatrix}</script><p>半正定：$x^T\\: Gram\\; x\\geqslant 0$</p>\n<h2 id=\"常用核函数\"><a href=\"#常用核函数\" class=\"headerlink\" title=\"常用核函数\"></a>常用核函数</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>核函数</th>\n<th>英文</th>\n<th>公式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线性核函数</td>\n<td>Linear Kernel</td>\n<td>$K(x, z) = x \\cdot z$</td>\n</tr>\n<tr>\n<td>多项式核函数</td>\n<td>Polynomial Kernel</td>\n<td>$K(x, z) = （\\gamma x \\cdot z  + r)^d$</td>\n</tr>\n<tr>\n<td>高斯核函数</td>\n<td>Gaussian Kernel</td>\n<td>$K(x, z) = exp(-\\gamma$&#124;&#124;$x-z$&#124;&#124;$^2)$</td>\n</tr>\n<tr>\n<td>Sigmoid核函数</td>\n<td>Sigmoid Kernel</td>\n<td>$K(x, z) = tanh（\\gamma x \\cdot z  + r)$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>线性核函数<br>线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：<script type=\"math/tex\">K(x, z) = x \\cdot z</script>也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。</li>\n<li>多项式核函数<br>多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex\">K(x, z) = （\\gamma x \\cdot z  + r)^d</script>其中，$γ,r,d$都需要自己调参定义。</li>\n<li>高斯核函数<br>高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：<script type=\"math/tex\">K(x, z) = exp(-\\gamma||x-z||^2)</script>其中，$γ$大于0，需要自己调参定义。</li>\n<li>Sigmoid核函数<br>Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex\">K(x, z) = tanh（\\gamma x \\cdot z  + r)</script>其中，$γ,r$都需要自己调参定义。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>之前分析的感知机、主成分分析（Principle component analysis, PCA）包括后面看的支撑向量机（Support vector machines, SVM），都有用到核函数。核函数是将信号映射到高维，而PCA一般用来降维。这里简单梳理一下核函数的知识：</p>\n<h1 id=\"核函数基本概念\"><a href=\"#核函数基本概念\" class=\"headerlink\" title=\"核函数基本概念\"></a>核函数基本概念</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>设$\\chi $是输入空间(欧氏空间$\\mathbb{R}^{n}$的子集或离散集合)，又设$\\mathbb{R}^{H}$为特征空间(希尔伯特空间)，如果存在一个从$\\chi $到$\\mathbb{R}^{H}$的映射<script type=\"math/tex\">\\phi  (x):\\chi \\rightarrow \\mathbb{H}</script>使得对所有$x,z\\in \\chi $，函数$K(x,z)$满足条件<script type=\"math/tex\">K(x,z)=\\phi  (x) \\cdot \\phi  (z)</script>则称$K(x,z)$为核函数，$\\phi  (x)$为映射函数，式中$\\phi  (x) \\cdot \\phi  (z)$为$\\phi  (x)$和$\\phi  (z)$的内积</p>\n<p>核函数：是映射关系$\\phi  (x)$的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数，这通常是我们希望的。</p>\n<h2 id=\"核函数的作用\"><a href=\"#核函数的作用\" class=\"headerlink\" title=\"核函数的作用\"></a>核函数的作用</h2><ul>\n<li>聚类、分类</li>\n</ul>\n<p><img src=\"/2017/09/02/核函数/核函数-e3fe62f2.png\" alt=\"\"><br>二维映射到三维，区分就更容易了，这是聚类、分类常用核函数的原因。为什么PCA这样一个降维算法也用核函数呢？</p>\n<ul>\n<li>降维<br><img src=\"/2017/09/02/核函数/核函数-f46521d0.png\" alt=\"\"></li>\n</ul>\n<p>左图为原数据，右图为映射到三维的数据，可以看出：同样是降到1维，先通过Kernel映射到（Kernel是映射的内积，不要弄乱了）三维，再投影到1维，就容易分离开，这就是Kernel在PCA降维中的应用，本质还是对原有数据增加维度。</p>\n<h1 id=\"核函数为什么可以映射到高维\"><a href=\"#核函数为什么可以映射到高维\" class=\"headerlink\" title=\"核函数为什么可以映射到高维\"></a>核函数为什么可以映射到高维</h1><h2 id=\"为什么实现数据映射到高维\"><a href=\"#为什么实现数据映射到高维\" class=\"headerlink\" title=\"为什么实现数据映射到高维\"></a>为什么实现数据映射到高维</h2><p><img src=\"/2017/09/02/核函数/核函数-7d4cb2e5.png\" alt=\"\"></p>\n<ul>\n<li>设原空间数据点$a_1=(x_1,x_2)；a_2=(x_1’,x_2’)$；</li>\n<li>设高维空间的数据点为$A_1 =\\phi (a_1)=(z_1,z_2,z_3)；A_2=\\phi (a_1)=(z_1’,z_2’,z_3’)$</li>\n</ul>\n<p>$\\left \\langle a_1,a_2 \\right \\rangle$为两点之间的内积$\\left \\langle a_1,a_2 \\right \\rangle = \\left \\langle (x_1,x_2),(x_1’,x_2’) \\right \\rangle =x_1x_1’+x_2x_2’$</p>\n<p>$&lt;\\phi (a_1),\\phi (a_2)&gt;=&lt;\\phi (x_1,x_2),\\phi (x_1’,x_2’)&gt;=&lt;(z_1,z_2,z_3),(z_1’,z_2’,z_3’)&gt;=&lt;(x_1^2,\\sqrt{2}x_1x_2,x_2^2),({x}_1’^2,\\sqrt{2}x_1’x_2’,{x}_2’^2)&gt;=x_1^2x_1’^2+2x_1x_2x_1’x_2’+x_2^2x_2’^2=(x_1x_1’+x_2x_2’)^2=(&lt;a_1,a_2’&gt;)^2=k(a_1,a_2)$</p>\n<h2 id=\"为什么不用映射函数-phi-x-，而用他们的内积形式-K-x-z-，即Kernel函数？\"><a href=\"#为什么不用映射函数-phi-x-，而用他们的内积形式-K-x-z-，即Kernel函数？\" class=\"headerlink\" title=\"为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？\"></a>为什么不用映射函数$\\phi  (x)$，而用他们的内积形式$K(x,z)$，即Kernel函数？</h2><p>因为$(x,z)$一起出现的时候，$K(x,z)=\\phi  (x) \\cdot \\phi  (z)$有许多固定的形式可以调用，而不必求解或者关心$\\phi  (x)$的具体形式，这大大简化了求解。</p>\n<h2 id=\"核函数的用法\"><a href=\"#核函数的用法\" class=\"headerlink\" title=\"核函数的用法\"></a>核函数的用法</h2><ol>\n<li><p>两点之间的距离</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\left \\| \\phi (x)-  \\phi (x')\\right \\|^2\n&=(\\phi (x)-  \\phi (x'))^T(\\phi (x)-  \\phi (x'))\\\\\n&=\\phi (x)^T\\phi (x)-2\\phi (x)^T\\phi (x')+\\phi (x')^T\\phi (x')\\\\\n&=<\\phi (x),\\phi (x)>-2<\\phi (x),\\phi (x')>+<\\phi (x'),\\phi (x')>\\\\\n&=K(x,x)-2K(x,x')+K(x',x')\n\\end{align*}</script></li>\n<li><p>两点之间的角度</p>\n<script type=\"math/tex; mode=display\"><\\phi (x),\\phi (x')>=\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|cos\\theta \\\\\n\\Rightarrow cos\\theta =\\frac{<\\phi (x),\\phi (x')>}{\\left \\| \\phi (x)\\right \\|\\cdot \\left \\| \\phi (x')\\right \\|}=\\frac{<\\phi (x),\\phi (x')>}{\\sqrt{<\\phi (x),\\phi (x)>}\\sqrt{<\\phi (x'),\\phi (x')>}}</script></li>\n</ol>\n<h2 id=\"什么样的函数才可以叫做核函数？\"><a href=\"#什么样的函数才可以叫做核函数？\" class=\"headerlink\" title=\"什么样的函数才可以叫做核函数？\"></a>什么样的函数才可以叫做核函数？</h2><p>对称函数$K(x,z)$为正定核的充要条件如下：对任意$x_i\\in \\chi ,i=1,2,\\cdots ,m$,任意正整数$m$,对称函数$K(x,z)$对应的Gram矩阵是半正定。</p>\n<script type=\"math/tex; mode=display\">Gram = \\begin{bmatrix}\nK(x_1,x_1) & \\cdots  & K(x_1,x_n)\\\\\n\\vdots  & \\ddots  & \\vdots \\\\\nK(x_n,x_1) & \\cdots  & K(x_n,x_n)\n\\end{bmatrix}</script><p>半正定：$x^T\\: Gram\\; x\\geqslant 0$</p>\n<h2 id=\"常用核函数\"><a href=\"#常用核函数\" class=\"headerlink\" title=\"常用核函数\"></a>常用核函数</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>核函数</th>\n<th>英文</th>\n<th>公式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>线性核函数</td>\n<td>Linear Kernel</td>\n<td>$K(x, z) = x \\cdot z$</td>\n</tr>\n<tr>\n<td>多项式核函数</td>\n<td>Polynomial Kernel</td>\n<td>$K(x, z) = （\\gamma x \\cdot z  + r)^d$</td>\n</tr>\n<tr>\n<td>高斯核函数</td>\n<td>Gaussian Kernel</td>\n<td>$K(x, z) = exp(-\\gamma$&#124;&#124;$x-z$&#124;&#124;$^2)$</td>\n</tr>\n<tr>\n<td>Sigmoid核函数</td>\n<td>Sigmoid Kernel</td>\n<td>$K(x, z) = tanh（\\gamma x \\cdot z  + r)$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>线性核函数<br>线性核函数（Linear Kernel）其实就是我们前两篇的线性可分SVM，表达式为：<script type=\"math/tex\">K(x, z) = x \\cdot z</script>也就是说，线性可分SVM我们可以和线性不可分SVM归为一类，区别仅仅在于线性可分SVM用的是线性核函数。</li>\n<li>多项式核函数<br>多项式核函数（Polynomial Kernel）是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex\">K(x, z) = （\\gamma x \\cdot z  + r)^d</script>其中，$γ,r,d$都需要自己调参定义。</li>\n<li>高斯核函数<br>高斯核函数（Gaussian Kernel），在SVM中也称为径向基核函数（Radial Basis Function,RBF），它是非线性分类SVM最主流的核函数。libsvm默认的核函数就是它。表达式为：<script type=\"math/tex\">K(x, z) = exp(-\\gamma||x-z||^2)</script>其中，$γ$大于0，需要自己调参定义。</li>\n<li>Sigmoid核函数<br>Sigmoid核函数（Sigmoid Kernel）也是线性不可分SVM常用的核函数之一，表达式为：<script type=\"math/tex\">K(x, z) = tanh（\\gamma x \\cdot z  + r)</script>其中，$γ,r$都需要自己调参定义。</li>\n</ul>\n"},{"title":"梯度类方法与对偶算法","date":"2017-08-18T12:37:34.000Z","_content":"\n# 梯度类方法\n梯度类方法是无约束优化中非常常用的方法，其依据的最根本的事实就是梯度的负方向是函数值下降最快的方向。但是常用的 **gradient descent 必须要求函数的连续可导**，而对于某些**连续不可导**的问题（如lasso regression），gradient descent 无能为力，这是需要用到**subgradient descent**和**proximal gradient descent**.\n<!--more-->\n## gradient descent\n梯度下降法的迭代公式为\n$$x^{(k)} = x^{(k-1)} - t_k\\nabla f(x^{(k-1)} )$$\n上式中上标 $(k)$ 表示第 $k$ 次迭代, 而 $t_k$ 表示步长，$\\nabla f(x^{(k-1)})$表示在点 $x^{(k-1)}$ 的梯度。\n\n这里对于梯度下降主要讨论其步长选择的问题， 最简单直接的方式是固定每次的步长为一个恒定值，但是如果步长过大或过小时，可能会导致结果难以收敛或者收敛速度很慢。因此提出了可变长步长的方法，可变长步长的方法指的是根据每次迭代依照一定的规则改变步长，下面介绍两种：backtracking line search 和 exact line serach。\n\n### backtracking line search\n\nbacktracking line search 需要先选择两个固定的参数 $α,β$ , 要求 $0<β<1,0<α<1/2$每次迭代的时候，假如下式成立\n\n$$f(x - t\\nabla f(x)) > f(x) - \\alpha t||\\nabla f(x)||_2^2$$\n则改变步长为 $t=βt$, 否则步长不变。\n\n这种方法的思想是当步长过大的时候(即跨过了最优点)，减小步长，否则保持步长不变，如下式是一个简单的例子\n![backtracking line search](梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png)\n\n### exact line serach\n\nexact line serach 则是得到先计算出梯度 $\\nabla f(x^{(k-1)} )$,然后代入下面的函数中，此时只有步长 $t_k$ 是未知，因此可对 $t_k$ 进行求导并令其为0，求得的 $t_k$ 即为当前的最优的步长，因为这个步长令当前迭代下降的距离最大。\n$$f(x^{(k-1)} - t_k\\nabla f(x^{(k-1)} ))$$\n这种方法也被称为最速下降法。\n\n# 对偶类算法\n\n## 拉格朗日\n拉格朗日对偶性是**解决带约束的最优化问题**的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机。\n\n### 拉格朗日函数\n\n假设 $f(x)，c_i(x),h_j(x)$ 是定义在 $\\mathbb{R}^{n}$ 上的连续可微函数。我们需要求解约束最优化问题：\n\n$$\\underset{x\\in \\mathbb{R}^n}{min} \\;  f(x)  \\tag 1$$\n\n$$\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k  \\tag 2\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l \\tag 3\n\\end{align}$$\n\n为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：\n$$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}$$\n其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$\n\n### 极小极大问题\n\n如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即\n$$\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5$$\n\n确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数\n\n- 如果 $x$ 满足原始问题中约束，\n由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0\n\n- 如果$x$不满足原始问题中的约束，那么$θ(x)=+∞$。若某个$i$使约束$c_i(x)>0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。\n\n综上：\n$$\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.$$\n\n**求解原问题的最小值**\n\n$$\\underset{x\\in \\mathbb{R}^n}{min}; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)$$\n\n### 极大极小问题（对偶问题）\n\n$$\\theta _D(\\alpha ,\\beta )=\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$$\n\n$$\\max_{\\alpha,\\beta:\\alpha_i\\ge0}\\theta _D(\\alpha ,\\beta )=\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$$\n可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：\n$$\\begin{align*}\n&\\underset{\\alpha,\\beta}{max}\\; \\min_{x\\in\\mathbb{R}^{n}}L(x,\\alpha,\\beta) \\\\\n\\mathbb{s.t.}&\\quad\\alpha_i\\ge0,\\quad i=1,2,\\cdots,k\n\\end{align*}$$\n\n### 原始问题和对偶问题的关系\n#### 定理1\n若原始问题和对偶问题都有最优值，则\n$$\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $$\n\n\n$$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)$$\n\n**推论**：设 $x^{\\ast}$ 和 $a^{\\ast},β^{\\ast}$ 分别是原始问题 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $ 和对偶问题 $\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $ 的可行解，并且 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$，则 $x^{\\ast}$和 $a^{\\ast}$,$β^{\\ast}$ 分别是原始问题和对偶问题的最优解。\n\n#### 定理2：KKT条件(原始问题与对偶问题的解相等的条件)\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^{\\ast}$和$a^{\\ast},β^{\\ast}$分别是原始问题和对偶问题的解的充分必要条件是$x^{\\ast},a^{\\ast},β^{\\ast}$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）\n$$\\begin{align*}\n\\nabla_xL(x^*,\\alpha^*,\\beta^*)&=0\\\\\n\\nabla_{\\alpha}L(x^*,\\alpha^*,\\beta^*) &=0 \\\\\n\\nabla_{\\beta}L(x^*,\\alpha^*,\\beta^*)&=0\n\\end{align*}$$\n$$\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}$$\n - 仿射函数\n$$f(x)=A\\cdot x+b$$仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$ 可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。\n","source":"_posts/梯度类方法与对偶算法.md","raw":"---\ntitle: 梯度类方法与对偶算法\ndate: 2017-08-18 20:37:34\ntags: [人工智能,优化]\ncategories: 数学\n---\n\n# 梯度类方法\n梯度类方法是无约束优化中非常常用的方法，其依据的最根本的事实就是梯度的负方向是函数值下降最快的方向。但是常用的 **gradient descent 必须要求函数的连续可导**，而对于某些**连续不可导**的问题（如lasso regression），gradient descent 无能为力，这是需要用到**subgradient descent**和**proximal gradient descent**.\n<!--more-->\n## gradient descent\n梯度下降法的迭代公式为\n$$x^{(k)} = x^{(k-1)} - t_k\\nabla f(x^{(k-1)} )$$\n上式中上标 $(k)$ 表示第 $k$ 次迭代, 而 $t_k$ 表示步长，$\\nabla f(x^{(k-1)})$表示在点 $x^{(k-1)}$ 的梯度。\n\n这里对于梯度下降主要讨论其步长选择的问题， 最简单直接的方式是固定每次的步长为一个恒定值，但是如果步长过大或过小时，可能会导致结果难以收敛或者收敛速度很慢。因此提出了可变长步长的方法，可变长步长的方法指的是根据每次迭代依照一定的规则改变步长，下面介绍两种：backtracking line search 和 exact line serach。\n\n### backtracking line search\n\nbacktracking line search 需要先选择两个固定的参数 $α,β$ , 要求 $0<β<1,0<α<1/2$每次迭代的时候，假如下式成立\n\n$$f(x - t\\nabla f(x)) > f(x) - \\alpha t||\\nabla f(x)||_2^2$$\n则改变步长为 $t=βt$, 否则步长不变。\n\n这种方法的思想是当步长过大的时候(即跨过了最优点)，减小步长，否则保持步长不变，如下式是一个简单的例子\n![backtracking line search](梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png)\n\n### exact line serach\n\nexact line serach 则是得到先计算出梯度 $\\nabla f(x^{(k-1)} )$,然后代入下面的函数中，此时只有步长 $t_k$ 是未知，因此可对 $t_k$ 进行求导并令其为0，求得的 $t_k$ 即为当前的最优的步长，因为这个步长令当前迭代下降的距离最大。\n$$f(x^{(k-1)} - t_k\\nabla f(x^{(k-1)} ))$$\n这种方法也被称为最速下降法。\n\n# 对偶类算法\n\n## 拉格朗日\n拉格朗日对偶性是**解决带约束的最优化问题**的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机。\n\n### 拉格朗日函数\n\n假设 $f(x)，c_i(x),h_j(x)$ 是定义在 $\\mathbb{R}^{n}$ 上的连续可微函数。我们需要求解约束最优化问题：\n\n$$\\underset{x\\in \\mathbb{R}^n}{min} \\;  f(x)  \\tag 1$$\n\n$$\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k  \\tag 2\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l \\tag 3\n\\end{align}$$\n\n为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：\n$$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}$$\n其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$\n\n### 极小极大问题\n\n如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即\n$$\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5$$\n\n确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数\n\n- 如果 $x$ 满足原始问题中约束，\n由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0\n\n- 如果$x$不满足原始问题中的约束，那么$θ(x)=+∞$。若某个$i$使约束$c_i(x)>0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。\n\n综上：\n$$\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.$$\n\n**求解原问题的最小值**\n\n$$\\underset{x\\in \\mathbb{R}^n}{min}; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)$$\n\n### 极大极小问题（对偶问题）\n\n$$\\theta _D(\\alpha ,\\beta )=\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$$\n\n$$\\max_{\\alpha,\\beta:\\alpha_i\\ge0}\\theta _D(\\alpha ,\\beta )=\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$$\n可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：\n$$\\begin{align*}\n&\\underset{\\alpha,\\beta}{max}\\; \\min_{x\\in\\mathbb{R}^{n}}L(x,\\alpha,\\beta) \\\\\n\\mathbb{s.t.}&\\quad\\alpha_i\\ge0,\\quad i=1,2,\\cdots,k\n\\end{align*}$$\n\n### 原始问题和对偶问题的关系\n#### 定理1\n若原始问题和对偶问题都有最优值，则\n$$\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $$\n\n\n$$\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)$$\n\n**推论**：设 $x^{\\ast}$ 和 $a^{\\ast},β^{\\ast}$ 分别是原始问题 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $ 和对偶问题 $\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $ 的可行解，并且 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$，则 $x^{\\ast}$和 $a^{\\ast}$,$β^{\\ast}$ 分别是原始问题和对偶问题的最优解。\n\n#### 定理2：KKT条件(原始问题与对偶问题的解相等的条件)\n假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^{\\ast}$和$a^{\\ast},β^{\\ast}$分别是原始问题和对偶问题的解的充分必要条件是$x^{\\ast},a^{\\ast},β^{\\ast}$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）\n$$\\begin{align*}\n\\nabla_xL(x^*,\\alpha^*,\\beta^*)&=0\\\\\n\\nabla_{\\alpha}L(x^*,\\alpha^*,\\beta^*) &=0 \\\\\n\\nabla_{\\beta}L(x^*,\\alpha^*,\\beta^*)&=0\n\\end{align*}$$\n$$\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}$$\n - 仿射函数\n$$f(x)=A\\cdot x+b$$仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$ 可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。\n","slug":"梯度类方法与对偶算法","published":1,"updated":"2019-07-30T01:54:38.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0o005dhomjj5v6pe7g","content":"<h1 id=\"梯度类方法\"><a href=\"#梯度类方法\" class=\"headerlink\" title=\"梯度类方法\"></a>梯度类方法</h1><p>梯度类方法是无约束优化中非常常用的方法，其依据的最根本的事实就是梯度的负方向是函数值下降最快的方向。但是常用的 <strong>gradient descent 必须要求函数的连续可导</strong>，而对于某些<strong>连续不可导</strong>的问题（如lasso regression），gradient descent 无能为力，这是需要用到<strong>subgradient descent</strong>和<strong>proximal gradient descent</strong>.<br><a id=\"more\"></a></p>\n<h2 id=\"gradient-descent\"><a href=\"#gradient-descent\" class=\"headerlink\" title=\"gradient descent\"></a>gradient descent</h2><p>梯度下降法的迭代公式为</p>\n<script type=\"math/tex; mode=display\">x^{(k)} = x^{(k-1)} - t_k\\nabla f(x^{(k-1)} )</script><p>上式中上标 $(k)$ 表示第 $k$ 次迭代, 而 $t_k$ 表示步长，$\\nabla f(x^{(k-1)})$表示在点 $x^{(k-1)}$ 的梯度。</p>\n<p>这里对于梯度下降主要讨论其步长选择的问题， 最简单直接的方式是固定每次的步长为一个恒定值，但是如果步长过大或过小时，可能会导致结果难以收敛或者收敛速度很慢。因此提出了可变长步长的方法，可变长步长的方法指的是根据每次迭代依照一定的规则改变步长，下面介绍两种：backtracking line search 和 exact line serach。</p>\n<h3 id=\"backtracking-line-search\"><a href=\"#backtracking-line-search\" class=\"headerlink\" title=\"backtracking line search\"></a>backtracking line search</h3><p>backtracking line search 需要先选择两个固定的参数 $α,β$ , 要求 $0&lt;β&lt;1,0&lt;α&lt;1/2$每次迭代的时候，假如下式成立</p>\n<script type=\"math/tex; mode=display\">f(x - t\\nabla f(x)) > f(x) - \\alpha t||\\nabla f(x)||_2^2</script><p>则改变步长为 $t=βt$, 否则步长不变。</p>\n<p>这种方法的思想是当步长过大的时候(即跨过了最优点)，减小步长，否则保持步长不变，如下式是一个简单的例子<br><img src=\"/2017/08/18/梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png\" alt=\"backtracking line search\"></p>\n<h3 id=\"exact-line-serach\"><a href=\"#exact-line-serach\" class=\"headerlink\" title=\"exact line serach\"></a>exact line serach</h3><p>exact line serach 则是得到先计算出梯度 $\\nabla f(x^{(k-1)} )$,然后代入下面的函数中，此时只有步长 $t_k$ 是未知，因此可对 $t_k$ 进行求导并令其为0，求得的 $t_k$ 即为当前的最优的步长，因为这个步长令当前迭代下降的距离最大。</p>\n<script type=\"math/tex; mode=display\">f(x^{(k-1)} - t_k\\nabla f(x^{(k-1)} ))</script><p>这种方法也被称为最速下降法。</p>\n<h1 id=\"对偶类算法\"><a href=\"#对偶类算法\" class=\"headerlink\" title=\"对偶类算法\"></a>对偶类算法</h1><h2 id=\"拉格朗日\"><a href=\"#拉格朗日\" class=\"headerlink\" title=\"拉格朗日\"></a>拉格朗日</h2><p>拉格朗日对偶性是<strong>解决带约束的最优化问题</strong>的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机。</p>\n<h3 id=\"拉格朗日函数\"><a href=\"#拉格朗日函数\" class=\"headerlink\" title=\"拉格朗日函数\"></a>拉格朗日函数</h3><p>假设 $f(x)，c_i(x),h_j(x)$ 是定义在 $\\mathbb{R}^{n}$ 上的连续可微函数。我们需要求解约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min} \\;  f(x)  \\tag 1</script><script type=\"math/tex; mode=display\">\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k  \\tag 2\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l \\tag 3\n\\end{align}</script><p>为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：</p>\n<script type=\"math/tex; mode=display\">L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}</script><p>其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$</p>\n<h3 id=\"极小极大问题\"><a href=\"#极小极大问题\" class=\"headerlink\" title=\"极小极大问题\"></a>极小极大问题</h3><p>如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5</script><p>确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数</p>\n<ul>\n<li><p>如果 $x$ 满足原始问题中约束，<br>由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0</p>\n</li>\n<li><p>如果$x$不满足原始问题中的约束，那么$θ(x)=+∞$。若某个$i$使约束$c_i(x)&gt;0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。</p>\n</li>\n</ul>\n<p>综上：</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.</script><p><strong>求解原问题的最小值</strong></p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min}; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><h3 id=\"极大极小问题（对偶问题）\"><a href=\"#极大极小问题（对偶问题）\" class=\"headerlink\" title=\"极大极小问题（对偶问题）\"></a>极大极小问题（对偶问题）</h3><script type=\"math/tex; mode=display\">\\theta _D(\\alpha ,\\beta )=\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\max_{\\alpha,\\beta:\\alpha_i\\ge0}\\theta _D(\\alpha ,\\beta )=\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)</script><p>可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underset{\\alpha,\\beta}{max}\\; \\min_{x\\in\\mathbb{R}^{n}}L(x,\\alpha,\\beta) \\\\\n\\mathbb{s.t.}&\\quad\\alpha_i\\ge0,\\quad i=1,2,\\cdots,k\n\\end{align*}</script><h3 id=\"原始问题和对偶问题的关系\"><a href=\"#原始问题和对偶问题的关系\" class=\"headerlink\" title=\"原始问题和对偶问题的关系\"></a>原始问题和对偶问题的关系</h3><h4 id=\"定理1\"><a href=\"#定理1\" class=\"headerlink\" title=\"定理1\"></a>定理1</h4><p>若原始问题和对偶问题都有最优值，则</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)</script><p><strong>推论</strong>：设 $x^{\\ast}$ 和 $a^{\\ast},β^{\\ast}$ 分别是原始问题 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $ 和对偶问题 $\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $ 的可行解，并且 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$，则 $x^{\\ast}$和 $a^{\\ast}$,$β^{\\ast}$ 分别是原始问题和对偶问题的最优解。</p>\n<h4 id=\"定理2：KKT条件-原始问题与对偶问题的解相等的条件\"><a href=\"#定理2：KKT条件-原始问题与对偶问题的解相等的条件\" class=\"headerlink\" title=\"定理2：KKT条件(原始问题与对偶问题的解相等的条件)\"></a>定理2：KKT条件(原始问题与对偶问题的解相等的条件)</h4><p>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^{\\ast}$和$a^{\\ast},β^{\\ast}$分别是原始问题和对偶问题的解的充分必要条件是$x^{\\ast},a^{\\ast},β^{\\ast}$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\nabla_xL(x^*,\\alpha^*,\\beta^*)&=0\\\\\n\\nabla_{\\alpha}L(x^*,\\alpha^*,\\beta^*) &=0 \\\\\n\\nabla_{\\beta}L(x^*,\\alpha^*,\\beta^*)&=0\n\\end{align*}</script><script type=\"math/tex; mode=display\">\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}</script><ul>\n<li>仿射函数<br><script type=\"math/tex\">f(x)=A\\cdot x+b</script>仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$ 可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"梯度类方法\"><a href=\"#梯度类方法\" class=\"headerlink\" title=\"梯度类方法\"></a>梯度类方法</h1><p>梯度类方法是无约束优化中非常常用的方法，其依据的最根本的事实就是梯度的负方向是函数值下降最快的方向。但是常用的 <strong>gradient descent 必须要求函数的连续可导</strong>，而对于某些<strong>连续不可导</strong>的问题（如lasso regression），gradient descent 无能为力，这是需要用到<strong>subgradient descent</strong>和<strong>proximal gradient descent</strong>.<br></p>","more":"<p></p>\n<h2 id=\"gradient-descent\"><a href=\"#gradient-descent\" class=\"headerlink\" title=\"gradient descent\"></a>gradient descent</h2><p>梯度下降法的迭代公式为</p>\n<script type=\"math/tex; mode=display\">x^{(k)} = x^{(k-1)} - t_k\\nabla f(x^{(k-1)} )</script><p>上式中上标 $(k)$ 表示第 $k$ 次迭代, 而 $t_k$ 表示步长，$\\nabla f(x^{(k-1)})$表示在点 $x^{(k-1)}$ 的梯度。</p>\n<p>这里对于梯度下降主要讨论其步长选择的问题， 最简单直接的方式是固定每次的步长为一个恒定值，但是如果步长过大或过小时，可能会导致结果难以收敛或者收敛速度很慢。因此提出了可变长步长的方法，可变长步长的方法指的是根据每次迭代依照一定的规则改变步长，下面介绍两种：backtracking line search 和 exact line serach。</p>\n<h3 id=\"backtracking-line-search\"><a href=\"#backtracking-line-search\" class=\"headerlink\" title=\"backtracking line search\"></a>backtracking line search</h3><p>backtracking line search 需要先选择两个固定的参数 $α,β$ , 要求 $0&lt;β&lt;1,0&lt;α&lt;1/2$每次迭代的时候，假如下式成立</p>\n<script type=\"math/tex; mode=display\">f(x - t\\nabla f(x)) > f(x) - \\alpha t||\\nabla f(x)||_2^2</script><p>则改变步长为 $t=βt$, 否则步长不变。</p>\n<p>这种方法的思想是当步长过大的时候(即跨过了最优点)，减小步长，否则保持步长不变，如下式是一个简单的例子<br><img src=\"/2017/08/18/梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png\" alt=\"backtracking line search\"></p>\n<h3 id=\"exact-line-serach\"><a href=\"#exact-line-serach\" class=\"headerlink\" title=\"exact line serach\"></a>exact line serach</h3><p>exact line serach 则是得到先计算出梯度 $\\nabla f(x^{(k-1)} )$,然后代入下面的函数中，此时只有步长 $t_k$ 是未知，因此可对 $t_k$ 进行求导并令其为0，求得的 $t_k$ 即为当前的最优的步长，因为这个步长令当前迭代下降的距离最大。</p>\n<script type=\"math/tex; mode=display\">f(x^{(k-1)} - t_k\\nabla f(x^{(k-1)} ))</script><p>这种方法也被称为最速下降法。</p>\n<h1 id=\"对偶类算法\"><a href=\"#对偶类算法\" class=\"headerlink\" title=\"对偶类算法\"></a>对偶类算法</h1><h2 id=\"拉格朗日\"><a href=\"#拉格朗日\" class=\"headerlink\" title=\"拉格朗日\"></a>拉格朗日</h2><p>拉格朗日对偶性是<strong>解决带约束的最优化问题</strong>的方法，在实际应用中，通过拉格朗日对偶原理将原始问题转换成对偶问题，将原来不容易解决的问题转化为一个容易解决的问题，如支持向量机。</p>\n<h3 id=\"拉格朗日函数\"><a href=\"#拉格朗日函数\" class=\"headerlink\" title=\"拉格朗日函数\"></a>拉格朗日函数</h3><p>假设 $f(x)，c_i(x),h_j(x)$ 是定义在 $\\mathbb{R}^{n}$ 上的连续可微函数。我们需要求解约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min} \\;  f(x)  \\tag 1</script><script type=\"math/tex; mode=display\">\\begin{align}\n\\mathbb{s.t.}\\quad &c_i(x) \\le 0,\\quad i=1,2,\\cdots,k  \\tag 2\\\\\n&h_j(x)=0,\\quad j=1,2,\\cdots,l \\tag 3\n\\end{align}</script><p>为了求解原始问题，我们首先引入广义拉格朗日函数(generalized Lagrange function)：</p>\n<script type=\"math/tex; mode=display\">L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}^k \\alpha_ic_i(x) + \\sum_{j=1}^l\\beta_jh_j(x) \\tag{4}</script><p>其中，$x=(x_1,x_2,\\cdots,x_n)^T \\in \\mathbb{R}^n$，$\\alpha_i$和$\\beta_j$是拉格朗日乘子，特别要求$\\alpha_i\\geqslant 0$</p>\n<h3 id=\"极小极大问题\"><a href=\"#极小极大问题\" class=\"headerlink\" title=\"极小极大问题\"></a>极小极大问题</h3><p>如果把$L(x,\\alpha,\\beta)$看作是$\\alpha、\\beta$的函数，求其最大值，即</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) \\tag 5</script><p>确定$\\alpha、\\beta$使$L(x,\\alpha,\\beta)$取得最大值，（此过程中把$x$看做常量）下面通过$x$是否满足约束条件两方面来分析这个函数</p>\n<ul>\n<li><p>如果 $x$ 满足原始问题中约束，<br>由(2)、(3)、(4)、(5)可知 $θ(x)=f(x)$。（少的两项一个是非正的，一个是0，要取最大值的话当然得令两者都为0</p>\n</li>\n<li><p>如果$x$不满足原始问题中的约束，那么$θ(x)=+∞$。若某个$i$使约束$c_i(x)&gt;0$，则可令则可令$\\alpha \\rightarrow +∞$，若某个$j$使得$h_j(x)\\neq 0,$,则可令$\\beta_j h_j(x) \\rightarrow +∞$，而将其余各$\\alpha _i、\\beta_j$均取为0。</p>\n</li>\n</ul>\n<p>综上：</p>\n<script type=\"math/tex; mode=display\">\\theta_p(x)=\\left\\{\\begin{matrix}\nf(x),&x 满足原始问题约束\\\\\n+\\infty,&其他\n\\end{matrix}\\right.</script><p><strong>求解原问题的最小值</strong></p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in \\mathbb{R}^n}{min}; \\theta_p(x)=  \\underset{x\\in \\mathbb{R}^n}{min}\\; f(x)=\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><h3 id=\"极大极小问题（对偶问题）\"><a href=\"#极大极小问题（对偶问题）\" class=\"headerlink\" title=\"极大极小问题（对偶问题）\"></a>极大极小问题（对偶问题）</h3><script type=\"math/tex; mode=display\">\\theta _D(\\alpha ,\\beta )=\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\max_{\\alpha,\\beta:\\alpha_i\\ge0}\\theta _D(\\alpha ,\\beta )=\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)</script><p>可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n&\\underset{\\alpha,\\beta}{max}\\; \\min_{x\\in\\mathbb{R}^{n}}L(x,\\alpha,\\beta) \\\\\n\\mathbb{s.t.}&\\quad\\alpha_i\\ge0,\\quad i=1,2,\\cdots,k\n\\end{align*}</script><h3 id=\"原始问题和对偶问题的关系\"><a href=\"#原始问题和对偶问题的关系\" class=\"headerlink\" title=\"原始问题和对偶问题的关系\"></a>原始问题和对偶问题的关系</h3><h4 id=\"定理1\"><a href=\"#定理1\" class=\"headerlink\" title=\"定理1\"></a>定理1</h4><p>若原始问题和对偶问题都有最优值，则</p>\n<script type=\"math/tex; mode=display\">\\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant L(x,\\alpha,\\beta) \\leqslant \\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta)</script><script type=\"math/tex; mode=display\">\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) \\leqslant \\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) ={min}\\; f(x)</script><p><strong>推论</strong>：设 $x^{\\ast}$ 和 $a^{\\ast},β^{\\ast}$ 分别是原始问题 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\max_{\\alpha,\\beta:\\alpha_i\\ge0}L(x,\\alpha,\\beta) $ 和对偶问题 $\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta) $ 的可行解，并且 $\\underset{x\\in \\mathbb{R}^n}{min}\\;\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}L(x,\\alpha,\\beta) =\\underset{\\alpha,\\beta:\\alpha_i\\ge0}{max}\\; \\underset{x\\in\\mathbb{R}^{n}}{min}\\; L(x,\\alpha,\\beta)$，则 $x^{\\ast}$和 $a^{\\ast}$,$β^{\\ast}$ 分别是原始问题和对偶问题的最优解。</p>\n<h4 id=\"定理2：KKT条件-原始问题与对偶问题的解相等的条件\"><a href=\"#定理2：KKT条件-原始问题与对偶问题的解相等的条件\" class=\"headerlink\" title=\"定理2：KKT条件(原始问题与对偶问题的解相等的条件)\"></a>定理2：KKT条件(原始问题与对偶问题的解相等的条件)</h4><p>假设函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，并且不等式约束$c_i(x)$是严格可行的，则$x^{\\ast}$和$a^{\\ast},β^{\\ast}$分别是原始问题和对偶问题的解的充分必要条件是$x^{\\ast},a^{\\ast},β^{\\ast}$满足下面的Karush-Kuhn-Tucker(KKT)条件：（判断极值、其余项为0）</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\n\\nabla_xL(x^*,\\alpha^*,\\beta^*)&=0\\\\\n\\nabla_{\\alpha}L(x^*,\\alpha^*,\\beta^*) &=0 \\\\\n\\nabla_{\\beta}L(x^*,\\alpha^*,\\beta^*)&=0\n\\end{align*}</script><script type=\"math/tex; mode=display\">\\begin{align*}\n\\alpha_i^*c_i(\\boldsymbol{x}^*)&=0,\\quad i=1,2,\\cdots,k\\\\\nc_i(\\boldsymbol{x}^*)&\\le0,\\quad i=1,2,\\cdots,k \\\\\n\\alpha_i^*&\\ge0,\\quad i=1,2,\\cdots,k  \\\\\nh_j(\\boldsymbol{x}^*)&=0,\\quad j=1,2,\\cdots,l\n\\end{align*}</script><ul>\n<li>仿射函数<br><script type=\"math/tex\">f(x)=A\\cdot x+b</script>仿射函数就是一个线性函数，其输入是$n$ 维向量，参数 $A$ 可以是常数，也可以是 $m×n$ 的矩阵，$b$ 可以是常数，也可以是 $m$ 维的列向量，输出是一个 $m $维的列向量。在几何上，仿射函数是一个线性空间到另一个线性空间的变换。</li>\n</ul>"},{"title":"概率","date":"2017-08-14T14:00:04.000Z","_content":"\n# 随机变量与概率\n## 概率密度函数的积分\n- 离散随机变量\n假设随机变量 $X$ 的取值域为 $Ω = \\{x_i\\}_{i=1}^\\infty$，那么对于任何一个 $x_i$，事件 $X = x_i$ 的概率记为 $P(x_i)$. 对于 $Ω$ 的任何一个子集 $S = \\{x_i\\}_{i=1}^\\infty =1$，事件 $X ∈ S$ 的概率为\n$$P(S) = \\sum_{i=1}^{\\infty }P(x_1)$$\n对于离散随机变量，概率为概率函数的求和\n\n- 连续随机变量\n假设随机变量 $X$ 的取值域为 $\\mathbb{R}$，那么对于几乎所有 $x ∈R$, 事件 $X = x$ 的概率 $P(X = x)$ 都等于 0. 所以我们转而定义概率密度函数 $f : \\mathbb{R}→ [0,∞)$. 对于任何区间 $(a,b)$, 事件 $X ∈ (a,b)$ 的概率为\n$$P((a,b)) = \\int_{a}^{b}f(x)dx$$\n\n<!--more-->\n\n## 条件概率与贝叶斯公式\n### 条件概率\n条件 $A$ 下事件 $S$ 发生的概率\n$$P(S|A) = \\frac{P(S\\cap A)}{P(A)}$$\n### 贝叶斯公式\n$$P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$$\n\n# 大数定律和中心极限定理\n## [随机变量的矩 ](https://www.jianshu.com/p/c4aaa8ddb02f)\n设 $X,Y$ 为随机变量,则\n$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩\n$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距\n$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩\n$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩\n\n- 当 $n = 1$ 时，$E(X)$ 为随机变量的期望\n- 当 $n = 2$ 时，$Var(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^2f(x)dx=E(X^2)−E(X)^2=\\sum_{i=1}^nx_i^2p_i-\\mu ^2$ 为随机变量的方差 特征函数，\n- 当 $n=3$时，偏度$S(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^3f(x)dx$\n- 当 $n=4$时，峰度$K(x)=\\frac{\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^4f(x)dx}{\\sigma ^2}-3$\n- 归一化n阶中心矩为 $\\frac{E[(x-\\mu)^n ]}{\\sigma ^n}$\n- 混合矩：混合矩是多个变量的矩，比如协方差，协偏度，协峰度。虽然协方差只有一个，但协偏度和协峰度存在多个\n\n### 几何意义\n- 一阶矩：矩可以描述随机变量的一些特征，期望是 $X$ “中心”位置的一种 描述，\n- 二阶矩：方差可以描述 $X$ 的分散程度, 特征函数可以全面描述概率分布.\n- 三阶矩：任何对称分布偏态为0，向左偏斜（分布尾部在左侧较长）具有负偏度；向右偏斜分布（分布尾部在右侧较长）具有正偏度\n<center></center>\n- 四阶矩：峰度表示分布的波峰和尾部与正态分布的区别。完全符合正态分布的数据峰度值为0,且正态分布曲线被称为基线。如果样本峰度显著偏离0，就可判断此数据不是正态分布。\n<center></center>\n\n## 切比雪夫不等式\n设 $X$ 为随机变量，期望值为 $µ$, 标准差为 $σ$, 对于任何实数 $k > 0$\n$$P(|X −µ|≥ kσ) ≤\\frac{1}{k^2} $$\n\n![](概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif)\n\n## [随机变量的协方差与相关系数](https://www.zhihu.com/question/20852004)\n- X、Y的协方差： $cov(X,Y ) =E\\left ( (X-\\mu _x)(Y-\\mu _y) \\right )= E(XY )−E(X)E(Y ) $\n协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）\n- X、Y的相关系数： $cov(X,Y)/\\sqrt{Var(X)Var(Y)}$\n协方差的标准化\n\n## 特征函数\n\n\n## 重要极限\n$\\underset{n→∞}{lim}(1 + 1/n)^n$存在，且定义 $e = \\underset{n→∞}{lim}(1 + 1/n)^n$ 于是定义 $e = \\underset{n→∞}{lim}(1 + x/n)^n$\n\n## 大数定律\n$X$ 是随机变量，$µ$ 是 $X$ 的期望，$σ$ 是 $X$ 的方差.$\\{X_k\\}^∞ _{k=1}$ 是服从 $X$ 的独立同分步随机变量，那么 $\\overline{X}_k=\\frac{\\sum_{k=1}^{n}X_k}{n}$  依概率收敛于 $µ$. 也就是说对于任何 $ϵ > 0$ 有\n$$\\lim_{n\\rightarrow \\infty }P(|\\overline{X}_n-\\mu |>\\epsilon )=0$$\n- 当大量重复同一个实验时，实验的平均结果会接近于期望值\n- 重复次数越多越接近\n\n## [中心极限定理](https://zhuanlan.zhihu.com/p/25241653)\n中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布\n\n# [几种常见的分布](https://wenku.baidu.com/view/8133c0056edb6f1aff001f1c.html)\n- 离散概率分布（Discrete）\n离散均匀分布（discrete uniform）、伯努利分布（Bernoulli）、二项式分布（Binomial）、泊松分布（Poisson）、超几何分布（Hypergeometric）\n- 连续概率分布（continuous）\n均匀分布（Uniform）、正态分布（Normal/Gaussian）、指数分布（Exponential）、Gamma分布 、Beta分布、Gumbel分布\n- 抽样分布\n卡方分布、F分布、t分布\n","source":"_posts/概率.md","raw":"---\ntitle: 概率\ndate: 2017-08-14 22:00:04\ntags: [人工智能,概率,中心极限定理,大数定律]\ncategories: 数学\n---\n\n# 随机变量与概率\n## 概率密度函数的积分\n- 离散随机变量\n假设随机变量 $X$ 的取值域为 $Ω = \\{x_i\\}_{i=1}^\\infty$，那么对于任何一个 $x_i$，事件 $X = x_i$ 的概率记为 $P(x_i)$. 对于 $Ω$ 的任何一个子集 $S = \\{x_i\\}_{i=1}^\\infty =1$，事件 $X ∈ S$ 的概率为\n$$P(S) = \\sum_{i=1}^{\\infty }P(x_1)$$\n对于离散随机变量，概率为概率函数的求和\n\n- 连续随机变量\n假设随机变量 $X$ 的取值域为 $\\mathbb{R}$，那么对于几乎所有 $x ∈R$, 事件 $X = x$ 的概率 $P(X = x)$ 都等于 0. 所以我们转而定义概率密度函数 $f : \\mathbb{R}→ [0,∞)$. 对于任何区间 $(a,b)$, 事件 $X ∈ (a,b)$ 的概率为\n$$P((a,b)) = \\int_{a}^{b}f(x)dx$$\n\n<!--more-->\n\n## 条件概率与贝叶斯公式\n### 条件概率\n条件 $A$ 下事件 $S$ 发生的概率\n$$P(S|A) = \\frac{P(S\\cap A)}{P(A)}$$\n### 贝叶斯公式\n$$P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$$\n\n# 大数定律和中心极限定理\n## [随机变量的矩 ](https://www.jianshu.com/p/c4aaa8ddb02f)\n设 $X,Y$ 为随机变量,则\n$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩\n$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距\n$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩\n$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩\n\n- 当 $n = 1$ 时，$E(X)$ 为随机变量的期望\n- 当 $n = 2$ 时，$Var(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^2f(x)dx=E(X^2)−E(X)^2=\\sum_{i=1}^nx_i^2p_i-\\mu ^2$ 为随机变量的方差 特征函数，\n- 当 $n=3$时，偏度$S(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^3f(x)dx$\n- 当 $n=4$时，峰度$K(x)=\\frac{\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^4f(x)dx}{\\sigma ^2}-3$\n- 归一化n阶中心矩为 $\\frac{E[(x-\\mu)^n ]}{\\sigma ^n}$\n- 混合矩：混合矩是多个变量的矩，比如协方差，协偏度，协峰度。虽然协方差只有一个，但协偏度和协峰度存在多个\n\n### 几何意义\n- 一阶矩：矩可以描述随机变量的一些特征，期望是 $X$ “中心”位置的一种 描述，\n- 二阶矩：方差可以描述 $X$ 的分散程度, 特征函数可以全面描述概率分布.\n- 三阶矩：任何对称分布偏态为0，向左偏斜（分布尾部在左侧较长）具有负偏度；向右偏斜分布（分布尾部在右侧较长）具有正偏度\n<center></center>\n- 四阶矩：峰度表示分布的波峰和尾部与正态分布的区别。完全符合正态分布的数据峰度值为0,且正态分布曲线被称为基线。如果样本峰度显著偏离0，就可判断此数据不是正态分布。\n<center></center>\n\n## 切比雪夫不等式\n设 $X$ 为随机变量，期望值为 $µ$, 标准差为 $σ$, 对于任何实数 $k > 0$\n$$P(|X −µ|≥ kσ) ≤\\frac{1}{k^2} $$\n\n![](概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif)\n\n## [随机变量的协方差与相关系数](https://www.zhihu.com/question/20852004)\n- X、Y的协方差： $cov(X,Y ) =E\\left ( (X-\\mu _x)(Y-\\mu _y) \\right )= E(XY )−E(X)E(Y ) $\n协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）\n- X、Y的相关系数： $cov(X,Y)/\\sqrt{Var(X)Var(Y)}$\n协方差的标准化\n\n## 特征函数\n\n\n## 重要极限\n$\\underset{n→∞}{lim}(1 + 1/n)^n$存在，且定义 $e = \\underset{n→∞}{lim}(1 + 1/n)^n$ 于是定义 $e = \\underset{n→∞}{lim}(1 + x/n)^n$\n\n## 大数定律\n$X$ 是随机变量，$µ$ 是 $X$ 的期望，$σ$ 是 $X$ 的方差.$\\{X_k\\}^∞ _{k=1}$ 是服从 $X$ 的独立同分步随机变量，那么 $\\overline{X}_k=\\frac{\\sum_{k=1}^{n}X_k}{n}$  依概率收敛于 $µ$. 也就是说对于任何 $ϵ > 0$ 有\n$$\\lim_{n\\rightarrow \\infty }P(|\\overline{X}_n-\\mu |>\\epsilon )=0$$\n- 当大量重复同一个实验时，实验的平均结果会接近于期望值\n- 重复次数越多越接近\n\n## [中心极限定理](https://zhuanlan.zhihu.com/p/25241653)\n中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布\n\n# [几种常见的分布](https://wenku.baidu.com/view/8133c0056edb6f1aff001f1c.html)\n- 离散概率分布（Discrete）\n离散均匀分布（discrete uniform）、伯努利分布（Bernoulli）、二项式分布（Binomial）、泊松分布（Poisson）、超几何分布（Hypergeometric）\n- 连续概率分布（continuous）\n均匀分布（Uniform）、正态分布（Normal/Gaussian）、指数分布（Exponential）、Gamma分布 、Beta分布、Gumbel分布\n- 抽样分布\n卡方分布、F分布、t分布\n","slug":"概率","published":1,"updated":"2019-07-30T01:54:38.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0q005hhomj2l67o87o","content":"<h1 id=\"随机变量与概率\"><a href=\"#随机变量与概率\" class=\"headerlink\" title=\"随机变量与概率\"></a>随机变量与概率</h1><h2 id=\"概率密度函数的积分\"><a href=\"#概率密度函数的积分\" class=\"headerlink\" title=\"概率密度函数的积分\"></a>概率密度函数的积分</h2><ul>\n<li><p>离散随机变量<br>假设随机变量 $X$ 的取值域为 $Ω = \\{x_i\\}_{i=1}^\\infty$，那么对于任何一个 $x_i$，事件 $X = x_i$ 的概率记为 $P(x_i)$. 对于 $Ω$ 的任何一个子集 $S = \\{x_i\\}_{i=1}^\\infty =1$，事件 $X ∈ S$ 的概率为</p>\n<script type=\"math/tex; mode=display\">P(S) = \\sum_{i=1}^{\\infty }P(x_1)</script><p>对于离散随机变量，概率为概率函数的求和</p>\n</li>\n<li><p>连续随机变量<br>假设随机变量 $X$ 的取值域为 $\\mathbb{R}$，那么对于几乎所有 $x ∈R$, 事件 $X = x$ 的概率 $P(X = x)$ 都等于 0. 所以我们转而定义概率密度函数 $f : \\mathbb{R}→ [0,∞)$. 对于任何区间 $(a,b)$, 事件 $X ∈ (a,b)$ 的概率为</p>\n<script type=\"math/tex; mode=display\">P((a,b)) = \\int_{a}^{b}f(x)dx</script></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"条件概率与贝叶斯公式\"><a href=\"#条件概率与贝叶斯公式\" class=\"headerlink\" title=\"条件概率与贝叶斯公式\"></a>条件概率与贝叶斯公式</h2><h3 id=\"条件概率\"><a href=\"#条件概率\" class=\"headerlink\" title=\"条件概率\"></a>条件概率</h3><p>条件 $A$ 下事件 $S$ 发生的概率</p>\n<script type=\"math/tex; mode=display\">P(S|A) = \\frac{P(S\\cap A)}{P(A)}</script><h3 id=\"贝叶斯公式\"><a href=\"#贝叶斯公式\" class=\"headerlink\" title=\"贝叶斯公式\"></a>贝叶斯公式</h3><script type=\"math/tex; mode=display\">P(A|B) = \\frac{P(B|A)P(A)}{P(B)}</script><h1 id=\"大数定律和中心极限定理\"><a href=\"#大数定律和中心极限定理\" class=\"headerlink\" title=\"大数定律和中心极限定理\"></a>大数定律和中心极限定理</h1><h2 id=\"随机变量的矩\"><a href=\"#随机变量的矩\" class=\"headerlink\" title=\"随机变量的矩 \"></a><a href=\"https://www.jianshu.com/p/c4aaa8ddb02f\" target=\"_blank\" rel=\"noopener\">随机变量的矩 </a></h2><p>设 $X,Y$ 为随机变量,则<br>$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩<br>$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距<br>$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩<br>$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩</p>\n<ul>\n<li>当 $n = 1$ 时，$E(X)$ 为随机变量的期望</li>\n<li>当 $n = 2$ 时，$Var(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^2f(x)dx=E(X^2)−E(X)^2=\\sum_{i=1}^nx_i^2p_i-\\mu ^2$ 为随机变量的方差 特征函数，</li>\n<li>当 $n=3$时，偏度$S(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^3f(x)dx$</li>\n<li>当 $n=4$时，峰度$K(x)=\\frac{\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^4f(x)dx}{\\sigma ^2}-3$</li>\n<li>归一化n阶中心矩为 $\\frac{E[(x-\\mu)^n ]}{\\sigma ^n}$</li>\n<li>混合矩：混合矩是多个变量的矩，比如协方差，协偏度，协峰度。虽然协方差只有一个，但协偏度和协峰度存在多个</li>\n</ul>\n<h3 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h3><ul>\n<li>一阶矩：矩可以描述随机变量的一些特征，期望是 $X$ “中心”位置的一种 描述，</li>\n<li>二阶矩：方差可以描述 $X$ 的分散程度, 特征函数可以全面描述概率分布.</li>\n<li>三阶矩：任何对称分布偏态为0，向左偏斜（分布尾部在左侧较长）具有负偏度；向右偏斜分布（分布尾部在右侧较长）具有正偏度<center></center></li>\n<li>四阶矩：峰度表示分布的波峰和尾部与正态分布的区别。完全符合正态分布的数据峰度值为0,且正态分布曲线被称为基线。如果样本峰度显著偏离0，就可判断此数据不是正态分布。<center></center>\n\n</li>\n</ul>\n<h2 id=\"切比雪夫不等式\"><a href=\"#切比雪夫不等式\" class=\"headerlink\" title=\"切比雪夫不等式\"></a>切比雪夫不等式</h2><p>设 $X$ 为随机变量，期望值为 $µ$, 标准差为 $σ$, 对于任何实数 $k &gt; 0$</p>\n<script type=\"math/tex; mode=display\">P(|X −µ|≥ kσ) ≤\\frac{1}{k^2}</script><p><img src=\"/2017/08/14/概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif\" alt=\"\"></p>\n<h2 id=\"随机变量的协方差与相关系数\"><a href=\"#随机变量的协方差与相关系数\" class=\"headerlink\" title=\"随机变量的协方差与相关系数\"></a><a href=\"https://www.zhihu.com/question/20852004\" target=\"_blank\" rel=\"noopener\">随机变量的协方差与相关系数</a></h2><ul>\n<li>X、Y的协方差： $cov(X,Y ) =E\\left ( (X-\\mu _x)(Y-\\mu _y) \\right )= E(XY )−E(X)E(Y ) $<br>协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）</li>\n<li>X、Y的相关系数： $cov(X,Y)/\\sqrt{Var(X)Var(Y)}$<br>协方差的标准化</li>\n</ul>\n<h2 id=\"特征函数\"><a href=\"#特征函数\" class=\"headerlink\" title=\"特征函数\"></a>特征函数</h2><h2 id=\"重要极限\"><a href=\"#重要极限\" class=\"headerlink\" title=\"重要极限\"></a>重要极限</h2><p>$\\underset{n→∞}{lim}(1 + 1/n)^n$存在，且定义 $e = \\underset{n→∞}{lim}(1 + 1/n)^n$ 于是定义 $e = \\underset{n→∞}{lim}(1 + x/n)^n$</p>\n<h2 id=\"大数定律\"><a href=\"#大数定律\" class=\"headerlink\" title=\"大数定律\"></a>大数定律</h2><p>$X$ 是随机变量，$µ$ 是 $X$ 的期望，$σ$ 是 $X$ 的方差.$\\{X_k\\}^∞ _{k=1}$ 是服从 $X$ 的独立同分步随机变量，那么 $\\overline{X}_k=\\frac{\\sum_{k=1}^{n}X_k}{n}$  依概率收敛于 $µ$. 也就是说对于任何 $ϵ &gt; 0$ 有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n\\rightarrow \\infty }P(|\\overline{X}_n-\\mu |>\\epsilon )=0</script><ul>\n<li>当大量重复同一个实验时，实验的平均结果会接近于期望值</li>\n<li>重复次数越多越接近</li>\n</ul>\n<h2 id=\"中心极限定理\"><a href=\"#中心极限定理\" class=\"headerlink\" title=\"中心极限定理\"></a><a href=\"https://zhuanlan.zhihu.com/p/25241653\" target=\"_blank\" rel=\"noopener\">中心极限定理</a></h2><p>中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布</p>\n<h1 id=\"几种常见的分布\"><a href=\"#几种常见的分布\" class=\"headerlink\" title=\"几种常见的分布\"></a><a href=\"https://wenku.baidu.com/view/8133c0056edb6f1aff001f1c.html\" target=\"_blank\" rel=\"noopener\">几种常见的分布</a></h1><ul>\n<li>离散概率分布（Discrete）<br>离散均匀分布（discrete uniform）、伯努利分布（Bernoulli）、二项式分布（Binomial）、泊松分布（Poisson）、超几何分布（Hypergeometric）</li>\n<li>连续概率分布（continuous）<br>均匀分布（Uniform）、正态分布（Normal/Gaussian）、指数分布（Exponential）、Gamma分布 、Beta分布、Gumbel分布</li>\n<li>抽样分布<br>卡方分布、F分布、t分布</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"随机变量与概率\"><a href=\"#随机变量与概率\" class=\"headerlink\" title=\"随机变量与概率\"></a>随机变量与概率</h1><h2 id=\"概率密度函数的积分\"><a href=\"#概率密度函数的积分\" class=\"headerlink\" title=\"概率密度函数的积分\"></a>概率密度函数的积分</h2><ul>\n<li><p>离散随机变量<br>假设随机变量 $X$ 的取值域为 $Ω = \\{x_i\\}_{i=1}^\\infty$，那么对于任何一个 $x_i$，事件 $X = x_i$ 的概率记为 $P(x_i)$. 对于 $Ω$ 的任何一个子集 $S = \\{x_i\\}_{i=1}^\\infty =1$，事件 $X ∈ S$ 的概率为</p>\n<script type=\"math/tex; mode=display\">P(S) = \\sum_{i=1}^{\\infty }P(x_1)</script><p>对于离散随机变量，概率为概率函数的求和</p>\n</li>\n<li><p>连续随机变量<br>假设随机变量 $X$ 的取值域为 $\\mathbb{R}$，那么对于几乎所有 $x ∈R$, 事件 $X = x$ 的概率 $P(X = x)$ 都等于 0. 所以我们转而定义概率密度函数 $f : \\mathbb{R}→ [0,∞)$. 对于任何区间 $(a,b)$, 事件 $X ∈ (a,b)$ 的概率为</p>\n<script type=\"math/tex; mode=display\">P((a,b)) = \\int_{a}^{b}f(x)dx</script></li>\n</ul>","more":"<h2 id=\"条件概率与贝叶斯公式\"><a href=\"#条件概率与贝叶斯公式\" class=\"headerlink\" title=\"条件概率与贝叶斯公式\"></a>条件概率与贝叶斯公式</h2><h3 id=\"条件概率\"><a href=\"#条件概率\" class=\"headerlink\" title=\"条件概率\"></a>条件概率</h3><p>条件 $A$ 下事件 $S$ 发生的概率</p>\n<script type=\"math/tex; mode=display\">P(S|A) = \\frac{P(S\\cap A)}{P(A)}</script><h3 id=\"贝叶斯公式\"><a href=\"#贝叶斯公式\" class=\"headerlink\" title=\"贝叶斯公式\"></a>贝叶斯公式</h3><script type=\"math/tex; mode=display\">P(A|B) = \\frac{P(B|A)P(A)}{P(B)}</script><h1 id=\"大数定律和中心极限定理\"><a href=\"#大数定律和中心极限定理\" class=\"headerlink\" title=\"大数定律和中心极限定理\"></a>大数定律和中心极限定理</h1><h2 id=\"随机变量的矩\"><a href=\"#随机变量的矩\" class=\"headerlink\" title=\"随机变量的矩 \"></a><a href=\"https://www.jianshu.com/p/c4aaa8ddb02f\" target=\"_blank\" rel=\"noopener\">随机变量的矩 </a></h2><p>设 $X,Y$ 为随机变量,则<br>$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩<br>$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距<br>$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩<br>$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩</p>\n<ul>\n<li>当 $n = 1$ 时，$E(X)$ 为随机变量的期望</li>\n<li>当 $n = 2$ 时，$Var(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^2f(x)dx=E(X^2)−E(X)^2=\\sum_{i=1}^nx_i^2p_i-\\mu ^2$ 为随机变量的方差 特征函数，</li>\n<li>当 $n=3$时，偏度$S(x)=\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^3f(x)dx$</li>\n<li>当 $n=4$时，峰度$K(x)=\\frac{\\int_{-\\infty }^{\\infty }[x_i-\\mu ]^4f(x)dx}{\\sigma ^2}-3$</li>\n<li>归一化n阶中心矩为 $\\frac{E[(x-\\mu)^n ]}{\\sigma ^n}$</li>\n<li>混合矩：混合矩是多个变量的矩，比如协方差，协偏度，协峰度。虽然协方差只有一个，但协偏度和协峰度存在多个</li>\n</ul>\n<h3 id=\"几何意义\"><a href=\"#几何意义\" class=\"headerlink\" title=\"几何意义\"></a>几何意义</h3><ul>\n<li>一阶矩：矩可以描述随机变量的一些特征，期望是 $X$ “中心”位置的一种 描述，</li>\n<li>二阶矩：方差可以描述 $X$ 的分散程度, 特征函数可以全面描述概率分布.</li>\n<li>三阶矩：任何对称分布偏态为0，向左偏斜（分布尾部在左侧较长）具有负偏度；向右偏斜分布（分布尾部在右侧较长）具有正偏度<center></center></li>\n<li>四阶矩：峰度表示分布的波峰和尾部与正态分布的区别。完全符合正态分布的数据峰度值为0,且正态分布曲线被称为基线。如果样本峰度显著偏离0，就可判断此数据不是正态分布。<center></center>\n\n</li>\n</ul>\n<h2 id=\"切比雪夫不等式\"><a href=\"#切比雪夫不等式\" class=\"headerlink\" title=\"切比雪夫不等式\"></a>切比雪夫不等式</h2><p>设 $X$ 为随机变量，期望值为 $µ$, 标准差为 $σ$, 对于任何实数 $k &gt; 0$</p>\n<script type=\"math/tex; mode=display\">P(|X −µ|≥ kσ) ≤\\frac{1}{k^2}</script><p><img src=\"/2017/08/14/概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif\" alt=\"\"></p>\n<h2 id=\"随机变量的协方差与相关系数\"><a href=\"#随机变量的协方差与相关系数\" class=\"headerlink\" title=\"随机变量的协方差与相关系数\"></a><a href=\"https://www.zhihu.com/question/20852004\" target=\"_blank\" rel=\"noopener\">随机变量的协方差与相关系数</a></h2><ul>\n<li>X、Y的协方差： $cov(X,Y ) =E\\left ( (X-\\mu _x)(Y-\\mu _y) \\right )= E(XY )−E(X)E(Y ) $<br>协方差就是衡量两个变量相关性的变量。当协方差为正时，两个变量呈正相关关系（同增同减）；当协方差为负时，两个变量呈负相关关系（一增一减）</li>\n<li>X、Y的相关系数： $cov(X,Y)/\\sqrt{Var(X)Var(Y)}$<br>协方差的标准化</li>\n</ul>\n<h2 id=\"特征函数\"><a href=\"#特征函数\" class=\"headerlink\" title=\"特征函数\"></a>特征函数</h2><h2 id=\"重要极限\"><a href=\"#重要极限\" class=\"headerlink\" title=\"重要极限\"></a>重要极限</h2><p>$\\underset{n→∞}{lim}(1 + 1/n)^n$存在，且定义 $e = \\underset{n→∞}{lim}(1 + 1/n)^n$ 于是定义 $e = \\underset{n→∞}{lim}(1 + x/n)^n$</p>\n<h2 id=\"大数定律\"><a href=\"#大数定律\" class=\"headerlink\" title=\"大数定律\"></a>大数定律</h2><p>$X$ 是随机变量，$µ$ 是 $X$ 的期望，$σ$ 是 $X$ 的方差.$\\{X_k\\}^∞ _{k=1}$ 是服从 $X$ 的独立同分步随机变量，那么 $\\overline{X}_k=\\frac{\\sum_{k=1}^{n}X_k}{n}$  依概率收敛于 $µ$. 也就是说对于任何 $ϵ &gt; 0$ 有</p>\n<script type=\"math/tex; mode=display\">\\lim_{n\\rightarrow \\infty }P(|\\overline{X}_n-\\mu |>\\epsilon )=0</script><ul>\n<li>当大量重复同一个实验时，实验的平均结果会接近于期望值</li>\n<li>重复次数越多越接近</li>\n</ul>\n<h2 id=\"中心极限定理\"><a href=\"#中心极限定理\" class=\"headerlink\" title=\"中心极限定理\"></a><a href=\"https://zhuanlan.zhihu.com/p/25241653\" target=\"_blank\" rel=\"noopener\">中心极限定理</a></h2><p>中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布</p>\n<h1 id=\"几种常见的分布\"><a href=\"#几种常见的分布\" class=\"headerlink\" title=\"几种常见的分布\"></a><a href=\"https://wenku.baidu.com/view/8133c0056edb6f1aff001f1c.html\" target=\"_blank\" rel=\"noopener\">几种常见的分布</a></h1><ul>\n<li>离散概率分布（Discrete）<br>离散均匀分布（discrete uniform）、伯努利分布（Bernoulli）、二项式分布（Binomial）、泊松分布（Poisson）、超几何分布（Hypergeometric）</li>\n<li>连续概率分布（continuous）<br>均匀分布（Uniform）、正态分布（Normal/Gaussian）、指数分布（Exponential）、Gamma分布 、Beta分布、Gumbel分布</li>\n<li>抽样分布<br>卡方分布、F分布、t分布</li>\n</ul>"},{"title":"正定二次型和正定矩阵","date":"2017-08-18T03:31:57.000Z","_content":"\n# 二次型矩阵\n对于一个方阵$A∈ R^{n×n}$和一个向量$x∈ R^n$，标量$x^TAx$被称作一个二次型。显式地写出来，\n$$x^TAx=\\sum_{i=1}^{n}x_i(Ax)_i=\\sum_{i=1}^{n}x_i\\left ( \\sum_{j=1}^{n}A_{ij}x_j \\right )=\\sum_{i=1}^{n}\\sum_{j=1}^{n}A_{ij}x_ix_j$$\n上式实际为一个二次多项式例如：\n$$\\left [ x_1 x_2 \\right ]\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 4\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}=[x_1,x_2]\n\\begin{bmatrix}\nx_1+3x_2\\\\\n2x_1+4x_2\n\\end{bmatrix}=x_1^2+5x_1x_2+4x_2^2\n$$\n\n<!--more-->\n\n# 分类\n\n对于任一个n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$，作为一个 $n$ 元二次齐次多项式，我们往往需要考虑它的取值问题，显然当 $x_1=x_2=\\cdots=x_n=0$ 时，二次型 $f$ 的值为 $f(0,0,\\cdots,0)=0$ ，下面我们根据当 $x_1,x_2,\\cdots,x_n$ 取不全为零的 $n$ 个数时，即当 $X$ 为任一个非零列向量时，取值的不同情况，给出以下定义：\n\n定义2.1：设有n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$。\n 1. 如果对于任何非零列向量 $X$ ，都有 $X^TAX>0$，则称为正定二次型，称对称矩阵 $A$ 为正定矩阵。\n 2. 如果对于任何非零列向量 $X$ ，都有 $X^TAX\\geqslant 0$，则称为半正定二次型，称 $A$ 为半正定矩阵。\n 3. 如果对于任何非零列向量 $X$ ，都有 $X^TAX<0$，则称为负定二次型，称 $A$ 为负定矩阵。\n 4. 如果对于任何非零列量 $X$ ，都有 $X^TAX\\leqslant  0$，则称为半负定二次型，称 $A$ 为半负定矩阵。\n 5. 其它的实二次型称为不定二次型，其矩阵称为不定矩阵。\n\n- 例子\n\n![](正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png)\n\n# 正定矩阵性质\n1. 正定矩阵的行列式恒为正；\n1. 两个正定矩阵的和是正定矩阵；\n1. 正实数与正定矩阵的乘积是正定矩阵。\n## 正定等价命题\n1. $A$是正定矩阵；\n1. $A$的一切顺序主子式均为正；\n1. $A$的一切主子式均为正；\n1. $A$的特征值均为正；\n1. 存在实可逆矩阵$C$，使$A=C'C$；\n1. 存在秩为$n$的$m×n$实矩阵$B$，使$A=B'B$；\n1. 存在主对角线元素全为正的实三角矩阵$R$，使$A=R'R$\n\n# 正定矩阵判别方法\n1. 求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。\n\n1. 计算A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的；若A的各阶顺序主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。\n\n![](正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png)\n\n# 半正定矩阵性质\n1. 半正定矩阵的行列式是非负的；\n1. 两个半正定矩阵的和是半正定的；\n1. 非负实数与半正定矩阵的数乘矩阵是半正定的。\n## 半正定等价命题\n1. $A$是是半正定的；\n1. $A$的一切顺序主子式均为非负的；\n1. $A$的一切主子式均为非负的；\n1. $A$的特征值均为正；\n1. 存在$n$阶实矩阵$C$，使$A=C'C$；\n1. 存在秩为$r$的$r×n$实矩阵$B$，使$A=B'B$\n","source":"_posts/正定二次型和正定矩阵.md","raw":"---\ntitle: 正定二次型和正定矩阵\ndate: 2017-08-18 11:31:57\ntags: [人工智能,线性代数,矩阵]\ncategories: 数学\n---\n\n# 二次型矩阵\n对于一个方阵$A∈ R^{n×n}$和一个向量$x∈ R^n$，标量$x^TAx$被称作一个二次型。显式地写出来，\n$$x^TAx=\\sum_{i=1}^{n}x_i(Ax)_i=\\sum_{i=1}^{n}x_i\\left ( \\sum_{j=1}^{n}A_{ij}x_j \\right )=\\sum_{i=1}^{n}\\sum_{j=1}^{n}A_{ij}x_ix_j$$\n上式实际为一个二次多项式例如：\n$$\\left [ x_1 x_2 \\right ]\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 4\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}=[x_1,x_2]\n\\begin{bmatrix}\nx_1+3x_2\\\\\n2x_1+4x_2\n\\end{bmatrix}=x_1^2+5x_1x_2+4x_2^2\n$$\n\n<!--more-->\n\n# 分类\n\n对于任一个n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$，作为一个 $n$ 元二次齐次多项式，我们往往需要考虑它的取值问题，显然当 $x_1=x_2=\\cdots=x_n=0$ 时，二次型 $f$ 的值为 $f(0,0,\\cdots,0)=0$ ，下面我们根据当 $x_1,x_2,\\cdots,x_n$ 取不全为零的 $n$ 个数时，即当 $X$ 为任一个非零列向量时，取值的不同情况，给出以下定义：\n\n定义2.1：设有n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$。\n 1. 如果对于任何非零列向量 $X$ ，都有 $X^TAX>0$，则称为正定二次型，称对称矩阵 $A$ 为正定矩阵。\n 2. 如果对于任何非零列向量 $X$ ，都有 $X^TAX\\geqslant 0$，则称为半正定二次型，称 $A$ 为半正定矩阵。\n 3. 如果对于任何非零列向量 $X$ ，都有 $X^TAX<0$，则称为负定二次型，称 $A$ 为负定矩阵。\n 4. 如果对于任何非零列量 $X$ ，都有 $X^TAX\\leqslant  0$，则称为半负定二次型，称 $A$ 为半负定矩阵。\n 5. 其它的实二次型称为不定二次型，其矩阵称为不定矩阵。\n\n- 例子\n\n![](正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png)\n\n# 正定矩阵性质\n1. 正定矩阵的行列式恒为正；\n1. 两个正定矩阵的和是正定矩阵；\n1. 正实数与正定矩阵的乘积是正定矩阵。\n## 正定等价命题\n1. $A$是正定矩阵；\n1. $A$的一切顺序主子式均为正；\n1. $A$的一切主子式均为正；\n1. $A$的特征值均为正；\n1. 存在实可逆矩阵$C$，使$A=C'C$；\n1. 存在秩为$n$的$m×n$实矩阵$B$，使$A=B'B$；\n1. 存在主对角线元素全为正的实三角矩阵$R$，使$A=R'R$\n\n# 正定矩阵判别方法\n1. 求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。\n\n1. 计算A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的；若A的各阶顺序主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。\n\n![](正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png)\n\n# 半正定矩阵性质\n1. 半正定矩阵的行列式是非负的；\n1. 两个半正定矩阵的和是半正定的；\n1. 非负实数与半正定矩阵的数乘矩阵是半正定的。\n## 半正定等价命题\n1. $A$是是半正定的；\n1. $A$的一切顺序主子式均为非负的；\n1. $A$的一切主子式均为非负的；\n1. $A$的特征值均为正；\n1. 存在$n$阶实矩阵$C$，使$A=C'C$；\n1. 存在秩为$r$的$r×n$实矩阵$B$，使$A=B'B$\n","slug":"正定二次型和正定矩阵","published":1,"updated":"2019-07-30T01:54:38.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0s005lhomjn0eu9ii7","content":"<h1 id=\"二次型矩阵\"><a href=\"#二次型矩阵\" class=\"headerlink\" title=\"二次型矩阵\"></a>二次型矩阵</h1><p>对于一个方阵$A∈ R^{n×n}$和一个向量$x∈ R^n$，标量$x^TAx$被称作一个二次型。显式地写出来，</p>\n<script type=\"math/tex; mode=display\">x^TAx=\\sum_{i=1}^{n}x_i(Ax)_i=\\sum_{i=1}^{n}x_i\\left ( \\sum_{j=1}^{n}A_{ij}x_j \\right )=\\sum_{i=1}^{n}\\sum_{j=1}^{n}A_{ij}x_ix_j</script><p>上式实际为一个二次多项式例如：</p>\n<script type=\"math/tex; mode=display\">\\left [ x_1 x_2 \\right ]\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 4\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}=[x_1,x_2]\n\\begin{bmatrix}\nx_1+3x_2\\\\\n2x_1+4x_2\n\\end{bmatrix}=x_1^2+5x_1x_2+4x_2^2</script><a id=\"more\"></a>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p>对于任一个n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$，作为一个 $n$ 元二次齐次多项式，我们往往需要考虑它的取值问题，显然当 $x_1=x_2=\\cdots=x_n=0$ 时，二次型 $f$ 的值为 $f(0,0,\\cdots,0)=0$ ，下面我们根据当 $x_1,x_2,\\cdots,x_n$ 取不全为零的 $n$ 个数时，即当 $X$ 为任一个非零列向量时，取值的不同情况，给出以下定义：</p>\n<p>定义2.1：设有n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$。</p>\n<ol>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX&gt;0$，则称为正定二次型，称对称矩阵 $A$ 为正定矩阵。</li>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX\\geqslant 0$，则称为半正定二次型，称 $A$ 为半正定矩阵。</li>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX&lt;0$，则称为负定二次型，称 $A$ 为负定矩阵。</li>\n<li>如果对于任何非零列量 $X$ ，都有 $X^TAX\\leqslant  0$，则称为半负定二次型，称 $A$ 为半负定矩阵。</li>\n<li>其它的实二次型称为不定二次型，其矩阵称为不定矩阵。</li>\n</ol>\n<ul>\n<li>例子</li>\n</ul>\n<p><img src=\"/2017/08/18/正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png\" alt=\"\"></p>\n<h1 id=\"正定矩阵性质\"><a href=\"#正定矩阵性质\" class=\"headerlink\" title=\"正定矩阵性质\"></a>正定矩阵性质</h1><ol>\n<li>正定矩阵的行列式恒为正；</li>\n<li>两个正定矩阵的和是正定矩阵；</li>\n<li>正实数与正定矩阵的乘积是正定矩阵。<h2 id=\"正定等价命题\"><a href=\"#正定等价命题\" class=\"headerlink\" title=\"正定等价命题\"></a>正定等价命题</h2></li>\n<li>$A$是正定矩阵；</li>\n<li>$A$的一切顺序主子式均为正；</li>\n<li>$A$的一切主子式均为正；</li>\n<li>$A$的特征值均为正；</li>\n<li>存在实可逆矩阵$C$，使$A=C’C$；</li>\n<li>存在秩为$n$的$m×n$实矩阵$B$，使$A=B’B$；</li>\n<li>存在主对角线元素全为正的实三角矩阵$R$，使$A=R’R$</li>\n</ol>\n<h1 id=\"正定矩阵判别方法\"><a href=\"#正定矩阵判别方法\" class=\"headerlink\" title=\"正定矩阵判别方法\"></a>正定矩阵判别方法</h1><ol>\n<li><p>求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。</p>\n</li>\n<li><p>计算A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的；若A的各阶顺序主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。</p>\n</li>\n</ol>\n<p><img src=\"/2017/08/18/正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png\" alt=\"\"></p>\n<h1 id=\"半正定矩阵性质\"><a href=\"#半正定矩阵性质\" class=\"headerlink\" title=\"半正定矩阵性质\"></a>半正定矩阵性质</h1><ol>\n<li>半正定矩阵的行列式是非负的；</li>\n<li>两个半正定矩阵的和是半正定的；</li>\n<li>非负实数与半正定矩阵的数乘矩阵是半正定的。<h2 id=\"半正定等价命题\"><a href=\"#半正定等价命题\" class=\"headerlink\" title=\"半正定等价命题\"></a>半正定等价命题</h2></li>\n<li>$A$是是半正定的；</li>\n<li>$A$的一切顺序主子式均为非负的；</li>\n<li>$A$的一切主子式均为非负的；</li>\n<li>$A$的特征值均为正；</li>\n<li>存在$n$阶实矩阵$C$，使$A=C’C$；</li>\n<li>存在秩为$r$的$r×n$实矩阵$B$，使$A=B’B$</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"二次型矩阵\"><a href=\"#二次型矩阵\" class=\"headerlink\" title=\"二次型矩阵\"></a>二次型矩阵</h1><p>对于一个方阵$A∈ R^{n×n}$和一个向量$x∈ R^n$，标量$x^TAx$被称作一个二次型。显式地写出来，</p>\n<script type=\"math/tex; mode=display\">x^TAx=\\sum_{i=1}^{n}x_i(Ax)_i=\\sum_{i=1}^{n}x_i\\left ( \\sum_{j=1}^{n}A_{ij}x_j \\right )=\\sum_{i=1}^{n}\\sum_{j=1}^{n}A_{ij}x_ix_j</script><p>上式实际为一个二次多项式例如：</p>\n<script type=\"math/tex; mode=display\">\\left [ x_1 x_2 \\right ]\n\\begin{bmatrix}\n1 & 3\\\\\n2 & 4\n\\end{bmatrix}\\begin{bmatrix}\nx_1\\\\\nx_2\n\\end{bmatrix}=[x_1,x_2]\n\\begin{bmatrix}\nx_1+3x_2\\\\\n2x_1+4x_2\n\\end{bmatrix}=x_1^2+5x_1x_2+4x_2^2</script>","more":"<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><p>对于任一个n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$，作为一个 $n$ 元二次齐次多项式，我们往往需要考虑它的取值问题，显然当 $x_1=x_2=\\cdots=x_n=0$ 时，二次型 $f$ 的值为 $f(0,0,\\cdots,0)=0$ ，下面我们根据当 $x_1,x_2,\\cdots,x_n$ 取不全为零的 $n$ 个数时，即当 $X$ 为任一个非零列向量时，取值的不同情况，给出以下定义：</p>\n<p>定义2.1：设有n元实二次型 $f(x_1,x_2,\\cdots ,x_n)=X^TAX$。</p>\n<ol>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX&gt;0$，则称为正定二次型，称对称矩阵 $A$ 为正定矩阵。</li>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX\\geqslant 0$，则称为半正定二次型，称 $A$ 为半正定矩阵。</li>\n<li>如果对于任何非零列向量 $X$ ，都有 $X^TAX&lt;0$，则称为负定二次型，称 $A$ 为负定矩阵。</li>\n<li>如果对于任何非零列量 $X$ ，都有 $X^TAX\\leqslant  0$，则称为半负定二次型，称 $A$ 为半负定矩阵。</li>\n<li>其它的实二次型称为不定二次型，其矩阵称为不定矩阵。</li>\n</ol>\n<ul>\n<li>例子</li>\n</ul>\n<p><img src=\"/2017/08/18/正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png\" alt=\"\"></p>\n<h1 id=\"正定矩阵性质\"><a href=\"#正定矩阵性质\" class=\"headerlink\" title=\"正定矩阵性质\"></a>正定矩阵性质</h1><ol>\n<li>正定矩阵的行列式恒为正；</li>\n<li>两个正定矩阵的和是正定矩阵；</li>\n<li>正实数与正定矩阵的乘积是正定矩阵。<h2 id=\"正定等价命题\"><a href=\"#正定等价命题\" class=\"headerlink\" title=\"正定等价命题\"></a>正定等价命题</h2></li>\n<li>$A$是正定矩阵；</li>\n<li>$A$的一切顺序主子式均为正；</li>\n<li>$A$的一切主子式均为正；</li>\n<li>$A$的特征值均为正；</li>\n<li>存在实可逆矩阵$C$，使$A=C’C$；</li>\n<li>存在秩为$n$的$m×n$实矩阵$B$，使$A=B’B$；</li>\n<li>存在主对角线元素全为正的实三角矩阵$R$，使$A=R’R$</li>\n</ol>\n<h1 id=\"正定矩阵判别方法\"><a href=\"#正定矩阵判别方法\" class=\"headerlink\" title=\"正定矩阵判别方法\"></a>正定矩阵判别方法</h1><ol>\n<li><p>求出A的所有特征值。若A的特征值均为正数，则A是正定的；若A的特征值均为负数，则A为负定的。</p>\n</li>\n<li><p>计算A的各阶顺序主子式。若A的各阶顺序主子式均大于零，则A是正定的；若A的各阶顺序主子式中，奇数阶主子式为负，偶数阶为正，则A为负定的。</p>\n</li>\n</ol>\n<p><img src=\"/2017/08/18/正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png\" alt=\"\"></p>\n<h1 id=\"半正定矩阵性质\"><a href=\"#半正定矩阵性质\" class=\"headerlink\" title=\"半正定矩阵性质\"></a>半正定矩阵性质</h1><ol>\n<li>半正定矩阵的行列式是非负的；</li>\n<li>两个半正定矩阵的和是半正定的；</li>\n<li>非负实数与半正定矩阵的数乘矩阵是半正定的。<h2 id=\"半正定等价命题\"><a href=\"#半正定等价命题\" class=\"headerlink\" title=\"半正定等价命题\"></a>半正定等价命题</h2></li>\n<li>$A$是是半正定的；</li>\n<li>$A$的一切顺序主子式均为非负的；</li>\n<li>$A$的一切主子式均为非负的；</li>\n<li>$A$的特征值均为正；</li>\n<li>存在$n$阶实矩阵$C$，使$A=C’C$；</li>\n<li>存在秩为$r$的$r×n$实矩阵$B$，使$A=B’B$</li>\n</ol>"},{"title":"矩阵求导","date":"2018-09-23T13:10:27.000Z","_content":"","source":"_posts/矩阵求导.md","raw":"---\ntitle: 矩阵求导\ndate: 2018-09-23 21:10:27\ntags:\n---\n","slug":"矩阵求导","published":1,"updated":"2019-07-30T01:54:38.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0u005ohomj1mxgjcxm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"牛顿法和拟牛顿法","date":"2017-09-03T03:12:56.000Z","_content":"牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是求解无约束最优化问题的常用方法。方法使用函数 $f(x)$的一二阶导数。具有收敛速度快、迭代次数少、计算量大的特点。\n# 问题描述\n\n考虑如下无约束极小化问题：\n\n\n\n$$\\min_{x\\in R^n} \\; f(x)$$\n\n最优点记为$x^\\ast$\n\n# 牛顿法\n- 输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $\n- 输出：$f(x)$的极小点$x^\\ast$\n 1. 确定初始点$x_0$，置$k=0$。\n 1. 计算 $g_k=g(x^{(k)})$\n 1. 若$\\left \\| g_k \\right \\|<\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$\n 1. 计算$H_k=H(x^{(k)})$\n 1. 置$x^{(k+1)}=x^{(k)}-H_k^{-1}g_k$\n 1. 置$k=k+1$，转第二步骤\n\n其中$g_k=\\bigtriangledown f(x^{(k)})$，$H_k=\\bigtriangledown^2 f(x^{(k)})=\\left [\\frac{\\partial^2 f}{\\partial x_i\\partial x_j} \\right ]_{n\\times n}$。$H_{k}^{-1}$为$x^{(k)}$的Hessian的逆矩阵,\n\n$$g(f)=\\bigtriangledown f=\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x_1} \\\\\n\\frac{\\partial f}{\\partial x_2} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial x_n} \\\\\n\\end{bmatrix}\n\\; \\; \\; \\; \\;\nH(f)= \\bigtriangledown^2 f=\n\\begin{bmatrix}\n\\frac{\\partial^2 f}{\\partial x^2_1} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x^2_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\\\n\\vdots & \\ddots & \\vdots \\\\\\\n\\frac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x^2_n}\n\\end{bmatrix}$$\n\n\n## 代数推导\n假设函数 $f(x)$ 二次可微，则在当前第$k$次迭代点 $x^{(k)}$ 对 $f(x)$ 进行二阶泰勒展开\n\n$$f \\left ( x \\right ) \\approx f \\left ( x^{(k)} \\right )+{f}'\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )+\\frac{1}{2}{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )^2$$\n\n求函数 $f(x)$ 极值则可以转化为对 $f(x)$ 求导并令其为0，\n$$\\frac{\\partial f}{\\partial x} \\approx  f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )=0$$\n得到\n$$\\begin{align*}\nx&=x^{(k)}-\\frac{f'\\left ( x^{(k)} \\right )}{f''\\left ( x^{(k)} \\right )} \\\\\n &= x^{(k)}-H_{k}^{-1}g_k  \\\\\nx^{(k+1)} &= x^{(k)}-H_{k}^{-1}g_k\n\\end{align*}$$\n\n# 阻尼牛顿法\n原始牛顿法由于迭代公式中没有步长因子，而是固定步长，有时会使迭代超过极值点，即$f(x^{(k+1)})>f(x^k)$，在牛顿方向上附加了步长因子，每次调整时会在搜索空间，在该方向找到最优步长，然后调整\n$$\\lambda _k=arg\\; \\underset{\\lambda \\in \\mathbb{R}}{min}\\; f(x_k+\\lambda H_k^{-1}g_k)\\;\\;\\;\\;\\;\\;\\; \\tag 2$$\n- 输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $\n- 输出：$f(x)$的极小点$x^\\ast$\n 1. 确定初始点$x_0$，置$k=0$。\n 1. 计算 $g_k=g(x^{(k)})$\n 1. 若$\\left \\| g_k \\right \\|<\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$\n 1. 计算$H_k=H(x^{(k)})$\n 1. 利用$(2)$式子得到步长$\\lambda_k$置$x^{(k+1)}=x^{(k)}-\\lambda_k H_k^{-1}g_k$\n 1. 置$k=k+1$，转第二步骤\n\n\n\n # 拟牛顿算法\n ## 拟牛顿思路\n 因为Hessian矩阵的计算量大而且无法保持正定所以采用拟牛顿算法。拟牛顿算法的基本思想是**不用二阶偏导数而构造出可以近似Hessian矩阵(或者Hessian矩阵的逆矩阵)的正定对称矩阵，在拟牛顿的条件下优化目标函数**\n ## 拟牛顿条件\n $$\\begin{align*}\n \\frac{\\partial f}{\\partial x} &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )\\\\\n f'\\left ( x^{(k+1)} \\right ) &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x^{(k+1)}-x^{(k)} \\right ) \\\\\n g_{k+1}-g_k &\\approx H_k\\left ( x^{(k+1)}-x^{(k)} \\right )\n \\end{align*}$$\n 拟牛顿法对$H_k$或$H_k^{-1}$取近似值，可减少计算量。记$B\\approx H$，$D\\approx H^{-1}$，$y_k=g_{k+1}-g_k$，$s_k=x_{k+1}-x_k$。根据拟牛顿条件，可得近似公式：\n\n $$\\color{red}{B_{k+1}=\\frac{y_k}{s_k}   \\;\\;\\;\\;\\;\\;\\;\\;D_{k+1}=\\frac{s_k}{y_k}}$$\n\n ## DFP算法\nDFP算法采用的是$D$，但并不直接计算$D$，而是计算每一步DD的增量$ΔD$来间接的求出$D$。这也是很多优化算法的做法，因为一般上一步的中间结果对下一步的计算仍有价值，若直接抛弃重新计算耗时耗力耗内存，重新发明了轮子。\n\n$$D_{k+1}=D_k+\\Delta D_k$$\n\n$D_0$通常取单位矩阵I，关键导出每一步的$ΔD_k$。\n通过一系列艰苦而又卓绝的推导计算假设取便，最终的导出结果为：\n\n$$\\color{red}{\\begin{align*}\nD_{k+1}&=D_k+\\Delta D_k\\; \\; \\; \\; k=0,1,2,\\cdots \\\\\n\\Delta D_k &=\\frac{s_ks_k^T}{s_k^Ty_k} -\\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}\n\\end{align*}}$$\n\n一般来说，在进行中间增量计算时，都要经过这一步艰苦而又卓绝的推导计算。\n## BFGS算法\nBFGS算法与DFP算法类似，只是采用的BB来近似HH。最终的公式为：\n$$\\color{red}{\\begin{align*}\n\\Delta B_k &=\\frac{y_ky_k^T}{s_k^Ty_k} -\\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}\n\\end{align*}}$$\n\n## L-BFGS\nL-BFGS算法对BFGS算法进行改进，不再存储矩阵$D_k$，因为$D_k$有时候比较大，计算机的肚子盛不下。但是我们用到$D_k$的时候怎么办呢？答案是根据公式求出来。\n\n从上面的算法推导可知，$D_k$只跟$D_0$和序列$\\{s_k\\}$和$\\{y_k\\}$有关。即我们知道了后者，即可以求得前者。进一步近似，我们只需要序列$\\{s_k\\}$和$\\{y_k\\}$的最近$m$个值即可。这样说来，我们的计算机内存中只需要存储这两个序列即可，瞬间卸掉了很多东西，正是春风得意马蹄轻。当然，这样cpu的计算量也会相应的增加，这是可以接受的，马，也是可以接受的。\n\n最终的递推关系为\n\n$$D_{k+1}=V^T_kD_kV_k+\\rho_k s_ks^T_k$$\n\n\n其中\n\n\n$$\\rho_k=\\frac{1}{y^T_ks_k},V_k=I-\\rho_ky_ks^T_k$$\n","source":"_posts/牛顿法和拟牛顿法.md","raw":"---\ntitle: 牛顿法和拟牛顿法\ndate: 2017-09-03 11:12:56\ntags: [优化,凸优化,人工智能]\ncategories: 机器学习\n---\n牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是求解无约束最优化问题的常用方法。方法使用函数 $f(x)$的一二阶导数。具有收敛速度快、迭代次数少、计算量大的特点。\n# 问题描述\n\n考虑如下无约束极小化问题：\n\n\n\n$$\\min_{x\\in R^n} \\; f(x)$$\n\n最优点记为$x^\\ast$\n\n# 牛顿法\n- 输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $\n- 输出：$f(x)$的极小点$x^\\ast$\n 1. 确定初始点$x_0$，置$k=0$。\n 1. 计算 $g_k=g(x^{(k)})$\n 1. 若$\\left \\| g_k \\right \\|<\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$\n 1. 计算$H_k=H(x^{(k)})$\n 1. 置$x^{(k+1)}=x^{(k)}-H_k^{-1}g_k$\n 1. 置$k=k+1$，转第二步骤\n\n其中$g_k=\\bigtriangledown f(x^{(k)})$，$H_k=\\bigtriangledown^2 f(x^{(k)})=\\left [\\frac{\\partial^2 f}{\\partial x_i\\partial x_j} \\right ]_{n\\times n}$。$H_{k}^{-1}$为$x^{(k)}$的Hessian的逆矩阵,\n\n$$g(f)=\\bigtriangledown f=\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x_1} \\\\\n\\frac{\\partial f}{\\partial x_2} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial x_n} \\\\\n\\end{bmatrix}\n\\; \\; \\; \\; \\;\nH(f)= \\bigtriangledown^2 f=\n\\begin{bmatrix}\n\\frac{\\partial^2 f}{\\partial x^2_1} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x^2_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\\\n\\vdots & \\ddots & \\vdots \\\\\\\n\\frac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x^2_n}\n\\end{bmatrix}$$\n\n\n## 代数推导\n假设函数 $f(x)$ 二次可微，则在当前第$k$次迭代点 $x^{(k)}$ 对 $f(x)$ 进行二阶泰勒展开\n\n$$f \\left ( x \\right ) \\approx f \\left ( x^{(k)} \\right )+{f}'\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )+\\frac{1}{2}{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )^2$$\n\n求函数 $f(x)$ 极值则可以转化为对 $f(x)$ 求导并令其为0，\n$$\\frac{\\partial f}{\\partial x} \\approx  f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )=0$$\n得到\n$$\\begin{align*}\nx&=x^{(k)}-\\frac{f'\\left ( x^{(k)} \\right )}{f''\\left ( x^{(k)} \\right )} \\\\\n &= x^{(k)}-H_{k}^{-1}g_k  \\\\\nx^{(k+1)} &= x^{(k)}-H_{k}^{-1}g_k\n\\end{align*}$$\n\n# 阻尼牛顿法\n原始牛顿法由于迭代公式中没有步长因子，而是固定步长，有时会使迭代超过极值点，即$f(x^{(k+1)})>f(x^k)$，在牛顿方向上附加了步长因子，每次调整时会在搜索空间，在该方向找到最优步长，然后调整\n$$\\lambda _k=arg\\; \\underset{\\lambda \\in \\mathbb{R}}{min}\\; f(x_k+\\lambda H_k^{-1}g_k)\\;\\;\\;\\;\\;\\;\\; \\tag 2$$\n- 输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $\n- 输出：$f(x)$的极小点$x^\\ast$\n 1. 确定初始点$x_0$，置$k=0$。\n 1. 计算 $g_k=g(x^{(k)})$\n 1. 若$\\left \\| g_k \\right \\|<\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$\n 1. 计算$H_k=H(x^{(k)})$\n 1. 利用$(2)$式子得到步长$\\lambda_k$置$x^{(k+1)}=x^{(k)}-\\lambda_k H_k^{-1}g_k$\n 1. 置$k=k+1$，转第二步骤\n\n\n\n # 拟牛顿算法\n ## 拟牛顿思路\n 因为Hessian矩阵的计算量大而且无法保持正定所以采用拟牛顿算法。拟牛顿算法的基本思想是**不用二阶偏导数而构造出可以近似Hessian矩阵(或者Hessian矩阵的逆矩阵)的正定对称矩阵，在拟牛顿的条件下优化目标函数**\n ## 拟牛顿条件\n $$\\begin{align*}\n \\frac{\\partial f}{\\partial x} &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )\\\\\n f'\\left ( x^{(k+1)} \\right ) &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x^{(k+1)}-x^{(k)} \\right ) \\\\\n g_{k+1}-g_k &\\approx H_k\\left ( x^{(k+1)}-x^{(k)} \\right )\n \\end{align*}$$\n 拟牛顿法对$H_k$或$H_k^{-1}$取近似值，可减少计算量。记$B\\approx H$，$D\\approx H^{-1}$，$y_k=g_{k+1}-g_k$，$s_k=x_{k+1}-x_k$。根据拟牛顿条件，可得近似公式：\n\n $$\\color{red}{B_{k+1}=\\frac{y_k}{s_k}   \\;\\;\\;\\;\\;\\;\\;\\;D_{k+1}=\\frac{s_k}{y_k}}$$\n\n ## DFP算法\nDFP算法采用的是$D$，但并不直接计算$D$，而是计算每一步DD的增量$ΔD$来间接的求出$D$。这也是很多优化算法的做法，因为一般上一步的中间结果对下一步的计算仍有价值，若直接抛弃重新计算耗时耗力耗内存，重新发明了轮子。\n\n$$D_{k+1}=D_k+\\Delta D_k$$\n\n$D_0$通常取单位矩阵I，关键导出每一步的$ΔD_k$。\n通过一系列艰苦而又卓绝的推导计算假设取便，最终的导出结果为：\n\n$$\\color{red}{\\begin{align*}\nD_{k+1}&=D_k+\\Delta D_k\\; \\; \\; \\; k=0,1,2,\\cdots \\\\\n\\Delta D_k &=\\frac{s_ks_k^T}{s_k^Ty_k} -\\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}\n\\end{align*}}$$\n\n一般来说，在进行中间增量计算时，都要经过这一步艰苦而又卓绝的推导计算。\n## BFGS算法\nBFGS算法与DFP算法类似，只是采用的BB来近似HH。最终的公式为：\n$$\\color{red}{\\begin{align*}\n\\Delta B_k &=\\frac{y_ky_k^T}{s_k^Ty_k} -\\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}\n\\end{align*}}$$\n\n## L-BFGS\nL-BFGS算法对BFGS算法进行改进，不再存储矩阵$D_k$，因为$D_k$有时候比较大，计算机的肚子盛不下。但是我们用到$D_k$的时候怎么办呢？答案是根据公式求出来。\n\n从上面的算法推导可知，$D_k$只跟$D_0$和序列$\\{s_k\\}$和$\\{y_k\\}$有关。即我们知道了后者，即可以求得前者。进一步近似，我们只需要序列$\\{s_k\\}$和$\\{y_k\\}$的最近$m$个值即可。这样说来，我们的计算机内存中只需要存储这两个序列即可，瞬间卸掉了很多东西，正是春风得意马蹄轻。当然，这样cpu的计算量也会相应的增加，这是可以接受的，马，也是可以接受的。\n\n最终的递推关系为\n\n$$D_{k+1}=V^T_kD_kV_k+\\rho_k s_ks^T_k$$\n\n\n其中\n\n\n$$\\rho_k=\\frac{1}{y^T_ks_k},V_k=I-\\rho_ky_ks^T_k$$\n","slug":"牛顿法和拟牛顿法","published":1,"updated":"2019-07-30T01:54:38.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0w005rhomjgykposhj","content":"<p>牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是求解无约束最优化问题的常用方法。方法使用函数 $f(x)$的一二阶导数。具有收敛速度快、迭代次数少、计算量大的特点。</p>\n<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>考虑如下无约束极小化问题：</p>\n<script type=\"math/tex; mode=display\">\\min_{x\\in R^n} \\; f(x)</script><p>最优点记为$x^\\ast$</p>\n<h1 id=\"牛顿法\"><a href=\"#牛顿法\" class=\"headerlink\" title=\"牛顿法\"></a>牛顿法</h1><ul>\n<li>输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $</li>\n<li>输出：$f(x)$的极小点$x^\\ast$<ol>\n<li>确定初始点$x_0$，置$k=0$。</li>\n<li>计算 $g_k=g(x^{(k)})$</li>\n<li>若$\\left | g_k \\right |&lt;\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$</li>\n<li>计算$H_k=H(x^{(k)})$</li>\n<li>置$x^{(k+1)}=x^{(k)}-H_k^{-1}g_k$</li>\n<li>置$k=k+1$，转第二步骤</li>\n</ol>\n</li>\n</ul>\n<p>其中$g_k=\\bigtriangledown f(x^{(k)})$，$H_k=\\bigtriangledown^2 f(x^{(k)})=\\left [\\frac{\\partial^2 f}{\\partial x_i\\partial x_j} \\right ]_{n\\times n}$。$H_{k}^{-1}$为$x^{(k)}$的Hessian的逆矩阵,</p>\n<script type=\"math/tex; mode=display\">g(f)=\\bigtriangledown f=\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x_1} \\\\\n\\frac{\\partial f}{\\partial x_2} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial x_n} \\\\\n\\end{bmatrix}\n\\; \\; \\; \\; \\;\nH(f)= \\bigtriangledown^2 f=\n\\begin{bmatrix}\n\\frac{\\partial^2 f}{\\partial x^2_1} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x^2_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\\\n\\vdots & \\ddots & \\vdots \\\\\\\n\\frac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x^2_n}\n\\end{bmatrix}</script><h2 id=\"代数推导\"><a href=\"#代数推导\" class=\"headerlink\" title=\"代数推导\"></a>代数推导</h2><p>假设函数 $f(x)$ 二次可微，则在当前第$k$次迭代点 $x^{(k)}$ 对 $f(x)$ 进行二阶泰勒展开</p>\n<script type=\"math/tex; mode=display\">f \\left ( x \\right ) \\approx f \\left ( x^{(k)} \\right )+{f}'\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )+\\frac{1}{2}{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )^2</script><p>求函数 $f(x)$ 极值则可以转化为对 $f(x)$ 求导并令其为0，</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial f}{\\partial x} \\approx  f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )=0</script><p>得到</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nx&=x^{(k)}-\\frac{f'\\left ( x^{(k)} \\right )}{f''\\left ( x^{(k)} \\right )} \\\\\n &= x^{(k)}-H_{k}^{-1}g_k  \\\\\nx^{(k+1)} &= x^{(k)}-H_{k}^{-1}g_k\n\\end{align*}</script><h1 id=\"阻尼牛顿法\"><a href=\"#阻尼牛顿法\" class=\"headerlink\" title=\"阻尼牛顿法\"></a>阻尼牛顿法</h1><p>原始牛顿法由于迭代公式中没有步长因子，而是固定步长，有时会使迭代超过极值点，即$f(x^{(k+1)})&gt;f(x^k)$，在牛顿方向上附加了步长因子，每次调整时会在搜索空间，在该方向找到最优步长，然后调整</p>\n<script type=\"math/tex; mode=display\">\\lambda _k=arg\\; \\underset{\\lambda \\in \\mathbb{R}}{min}\\; f(x_k+\\lambda H_k^{-1}g_k)\\;\\;\\;\\;\\;\\;\\; \\tag 2</script><ul>\n<li>输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $</li>\n<li>输出：$f(x)$的极小点$x^\\ast$<ol>\n<li>确定初始点$x_0$，置$k=0$。</li>\n<li>计算 $g_k=g(x^{(k)})$</li>\n<li>若$\\left | g_k \\right |&lt;\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$</li>\n<li>计算$H_k=H(x^{(k)})$</li>\n<li>利用$(2)$式子得到步长$\\lambda_k$置$x^{(k+1)}=x^{(k)}-\\lambda_k H_k^{-1}g_k$</li>\n<li>置$k=k+1$，转第二步骤</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"拟牛顿算法\"><a href=\"#拟牛顿算法\" class=\"headerlink\" title=\"拟牛顿算法\"></a>拟牛顿算法</h1><h2 id=\"拟牛顿思路\"><a href=\"#拟牛顿思路\" class=\"headerlink\" title=\"拟牛顿思路\"></a>拟牛顿思路</h2><p> 因为Hessian矩阵的计算量大而且无法保持正定所以采用拟牛顿算法。拟牛顿算法的基本思想是<strong>不用二阶偏导数而构造出可以近似Hessian矩阵(或者Hessian矩阵的逆矩阵)的正定对称矩阵，在拟牛顿的条件下优化目标函数</strong></p>\n<h2 id=\"拟牛顿条件\"><a href=\"#拟牛顿条件\" class=\"headerlink\" title=\"拟牛顿条件\"></a>拟牛顿条件</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n \\frac{\\partial f}{\\partial x} &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )\\\\\n f'\\left ( x^{(k+1)} \\right ) &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x^{(k+1)}-x^{(k)} \\right ) \\\\\n g_{k+1}-g_k &\\approx H_k\\left ( x^{(k+1)}-x^{(k)} \\right )\n \\end{align*}</script><p> 拟牛顿法对$H_k$或$H_k^{-1}$取近似值，可减少计算量。记$B\\approx H$，$D\\approx H^{-1}$，$y_k=g_{k+1}-g_k$，$s_k=x_{k+1}-x_k$。根据拟牛顿条件，可得近似公式：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{B_{k+1}=\\frac{y_k}{s_k}   \\;\\;\\;\\;\\;\\;\\;\\;D_{k+1}=\\frac{s_k}{y_k}}</script><h2 id=\"DFP算法\"><a href=\"#DFP算法\" class=\"headerlink\" title=\"DFP算法\"></a>DFP算法</h2><p>DFP算法采用的是$D$，但并不直接计算$D$，而是计算每一步DD的增量$ΔD$来间接的求出$D$。这也是很多优化算法的做法，因为一般上一步的中间结果对下一步的计算仍有价值，若直接抛弃重新计算耗时耗力耗内存，重新发明了轮子。</p>\n<script type=\"math/tex; mode=display\">D_{k+1}=D_k+\\Delta D_k</script><p>$D_0$通常取单位矩阵I，关键导出每一步的$ΔD_k$。<br>通过一系列艰苦而又卓绝的推导计算假设取便，最终的导出结果为：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\begin{align*}\nD_{k+1}&=D_k+\\Delta D_k\\; \\; \\; \\; k=0,1,2,\\cdots \\\\\n\\Delta D_k &=\\frac{s_ks_k^T}{s_k^Ty_k} -\\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}\n\\end{align*}}</script><p>一般来说，在进行中间增量计算时，都要经过这一步艰苦而又卓绝的推导计算。</p>\n<h2 id=\"BFGS算法\"><a href=\"#BFGS算法\" class=\"headerlink\" title=\"BFGS算法\"></a>BFGS算法</h2><p>BFGS算法与DFP算法类似，只是采用的BB来近似HH。最终的公式为：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\begin{align*}\n\\Delta B_k &=\\frac{y_ky_k^T}{s_k^Ty_k} -\\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}\n\\end{align*}}</script><h2 id=\"L-BFGS\"><a href=\"#L-BFGS\" class=\"headerlink\" title=\"L-BFGS\"></a>L-BFGS</h2><p>L-BFGS算法对BFGS算法进行改进，不再存储矩阵$D_k$，因为$D_k$有时候比较大，计算机的肚子盛不下。但是我们用到$D_k$的时候怎么办呢？答案是根据公式求出来。</p>\n<p>从上面的算法推导可知，$D_k$只跟$D_0$和序列$\\{s_k\\}$和$\\{y_k\\}$有关。即我们知道了后者，即可以求得前者。进一步近似，我们只需要序列$\\{s_k\\}$和$\\{y_k\\}$的最近$m$个值即可。这样说来，我们的计算机内存中只需要存储这两个序列即可，瞬间卸掉了很多东西，正是春风得意马蹄轻。当然，这样cpu的计算量也会相应的增加，这是可以接受的，马，也是可以接受的。</p>\n<p>最终的递推关系为</p>\n<script type=\"math/tex; mode=display\">D_{k+1}=V^T_kD_kV_k+\\rho_k s_ks^T_k</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\\rho_k=\\frac{1}{y^T_ks_k},V_k=I-\\rho_ky_ks^T_k</script>","site":{"data":{}},"excerpt":"","more":"<p>牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是求解无约束最优化问题的常用方法。方法使用函数 $f(x)$的一二阶导数。具有收敛速度快、迭代次数少、计算量大的特点。</p>\n<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>考虑如下无约束极小化问题：</p>\n<script type=\"math/tex; mode=display\">\\min_{x\\in R^n} \\; f(x)</script><p>最优点记为$x^\\ast$</p>\n<h1 id=\"牛顿法\"><a href=\"#牛顿法\" class=\"headerlink\" title=\"牛顿法\"></a>牛顿法</h1><ul>\n<li>输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $</li>\n<li>输出：$f(x)$的极小点$x^\\ast$<ol>\n<li>确定初始点$x_0$，置$k=0$。</li>\n<li>计算 $g_k=g(x^{(k)})$</li>\n<li>若$\\left | g_k \\right |&lt;\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$</li>\n<li>计算$H_k=H(x^{(k)})$</li>\n<li>置$x^{(k+1)}=x^{(k)}-H_k^{-1}g_k$</li>\n<li>置$k=k+1$，转第二步骤</li>\n</ol>\n</li>\n</ul>\n<p>其中$g_k=\\bigtriangledown f(x^{(k)})$，$H_k=\\bigtriangledown^2 f(x^{(k)})=\\left [\\frac{\\partial^2 f}{\\partial x_i\\partial x_j} \\right ]_{n\\times n}$。$H_{k}^{-1}$为$x^{(k)}$的Hessian的逆矩阵,</p>\n<script type=\"math/tex; mode=display\">g(f)=\\bigtriangledown f=\\begin{bmatrix}\n\\frac{\\partial f}{\\partial x_1} \\\\\n\\frac{\\partial f}{\\partial x_2} \\\\\n\\vdots \\\\\n\\frac{\\partial f}{\\partial x_n} \\\\\n\\end{bmatrix}\n\\; \\; \\; \\; \\;\nH(f)= \\bigtriangledown^2 f=\n\\begin{bmatrix}\n\\frac{\\partial^2 f}{\\partial x^2_1} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x^2_2} \\cdots & \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\\\n\\vdots & \\ddots & \\vdots \\\\\\\n\\frac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} \\cdots & \\frac{\\partial^2 f}{\\partial x^2_n}\n\\end{bmatrix}</script><h2 id=\"代数推导\"><a href=\"#代数推导\" class=\"headerlink\" title=\"代数推导\"></a>代数推导</h2><p>假设函数 $f(x)$ 二次可微，则在当前第$k$次迭代点 $x^{(k)}$ 对 $f(x)$ 进行二阶泰勒展开</p>\n<script type=\"math/tex; mode=display\">f \\left ( x \\right ) \\approx f \\left ( x^{(k)} \\right )+{f}'\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )+\\frac{1}{2}{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )^2</script><p>求函数 $f(x)$ 极值则可以转化为对 $f(x)$ 求导并令其为0，</p>\n<script type=\"math/tex; mode=display\">\\frac{\\partial f}{\\partial x} \\approx  f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )=0</script><p>得到</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nx&=x^{(k)}-\\frac{f'\\left ( x^{(k)} \\right )}{f''\\left ( x^{(k)} \\right )} \\\\\n &= x^{(k)}-H_{k}^{-1}g_k  \\\\\nx^{(k+1)} &= x^{(k)}-H_{k}^{-1}g_k\n\\end{align*}</script><h1 id=\"阻尼牛顿法\"><a href=\"#阻尼牛顿法\" class=\"headerlink\" title=\"阻尼牛顿法\"></a>阻尼牛顿法</h1><p>原始牛顿法由于迭代公式中没有步长因子，而是固定步长，有时会使迭代超过极值点，即$f(x^{(k+1)})&gt;f(x^k)$，在牛顿方向上附加了步长因子，每次调整时会在搜索空间，在该方向找到最优步长，然后调整</p>\n<script type=\"math/tex; mode=display\">\\lambda _k=arg\\; \\underset{\\lambda \\in \\mathbb{R}}{min}\\; f(x_k+\\lambda H_k^{-1}g_k)\\;\\;\\;\\;\\;\\;\\; \\tag 2</script><ul>\n<li>输入：目标函数$f(x)$，梯度$g(x)=\\bigtriangledown f(x)$，海森矩阵$H(x)$，精度要求$\\varepsilon $</li>\n<li>输出：$f(x)$的极小点$x^\\ast$<ol>\n<li>确定初始点$x_0$，置$k=0$。</li>\n<li>计算 $g_k=g(x^{(k)})$</li>\n<li>若$\\left | g_k \\right |&lt;\\varepsilon $，则停止计算，得近似解$x^\\ast=x^{(k)}$</li>\n<li>计算$H_k=H(x^{(k)})$</li>\n<li>利用$(2)$式子得到步长$\\lambda_k$置$x^{(k+1)}=x^{(k)}-\\lambda_k H_k^{-1}g_k$</li>\n<li>置$k=k+1$，转第二步骤</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"拟牛顿算法\"><a href=\"#拟牛顿算法\" class=\"headerlink\" title=\"拟牛顿算法\"></a>拟牛顿算法</h1><h2 id=\"拟牛顿思路\"><a href=\"#拟牛顿思路\" class=\"headerlink\" title=\"拟牛顿思路\"></a>拟牛顿思路</h2><p> 因为Hessian矩阵的计算量大而且无法保持正定所以采用拟牛顿算法。拟牛顿算法的基本思想是<strong>不用二阶偏导数而构造出可以近似Hessian矩阵(或者Hessian矩阵的逆矩阵)的正定对称矩阵，在拟牛顿的条件下优化目标函数</strong></p>\n<h2 id=\"拟牛顿条件\"><a href=\"#拟牛顿条件\" class=\"headerlink\" title=\"拟牛顿条件\"></a>拟牛顿条件</h2><script type=\"math/tex; mode=display\">\\begin{align*}\n \\frac{\\partial f}{\\partial x} &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x-x^{(k)} \\right )\\\\\n f'\\left ( x^{(k+1)} \\right ) &\\approx f'\\left ( x^{(k)} \\right )+{f}''\\left ( x^{(k)} \\right )\\left ( x^{(k+1)}-x^{(k)} \\right ) \\\\\n g_{k+1}-g_k &\\approx H_k\\left ( x^{(k+1)}-x^{(k)} \\right )\n \\end{align*}</script><p> 拟牛顿法对$H_k$或$H_k^{-1}$取近似值，可减少计算量。记$B\\approx H$，$D\\approx H^{-1}$，$y_k=g_{k+1}-g_k$，$s_k=x_{k+1}-x_k$。根据拟牛顿条件，可得近似公式：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{B_{k+1}=\\frac{y_k}{s_k}   \\;\\;\\;\\;\\;\\;\\;\\;D_{k+1}=\\frac{s_k}{y_k}}</script><h2 id=\"DFP算法\"><a href=\"#DFP算法\" class=\"headerlink\" title=\"DFP算法\"></a>DFP算法</h2><p>DFP算法采用的是$D$，但并不直接计算$D$，而是计算每一步DD的增量$ΔD$来间接的求出$D$。这也是很多优化算法的做法，因为一般上一步的中间结果对下一步的计算仍有价值，若直接抛弃重新计算耗时耗力耗内存，重新发明了轮子。</p>\n<script type=\"math/tex; mode=display\">D_{k+1}=D_k+\\Delta D_k</script><p>$D_0$通常取单位矩阵I，关键导出每一步的$ΔD_k$。<br>通过一系列艰苦而又卓绝的推导计算假设取便，最终的导出结果为：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\begin{align*}\nD_{k+1}&=D_k+\\Delta D_k\\; \\; \\; \\; k=0,1,2,\\cdots \\\\\n\\Delta D_k &=\\frac{s_ks_k^T}{s_k^Ty_k} -\\frac{D_ky_ky_k^TD_k}{y_k^TD_ky_k}\n\\end{align*}}</script><p>一般来说，在进行中间增量计算时，都要经过这一步艰苦而又卓绝的推导计算。</p>\n<h2 id=\"BFGS算法\"><a href=\"#BFGS算法\" class=\"headerlink\" title=\"BFGS算法\"></a>BFGS算法</h2><p>BFGS算法与DFP算法类似，只是采用的BB来近似HH。最终的公式为：</p>\n<script type=\"math/tex; mode=display\">\\color{red}{\\begin{align*}\n\\Delta B_k &=\\frac{y_ky_k^T}{s_k^Ty_k} -\\frac{B_ks_ks_k^TB_k}{s_k^TB_ks_k}\n\\end{align*}}</script><h2 id=\"L-BFGS\"><a href=\"#L-BFGS\" class=\"headerlink\" title=\"L-BFGS\"></a>L-BFGS</h2><p>L-BFGS算法对BFGS算法进行改进，不再存储矩阵$D_k$，因为$D_k$有时候比较大，计算机的肚子盛不下。但是我们用到$D_k$的时候怎么办呢？答案是根据公式求出来。</p>\n<p>从上面的算法推导可知，$D_k$只跟$D_0$和序列$\\{s_k\\}$和$\\{y_k\\}$有关。即我们知道了后者，即可以求得前者。进一步近似，我们只需要序列$\\{s_k\\}$和$\\{y_k\\}$的最近$m$个值即可。这样说来，我们的计算机内存中只需要存储这两个序列即可，瞬间卸掉了很多东西，正是春风得意马蹄轻。当然，这样cpu的计算量也会相应的增加，这是可以接受的，马，也是可以接受的。</p>\n<p>最终的递推关系为</p>\n<script type=\"math/tex; mode=display\">D_{k+1}=V^T_kD_kV_k+\\rho_k s_ks^T_k</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\\rho_k=\\frac{1}{y^T_ks_k},V_k=I-\\rho_ky_ks^T_k</script>"},{"title":"特征值与特征向量","date":"2017-08-18T03:51:18.000Z","_content":"\n# 定义\n## 特征向量\n矩阵在空间变换过程中，没有发生旋转的向量。因此特征向量可以看过空间变换的旋转轴。\n## 特征值\n特征向量在变换中拉伸或压缩比例的因子\n\n![特征值与特征向量意图](特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif)\n\n<!--more-->\n\n# 计算\n$\\vec{v}$为特征向量，$\\lambda $为特征值。求解如下所示：\n$$\\begin{align*}\nA\\vec{v}&=\\lambda \\vec{v} \\\\\nA\\vec{v}- \\lambda \\vec{v} &= \\vec{0}\\\\\n(A- \\lambda I)\\vec{v} &= \\vec{0}\n\\end{align*}$$\n存在一个非零向量 $\\vec{v}$ 使得 $(A- \\lambda I)\\vec{v} = \\vec{0}$ 则\n$$det(A- \\lambda I)=0$$\n求出$\\lambda $即特征值，带入特征值$\\lambda $解得特征向量$\\vec{v}$。\n\n![](特征值与特征向量/9553ee95232883adcf8266498d10940e.gif)\n\n\n# 对角矩阵\n对角矩阵的所有基向量都是特征向量\n$$\\begin{bmatrix}\n-5 & 0 & 0 & 0\\\\\n0 & -2 & 0 & 0\\\\\n0 & 0 & -4 & 0\\\\\n0 & 0 & 0 & 4\n\\end{bmatrix}$$\n## 对角矩阵的优势\n\n![对角矩阵的优势](特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif)\n\n## 对角矩阵的使用\n求出特征向量，利用基变换将原空间变换为以特征向量为基的空间，再利用基变换将以特征向量为基的空间变换为原空间\n","source":"_posts/特征值与特征向量.md","raw":"---\ntitle: 特征值与特征向量\ndate: 2017-08-18 11:51:18\ntags: [人工智能,线性代数,矩阵]\ncategories: 数学\n---\n\n# 定义\n## 特征向量\n矩阵在空间变换过程中，没有发生旋转的向量。因此特征向量可以看过空间变换的旋转轴。\n## 特征值\n特征向量在变换中拉伸或压缩比例的因子\n\n![特征值与特征向量意图](特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif)\n\n<!--more-->\n\n# 计算\n$\\vec{v}$为特征向量，$\\lambda $为特征值。求解如下所示：\n$$\\begin{align*}\nA\\vec{v}&=\\lambda \\vec{v} \\\\\nA\\vec{v}- \\lambda \\vec{v} &= \\vec{0}\\\\\n(A- \\lambda I)\\vec{v} &= \\vec{0}\n\\end{align*}$$\n存在一个非零向量 $\\vec{v}$ 使得 $(A- \\lambda I)\\vec{v} = \\vec{0}$ 则\n$$det(A- \\lambda I)=0$$\n求出$\\lambda $即特征值，带入特征值$\\lambda $解得特征向量$\\vec{v}$。\n\n![](特征值与特征向量/9553ee95232883adcf8266498d10940e.gif)\n\n\n# 对角矩阵\n对角矩阵的所有基向量都是特征向量\n$$\\begin{bmatrix}\n-5 & 0 & 0 & 0\\\\\n0 & -2 & 0 & 0\\\\\n0 & 0 & -4 & 0\\\\\n0 & 0 & 0 & 4\n\\end{bmatrix}$$\n## 对角矩阵的优势\n\n![对角矩阵的优势](特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif)\n\n## 对角矩阵的使用\n求出特征向量，利用基变换将原空间变换为以特征向量为基的空间，再利用基变换将以特征向量为基的空间变换为原空间\n","slug":"特征值与特征向量","published":1,"updated":"2019-07-30T01:54:38.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j0y005uhomj1jsjhd7s","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h2 id=\"特征向量\"><a href=\"#特征向量\" class=\"headerlink\" title=\"特征向量\"></a>特征向量</h2><p>矩阵在空间变换过程中，没有发生旋转的向量。因此特征向量可以看过空间变换的旋转轴。</p>\n<h2 id=\"特征值\"><a href=\"#特征值\" class=\"headerlink\" title=\"特征值\"></a>特征值</h2><p>特征向量在变换中拉伸或压缩比例的因子</p>\n<p><img src=\"/2017/08/18/特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif\" alt=\"特征值与特征向量意图\"></p>\n<a id=\"more\"></a>\n<h1 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h1><p>$\\vec{v}$为特征向量，$\\lambda $为特征值。求解如下所示：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nA\\vec{v}&=\\lambda \\vec{v} \\\\\nA\\vec{v}- \\lambda \\vec{v} &= \\vec{0}\\\\\n(A- \\lambda I)\\vec{v} &= \\vec{0}\n\\end{align*}</script><p>存在一个非零向量 $\\vec{v}$ 使得 $(A- \\lambda I)\\vec{v} = \\vec{0}$ 则</p>\n<script type=\"math/tex; mode=display\">det(A- \\lambda I)=0</script><p>求出$\\lambda $即特征值，带入特征值$\\lambda $解得特征向量$\\vec{v}$。</p>\n<p><img src=\"/2017/08/18/特征值与特征向量/9553ee95232883adcf8266498d10940e.gif\" alt=\"\"></p>\n<h1 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h1><p>对角矩阵的所有基向量都是特征向量</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n-5 & 0 & 0 & 0\\\\\n0 & -2 & 0 & 0\\\\\n0 & 0 & -4 & 0\\\\\n0 & 0 & 0 & 4\n\\end{bmatrix}</script><h2 id=\"对角矩阵的优势\"><a href=\"#对角矩阵的优势\" class=\"headerlink\" title=\"对角矩阵的优势\"></a>对角矩阵的优势</h2><p><img src=\"/2017/08/18/特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif\" alt=\"对角矩阵的优势\"></p>\n<h2 id=\"对角矩阵的使用\"><a href=\"#对角矩阵的使用\" class=\"headerlink\" title=\"对角矩阵的使用\"></a>对角矩阵的使用</h2><p>求出特征向量，利用基变换将原空间变换为以特征向量为基的空间，再利用基变换将以特征向量为基的空间变换为原空间</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><h2 id=\"特征向量\"><a href=\"#特征向量\" class=\"headerlink\" title=\"特征向量\"></a>特征向量</h2><p>矩阵在空间变换过程中，没有发生旋转的向量。因此特征向量可以看过空间变换的旋转轴。</p>\n<h2 id=\"特征值\"><a href=\"#特征值\" class=\"headerlink\" title=\"特征值\"></a>特征值</h2><p>特征向量在变换中拉伸或压缩比例的因子</p>\n<p><img src=\"/2017/08/18/特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif\" alt=\"特征值与特征向量意图\"></p>","more":"<h1 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h1><p>$\\vec{v}$为特征向量，$\\lambda $为特征值。求解如下所示：</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nA\\vec{v}&=\\lambda \\vec{v} \\\\\nA\\vec{v}- \\lambda \\vec{v} &= \\vec{0}\\\\\n(A- \\lambda I)\\vec{v} &= \\vec{0}\n\\end{align*}</script><p>存在一个非零向量 $\\vec{v}$ 使得 $(A- \\lambda I)\\vec{v} = \\vec{0}$ 则</p>\n<script type=\"math/tex; mode=display\">det(A- \\lambda I)=0</script><p>求出$\\lambda $即特征值，带入特征值$\\lambda $解得特征向量$\\vec{v}$。</p>\n<p><img src=\"/2017/08/18/特征值与特征向量/9553ee95232883adcf8266498d10940e.gif\" alt=\"\"></p>\n<h1 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h1><p>对角矩阵的所有基向量都是特征向量</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n-5 & 0 & 0 & 0\\\\\n0 & -2 & 0 & 0\\\\\n0 & 0 & -4 & 0\\\\\n0 & 0 & 0 & 4\n\\end{bmatrix}</script><h2 id=\"对角矩阵的优势\"><a href=\"#对角矩阵的优势\" class=\"headerlink\" title=\"对角矩阵的优势\"></a>对角矩阵的优势</h2><p><img src=\"/2017/08/18/特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif\" alt=\"对角矩阵的优势\"></p>\n<h2 id=\"对角矩阵的使用\"><a href=\"#对角矩阵的使用\" class=\"headerlink\" title=\"对角矩阵的使用\"></a>对角矩阵的使用</h2><p>求出特征向量，利用基变换将原空间变换为以特征向量为基的空间，再利用基变换将以特征向量为基的空间变换为原空间</p>"},{"title":"矩阵的基础概念","date":"2017-08-18T07:45:40.000Z","_content":"\n# 零向量\n变换后落在原点的向量的集合被称为矩阵的‘零空间’或者‘核’。\n\n- 零向量一定在列空间中\n- 对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身\n- 对于一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上，变换后的已给向量落在零向量上，而“零空间”正是这些向量所构成的空间\n\n# 对角矩阵\n\n在方阵中，对角线（从左上到右下）上的值称为对角元素。\n非对角元素全部为0的矩阵称为对角矩阵。\n对角矩阵表示的映射是沿着坐标轴伸缩，其中对角元素就是各坐标轴伸缩的倍率\n\n# 矩阵的秩\n\n矩阵的秩，为变换后的空间的维数\n\n# 单位矩阵\n\n方阵中，如果除了对角线（从左上到右下）上的元素为1，其余元素都为0，则该矩阵称为单位矩阵，记为 $I$ 。 $I_{n}$ 表示 $n$ 阶单位矩阵。**单位矩阵表示的映射是“什么都不做”的映射。**\n$$I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}$$\n\n# 奇异矩阵\n行列式为零的矩阵\n\n# 逆矩阵\n$$AA^{-1}=A^{-1}A=I$$\n\n# 零矩阵\n\n所有元素都为0的矩阵称为零矩阵，记为 $O$ 。**零矩阵表示的映射是将所有的点都映射到原点的映射**\n\n# 行列式\n\n线性变换的行列式即线性变换改变面积的比例。\n$$det(M_1M_2) = det(M_1)det(M_2)$$\n-  检验一个矩阵的行列式是否为0，就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上\n- 在三维空间下，行列式可以简单看作这个平行六面体的体积，行列式为0则意味着整个空间被压缩为零体积的东西，也就是一个平面或者一条直线，或者更极端情况下的一个点\n\n# 特征分解\n\n如果说一个向量 $v$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：\n$$Av=\\lambda v$$\n$\\lambda$ 为特征向量 $v$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式：\n$$A=Q\\Sigma Q^{-1}$$\n其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\\Sigma$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。\n\n对于矩阵为高维的情况下，那么这个矩阵就是高维空间下的一个线性变换。可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。\n\n总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。\n\n# 奇异值分解\n\n特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个 $N \\ast  M $的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：\n\n分解形式：\n![](矩阵的基础概念/矩阵的基础概念-bced7336.png)\n假设A是一个 $M*N$ 的矩阵，那么得到的U是一个$M\\ast M$ 的方阵（称为左奇异向量），$Σ$ 是一个 $M\\ast N$ 的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$ ($V$的转置)是一个 $N\\ast N$ 的矩阵（称为右奇异向量）。\n\n# LU分解\n给定矩阵 $A$，将$A$表示成下三角矩阵L和上三角矩阵U的乘积，称为LU分解\n","source":"_posts/矩阵的基础概念.md","raw":"---\ntitle: 矩阵的基础概念\ndate: 2017-08-18 15:45:40\ntags: [人工智能,线性代数,矩阵]\ncategories: 数学\n---\n\n# 零向量\n变换后落在原点的向量的集合被称为矩阵的‘零空间’或者‘核’。\n\n- 零向量一定在列空间中\n- 对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身\n- 对于一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上，变换后的已给向量落在零向量上，而“零空间”正是这些向量所构成的空间\n\n# 对角矩阵\n\n在方阵中，对角线（从左上到右下）上的值称为对角元素。\n非对角元素全部为0的矩阵称为对角矩阵。\n对角矩阵表示的映射是沿着坐标轴伸缩，其中对角元素就是各坐标轴伸缩的倍率\n\n# 矩阵的秩\n\n矩阵的秩，为变换后的空间的维数\n\n# 单位矩阵\n\n方阵中，如果除了对角线（从左上到右下）上的元素为1，其余元素都为0，则该矩阵称为单位矩阵，记为 $I$ 。 $I_{n}$ 表示 $n$ 阶单位矩阵。**单位矩阵表示的映射是“什么都不做”的映射。**\n$$I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}$$\n\n# 奇异矩阵\n行列式为零的矩阵\n\n# 逆矩阵\n$$AA^{-1}=A^{-1}A=I$$\n\n# 零矩阵\n\n所有元素都为0的矩阵称为零矩阵，记为 $O$ 。**零矩阵表示的映射是将所有的点都映射到原点的映射**\n\n# 行列式\n\n线性变换的行列式即线性变换改变面积的比例。\n$$det(M_1M_2) = det(M_1)det(M_2)$$\n-  检验一个矩阵的行列式是否为0，就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上\n- 在三维空间下，行列式可以简单看作这个平行六面体的体积，行列式为0则意味着整个空间被压缩为零体积的东西，也就是一个平面或者一条直线，或者更极端情况下的一个点\n\n# 特征分解\n\n如果说一个向量 $v$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：\n$$Av=\\lambda v$$\n$\\lambda$ 为特征向量 $v$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式：\n$$A=Q\\Sigma Q^{-1}$$\n其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\\Sigma$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。\n\n对于矩阵为高维的情况下，那么这个矩阵就是高维空间下的一个线性变换。可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。\n\n总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。\n\n# 奇异值分解\n\n特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个 $N \\ast  M $的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：\n\n分解形式：\n![](矩阵的基础概念/矩阵的基础概念-bced7336.png)\n假设A是一个 $M*N$ 的矩阵，那么得到的U是一个$M\\ast M$ 的方阵（称为左奇异向量），$Σ$ 是一个 $M\\ast N$ 的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$ ($V$的转置)是一个 $N\\ast N$ 的矩阵（称为右奇异向量）。\n\n# LU分解\n给定矩阵 $A$，将$A$表示成下三角矩阵L和上三角矩阵U的乘积，称为LU分解\n","slug":"矩阵的基础概念","published":1,"updated":"2019-07-30T01:54:38.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j10005zhomjikqgmpzb","content":"<h1 id=\"零向量\"><a href=\"#零向量\" class=\"headerlink\" title=\"零向量\"></a>零向量</h1><p>变换后落在原点的向量的集合被称为矩阵的‘零空间’或者‘核’。</p>\n<ul>\n<li>零向量一定在列空间中</li>\n<li>对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身</li>\n<li>对于一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上，变换后的已给向量落在零向量上，而“零空间”正是这些向量所构成的空间</li>\n</ul>\n<h1 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h1><p>在方阵中，对角线（从左上到右下）上的值称为对角元素。<br>非对角元素全部为0的矩阵称为对角矩阵。<br>对角矩阵表示的映射是沿着坐标轴伸缩，其中对角元素就是各坐标轴伸缩的倍率</p>\n<h1 id=\"矩阵的秩\"><a href=\"#矩阵的秩\" class=\"headerlink\" title=\"矩阵的秩\"></a>矩阵的秩</h1><p>矩阵的秩，为变换后的空间的维数</p>\n<h1 id=\"单位矩阵\"><a href=\"#单位矩阵\" class=\"headerlink\" title=\"单位矩阵\"></a>单位矩阵</h1><p>方阵中，如果除了对角线（从左上到右下）上的元素为1，其余元素都为0，则该矩阵称为单位矩阵，记为 $I$ 。 $I_{n}$ 表示 $n$ 阶单位矩阵。<strong>单位矩阵表示的映射是“什么都不做”的映射。</strong></p>\n<script type=\"math/tex; mode=display\">I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}</script><h1 id=\"奇异矩阵\"><a href=\"#奇异矩阵\" class=\"headerlink\" title=\"奇异矩阵\"></a>奇异矩阵</h1><p>行列式为零的矩阵</p>\n<h1 id=\"逆矩阵\"><a href=\"#逆矩阵\" class=\"headerlink\" title=\"逆矩阵\"></a>逆矩阵</h1><script type=\"math/tex; mode=display\">AA^{-1}=A^{-1}A=I</script><h1 id=\"零矩阵\"><a href=\"#零矩阵\" class=\"headerlink\" title=\"零矩阵\"></a>零矩阵</h1><p>所有元素都为0的矩阵称为零矩阵，记为 $O$ 。<strong>零矩阵表示的映射是将所有的点都映射到原点的映射</strong></p>\n<h1 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h1><p>线性变换的行列式即线性变换改变面积的比例。</p>\n<script type=\"math/tex; mode=display\">det(M_1M_2) = det(M_1)det(M_2)</script><ul>\n<li>检验一个矩阵的行列式是否为0，就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上</li>\n<li>在三维空间下，行列式可以简单看作这个平行六面体的体积，行列式为0则意味着整个空间被压缩为零体积的东西，也就是一个平面或者一条直线，或者更极端情况下的一个点</li>\n</ul>\n<h1 id=\"特征分解\"><a href=\"#特征分解\" class=\"headerlink\" title=\"特征分解\"></a>特征分解</h1><p>如果说一个向量 $v$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：</p>\n<script type=\"math/tex; mode=display\">Av=\\lambda v</script><p>$\\lambda$ 为特征向量 $v$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式：</p>\n<script type=\"math/tex; mode=display\">A=Q\\Sigma Q^{-1}</script><p>其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\\Sigma$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。</p>\n<p>对于矩阵为高维的情况下，那么这个矩阵就是高维空间下的一个线性变换。可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。</p>\n<p>总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p>\n<h1 id=\"奇异值分解\"><a href=\"#奇异值分解\" class=\"headerlink\" title=\"奇异值分解\"></a>奇异值分解</h1><p>特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个 $N \\ast  M $的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：</p>\n<p>分解形式：<br><img src=\"/2017/08/18/矩阵的基础概念/矩阵的基础概念-bced7336.png\" alt=\"\"><br>假设A是一个 $M*N$ 的矩阵，那么得到的U是一个$M\\ast M$ 的方阵（称为左奇异向量），$Σ$ 是一个 $M\\ast N$ 的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$ ($V$的转置)是一个 $N\\ast N$ 的矩阵（称为右奇异向量）。</p>\n<h1 id=\"LU分解\"><a href=\"#LU分解\" class=\"headerlink\" title=\"LU分解\"></a>LU分解</h1><p>给定矩阵 $A$，将$A$表示成下三角矩阵L和上三角矩阵U的乘积，称为LU分解</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"零向量\"><a href=\"#零向量\" class=\"headerlink\" title=\"零向量\"></a>零向量</h1><p>变换后落在原点的向量的集合被称为矩阵的‘零空间’或者‘核’。</p>\n<ul>\n<li>零向量一定在列空间中</li>\n<li>对于一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身</li>\n<li>对于一个非满秩的矩阵来说，它将空间压缩到一个更低的维度上，变换后的已给向量落在零向量上，而“零空间”正是这些向量所构成的空间</li>\n</ul>\n<h1 id=\"对角矩阵\"><a href=\"#对角矩阵\" class=\"headerlink\" title=\"对角矩阵\"></a>对角矩阵</h1><p>在方阵中，对角线（从左上到右下）上的值称为对角元素。<br>非对角元素全部为0的矩阵称为对角矩阵。<br>对角矩阵表示的映射是沿着坐标轴伸缩，其中对角元素就是各坐标轴伸缩的倍率</p>\n<h1 id=\"矩阵的秩\"><a href=\"#矩阵的秩\" class=\"headerlink\" title=\"矩阵的秩\"></a>矩阵的秩</h1><p>矩阵的秩，为变换后的空间的维数</p>\n<h1 id=\"单位矩阵\"><a href=\"#单位矩阵\" class=\"headerlink\" title=\"单位矩阵\"></a>单位矩阵</h1><p>方阵中，如果除了对角线（从左上到右下）上的元素为1，其余元素都为0，则该矩阵称为单位矩阵，记为 $I$ 。 $I_{n}$ 表示 $n$ 阶单位矩阵。<strong>单位矩阵表示的映射是“什么都不做”的映射。</strong></p>\n<script type=\"math/tex; mode=display\">I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}</script><h1 id=\"奇异矩阵\"><a href=\"#奇异矩阵\" class=\"headerlink\" title=\"奇异矩阵\"></a>奇异矩阵</h1><p>行列式为零的矩阵</p>\n<h1 id=\"逆矩阵\"><a href=\"#逆矩阵\" class=\"headerlink\" title=\"逆矩阵\"></a>逆矩阵</h1><script type=\"math/tex; mode=display\">AA^{-1}=A^{-1}A=I</script><h1 id=\"零矩阵\"><a href=\"#零矩阵\" class=\"headerlink\" title=\"零矩阵\"></a>零矩阵</h1><p>所有元素都为0的矩阵称为零矩阵，记为 $O$ 。<strong>零矩阵表示的映射是将所有的点都映射到原点的映射</strong></p>\n<h1 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h1><p>线性变换的行列式即线性变换改变面积的比例。</p>\n<script type=\"math/tex; mode=display\">det(M_1M_2) = det(M_1)det(M_2)</script><ul>\n<li>检验一个矩阵的行列式是否为0，就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上</li>\n<li>在三维空间下，行列式可以简单看作这个平行六面体的体积，行列式为0则意味着整个空间被压缩为零体积的东西，也就是一个平面或者一条直线，或者更极端情况下的一个点</li>\n</ul>\n<h1 id=\"特征分解\"><a href=\"#特征分解\" class=\"headerlink\" title=\"特征分解\"></a>特征分解</h1><p>如果说一个向量 $v$ 是方阵 $A$ 的特征向量，将一定可以表示成下面的形式：</p>\n<script type=\"math/tex; mode=display\">Av=\\lambda v</script><p>$\\lambda$ 为特征向量 $v$ 对应的特征值。特征值分解是将一个矩阵分解为如下形式：</p>\n<script type=\"math/tex; mode=display\">A=Q\\Sigma Q^{-1}</script><p>其中， $Q$ 是这个矩阵 $A$ 的特征向量组成的矩阵， $\\Sigma$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说矩阵A的信息可以由其特征值和特征向量表示。</p>\n<p>对于矩阵为高维的情况下，那么这个矩阵就是高维空间下的一个线性变换。可以想象，这个变换也同样有很多的变换方向，我们通过特征值分解得到的前N个特征向量，那么就对应了这个矩阵最主要的N个变化方向。我们利用这前N个变化方向，就可以近似这个矩阵（变换）。</p>\n<p>总结一下，特征值分解可以得到特征值与特征向量，特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么。不过，特征值分解也有很多的局限，比如说变换的矩阵必须是方阵。</p>\n<h1 id=\"奇异值分解\"><a href=\"#奇异值分解\" class=\"headerlink\" title=\"奇异值分解\"></a>奇异值分解</h1><p>特征值分解是一个提取矩阵特征很不错的方法，但是它只是对方阵而言的，在现实的世界中，我们看到的大部分矩阵都不是方阵，比如说有N个学生，每个学生有M科成绩，这样形成的一个 $N \\ast  M $的矩阵就不可能是方阵，我们怎样才能描述这样普通的矩阵呢的重要特征呢？奇异值分解可以用来干这个事情，奇异值分解是一个能适用于任意的矩阵的一种分解的方法：</p>\n<p>分解形式：<br><img src=\"/2017/08/18/矩阵的基础概念/矩阵的基础概念-bced7336.png\" alt=\"\"><br>假设A是一个 $M*N$ 的矩阵，那么得到的U是一个$M\\ast M$ 的方阵（称为左奇异向量），$Σ$ 是一个 $M\\ast N$ 的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$ ($V$的转置)是一个 $N\\ast N$ 的矩阵（称为右奇异向量）。</p>\n<h1 id=\"LU分解\"><a href=\"#LU分解\" class=\"headerlink\" title=\"LU分解\"></a>LU分解</h1><p>给定矩阵 $A$，将$A$表示成下三角矩阵L和上三角矩阵U的乘积，称为LU分解</p>\n"},{"title":"矩阵的逆","date":"2017-08-17T02:54:38.000Z","_content":"# 定义\n\n设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵$A^{-1}$，使得： $AA^{-1}=A^{-1}A=I$。 则我们称$A^{-1}$是A的逆矩阵，而A则被称为可逆矩阵。\n注：单位矩阵\n$$I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}$$\n\n<!--more-->\n\n# 求解\n$$A^{-1}=\\frac{1}{|A|}A^{*}$$\n\n设矩阵$A$为\n$$A=\\begin{bmatrix}\nA_{11} & A_{12} & A_{13}\\\\\nA_{21} & A_{22} & A_{23}\\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}$$\n\n## 伴随矩阵$A^{*}$\n\n### 代数余子式\n\n- $M_{ij}$\n那么第i行，第j列的代数余子式为去掉A第i行，第j列之后的矩阵的行列式，记为$M_{ij}$\n那上面的矩阵A为例子，那么\n$$M_{11}=\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix}$$\n- 代数余子式\n那么代数余子式为$C_{ij}=(-1)^{i+j}M_{ij}$\n\n### 伴随矩阵\n\n矩阵A的伴随矩阵是A的余子矩阵的转置矩阵\n$$A^{*}=\\begin{bmatrix}\nC_{11} & C_{12} & C_{13}\\\\\nC_{21} & C_{22} & C_{23}\\\\\nC_{31} & C_{32} & C_{33}\n\\end{bmatrix}^{T} \\\\\n$$\n$$\\begin{bmatrix}\n(-1)^{(1+1)}\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(1+2)}\\begin{vmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(1+3)}\\begin{vmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(2+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(2+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(2+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(3+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22}\n\\end{vmatrix}\n\\end{bmatrix}^{T}$$\n\n## 求解行列式$|A|$\n\n$$det(A)=|A|=A_{11}det\\left (\\begin{bmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{bmatrix}\\right )-A_{12}det\\left (\\begin{bmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{bmatrix}\\right )+A_{13}det\\left (\\begin{bmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{bmatrix}\\right )\n$$\n","source":"_posts/矩阵的逆.md","raw":"---\ntitle: 矩阵的逆\ndate: 2017-08-17 10:54:38\ntags: [人工智能,线性代数,矩阵]\ncategories: 数学\n---\n# 定义\n\n设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵$A^{-1}$，使得： $AA^{-1}=A^{-1}A=I$。 则我们称$A^{-1}$是A的逆矩阵，而A则被称为可逆矩阵。\n注：单位矩阵\n$$I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}$$\n\n<!--more-->\n\n# 求解\n$$A^{-1}=\\frac{1}{|A|}A^{*}$$\n\n设矩阵$A$为\n$$A=\\begin{bmatrix}\nA_{11} & A_{12} & A_{13}\\\\\nA_{21} & A_{22} & A_{23}\\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}$$\n\n## 伴随矩阵$A^{*}$\n\n### 代数余子式\n\n- $M_{ij}$\n那么第i行，第j列的代数余子式为去掉A第i行，第j列之后的矩阵的行列式，记为$M_{ij}$\n那上面的矩阵A为例子，那么\n$$M_{11}=\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix}$$\n- 代数余子式\n那么代数余子式为$C_{ij}=(-1)^{i+j}M_{ij}$\n\n### 伴随矩阵\n\n矩阵A的伴随矩阵是A的余子矩阵的转置矩阵\n$$A^{*}=\\begin{bmatrix}\nC_{11} & C_{12} & C_{13}\\\\\nC_{21} & C_{22} & C_{23}\\\\\nC_{31} & C_{32} & C_{33}\n\\end{bmatrix}^{T} \\\\\n$$\n$$\\begin{bmatrix}\n(-1)^{(1+1)}\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(1+2)}\\begin{vmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(1+3)}\\begin{vmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(2+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(2+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(2+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(3+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22}\n\\end{vmatrix}\n\\end{bmatrix}^{T}$$\n\n## 求解行列式$|A|$\n\n$$det(A)=|A|=A_{11}det\\left (\\begin{bmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{bmatrix}\\right )-A_{12}det\\left (\\begin{bmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{bmatrix}\\right )+A_{13}det\\left (\\begin{bmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{bmatrix}\\right )\n$$\n","slug":"矩阵的逆","published":1,"updated":"2019-07-30T01:54:38.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j110061homjsg6ha64l","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵$A^{-1}$，使得： $AA^{-1}=A^{-1}A=I$。 则我们称$A^{-1}$是A的逆矩阵，而A则被称为可逆矩阵。<br>注：单位矩阵</p>\n<script type=\"math/tex; mode=display\">I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}</script><a id=\"more\"></a>\n<h1 id=\"求解\"><a href=\"#求解\" class=\"headerlink\" title=\"求解\"></a>求解</h1><script type=\"math/tex; mode=display\">A^{-1}=\\frac{1}{|A|}A^{*}</script><p>设矩阵$A$为</p>\n<script type=\"math/tex; mode=display\">A=\\begin{bmatrix}\nA_{11} & A_{12} & A_{13}\\\\\nA_{21} & A_{22} & A_{23}\\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}</script><h2 id=\"伴随矩阵-A\"><a href=\"#伴随矩阵-A\" class=\"headerlink\" title=\"伴随矩阵$A^{*}$\"></a>伴随矩阵$A^{*}$</h2><h3 id=\"代数余子式\"><a href=\"#代数余子式\" class=\"headerlink\" title=\"代数余子式\"></a>代数余子式</h3><ul>\n<li>$M_{ij}$<br>那么第i行，第j列的代数余子式为去掉A第i行，第j列之后的矩阵的行列式，记为$M_{ij}$<br>那上面的矩阵A为例子，那么<script type=\"math/tex; mode=display\">M_{11}=\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix}</script></li>\n<li>代数余子式<br>那么代数余子式为$C_{ij}=(-1)^{i+j}M_{ij}$</li>\n</ul>\n<h3 id=\"伴随矩阵\"><a href=\"#伴随矩阵\" class=\"headerlink\" title=\"伴随矩阵\"></a>伴随矩阵</h3><p>矩阵A的伴随矩阵是A的余子矩阵的转置矩阵</p>\n<script type=\"math/tex; mode=display\">A^{*}=\\begin{bmatrix}\nC_{11} & C_{12} & C_{13}\\\\\nC_{21} & C_{22} & C_{23}\\\\\nC_{31} & C_{32} & C_{33}\n\\end{bmatrix}^{T} \\\\</script><script type=\"math/tex; mode=display\">\\begin{bmatrix}\n(-1)^{(1+1)}\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(1+2)}\\begin{vmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(1+3)}\\begin{vmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(2+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(2+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(2+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(3+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22}\n\\end{vmatrix}\n\\end{bmatrix}^{T}</script><h2 id=\"求解行列式-A\"><a href=\"#求解行列式-A\" class=\"headerlink\" title=\"求解行列式$|A|$\"></a>求解行列式$|A|$</h2><script type=\"math/tex; mode=display\">det(A)=|A|=A_{11}det\\left (\\begin{bmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{bmatrix}\\right )-A_{12}det\\left (\\begin{bmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{bmatrix}\\right )+A_{13}det\\left (\\begin{bmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{bmatrix}\\right )</script>","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵$A^{-1}$，使得： $AA^{-1}=A^{-1}A=I$。 则我们称$A^{-1}$是A的逆矩阵，而A则被称为可逆矩阵。<br>注：单位矩阵</p>\n<script type=\"math/tex; mode=display\">I_{n}=\\begin{bmatrix}\n1 & 0 & \\cdots  & 0\\\\\n0 & 1 & \\cdots  & 0\\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\n0 & 0 & \\cdots  & 1\n\\end{bmatrix}</script>","more":"<h1 id=\"求解\"><a href=\"#求解\" class=\"headerlink\" title=\"求解\"></a>求解</h1><script type=\"math/tex; mode=display\">A^{-1}=\\frac{1}{|A|}A^{*}</script><p>设矩阵$A$为</p>\n<script type=\"math/tex; mode=display\">A=\\begin{bmatrix}\nA_{11} & A_{12} & A_{13}\\\\\nA_{21} & A_{22} & A_{23}\\\\\nA_{31} & A_{32} & A_{33}\n\\end{bmatrix}</script><h2 id=\"伴随矩阵-A\"><a href=\"#伴随矩阵-A\" class=\"headerlink\" title=\"伴随矩阵$A^{*}$\"></a>伴随矩阵$A^{*}$</h2><h3 id=\"代数余子式\"><a href=\"#代数余子式\" class=\"headerlink\" title=\"代数余子式\"></a>代数余子式</h3><ul>\n<li>$M_{ij}$<br>那么第i行，第j列的代数余子式为去掉A第i行，第j列之后的矩阵的行列式，记为$M_{ij}$<br>那上面的矩阵A为例子，那么<script type=\"math/tex; mode=display\">M_{11}=\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix}</script></li>\n<li>代数余子式<br>那么代数余子式为$C_{ij}=(-1)^{i+j}M_{ij}$</li>\n</ul>\n<h3 id=\"伴随矩阵\"><a href=\"#伴随矩阵\" class=\"headerlink\" title=\"伴随矩阵\"></a>伴随矩阵</h3><p>矩阵A的伴随矩阵是A的余子矩阵的转置矩阵</p>\n<script type=\"math/tex; mode=display\">A^{*}=\\begin{bmatrix}\nC_{11} & C_{12} & C_{13}\\\\\nC_{21} & C_{22} & C_{23}\\\\\nC_{31} & C_{32} & C_{33}\n\\end{bmatrix}^{T} \\\\</script><script type=\"math/tex; mode=display\">\\begin{bmatrix}\n(-1)^{(1+1)}\\begin{vmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(1+2)}\\begin{vmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(1+3)}\\begin{vmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(2+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{32} & A_{33}\n\\end{vmatrix} & (-1)^{(2+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{31} & A_{33}\n\\end{vmatrix} & (-1)^{(2+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{31} & A_{32}\n\\end{vmatrix}\\\\\n(-1)^{(3+1)}\\begin{vmatrix}\nA_{12} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+2)}\\begin{vmatrix}\nA_{11} & A_{13}\\\\\nA_{21} & A_{23}\n\\end{vmatrix} & (-1)^{(3+3)}\\begin{vmatrix}\nA_{11} & A_{12}\\\\\nA_{21} & A_{22}\n\\end{vmatrix}\n\\end{bmatrix}^{T}</script><h2 id=\"求解行列式-A\"><a href=\"#求解行列式-A\" class=\"headerlink\" title=\"求解行列式$|A|$\"></a>求解行列式$|A|$</h2><script type=\"math/tex; mode=display\">det(A)=|A|=A_{11}det\\left (\\begin{bmatrix}\nA_{22} & A_{23}\\\\\nA_{32} & A_{33}\n\\end{bmatrix}\\right )-A_{12}det\\left (\\begin{bmatrix}\nA_{21} & A_{23}\\\\\nA_{31} & A_{33}\n\\end{bmatrix}\\right )+A_{13}det\\left (\\begin{bmatrix}\nA_{21} & A_{22}\\\\\nA_{31} & A_{32}\n\\end{bmatrix}\\right )</script>"},{"title":"积分学","date":"2017-08-14T13:47:31.000Z","_content":"\n# 定义\n令 $f(x)$ 为开区间 $(a,b)$ 上的一个连续函数，对于任何一个正整 数 $n$ 定义,$x_i = a + \\frac{i(b-a)}{n}$ 求和式：\n$$S_n(f) =\\sum_{i=0}^{n-1}f(x_i)(x_{i+1}-x_i)$$\n如果极限 $\\underset{n→∞}{lim}S_n(f)$ 存在, 那么函数 $f(x)$ 在这个区间上的黎曼积分为\n$$\\int_{a}^{b}f(x)dx=\\lim_{n\\rightarrow \\infty }S_n(f)$$\n\n- 代数意义: 无穷求和\n- 几何意义: 函数与 X 轴之间的有向面积\n<!--more-->\n\n# 牛顿-莱布尼茨公式\n如果 $f(x)$ 是定义在闭区间 $[a,b]$ 上的可微函数, 那么就有\n$$\\int_{a}^{b}f'(x)dx=f(b)-f(a)$$\n不定积分表示为\n$$\\int_{a}^{b}f'(x)dx=f(x)+C$$\n\n- 牛顿-莱布尼茨公式展示了微分与积分的基本关系: 在一定程度上微分与积分互为逆运算.\n$$f'(x)=\\frac{df(x)}{dx}\\Rightarrow df(x)=f'(x)dx\\Rightarrow f(x)=\\int df(x)=\\int f'(x)dx$$\n\n## 示例\n函数 $ln(x)$ 的不定积分令 $f(x) = xln(x)−x$，则 $f′(x) = 1·ln(x) + x·\\frac{1}{x} −1 = ln(x)$.根据牛顿 -莱布尼茨公式我们得到\n$$\\int ln(t)dt=\\int f'(t)dt=xln(x)-x+C$$\n\n# 多变量积分\n如果一个函数 $f(x,y)$ 有多个变量，那么在矩形 $[a,b]×[c,d]$ 上 的多重积分可以看成是每一个变量的依次积分\n$$\\int_{c}^{d}\\int_{a}^{b}f(x,y)dxdy$$\n\n- 如果积分区域形状不规则，可以用一个矩形把积分区域包起 来，并令函数在积分区域外边等于 0.\n- 二重积分的几何意义是积分函数与 X −Y 坐标平面之间部 分的有向体积.\n","source":"_posts/积分学.md","raw":"---\ntitle: 积分学\ndate: 2017-08-14 21:47:31\ntags: [人工智能,高数]\ncategories: 数学\n---\n\n# 定义\n令 $f(x)$ 为开区间 $(a,b)$ 上的一个连续函数，对于任何一个正整 数 $n$ 定义,$x_i = a + \\frac{i(b-a)}{n}$ 求和式：\n$$S_n(f) =\\sum_{i=0}^{n-1}f(x_i)(x_{i+1}-x_i)$$\n如果极限 $\\underset{n→∞}{lim}S_n(f)$ 存在, 那么函数 $f(x)$ 在这个区间上的黎曼积分为\n$$\\int_{a}^{b}f(x)dx=\\lim_{n\\rightarrow \\infty }S_n(f)$$\n\n- 代数意义: 无穷求和\n- 几何意义: 函数与 X 轴之间的有向面积\n<!--more-->\n\n# 牛顿-莱布尼茨公式\n如果 $f(x)$ 是定义在闭区间 $[a,b]$ 上的可微函数, 那么就有\n$$\\int_{a}^{b}f'(x)dx=f(b)-f(a)$$\n不定积分表示为\n$$\\int_{a}^{b}f'(x)dx=f(x)+C$$\n\n- 牛顿-莱布尼茨公式展示了微分与积分的基本关系: 在一定程度上微分与积分互为逆运算.\n$$f'(x)=\\frac{df(x)}{dx}\\Rightarrow df(x)=f'(x)dx\\Rightarrow f(x)=\\int df(x)=\\int f'(x)dx$$\n\n## 示例\n函数 $ln(x)$ 的不定积分令 $f(x) = xln(x)−x$，则 $f′(x) = 1·ln(x) + x·\\frac{1}{x} −1 = ln(x)$.根据牛顿 -莱布尼茨公式我们得到\n$$\\int ln(t)dt=\\int f'(t)dt=xln(x)-x+C$$\n\n# 多变量积分\n如果一个函数 $f(x,y)$ 有多个变量，那么在矩形 $[a,b]×[c,d]$ 上 的多重积分可以看成是每一个变量的依次积分\n$$\\int_{c}^{d}\\int_{a}^{b}f(x,y)dxdy$$\n\n- 如果积分区域形状不规则，可以用一个矩形把积分区域包起 来，并令函数在积分区域外边等于 0.\n- 二重积分的几何意义是积分函数与 X −Y 坐标平面之间部 分的有向体积.\n","slug":"积分学","published":1,"updated":"2019-07-30T01:54:38.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j140065homjz3lyvy23","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>令 $f(x)$ 为开区间 $(a,b)$ 上的一个连续函数，对于任何一个正整 数 $n$ 定义,$x_i = a + \\frac{i(b-a)}{n}$ 求和式：</p>\n<script type=\"math/tex; mode=display\">S_n(f) =\\sum_{i=0}^{n-1}f(x_i)(x_{i+1}-x_i)</script><p>如果极限 $\\underset{n→∞}{lim}S_n(f)$ 存在, 那么函数 $f(x)$ 在这个区间上的黎曼积分为</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f(x)dx=\\lim_{n\\rightarrow \\infty }S_n(f)</script><ul>\n<li>代数意义: 无穷求和</li>\n<li>几何意义: 函数与 X 轴之间的有向面积<a id=\"more\"></a>\n</li>\n</ul>\n<h1 id=\"牛顿-莱布尼茨公式\"><a href=\"#牛顿-莱布尼茨公式\" class=\"headerlink\" title=\"牛顿-莱布尼茨公式\"></a>牛顿-莱布尼茨公式</h1><p>如果 $f(x)$ 是定义在闭区间 $[a,b]$ 上的可微函数, 那么就有</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f'(x)dx=f(b)-f(a)</script><p>不定积分表示为</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f'(x)dx=f(x)+C</script><ul>\n<li>牛顿-莱布尼茨公式展示了微分与积分的基本关系: 在一定程度上微分与积分互为逆运算.<script type=\"math/tex; mode=display\">f'(x)=\\frac{df(x)}{dx}\\Rightarrow df(x)=f'(x)dx\\Rightarrow f(x)=\\int df(x)=\\int f'(x)dx</script></li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>函数 $ln(x)$ 的不定积分令 $f(x) = xln(x)−x$，则 $f′(x) = 1·ln(x) + x·\\frac{1}{x} −1 = ln(x)$.根据牛顿 -莱布尼茨公式我们得到</p>\n<script type=\"math/tex; mode=display\">\\int ln(t)dt=\\int f'(t)dt=xln(x)-x+C</script><h1 id=\"多变量积分\"><a href=\"#多变量积分\" class=\"headerlink\" title=\"多变量积分\"></a>多变量积分</h1><p>如果一个函数 $f(x,y)$ 有多个变量，那么在矩形 $[a,b]×[c,d]$ 上 的多重积分可以看成是每一个变量的依次积分</p>\n<script type=\"math/tex; mode=display\">\\int_{c}^{d}\\int_{a}^{b}f(x,y)dxdy</script><ul>\n<li>如果积分区域形状不规则，可以用一个矩形把积分区域包起 来，并令函数在积分区域外边等于 0.</li>\n<li>二重积分的几何意义是积分函数与 X −Y 坐标平面之间部 分的有向体积.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>令 $f(x)$ 为开区间 $(a,b)$ 上的一个连续函数，对于任何一个正整 数 $n$ 定义,$x_i = a + \\frac{i(b-a)}{n}$ 求和式：</p>\n<script type=\"math/tex; mode=display\">S_n(f) =\\sum_{i=0}^{n-1}f(x_i)(x_{i+1}-x_i)</script><p>如果极限 $\\underset{n→∞}{lim}S_n(f)$ 存在, 那么函数 $f(x)$ 在这个区间上的黎曼积分为</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f(x)dx=\\lim_{n\\rightarrow \\infty }S_n(f)</script><ul>\n<li>代数意义: 无穷求和</li>\n<li>几何意义: 函数与 X 轴之间的有向面积</li></ul>","more":"\n\n<h1 id=\"牛顿-莱布尼茨公式\"><a href=\"#牛顿-莱布尼茨公式\" class=\"headerlink\" title=\"牛顿-莱布尼茨公式\"></a>牛顿-莱布尼茨公式</h1><p>如果 $f(x)$ 是定义在闭区间 $[a,b]$ 上的可微函数, 那么就有</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f'(x)dx=f(b)-f(a)</script><p>不定积分表示为</p>\n<script type=\"math/tex; mode=display\">\\int_{a}^{b}f'(x)dx=f(x)+C</script><ul>\n<li>牛顿-莱布尼茨公式展示了微分与积分的基本关系: 在一定程度上微分与积分互为逆运算.<script type=\"math/tex; mode=display\">f'(x)=\\frac{df(x)}{dx}\\Rightarrow df(x)=f'(x)dx\\Rightarrow f(x)=\\int df(x)=\\int f'(x)dx</script></li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>函数 $ln(x)$ 的不定积分令 $f(x) = xln(x)−x$，则 $f′(x) = 1·ln(x) + x·\\frac{1}{x} −1 = ln(x)$.根据牛顿 -莱布尼茨公式我们得到</p>\n<script type=\"math/tex; mode=display\">\\int ln(t)dt=\\int f'(t)dt=xln(x)-x+C</script><h1 id=\"多变量积分\"><a href=\"#多变量积分\" class=\"headerlink\" title=\"多变量积分\"></a>多变量积分</h1><p>如果一个函数 $f(x,y)$ 有多个变量，那么在矩形 $[a,b]×[c,d]$ 上 的多重积分可以看成是每一个变量的依次积分</p>\n<script type=\"math/tex; mode=display\">\\int_{c}^{d}\\int_{a}^{b}f(x,y)dxdy</script><ul>\n<li>如果积分区域形状不规则，可以用一个矩形把积分区域包起 来，并令函数在积分区域外边等于 0.</li>\n<li>二重积分的几何意义是积分函数与 X −Y 坐标平面之间部 分的有向体积.</li>\n</ul>"},{"title":"线性代数基础","date":"2017-08-17T06:23:52.000Z","_content":"\n# 标量，向量，矩阵和张量\n**标量（scalar）**：一个标量就是一个单独的数。用斜体表示标量，如 $s∈R$.\n\n**向量（vector）**：一个向量是一列数，我们用粗体的小写名称表示向量。比如 $x$，将向量x 写成方括号包含的纵柱：\n$${\\bf x}=  \\begin {bmatrix} x_1\\\\x_2\\\\ \\vdots \\\\x_n\\\\ \\end{bmatrix}$$\n\n**矩阵（matrix）**：矩阵是二维数组，我们通常赋予矩阵粗体大写变量名称，比如 $A​$ 。如果一个矩阵高度是 $m​$，宽度是 $n$​，那么说 $\\bf A\\in \\bf R ^{m \\times n}​$​ 。一个矩阵可以表示如下：\n$${\\bf A}= \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\  \\end{bmatrix}$$\n\n**张量（tensor）**：某些情况下，我们会讨论不止维坐标的数组。如果一组数组中的元素分布在若干维坐标的规则网络中，就将其称为张量。用 $A$​ 表示，如张量中坐标为 $(i,j,k)$ ​的元素记作 $A_{i,j,k}$ ​。\n**转置（transpose）**：矩阵的转置是以对角线为轴的镜像，这条从左上角到右下角的对角线称为主对角线（main diagonal）。将矩阵 $A$ 的转置表示为 $A^⊤$ 。定义如下：\n$$({\\bf A^\\top})_{i,j}=\\bf A_{j,i}$$\n$${\\bf A} = \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\ x_{31} & x_{32} \\end{bmatrix} \\implies {\\bf A^\\top}= \\begin{bmatrix} x_{11} &x_{21}&x_{31} \\\\ x_{21} & x_{22}& x_{32} \\end{bmatrix}$$\n\n<!--more-->\n\n# 向量运算\n\n## 加法\n\n设 $\\overrightarrow{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，$\\overrightarrow{w}=\\begin{bmatrix}3\\\\ -1\\end{bmatrix}$则$ \\overrightarrow{v}+\\overrightarrow{w}=\\begin{bmatrix}4\\\\ 1\\end{bmatrix}$\n\n## 数乘\n\n设 $\\overrightarrow{v}=\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}$，则$2\\overrightarrow{v}=\\begin{bmatrix} 3\\times 2 \\\\ 1\\times 2 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$\n\n## 矩阵-向量的乘积\n\n矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。\n\n$$A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}$$\n\n![](线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif)\n![](线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif)\n\n## 向量-向量的乘积\n\n向量可以看成一个矩阵，这个矩阵将空间压缩到了一维空间。\n$$\\overrightarrow{w}\\cdot \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|cos\\theta =\\begin{bmatrix}\n1\\\\\n-2\n\\end{bmatrix}\\cdot\\begin{bmatrix}\n4\\\\\n3\n\\end{bmatrix}=4\\times 1+3\\times (-2)=-2$$\n\n<font color=red>向量$\\overrightarrow{v}$在向量$\\overrightarrow{w}$上的投影乘以向量$\\overrightarrow{w}$的长度</font>\n\n![点积](线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif)\n\n## 向量的叉积\n向量的叉积是一个向量，向量 $\\overrightarrow{p}$ 的方向垂直于 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 的平面，向量 $\\overrightarrow{p}$ 的模是 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 所围成平面的面积(行列式)。\n\n$$\\overrightarrow{w}\\times  \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|sin\\theta =\\overrightarrow{p}$$\n\n![点积](线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg)\n\n### 高维情况\n\n$\\overrightarrow{w}\\times  \\overrightarrow{v}=\\overrightarrow{p}$则\n$$\\begin{align*}\np_1 &=v_2\\cdot w_3-v_3\\cdot w_2 \\\\\np_2 &=v_3\\cdot w_1-v_1\\cdot w_3  \\\\\np_3 &=v_1\\cdot w_2-v_2\\cdot w_1\n\\end{align*}$$\n\n![行列式](线性代数基础/5fed7bb9f99639d6299756bba298111b.gif)\n\n# 矩阵的运算\n对向量的线性空间变换\n\n## 矩阵加减法\n对应位置的元素相加相减\n![](线性代数基础/线性代数基础-fb168ecc.png)\n\n## 矩阵数乘\n![](线性代数基础/线性代数基础-c1b237dd.png)\n\n## 矩阵转置\n把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵\n![](线性代数基础/线性代数基础-20a01623.png)\n\n## 矩阵共轭\n\n![](线性代数基础/线性代数基础-76c02b4b.png)\n\n## 矩阵共轭转置\n\n![](线性代数基础/线性代数基础-93e8ff75.png)\n\n## 矩阵-向量的乘积\n矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。\n$$A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}$$\n\n![](线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif)\n![](线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif)\n\n## 矩阵-矩阵的乘积\n矩阵是一种线性变换，矩阵与矩阵相乘便是将空间进行线性变换之后再次进行线性变换。矩阵与矩阵的乘积是一种对于空间的复合线性变换。变换吸纳从右侧开始一次向左侧进行变换。线性变换的过程如下图所示：\n\n![](线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif)\n\n矩阵-矩阵的计算过程如下所示$$\\begin{bmatrix}\n0 & 2\\\\\n1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n1 & -2\\\\\n1 & 0\n\\end{bmatrix}=\\left\\{\\begin{matrix}1\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+1\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix} \\\\-2\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+0\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix}\\end{matrix}\\right.=\\begin{bmatrix}\n2 &0 \\\\\n1 & -2\n\\end{bmatrix}$$\n计算过程去下图所示\n\n![](线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif)\n\n### 矩阵-矩阵乘积的性质\n- 结合律即 $(AB)C = A(BC)$\n- 分配率即 $A(B + C) = AB + AC$\n- 注意哦，矩阵乘法没有交换律，即 $AB ≠BA$\n\n\n## [矩阵的逆](/2017/08/17/矩阵的逆)\n矩阵$A ∈ R^{n×n}$的逆,写作$A^{−1}$，是一个矩阵，并且是唯一的。是对矩阵$A$空间操作的逆变换。同时$AA^{−1}$也可以理解为矩阵$A$除以矩阵$A$ 等于单位矩阵$I$，$$A^{−1}A = I = AA^{−1}.$$\n\n![](线性代数基础/8d40107d18c971c5999be6beb599d618.gif)\n\n注意不是所有的矩阵都有逆。**例如非方阵，是没有逆的。然而，即便对于一些方阵，它仍有可能不存在逆。如果$A^{−1}$存在，我们称矩阵$A$ 是可逆的或非奇异的，如果不存在，则称矩阵$A$不可逆或奇异。如果一个方阵$A$有逆$A^{−1}$，它必须满秩**\n\n\n## 矩阵的秩\n\n**矩阵的秩实际上的经过矩阵操作后空间的维数**。在矩阵A中，非零子式的最高阶数称为矩阵A的秩，记为或秩。规定零矩阵的秩为零。\n\n\n### 求解思路\n\n$矩阵A\\xrightarrow{初等行变换}阶梯形矩阵B。$则$r(A)=r(B)=$($B$中非零行的行数)\n- 例子\n-\n求矩阵$$A=\\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}$$的秩。\n\n解：\n$$A= \\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &-9 &6  & -6\\\\\n0 &6  &-6 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &3 &-2  &2\\\\\n0 &0  &-0 & 0\n\\end{bmatrix}$$\n\n因此$r(A)=2$\n## 矩阵的迹\n方阵$A ∈ R^{n×n}$的迹，记作$tr(A)$，或可以省略括号表示成$trA$，是矩阵的对角线元素之和:$$trA=\\sum_{i=1}^{n}A_{ii}$$\n\n- 性质\n 1. 对于$A ∈ R^{n×n}， trA = trA^T .$\n 1. 对于$A，B ∈ R^{n×n}， tr(A + B) = trA + trB.$\n 1. 对于$A ∈ R^{n×n}， t ∈ R， tr(t\\ast A) = t\\ast trA.$\n 1.对于方阵 $A,B,C，trABC = trBCA = trCAB$，即使有更多的矩阵相乘，这个性质也不变.\n\n## 正交矩阵\n如果$x^Ty = 0$，则两个向量 $x，y ∈ R^n$是正交的。对于一个向量$x ∈ R^n$，如果 $|x|=1$ 则是 $x$ 归一化的。<font color=red>对于一个方阵$U ∈ R^{n×n}$，如果所有列都是彼此正交和归一化的，（列就称为标准正交）则这个方阵是正交的（注意在讨论向量或矩阵时，正交具有不同的含义）。</font> 根据正交和归一化的定义可得：\n\n$$U^T U = I = UU^T$$\n\n<font color=red>一个正交矩阵的逆矩阵的是它转置,正交矩阵必须是方阵</font>\n","source":"_posts/线性代数基础.md","raw":"---\ntitle: 线性代数基础\ndate: 2017-08-17 14:23:52\ntags: [人工智能,线性代数,向量,矩阵]\ncategories: 数学\n---\n\n# 标量，向量，矩阵和张量\n**标量（scalar）**：一个标量就是一个单独的数。用斜体表示标量，如 $s∈R$.\n\n**向量（vector）**：一个向量是一列数，我们用粗体的小写名称表示向量。比如 $x$，将向量x 写成方括号包含的纵柱：\n$${\\bf x}=  \\begin {bmatrix} x_1\\\\x_2\\\\ \\vdots \\\\x_n\\\\ \\end{bmatrix}$$\n\n**矩阵（matrix）**：矩阵是二维数组，我们通常赋予矩阵粗体大写变量名称，比如 $A​$ 。如果一个矩阵高度是 $m​$，宽度是 $n$​，那么说 $\\bf A\\in \\bf R ^{m \\times n}​$​ 。一个矩阵可以表示如下：\n$${\\bf A}= \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\  \\end{bmatrix}$$\n\n**张量（tensor）**：某些情况下，我们会讨论不止维坐标的数组。如果一组数组中的元素分布在若干维坐标的规则网络中，就将其称为张量。用 $A$​ 表示，如张量中坐标为 $(i,j,k)$ ​的元素记作 $A_{i,j,k}$ ​。\n**转置（transpose）**：矩阵的转置是以对角线为轴的镜像，这条从左上角到右下角的对角线称为主对角线（main diagonal）。将矩阵 $A$ 的转置表示为 $A^⊤$ 。定义如下：\n$$({\\bf A^\\top})_{i,j}=\\bf A_{j,i}$$\n$${\\bf A} = \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\ x_{31} & x_{32} \\end{bmatrix} \\implies {\\bf A^\\top}= \\begin{bmatrix} x_{11} &x_{21}&x_{31} \\\\ x_{21} & x_{22}& x_{32} \\end{bmatrix}$$\n\n<!--more-->\n\n# 向量运算\n\n## 加法\n\n设 $\\overrightarrow{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，$\\overrightarrow{w}=\\begin{bmatrix}3\\\\ -1\\end{bmatrix}$则$ \\overrightarrow{v}+\\overrightarrow{w}=\\begin{bmatrix}4\\\\ 1\\end{bmatrix}$\n\n## 数乘\n\n设 $\\overrightarrow{v}=\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}$，则$2\\overrightarrow{v}=\\begin{bmatrix} 3\\times 2 \\\\ 1\\times 2 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$\n\n## 矩阵-向量的乘积\n\n矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。\n\n$$A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}$$\n\n![](线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif)\n![](线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif)\n\n## 向量-向量的乘积\n\n向量可以看成一个矩阵，这个矩阵将空间压缩到了一维空间。\n$$\\overrightarrow{w}\\cdot \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|cos\\theta =\\begin{bmatrix}\n1\\\\\n-2\n\\end{bmatrix}\\cdot\\begin{bmatrix}\n4\\\\\n3\n\\end{bmatrix}=4\\times 1+3\\times (-2)=-2$$\n\n<font color=red>向量$\\overrightarrow{v}$在向量$\\overrightarrow{w}$上的投影乘以向量$\\overrightarrow{w}$的长度</font>\n\n![点积](线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif)\n\n## 向量的叉积\n向量的叉积是一个向量，向量 $\\overrightarrow{p}$ 的方向垂直于 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 的平面，向量 $\\overrightarrow{p}$ 的模是 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 所围成平面的面积(行列式)。\n\n$$\\overrightarrow{w}\\times  \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|sin\\theta =\\overrightarrow{p}$$\n\n![点积](线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg)\n\n### 高维情况\n\n$\\overrightarrow{w}\\times  \\overrightarrow{v}=\\overrightarrow{p}$则\n$$\\begin{align*}\np_1 &=v_2\\cdot w_3-v_3\\cdot w_2 \\\\\np_2 &=v_3\\cdot w_1-v_1\\cdot w_3  \\\\\np_3 &=v_1\\cdot w_2-v_2\\cdot w_1\n\\end{align*}$$\n\n![行列式](线性代数基础/5fed7bb9f99639d6299756bba298111b.gif)\n\n# 矩阵的运算\n对向量的线性空间变换\n\n## 矩阵加减法\n对应位置的元素相加相减\n![](线性代数基础/线性代数基础-fb168ecc.png)\n\n## 矩阵数乘\n![](线性代数基础/线性代数基础-c1b237dd.png)\n\n## 矩阵转置\n把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵\n![](线性代数基础/线性代数基础-20a01623.png)\n\n## 矩阵共轭\n\n![](线性代数基础/线性代数基础-76c02b4b.png)\n\n## 矩阵共轭转置\n\n![](线性代数基础/线性代数基础-93e8ff75.png)\n\n## 矩阵-向量的乘积\n矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。\n$$A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}$$\n\n![](线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif)\n![](线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif)\n\n## 矩阵-矩阵的乘积\n矩阵是一种线性变换，矩阵与矩阵相乘便是将空间进行线性变换之后再次进行线性变换。矩阵与矩阵的乘积是一种对于空间的复合线性变换。变换吸纳从右侧开始一次向左侧进行变换。线性变换的过程如下图所示：\n\n![](线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif)\n\n矩阵-矩阵的计算过程如下所示$$\\begin{bmatrix}\n0 & 2\\\\\n1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n1 & -2\\\\\n1 & 0\n\\end{bmatrix}=\\left\\{\\begin{matrix}1\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+1\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix} \\\\-2\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+0\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix}\\end{matrix}\\right.=\\begin{bmatrix}\n2 &0 \\\\\n1 & -2\n\\end{bmatrix}$$\n计算过程去下图所示\n\n![](线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif)\n\n### 矩阵-矩阵乘积的性质\n- 结合律即 $(AB)C = A(BC)$\n- 分配率即 $A(B + C) = AB + AC$\n- 注意哦，矩阵乘法没有交换律，即 $AB ≠BA$\n\n\n## [矩阵的逆](/2017/08/17/矩阵的逆)\n矩阵$A ∈ R^{n×n}$的逆,写作$A^{−1}$，是一个矩阵，并且是唯一的。是对矩阵$A$空间操作的逆变换。同时$AA^{−1}$也可以理解为矩阵$A$除以矩阵$A$ 等于单位矩阵$I$，$$A^{−1}A = I = AA^{−1}.$$\n\n![](线性代数基础/8d40107d18c971c5999be6beb599d618.gif)\n\n注意不是所有的矩阵都有逆。**例如非方阵，是没有逆的。然而，即便对于一些方阵，它仍有可能不存在逆。如果$A^{−1}$存在，我们称矩阵$A$ 是可逆的或非奇异的，如果不存在，则称矩阵$A$不可逆或奇异。如果一个方阵$A$有逆$A^{−1}$，它必须满秩**\n\n\n## 矩阵的秩\n\n**矩阵的秩实际上的经过矩阵操作后空间的维数**。在矩阵A中，非零子式的最高阶数称为矩阵A的秩，记为或秩。规定零矩阵的秩为零。\n\n\n### 求解思路\n\n$矩阵A\\xrightarrow{初等行变换}阶梯形矩阵B。$则$r(A)=r(B)=$($B$中非零行的行数)\n- 例子\n-\n求矩阵$$A=\\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}$$的秩。\n\n解：\n$$A= \\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &-9 &6  & -6\\\\\n0 &6  &-6 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &3 &-2  &2\\\\\n0 &0  &-0 & 0\n\\end{bmatrix}$$\n\n因此$r(A)=2$\n## 矩阵的迹\n方阵$A ∈ R^{n×n}$的迹，记作$tr(A)$，或可以省略括号表示成$trA$，是矩阵的对角线元素之和:$$trA=\\sum_{i=1}^{n}A_{ii}$$\n\n- 性质\n 1. 对于$A ∈ R^{n×n}， trA = trA^T .$\n 1. 对于$A，B ∈ R^{n×n}， tr(A + B) = trA + trB.$\n 1. 对于$A ∈ R^{n×n}， t ∈ R， tr(t\\ast A) = t\\ast trA.$\n 1.对于方阵 $A,B,C，trABC = trBCA = trCAB$，即使有更多的矩阵相乘，这个性质也不变.\n\n## 正交矩阵\n如果$x^Ty = 0$，则两个向量 $x，y ∈ R^n$是正交的。对于一个向量$x ∈ R^n$，如果 $|x|=1$ 则是 $x$ 归一化的。<font color=red>对于一个方阵$U ∈ R^{n×n}$，如果所有列都是彼此正交和归一化的，（列就称为标准正交）则这个方阵是正交的（注意在讨论向量或矩阵时，正交具有不同的含义）。</font> 根据正交和归一化的定义可得：\n\n$$U^T U = I = UU^T$$\n\n<font color=red>一个正交矩阵的逆矩阵的是它转置,正交矩阵必须是方阵</font>\n","slug":"线性代数基础","published":1,"updated":"2019-07-30T01:54:38.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j160068homj01i8dhh1","content":"<h1 id=\"标量，向量，矩阵和张量\"><a href=\"#标量，向量，矩阵和张量\" class=\"headerlink\" title=\"标量，向量，矩阵和张量\"></a>标量，向量，矩阵和张量</h1><p><strong>标量（scalar）</strong>：一个标量就是一个单独的数。用斜体表示标量，如 $s∈R$.</p>\n<p><strong>向量（vector）</strong>：一个向量是一列数，我们用粗体的小写名称表示向量。比如 $x$，将向量x 写成方括号包含的纵柱：</p>\n<script type=\"math/tex; mode=display\">{\\bf x}=  \\begin {bmatrix} x_1\\\\x_2\\\\ \\vdots \\\\x_n\\\\ \\end{bmatrix}</script><p><strong>矩阵（matrix）</strong>：矩阵是二维数组，我们通常赋予矩阵粗体大写变量名称，比如 $A​$ 。如果一个矩阵高度是 $m​$，宽度是 $n$​，那么说 $\\bf A\\in \\bf R ^{m \\times n}​$​ 。一个矩阵可以表示如下：</p>\n<script type=\"math/tex; mode=display\">{\\bf A}= \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\  \\end{bmatrix}</script><p><strong>张量（tensor）</strong>：某些情况下，我们会讨论不止维坐标的数组。如果一组数组中的元素分布在若干维坐标的规则网络中，就将其称为张量。用 $A$​ 表示，如张量中坐标为 $(i,j,k)$ ​的元素记作 $A_{i,j,k}$ ​。<br><strong>转置（transpose）</strong>：矩阵的转置是以对角线为轴的镜像，这条从左上角到右下角的对角线称为主对角线（main diagonal）。将矩阵 $A$ 的转置表示为 $A^⊤$ 。定义如下：</p>\n<script type=\"math/tex; mode=display\">({\\bf A^\\top})_{i,j}=\\bf A_{j,i}</script><script type=\"math/tex; mode=display\">{\\bf A} = \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\ x_{31} & x_{32} \\end{bmatrix} \\implies {\\bf A^\\top}= \\begin{bmatrix} x_{11} &x_{21}&x_{31} \\\\ x_{21} & x_{22}& x_{32} \\end{bmatrix}</script><a id=\"more\"></a>\n<h1 id=\"向量运算\"><a href=\"#向量运算\" class=\"headerlink\" title=\"向量运算\"></a>向量运算</h1><h2 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h2><p>设 $\\overrightarrow{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，$\\overrightarrow{w}=\\begin{bmatrix}3\\\\ -1\\end{bmatrix}$则$ \\overrightarrow{v}+\\overrightarrow{w}=\\begin{bmatrix}4\\\\ 1\\end{bmatrix}$</p>\n<h2 id=\"数乘\"><a href=\"#数乘\" class=\"headerlink\" title=\"数乘\"></a>数乘</h2><p>设 $\\overrightarrow{v}=\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}$，则$2\\overrightarrow{v}=\\begin{bmatrix} 3\\times 2 \\\\ 1\\times 2 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$</p>\n<h2 id=\"矩阵-向量的乘积\"><a href=\"#矩阵-向量的乘积\" class=\"headerlink\" title=\"矩阵-向量的乘积\"></a>矩阵-向量的乘积</h2><p>矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。</p>\n<script type=\"math/tex; mode=display\">A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}</script><p><img src=\"/2017/08/17/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif\" alt=\"\"><br><img src=\"/2017/08/17/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif\" alt=\"\"></p>\n<h2 id=\"向量-向量的乘积\"><a href=\"#向量-向量的乘积\" class=\"headerlink\" title=\"向量-向量的乘积\"></a>向量-向量的乘积</h2><p>向量可以看成一个矩阵，这个矩阵将空间压缩到了一维空间。</p>\n<script type=\"math/tex; mode=display\">\\overrightarrow{w}\\cdot \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|cos\\theta =\\begin{bmatrix}\n1\\\\\n-2\n\\end{bmatrix}\\cdot\\begin{bmatrix}\n4\\\\\n3\n\\end{bmatrix}=4\\times 1+3\\times (-2)=-2</script><font color=\"red\">向量$\\overrightarrow{v}$在向量$\\overrightarrow{w}$上的投影乘以向量$\\overrightarrow{w}$的长度</font>\n\n<p><img src=\"/2017/08/17/线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif\" alt=\"点积\"></p>\n<h2 id=\"向量的叉积\"><a href=\"#向量的叉积\" class=\"headerlink\" title=\"向量的叉积\"></a>向量的叉积</h2><p>向量的叉积是一个向量，向量 $\\overrightarrow{p}$ 的方向垂直于 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 的平面，向量 $\\overrightarrow{p}$ 的模是 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 所围成平面的面积(行列式)。</p>\n<script type=\"math/tex; mode=display\">\\overrightarrow{w}\\times  \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|sin\\theta =\\overrightarrow{p}</script><p><img src=\"/2017/08/17/线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg\" alt=\"点积\"></p>\n<h3 id=\"高维情况\"><a href=\"#高维情况\" class=\"headerlink\" title=\"高维情况\"></a>高维情况</h3><p>$\\overrightarrow{w}\\times  \\overrightarrow{v}=\\overrightarrow{p}$则</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_1 &=v_2\\cdot w_3-v_3\\cdot w_2 \\\\\np_2 &=v_3\\cdot w_1-v_1\\cdot w_3  \\\\\np_3 &=v_1\\cdot w_2-v_2\\cdot w_1\n\\end{align*}</script><p><img src=\"/2017/08/17/线性代数基础/5fed7bb9f99639d6299756bba298111b.gif\" alt=\"行列式\"></p>\n<h1 id=\"矩阵的运算\"><a href=\"#矩阵的运算\" class=\"headerlink\" title=\"矩阵的运算\"></a>矩阵的运算</h1><p>对向量的线性空间变换</p>\n<h2 id=\"矩阵加减法\"><a href=\"#矩阵加减法\" class=\"headerlink\" title=\"矩阵加减法\"></a>矩阵加减法</h2><p>对应位置的元素相加相减<br><img src=\"/2017/08/17/线性代数基础/线性代数基础-fb168ecc.png\" alt=\"\"></p>\n<h2 id=\"矩阵数乘\"><a href=\"#矩阵数乘\" class=\"headerlink\" title=\"矩阵数乘\"></a>矩阵数乘</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-c1b237dd.png\" alt=\"\"></p>\n<h2 id=\"矩阵转置\"><a href=\"#矩阵转置\" class=\"headerlink\" title=\"矩阵转置\"></a>矩阵转置</h2><p>把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵<br><img src=\"/2017/08/17/线性代数基础/线性代数基础-20a01623.png\" alt=\"\"></p>\n<h2 id=\"矩阵共轭\"><a href=\"#矩阵共轭\" class=\"headerlink\" title=\"矩阵共轭\"></a>矩阵共轭</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-76c02b4b.png\" alt=\"\"></p>\n<h2 id=\"矩阵共轭转置\"><a href=\"#矩阵共轭转置\" class=\"headerlink\" title=\"矩阵共轭转置\"></a>矩阵共轭转置</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-93e8ff75.png\" alt=\"\"></p>\n<h2 id=\"矩阵-向量的乘积-1\"><a href=\"#矩阵-向量的乘积-1\" class=\"headerlink\" title=\"矩阵-向量的乘积\"></a>矩阵-向量的乘积</h2><p>矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。</p>\n<script type=\"math/tex; mode=display\">A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}</script><p><img src=\"/2017/08/17/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif\" alt=\"\"><br><img src=\"/2017/08/17/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif\" alt=\"\"></p>\n<h2 id=\"矩阵-矩阵的乘积\"><a href=\"#矩阵-矩阵的乘积\" class=\"headerlink\" title=\"矩阵-矩阵的乘积\"></a>矩阵-矩阵的乘积</h2><p>矩阵是一种线性变换，矩阵与矩阵相乘便是将空间进行线性变换之后再次进行线性变换。矩阵与矩阵的乘积是一种对于空间的复合线性变换。变换吸纳从右侧开始一次向左侧进行变换。线性变换的过程如下图所示：</p>\n<p><img src=\"/2017/08/17/线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif\" alt=\"\"></p>\n<p>矩阵-矩阵的计算过程如下所示<script type=\"math/tex\">\\begin{bmatrix}\n0 & 2\\\\\n1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n1 & -2\\\\\n1 & 0\n\\end{bmatrix}=\\left\\{\\begin{matrix}1\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+1\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix} \\\\-2\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+0\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix}\\end{matrix}\\right.=\\begin{bmatrix}\n2 &0 \\\\\n1 & -2\n\\end{bmatrix}</script><br>计算过程去下图所示</p>\n<p><img src=\"/2017/08/17/线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif\" alt=\"\"></p>\n<h3 id=\"矩阵-矩阵乘积的性质\"><a href=\"#矩阵-矩阵乘积的性质\" class=\"headerlink\" title=\"矩阵-矩阵乘积的性质\"></a>矩阵-矩阵乘积的性质</h3><ul>\n<li>结合律即 $(AB)C = A(BC)$</li>\n<li>分配率即 $A(B + C) = AB + AC$</li>\n<li>注意哦，矩阵乘法没有交换律，即 $AB ≠BA$</li>\n</ul>\n<h2 id=\"矩阵的逆\"><a href=\"#矩阵的逆\" class=\"headerlink\" title=\"矩阵的逆\"></a><a href=\"/2017/08/17/矩阵的逆\">矩阵的逆</a></h2><p>矩阵$A ∈ R^{n×n}$的逆,写作$A^{−1}$，是一个矩阵，并且是唯一的。是对矩阵$A$空间操作的逆变换。同时$AA^{−1}$也可以理解为矩阵$A$除以矩阵$A$ 等于单位矩阵$I$，<script type=\"math/tex\">A^{−1}A = I = AA^{−1}.</script></p>\n<p><img src=\"/2017/08/17/线性代数基础/8d40107d18c971c5999be6beb599d618.gif\" alt=\"\"></p>\n<p>注意不是所有的矩阵都有逆。<strong>例如非方阵，是没有逆的。然而，即便对于一些方阵，它仍有可能不存在逆。如果$A^{−1}$存在，我们称矩阵$A$ 是可逆的或非奇异的，如果不存在，则称矩阵$A$不可逆或奇异。如果一个方阵$A$有逆$A^{−1}$，它必须满秩</strong></p>\n<h2 id=\"矩阵的秩\"><a href=\"#矩阵的秩\" class=\"headerlink\" title=\"矩阵的秩\"></a>矩阵的秩</h2><p><strong>矩阵的秩实际上的经过矩阵操作后空间的维数</strong>。在矩阵A中，非零子式的最高阶数称为矩阵A的秩，记为或秩。规定零矩阵的秩为零。</p>\n<h3 id=\"求解思路\"><a href=\"#求解思路\" class=\"headerlink\" title=\"求解思路\"></a>求解思路</h3><p>$矩阵A\\xrightarrow{初等行变换}阶梯形矩阵B。$则$r(A)=r(B)=$($B$中非零行的行数)</p>\n<ul>\n<li>例子<br>-<br>求矩阵<script type=\"math/tex\">A=\\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}</script>的秩。</li>\n</ul>\n<p>解：</p>\n<script type=\"math/tex; mode=display\">A= \\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &-9 &6  & -6\\\\\n0 &6  &-6 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &3 &-2  &2\\\\\n0 &0  &-0 & 0\n\\end{bmatrix}</script><p>因此$r(A)=2$</p>\n<h2 id=\"矩阵的迹\"><a href=\"#矩阵的迹\" class=\"headerlink\" title=\"矩阵的迹\"></a>矩阵的迹</h2><p>方阵$A ∈ R^{n×n}$的迹，记作$tr(A)$，或可以省略括号表示成$trA$，是矩阵的对角线元素之和:<script type=\"math/tex\">trA=\\sum_{i=1}^{n}A_{ii}</script></p>\n<ul>\n<li>性质<ol>\n<li>对于$A ∈ R^{n×n}， trA = trA^T .$</li>\n<li>对于$A，B ∈ R^{n×n}， tr(A + B) = trA + trB.$</li>\n<li>对于$A ∈ R^{n×n}， t ∈ R， tr(t\\ast A) = t\\ast trA.$<br>1.对于方阵 $A,B,C，trABC = trBCA = trCAB$，即使有更多的矩阵相乘，这个性质也不变.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"正交矩阵\"><a href=\"#正交矩阵\" class=\"headerlink\" title=\"正交矩阵\"></a>正交矩阵</h2><p>如果$x^Ty = 0$，则两个向量 $x，y ∈ R^n$是正交的。对于一个向量$x ∈ R^n$，如果 $|x|=1$ 则是 $x$ 归一化的。<font color=\"red\">对于一个方阵$U ∈ R^{n×n}$，如果所有列都是彼此正交和归一化的，（列就称为标准正交）则这个方阵是正交的（注意在讨论向量或矩阵时，正交具有不同的含义）。</font> 根据正交和归一化的定义可得：</p>\n<script type=\"math/tex; mode=display\">U^T U = I = UU^T</script><font color=\"red\">一个正交矩阵的逆矩阵的是它转置,正交矩阵必须是方阵</font>\n","site":{"data":{}},"excerpt":"<h1 id=\"标量，向量，矩阵和张量\"><a href=\"#标量，向量，矩阵和张量\" class=\"headerlink\" title=\"标量，向量，矩阵和张量\"></a>标量，向量，矩阵和张量</h1><p><strong>标量（scalar）</strong>：一个标量就是一个单独的数。用斜体表示标量，如 $s∈R$.</p>\n<p><strong>向量（vector）</strong>：一个向量是一列数，我们用粗体的小写名称表示向量。比如 $x$，将向量x 写成方括号包含的纵柱：</p>\n<script type=\"math/tex; mode=display\">{\\bf x}=  \\begin {bmatrix} x_1\\\\x_2\\\\ \\vdots \\\\x_n\\\\ \\end{bmatrix}</script><p><strong>矩阵（matrix）</strong>：矩阵是二维数组，我们通常赋予矩阵粗体大写变量名称，比如 $A​$ 。如果一个矩阵高度是 $m​$，宽度是 $n$​，那么说 $\\bf A\\in \\bf R ^{m \\times n}​$​ 。一个矩阵可以表示如下：</p>\n<script type=\"math/tex; mode=display\">{\\bf A}= \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\  \\end{bmatrix}</script><p><strong>张量（tensor）</strong>：某些情况下，我们会讨论不止维坐标的数组。如果一组数组中的元素分布在若干维坐标的规则网络中，就将其称为张量。用 $A$​ 表示，如张量中坐标为 $(i,j,k)$ ​的元素记作 $A_{i,j,k}$ ​。<br><strong>转置（transpose）</strong>：矩阵的转置是以对角线为轴的镜像，这条从左上角到右下角的对角线称为主对角线（main diagonal）。将矩阵 $A$ 的转置表示为 $A^⊤$ 。定义如下：</p>\n<script type=\"math/tex; mode=display\">({\\bf A^\\top})_{i,j}=\\bf A_{j,i}</script><script type=\"math/tex; mode=display\">{\\bf A} = \\begin{bmatrix} x_{11} &x_{12}\\\\ x_{21} & x_{22}\\\\ x_{31} & x_{32} \\end{bmatrix} \\implies {\\bf A^\\top}= \\begin{bmatrix} x_{11} &x_{21}&x_{31} \\\\ x_{21} & x_{22}& x_{32} \\end{bmatrix}</script>","more":"<h1 id=\"向量运算\"><a href=\"#向量运算\" class=\"headerlink\" title=\"向量运算\"></a>向量运算</h1><h2 id=\"加法\"><a href=\"#加法\" class=\"headerlink\" title=\"加法\"></a>加法</h2><p>设 $\\overrightarrow{v}=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，$\\overrightarrow{w}=\\begin{bmatrix}3\\\\ -1\\end{bmatrix}$则$ \\overrightarrow{v}+\\overrightarrow{w}=\\begin{bmatrix}4\\\\ 1\\end{bmatrix}$</p>\n<h2 id=\"数乘\"><a href=\"#数乘\" class=\"headerlink\" title=\"数乘\"></a>数乘</h2><p>设 $\\overrightarrow{v}=\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}$，则$2\\overrightarrow{v}=\\begin{bmatrix} 3\\times 2 \\\\ 1\\times 2 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$</p>\n<h2 id=\"矩阵-向量的乘积\"><a href=\"#矩阵-向量的乘积\" class=\"headerlink\" title=\"矩阵-向量的乘积\"></a>矩阵-向量的乘积</h2><p>矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。</p>\n<script type=\"math/tex; mode=display\">A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}</script><p><img src=\"/2017/08/17/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif\" alt=\"\"><br><img src=\"/2017/08/17/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif\" alt=\"\"></p>\n<h2 id=\"向量-向量的乘积\"><a href=\"#向量-向量的乘积\" class=\"headerlink\" title=\"向量-向量的乘积\"></a>向量-向量的乘积</h2><p>向量可以看成一个矩阵，这个矩阵将空间压缩到了一维空间。</p>\n<script type=\"math/tex; mode=display\">\\overrightarrow{w}\\cdot \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|cos\\theta =\\begin{bmatrix}\n1\\\\\n-2\n\\end{bmatrix}\\cdot\\begin{bmatrix}\n4\\\\\n3\n\\end{bmatrix}=4\\times 1+3\\times (-2)=-2</script><font color=\"red\">向量$\\overrightarrow{v}$在向量$\\overrightarrow{w}$上的投影乘以向量$\\overrightarrow{w}$的长度</font>\n\n<p><img src=\"/2017/08/17/线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif\" alt=\"点积\"></p>\n<h2 id=\"向量的叉积\"><a href=\"#向量的叉积\" class=\"headerlink\" title=\"向量的叉积\"></a>向量的叉积</h2><p>向量的叉积是一个向量，向量 $\\overrightarrow{p}$ 的方向垂直于 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 的平面，向量 $\\overrightarrow{p}$ 的模是 $\\overrightarrow{w}$ 与 $\\overrightarrow{v}$ 所围成平面的面积(行列式)。</p>\n<script type=\"math/tex; mode=display\">\\overrightarrow{w}\\times  \\overrightarrow{v}=|\\overrightarrow{w}|| \\overrightarrow{v}|sin\\theta =\\overrightarrow{p}</script><p><img src=\"/2017/08/17/线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg\" alt=\"点积\"></p>\n<h3 id=\"高维情况\"><a href=\"#高维情况\" class=\"headerlink\" title=\"高维情况\"></a>高维情况</h3><p>$\\overrightarrow{w}\\times  \\overrightarrow{v}=\\overrightarrow{p}$则</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\np_1 &=v_2\\cdot w_3-v_3\\cdot w_2 \\\\\np_2 &=v_3\\cdot w_1-v_1\\cdot w_3  \\\\\np_3 &=v_1\\cdot w_2-v_2\\cdot w_1\n\\end{align*}</script><p><img src=\"/2017/08/17/线性代数基础/5fed7bb9f99639d6299756bba298111b.gif\" alt=\"行列式\"></p>\n<h1 id=\"矩阵的运算\"><a href=\"#矩阵的运算\" class=\"headerlink\" title=\"矩阵的运算\"></a>矩阵的运算</h1><p>对向量的线性空间变换</p>\n<h2 id=\"矩阵加减法\"><a href=\"#矩阵加减法\" class=\"headerlink\" title=\"矩阵加减法\"></a>矩阵加减法</h2><p>对应位置的元素相加相减<br><img src=\"/2017/08/17/线性代数基础/线性代数基础-fb168ecc.png\" alt=\"\"></p>\n<h2 id=\"矩阵数乘\"><a href=\"#矩阵数乘\" class=\"headerlink\" title=\"矩阵数乘\"></a>矩阵数乘</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-c1b237dd.png\" alt=\"\"></p>\n<h2 id=\"矩阵转置\"><a href=\"#矩阵转置\" class=\"headerlink\" title=\"矩阵转置\"></a>矩阵转置</h2><p>把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵<br><img src=\"/2017/08/17/线性代数基础/线性代数基础-20a01623.png\" alt=\"\"></p>\n<h2 id=\"矩阵共轭\"><a href=\"#矩阵共轭\" class=\"headerlink\" title=\"矩阵共轭\"></a>矩阵共轭</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-76c02b4b.png\" alt=\"\"></p>\n<h2 id=\"矩阵共轭转置\"><a href=\"#矩阵共轭转置\" class=\"headerlink\" title=\"矩阵共轭转置\"></a>矩阵共轭转置</h2><p><img src=\"/2017/08/17/线性代数基础/线性代数基础-93e8ff75.png\" alt=\"\"></p>\n<h2 id=\"矩阵-向量的乘积-1\"><a href=\"#矩阵-向量的乘积-1\" class=\"headerlink\" title=\"矩阵-向量的乘积\"></a>矩阵-向量的乘积</h2><p>矩阵是空间的线性变换，矩阵与向量相乘便是将向量进行线性变换的结果。</p>\n<script type=\"math/tex; mode=display\">A\\overrightarrow{v}=\\begin{bmatrix}\n\\overset{i}{1} & \\overset{j}{3}\\\\\n-2 & 0\n\\end{bmatrix}\\begin{bmatrix}\n-1\\\\\n2\n\\end{bmatrix}=\\begin{bmatrix}\n-1\\times 1+2\\times 3\\\\\n-1\\times -2+2\\times 0\n\\end{bmatrix}=\\begin{bmatrix}\n5\\\\\n2\n\\end{bmatrix}</script><p><img src=\"/2017/08/17/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif\" alt=\"\"><br><img src=\"/2017/08/17/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif\" alt=\"\"></p>\n<h2 id=\"矩阵-矩阵的乘积\"><a href=\"#矩阵-矩阵的乘积\" class=\"headerlink\" title=\"矩阵-矩阵的乘积\"></a>矩阵-矩阵的乘积</h2><p>矩阵是一种线性变换，矩阵与矩阵相乘便是将空间进行线性变换之后再次进行线性变换。矩阵与矩阵的乘积是一种对于空间的复合线性变换。变换吸纳从右侧开始一次向左侧进行变换。线性变换的过程如下图所示：</p>\n<p><img src=\"/2017/08/17/线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif\" alt=\"\"></p>\n<p>矩阵-矩阵的计算过程如下所示<script type=\"math/tex\">\\begin{bmatrix}\n0 & 2\\\\\n1 & 0\n\\end{bmatrix}\\begin{bmatrix}\n1 & -2\\\\\n1 & 0\n\\end{bmatrix}=\\left\\{\\begin{matrix}1\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+1\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix} \\\\-2\\times \\begin{bmatrix}0\\\\ 1\\end{bmatrix}+0\\times \\begin{bmatrix}2\\\\ 0\\end{bmatrix}\\end{matrix}\\right.=\\begin{bmatrix}\n2 &0 \\\\\n1 & -2\n\\end{bmatrix}</script><br>计算过程去下图所示</p>\n<p><img src=\"/2017/08/17/线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif\" alt=\"\"></p>\n<h3 id=\"矩阵-矩阵乘积的性质\"><a href=\"#矩阵-矩阵乘积的性质\" class=\"headerlink\" title=\"矩阵-矩阵乘积的性质\"></a>矩阵-矩阵乘积的性质</h3><ul>\n<li>结合律即 $(AB)C = A(BC)$</li>\n<li>分配率即 $A(B + C) = AB + AC$</li>\n<li>注意哦，矩阵乘法没有交换律，即 $AB ≠BA$</li>\n</ul>\n<h2 id=\"矩阵的逆\"><a href=\"#矩阵的逆\" class=\"headerlink\" title=\"矩阵的逆\"></a><a href=\"/2017/08/17/矩阵的逆\">矩阵的逆</a></h2><p>矩阵$A ∈ R^{n×n}$的逆,写作$A^{−1}$，是一个矩阵，并且是唯一的。是对矩阵$A$空间操作的逆变换。同时$AA^{−1}$也可以理解为矩阵$A$除以矩阵$A$ 等于单位矩阵$I$，<script type=\"math/tex\">A^{−1}A = I = AA^{−1}.</script></p>\n<p><img src=\"/2017/08/17/线性代数基础/8d40107d18c971c5999be6beb599d618.gif\" alt=\"\"></p>\n<p>注意不是所有的矩阵都有逆。<strong>例如非方阵，是没有逆的。然而，即便对于一些方阵，它仍有可能不存在逆。如果$A^{−1}$存在，我们称矩阵$A$ 是可逆的或非奇异的，如果不存在，则称矩阵$A$不可逆或奇异。如果一个方阵$A$有逆$A^{−1}$，它必须满秩</strong></p>\n<h2 id=\"矩阵的秩\"><a href=\"#矩阵的秩\" class=\"headerlink\" title=\"矩阵的秩\"></a>矩阵的秩</h2><p><strong>矩阵的秩实际上的经过矩阵操作后空间的维数</strong>。在矩阵A中，非零子式的最高阶数称为矩阵A的秩，记为或秩。规定零矩阵的秩为零。</p>\n<h3 id=\"求解思路\"><a href=\"#求解思路\" class=\"headerlink\" title=\"求解思路\"></a>求解思路</h3><p>$矩阵A\\xrightarrow{初等行变换}阶梯形矩阵B。$则$r(A)=r(B)=$($B$中非零行的行数)</p>\n<ul>\n<li>例子<br>-<br>求矩阵<script type=\"math/tex\">A=\\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}</script>的秩。</li>\n</ul>\n<p>解：</p>\n<script type=\"math/tex; mode=display\">A= \\begin{bmatrix}\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\\\\\n1 &3  & 1 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n2 &-3  &8  & 2\\\\\n2 &12  &-2  & 12\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &-9 &6  & -6\\\\\n0 &6  &-6 & 4\n\\end{bmatrix}\\rightarrow  \\begin{bmatrix}\n1 &3  &1  & 4\\\\\n0 &3 &-2  &2\\\\\n0 &0  &-0 & 0\n\\end{bmatrix}</script><p>因此$r(A)=2$</p>\n<h2 id=\"矩阵的迹\"><a href=\"#矩阵的迹\" class=\"headerlink\" title=\"矩阵的迹\"></a>矩阵的迹</h2><p>方阵$A ∈ R^{n×n}$的迹，记作$tr(A)$，或可以省略括号表示成$trA$，是矩阵的对角线元素之和:<script type=\"math/tex\">trA=\\sum_{i=1}^{n}A_{ii}</script></p>\n<ul>\n<li>性质<ol>\n<li>对于$A ∈ R^{n×n}， trA = trA^T .$</li>\n<li>对于$A，B ∈ R^{n×n}， tr(A + B) = trA + trB.$</li>\n<li>对于$A ∈ R^{n×n}， t ∈ R， tr(t\\ast A) = t\\ast trA.$<br>1.对于方阵 $A,B,C，trABC = trBCA = trCAB$，即使有更多的矩阵相乘，这个性质也不变.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"正交矩阵\"><a href=\"#正交矩阵\" class=\"headerlink\" title=\"正交矩阵\"></a>正交矩阵</h2><p>如果$x^Ty = 0$，则两个向量 $x，y ∈ R^n$是正交的。对于一个向量$x ∈ R^n$，如果 $|x|=1$ 则是 $x$ 归一化的。<font color=\"red\">对于一个方阵$U ∈ R^{n×n}$，如果所有列都是彼此正交和归一化的，（列就称为标准正交）则这个方阵是正交的（注意在讨论向量或矩阵时，正交具有不同的含义）。</font> 根据正交和归一化的定义可得：</p>\n<script type=\"math/tex; mode=display\">U^T U = I = UU^T</script><font color=\"red\">一个正交矩阵的逆矩阵的是它转置,正交矩阵必须是方阵</font>"},{"title":"线性方程求解","date":"2017-08-18T03:57:48.000Z","_content":"\n$$\\begin{align*}\n2x+5y+3z &= -3\\\\\n4x+8z &= 0\\\\\nx+3y &= 2\n\\end{align*}\\Leftrightarrow \\overset{A}{\\overbrace{\\begin{bmatrix}\n2 & 5 & 3\\\\\n4 & 0 & 8\\\\\n1 & 3 & 0\n\\end{bmatrix}}}\\overset{\\overrightarrow{x}}{\\overbrace{\\begin{bmatrix}\nx\\\\\ny\\\\\nz\n\\end{bmatrix}}}=\\overset{\\overrightarrow{v}}{\\overbrace{\\begin{bmatrix}\n-3\\\\\n0\\\\\n2\n\\end{bmatrix}}}$$\n$$A\\overrightarrow{x}=\\overrightarrow{v}$$\n\n可以看做向量 $\\overrightarrow{x}$ 经过空间变换后变为向量 $\\overrightarrow{v}$ ，矩阵 $A$ 的变换过程有两种情况\n1. 空间变换之后，空间没有发生压缩。即$det(A)\\neq0$ ，矩阵 $A$ 满秩\n2. 空间变换之后，空间发生压缩，即$det(A)=0$ ，矩阵 $A$ 不是满秩\n\n![线性方程求解](线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif)\n\n<!--more-->\n\n# 空间变换之后，空间没有发生压缩\n空间变换之后，空间没有发生压缩。即 $det(A)\\neq0$ ，矩阵 $A$ 满秩。\n$$\\begin{align*}\nA\\overrightarrow{x}&=\\overrightarrow{v} \\\\\n\\overrightarrow{x} &= A^{-1}\\overrightarrow{v}\n\\end{align*}$$\n\n![](线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif)\n\n# 空间变换之后，空间发生压缩\n空间变换之后，空间发生压缩，即 $det(A)=0$ ，矩阵A不是满秩。此时你不能通过矩阵的逆变换将空间从一个低维状态复原到高维状态（即原空间）。\n\n![](线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif)\n\n<font color=red>\n此时方程的解如下，当 $\\overrightarrow{v}$ 在压缩的平面上方程有解，此时方程组可能有无穷个解；当 $\\overrightarrow{v}$ 不在压缩的平面上方程无解</font>\n\n![](线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif)\n","source":"_posts/线性方程求解.md","raw":"---\ntitle: 线性方程求解\ndate: 2017-08-18 11:57:48\ntags: [人工智能,线性代数,向量,矩阵]\ncategories: 数学\n---\n\n$$\\begin{align*}\n2x+5y+3z &= -3\\\\\n4x+8z &= 0\\\\\nx+3y &= 2\n\\end{align*}\\Leftrightarrow \\overset{A}{\\overbrace{\\begin{bmatrix}\n2 & 5 & 3\\\\\n4 & 0 & 8\\\\\n1 & 3 & 0\n\\end{bmatrix}}}\\overset{\\overrightarrow{x}}{\\overbrace{\\begin{bmatrix}\nx\\\\\ny\\\\\nz\n\\end{bmatrix}}}=\\overset{\\overrightarrow{v}}{\\overbrace{\\begin{bmatrix}\n-3\\\\\n0\\\\\n2\n\\end{bmatrix}}}$$\n$$A\\overrightarrow{x}=\\overrightarrow{v}$$\n\n可以看做向量 $\\overrightarrow{x}$ 经过空间变换后变为向量 $\\overrightarrow{v}$ ，矩阵 $A$ 的变换过程有两种情况\n1. 空间变换之后，空间没有发生压缩。即$det(A)\\neq0$ ，矩阵 $A$ 满秩\n2. 空间变换之后，空间发生压缩，即$det(A)=0$ ，矩阵 $A$ 不是满秩\n\n![线性方程求解](线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif)\n\n<!--more-->\n\n# 空间变换之后，空间没有发生压缩\n空间变换之后，空间没有发生压缩。即 $det(A)\\neq0$ ，矩阵 $A$ 满秩。\n$$\\begin{align*}\nA\\overrightarrow{x}&=\\overrightarrow{v} \\\\\n\\overrightarrow{x} &= A^{-1}\\overrightarrow{v}\n\\end{align*}$$\n\n![](线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif)\n\n# 空间变换之后，空间发生压缩\n空间变换之后，空间发生压缩，即 $det(A)=0$ ，矩阵A不是满秩。此时你不能通过矩阵的逆变换将空间从一个低维状态复原到高维状态（即原空间）。\n\n![](线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif)\n\n<font color=red>\n此时方程的解如下，当 $\\overrightarrow{v}$ 在压缩的平面上方程有解，此时方程组可能有无穷个解；当 $\\overrightarrow{v}$ 不在压缩的平面上方程无解</font>\n\n![](线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif)\n","slug":"线性方程求解","published":1,"updated":"2019-07-30T01:54:38.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j18006dhomjnfqp9not","content":"<script type=\"math/tex; mode=display\">\\begin{align*}\n2x+5y+3z &= -3\\\\\n4x+8z &= 0\\\\\nx+3y &= 2\n\\end{align*}\\Leftrightarrow \\overset{A}{\\overbrace{\\begin{bmatrix}\n2 & 5 & 3\\\\\n4 & 0 & 8\\\\\n1 & 3 & 0\n\\end{bmatrix}}}\\overset{\\overrightarrow{x}}{\\overbrace{\\begin{bmatrix}\nx\\\\\ny\\\\\nz\n\\end{bmatrix}}}=\\overset{\\overrightarrow{v}}{\\overbrace{\\begin{bmatrix}\n-3\\\\\n0\\\\\n2\n\\end{bmatrix}}}</script><script type=\"math/tex; mode=display\">A\\overrightarrow{x}=\\overrightarrow{v}</script><p>可以看做向量 $\\overrightarrow{x}$ 经过空间变换后变为向量 $\\overrightarrow{v}$ ，矩阵 $A$ 的变换过程有两种情况</p>\n<ol>\n<li>空间变换之后，空间没有发生压缩。即$det(A)\\neq0$ ，矩阵 $A$ 满秩</li>\n<li>空间变换之后，空间发生压缩，即$det(A)=0$ ，矩阵 $A$ 不是满秩</li>\n</ol>\n<p><img src=\"/2017/08/18/线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif\" alt=\"线性方程求解\"></p>\n<a id=\"more\"></a>\n<h1 id=\"空间变换之后，空间没有发生压缩\"><a href=\"#空间变换之后，空间没有发生压缩\" class=\"headerlink\" title=\"空间变换之后，空间没有发生压缩\"></a>空间变换之后，空间没有发生压缩</h1><p>空间变换之后，空间没有发生压缩。即 $det(A)\\neq0$ ，矩阵 $A$ 满秩。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nA\\overrightarrow{x}&=\\overrightarrow{v} \\\\\n\\overrightarrow{x} &= A^{-1}\\overrightarrow{v}\n\\end{align*}</script><p><img src=\"/2017/08/18/线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif\" alt=\"\"></p>\n<h1 id=\"空间变换之后，空间发生压缩\"><a href=\"#空间变换之后，空间发生压缩\" class=\"headerlink\" title=\"空间变换之后，空间发生压缩\"></a>空间变换之后，空间发生压缩</h1><p>空间变换之后，空间发生压缩，即 $det(A)=0$ ，矩阵A不是满秩。此时你不能通过矩阵的逆变换将空间从一个低维状态复原到高维状态（即原空间）。</p>\n<p><img src=\"/2017/08/18/线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif\" alt=\"\"></p>\n<font color=\"red\">\n此时方程的解如下，当 $\\overrightarrow{v}$ 在压缩的平面上方程有解，此时方程组可能有无穷个解；当 $\\overrightarrow{v}$ 不在压缩的平面上方程无解</font>\n\n<p><img src=\"/2017/08/18/线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<script type=\"math/tex; mode=display\">\\begin{align*}\n2x+5y+3z &= -3\\\\\n4x+8z &= 0\\\\\nx+3y &= 2\n\\end{align*}\\Leftrightarrow \\overset{A}{\\overbrace{\\begin{bmatrix}\n2 & 5 & 3\\\\\n4 & 0 & 8\\\\\n1 & 3 & 0\n\\end{bmatrix}}}\\overset{\\overrightarrow{x}}{\\overbrace{\\begin{bmatrix}\nx\\\\\ny\\\\\nz\n\\end{bmatrix}}}=\\overset{\\overrightarrow{v}}{\\overbrace{\\begin{bmatrix}\n-3\\\\\n0\\\\\n2\n\\end{bmatrix}}}</script><script type=\"math/tex; mode=display\">A\\overrightarrow{x}=\\overrightarrow{v}</script><p>可以看做向量 $\\overrightarrow{x}$ 经过空间变换后变为向量 $\\overrightarrow{v}$ ，矩阵 $A$ 的变换过程有两种情况</p>\n<ol>\n<li>空间变换之后，空间没有发生压缩。即$det(A)\\neq0$ ，矩阵 $A$ 满秩</li>\n<li>空间变换之后，空间发生压缩，即$det(A)=0$ ，矩阵 $A$ 不是满秩</li>\n</ol>\n<p><img src=\"/2017/08/18/线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif\" alt=\"线性方程求解\"></p>","more":"<h1 id=\"空间变换之后，空间没有发生压缩\"><a href=\"#空间变换之后，空间没有发生压缩\" class=\"headerlink\" title=\"空间变换之后，空间没有发生压缩\"></a>空间变换之后，空间没有发生压缩</h1><p>空间变换之后，空间没有发生压缩。即 $det(A)\\neq0$ ，矩阵 $A$ 满秩。</p>\n<script type=\"math/tex; mode=display\">\\begin{align*}\nA\\overrightarrow{x}&=\\overrightarrow{v} \\\\\n\\overrightarrow{x} &= A^{-1}\\overrightarrow{v}\n\\end{align*}</script><p><img src=\"/2017/08/18/线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif\" alt=\"\"></p>\n<h1 id=\"空间变换之后，空间发生压缩\"><a href=\"#空间变换之后，空间发生压缩\" class=\"headerlink\" title=\"空间变换之后，空间发生压缩\"></a>空间变换之后，空间发生压缩</h1><p>空间变换之后，空间发生压缩，即 $det(A)=0$ ，矩阵A不是满秩。此时你不能通过矩阵的逆变换将空间从一个低维状态复原到高维状态（即原空间）。</p>\n<p><img src=\"/2017/08/18/线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif\" alt=\"\"></p>\n<font color=\"red\">\n此时方程的解如下，当 $\\overrightarrow{v}$ 在压缩的平面上方程有解，此时方程组可能有无穷个解；当 $\\overrightarrow{v}$ 不在压缩的平面上方程无解</font>\n\n<p><img src=\"/2017/08/18/线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif\" alt=\"\"></p>"},{"title":"行列式","date":"2017-08-18T03:28:57.000Z","_content":"\n# 行列式\n行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作$det(A)$或 $| A |$。对于行列式的几何描述如下所示：\n1. 行列式求得是矩阵的面积。\n1. 行列式等于0时候，说明矩阵的空间操作把空间压缩为低维空间\n1. 行列式为负数的时候，说明空间发生了翻转\n1. 方阵特征值之积等于行列式值也可以如下这样理解\n\n<!--more-->\n\n![](行列式/行列式-b8781bc3.png)\n\n## 行列式的计算\n\n![二阶](行列式/行列式-ec72909a.png)\n![三阶](行列式/行列式-8ca7d05d.png)\n![](行列式/行列式-1194e010.png)\n![四阶](行列式/行列式-cc80fd31.png)\n","source":"_posts/行列式.md","raw":"---\ntitle: 行列式\ndate: 2017-08-18 11:28:57\ntags: [人工智能,线性代数,矩阵]\ncategories: 数学\n---\n\n# 行列式\n行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作$det(A)$或 $| A |$。对于行列式的几何描述如下所示：\n1. 行列式求得是矩阵的面积。\n1. 行列式等于0时候，说明矩阵的空间操作把空间压缩为低维空间\n1. 行列式为负数的时候，说明空间发生了翻转\n1. 方阵特征值之积等于行列式值也可以如下这样理解\n\n<!--more-->\n\n![](行列式/行列式-b8781bc3.png)\n\n## 行列式的计算\n\n![二阶](行列式/行列式-ec72909a.png)\n![三阶](行列式/行列式-8ca7d05d.png)\n![](行列式/行列式-1194e010.png)\n![四阶](行列式/行列式-cc80fd31.png)\n","slug":"行列式","published":1,"updated":"2019-07-30T01:54:38.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1a006fhomjf97d37sc","content":"<h1 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h1><p>行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作$det(A)$或 $| A |$。对于行列式的几何描述如下所示：</p>\n<ol>\n<li>行列式求得是矩阵的面积。</li>\n<li>行列式等于0时候，说明矩阵的空间操作把空间压缩为低维空间</li>\n<li>行列式为负数的时候，说明空间发生了翻转</li>\n<li>方阵特征值之积等于行列式值也可以如下这样理解</li>\n</ol>\n<a id=\"more\"></a>\n<p><img src=\"/2017/08/18/行列式/行列式-b8781bc3.png\" alt=\"\"></p>\n<h2 id=\"行列式的计算\"><a href=\"#行列式的计算\" class=\"headerlink\" title=\"行列式的计算\"></a>行列式的计算</h2><p><img src=\"/2017/08/18/行列式/行列式-ec72909a.png\" alt=\"二阶\"><br><img src=\"/2017/08/18/行列式/行列式-8ca7d05d.png\" alt=\"三阶\"><br><img src=\"/2017/08/18/行列式/行列式-1194e010.png\" alt=\"\"><br><img src=\"/2017/08/18/行列式/行列式-cc80fd31.png\" alt=\"四阶\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h1><p>行列式在数学中，是一个函数，其定义域为det的矩阵A，取值为一个标量，写作$det(A)$或 $| A |$。对于行列式的几何描述如下所示：</p>\n<ol>\n<li>行列式求得是矩阵的面积。</li>\n<li>行列式等于0时候，说明矩阵的空间操作把空间压缩为低维空间</li>\n<li>行列式为负数的时候，说明空间发生了翻转</li>\n<li>方阵特征值之积等于行列式值也可以如下这样理解</li>\n</ol>","more":"<p><img src=\"/2017/08/18/行列式/行列式-b8781bc3.png\" alt=\"\"></p>\n<h2 id=\"行列式的计算\"><a href=\"#行列式的计算\" class=\"headerlink\" title=\"行列式的计算\"></a>行列式的计算</h2><p><img src=\"/2017/08/18/行列式/行列式-ec72909a.png\" alt=\"二阶\"><br><img src=\"/2017/08/18/行列式/行列式-8ca7d05d.png\" alt=\"三阶\"><br><img src=\"/2017/08/18/行列式/行列式-1194e010.png\" alt=\"\"><br><img src=\"/2017/08/18/行列式/行列式-cc80fd31.png\" alt=\"四阶\"></p>"},{"title":"随机变量的统计特征","date":"2017-08-16T03:08:09.000Z","_content":"随机变量的统计特征主要包括期望，方差，协方差以及相关系数。\n<!--more-->\n# 期望\n- 离散型随机变量：\n$$E(X) = \\sum_{k=1}^{ +\\infty}p_kx_k$$\n- 连续型随机变量：\n$$E(X) = \\int_{-\\infty}^{ +\\infty} {xf(x)dx}$$\n\n## 期望有以下性质(C为常数,其他均为随机变量):\n\n1. $E(C)=C$\n1. $E(CX)=CE(X)$\n1. $E(X+Y)=E(X)+E(Y)$\n1. $E(XY)=E(X)E(Y)$ （$X,Y$ 相互独立）\n\n## 随机变量 $X$ 的函数的期望\n前面讨论随机变量的分布函数时，同时讨论了随机变量的函数的分布函数，这里同样对于**随机变量 $X$ 的函数的期望**进行讨论，其定义及求法如下所示。\n\n设 $Y$ 是随机变量 $X$ 的函数：$Y=g(X)$ ( $g$ 是连续函数)\n\n1. 如果 $X$ 是离散型随机变量，它的分布律为\n$$P(X=x_k) = p_k, k = 1,2,…$$\n若 $\\sum_{k=1}^{\\infty}g(x_k)p_k$ 绝对收敛，则有\n$$E(Y) = E[g(X)] = \\sum_{k=1}^{\\infty}g(x_k)p_k$$\n1. 如果 $X$ 是连续型随机变量，它的概率密度函数为 $f(x)$, 若 $\\int_{-\\infty}^{\\infty}g(x)f(x)dx$ 绝对收敛，则有\n$$E(Y) = E[g(X)] = \\int_{-\\infty}^{\\infty}g(x)f(x)dx$$\n\n这个定理的重要意义在于求 $E(Y)$ 的时候，不用再求 $Y$ 的分布律或概率密度函数，直接利用 $X$ 的分布律或概率密度函数即可。\n\n# 方差\n方差的原始定义为\n\n$$D(X) = E[(X-E(X))^2] = E(X^2) - E(X)^2$$\n## 方差有以下性质：\n\n1. $D(C)=0$\n1. $D(CX)=C^2D(X)$\n1. $D(X+Y)=D(X)+D(Y)+2E([X−E(X)][Y−E(Y)])$\n如果 $X，Y$ 是相互独立的，那么 $E([X−E(X)][Y−E(Y)])=0$ , 当这一项不为0的时候，称作变量 $X,Y$ 的协方差。\n\n# 常见分布的期望和方差\n前面我们提到了若干种典型的离散分布和连续分布，下面是这几种分布的期望和方差，记住这些常用的期望和方差能够在使用的时候省去推导过程。\n\n分布类型 | 概率密度函数 | 期望 | 方差\n:-:|:-:|:-:|:-:\n伯努利分布~$B(1,p)$ | $p = p^x(1-p)^{1-x}$ | $p$ | $p(1−p)$\n二项分布~$B(n,p)$ | $p_i = C_n^i p^i(1-p)^{n-i}(i=1,2)$ | $np$ | $np(1−p)$\n泊松分布~$P(λ)$ | $p_i = \\frac{\\lambda^ki e^{-\\lambda}}{i!}(i = 1,2,...)$ | $λ$ | $λ$\n均匀分布~$U(a,b)$ | $f(x) = \\frac{1}{b-a}$ | $\\frac{a+b}{2}$ | $\\frac{(b-a)^2}{12}$\n正态分布~$N(μ,σ^2)$ | $f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ | $μ$ | $σ^2$\n指数分布~$E(λ)$ | $f(x) = \\begin{cases}  \\lambda e^{-x\\lambda} &{x>0} \\\\ 0&{其他}\\end{cases}$ | $\\frac{1}{\\lambda}$ | $\\frac{1}{\\lambda^2}$\n\n# 切比雪夫不等式\n切比雪夫不等式的定义如下：\n\n设随机变量 $X$ 具有数学期望 $E(X)=μ$, 方差 $D(X)=σ^2$, 则对于任意正数 $ϵ$, 下面的不等式成立\n$$P(|X-\\mu|\\ge \\epsilon) \\le \\frac{\\sigma^2}{\\epsilon^2}$$\n从定义可知，切比雪夫不等式也可写成如下的形式：\n\n$$P(|X-\\mu| \\le \\epsilon) \\ge 1 - \\frac{\\sigma^2}{\\epsilon^2}$$\n切比雪夫不等式的一个重要意义在于当随机变量 $X$ 的分布未知，只知道 $E(X)$ 和 $D(X)$ 的情况下，对于事件 $(|X−μ|≤ϵ)$ 概率的下限的估计。\n\n# 协方差\n协方差表达了两个随机变量的相关性，正的协方差表达了正相关性，负的协方差表达了负相关性。协方差为0 表示两者不相关，对于同样的两个随机变量来说，计算出的协方差的绝对值越大，相关性越强。\n\n协方差的定义入下:\n\n$$Cov(X,Y)=E[X−E(X)][Y−E(Y)]$$\n\n## 协方差有以下性质：\n\n1. $Cov(X,Y)=Cov(Y,X)$\n1. $Cov(X,Y)=E(XY)−E(X)E(Y)$\n1. $Cov(aX,bY)=abCov(X,Y)$（a，b是常数）\n1. $Cov(X_1+X_2, Y) = Cov(X_1, Y) + Cov(X_2,Y)$\n\n## 相关系数\n假如我们现在有身高和体重这两个未知变量，对于一系列的样本我们算出的的协方差为30，那这究竟是多大的一个量呢？如果我们又发现，身高与鞋号的协方差为5，是否说明，相对于鞋号，身高与体重的的相关性更强呢？\n\n为了能进行这样的横向对比，我们计算相关系数(correlation coefficient)， 相关系数相当于是“归一化”的协方差。\n\n$$\\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}}$$\n相关系数是用协方差除以两个随机变量的标准差。**相关系数的大小在-1和1之间变化，等于0表示不相关**。再也不会出现因为计量单位变化，而数值变化较大的情况，而相关系数的大小的含义与协方差是一样的。\n\n需要注意的是上面提到的**相关**均指**线性相关**，$X,Y$ 不相关是指 $X,Y$ 之间不存在线性关系，但是他们还可能存在除线性关系以外的关系。因此，有以下结论: **$X,Y$ 相互独立则 $X,Y$ 一定不相关；反之 $X,Y$ 不相关，两者不一定相互独立。**\n\n\n\n# 矩和协方差矩阵\n## 矩\n下面介绍概率论中几种矩的定义\n\n设 $X,Y$ 为随机变量,则\n\n1. $E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩\n1. $E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距\n1. $E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩\n1. $E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩\n\n由以上定义我们可以知道，随机变量的期望是其**一阶原点矩，方差是其二阶中心距，协方差是其二阶混合中心矩。**\n\n## 协方差矩阵\n除此之外，另外一个常用的概念是协方差矩阵， 其定义如下：\n\n对于 $n$ 维随机变量 ($(X_1,X_2,X_3…,X_n)$) 构成的矩阵\n\n$$C= \\begin{bmatrix} c_{11} & c_{12} & \\cdots & c_{1n} \\\\ c_{21} & c_{22} & \\cdots & c_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ c_{n1} & c_{n2} & \\cdots & c_{nn} \\\\ \\end{bmatrix}$$\n其中各个元素为\n$$c_{ij} = Cov(X_i,X_j) = E((X_i - E[X_i])(X_j - E[X_j]))，i,j=1,2,3..n$$\n则称矩阵 $C$ 为协方差矩阵，由于 $c_{ij} = c_{ji}$ ， 因此上面的矩阵为一个对称矩阵。\n\n协方差矩阵其实是将二维随机变量的协方差一般化后拓展到了 $n$ 维随机变量上的一种表示形式，但是除了作为一种表示形式以外，协方差矩阵还存在着某些性质使得其在多个领域均有应用，如主成成分分析。\n","source":"_posts/随机变量的统计特征.md","raw":"---\ntitle: 随机变量的统计特征\ndate: 2017-08-16 11:08:09\ntags: [人工智能,概率,统计]\ncategories: 数学\n---\n随机变量的统计特征主要包括期望，方差，协方差以及相关系数。\n<!--more-->\n# 期望\n- 离散型随机变量：\n$$E(X) = \\sum_{k=1}^{ +\\infty}p_kx_k$$\n- 连续型随机变量：\n$$E(X) = \\int_{-\\infty}^{ +\\infty} {xf(x)dx}$$\n\n## 期望有以下性质(C为常数,其他均为随机变量):\n\n1. $E(C)=C$\n1. $E(CX)=CE(X)$\n1. $E(X+Y)=E(X)+E(Y)$\n1. $E(XY)=E(X)E(Y)$ （$X,Y$ 相互独立）\n\n## 随机变量 $X$ 的函数的期望\n前面讨论随机变量的分布函数时，同时讨论了随机变量的函数的分布函数，这里同样对于**随机变量 $X$ 的函数的期望**进行讨论，其定义及求法如下所示。\n\n设 $Y$ 是随机变量 $X$ 的函数：$Y=g(X)$ ( $g$ 是连续函数)\n\n1. 如果 $X$ 是离散型随机变量，它的分布律为\n$$P(X=x_k) = p_k, k = 1,2,…$$\n若 $\\sum_{k=1}^{\\infty}g(x_k)p_k$ 绝对收敛，则有\n$$E(Y) = E[g(X)] = \\sum_{k=1}^{\\infty}g(x_k)p_k$$\n1. 如果 $X$ 是连续型随机变量，它的概率密度函数为 $f(x)$, 若 $\\int_{-\\infty}^{\\infty}g(x)f(x)dx$ 绝对收敛，则有\n$$E(Y) = E[g(X)] = \\int_{-\\infty}^{\\infty}g(x)f(x)dx$$\n\n这个定理的重要意义在于求 $E(Y)$ 的时候，不用再求 $Y$ 的分布律或概率密度函数，直接利用 $X$ 的分布律或概率密度函数即可。\n\n# 方差\n方差的原始定义为\n\n$$D(X) = E[(X-E(X))^2] = E(X^2) - E(X)^2$$\n## 方差有以下性质：\n\n1. $D(C)=0$\n1. $D(CX)=C^2D(X)$\n1. $D(X+Y)=D(X)+D(Y)+2E([X−E(X)][Y−E(Y)])$\n如果 $X，Y$ 是相互独立的，那么 $E([X−E(X)][Y−E(Y)])=0$ , 当这一项不为0的时候，称作变量 $X,Y$ 的协方差。\n\n# 常见分布的期望和方差\n前面我们提到了若干种典型的离散分布和连续分布，下面是这几种分布的期望和方差，记住这些常用的期望和方差能够在使用的时候省去推导过程。\n\n分布类型 | 概率密度函数 | 期望 | 方差\n:-:|:-:|:-:|:-:\n伯努利分布~$B(1,p)$ | $p = p^x(1-p)^{1-x}$ | $p$ | $p(1−p)$\n二项分布~$B(n,p)$ | $p_i = C_n^i p^i(1-p)^{n-i}(i=1,2)$ | $np$ | $np(1−p)$\n泊松分布~$P(λ)$ | $p_i = \\frac{\\lambda^ki e^{-\\lambda}}{i!}(i = 1,2,...)$ | $λ$ | $λ$\n均匀分布~$U(a,b)$ | $f(x) = \\frac{1}{b-a}$ | $\\frac{a+b}{2}$ | $\\frac{(b-a)^2}{12}$\n正态分布~$N(μ,σ^2)$ | $f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$ | $μ$ | $σ^2$\n指数分布~$E(λ)$ | $f(x) = \\begin{cases}  \\lambda e^{-x\\lambda} &{x>0} \\\\ 0&{其他}\\end{cases}$ | $\\frac{1}{\\lambda}$ | $\\frac{1}{\\lambda^2}$\n\n# 切比雪夫不等式\n切比雪夫不等式的定义如下：\n\n设随机变量 $X$ 具有数学期望 $E(X)=μ$, 方差 $D(X)=σ^2$, 则对于任意正数 $ϵ$, 下面的不等式成立\n$$P(|X-\\mu|\\ge \\epsilon) \\le \\frac{\\sigma^2}{\\epsilon^2}$$\n从定义可知，切比雪夫不等式也可写成如下的形式：\n\n$$P(|X-\\mu| \\le \\epsilon) \\ge 1 - \\frac{\\sigma^2}{\\epsilon^2}$$\n切比雪夫不等式的一个重要意义在于当随机变量 $X$ 的分布未知，只知道 $E(X)$ 和 $D(X)$ 的情况下，对于事件 $(|X−μ|≤ϵ)$ 概率的下限的估计。\n\n# 协方差\n协方差表达了两个随机变量的相关性，正的协方差表达了正相关性，负的协方差表达了负相关性。协方差为0 表示两者不相关，对于同样的两个随机变量来说，计算出的协方差的绝对值越大，相关性越强。\n\n协方差的定义入下:\n\n$$Cov(X,Y)=E[X−E(X)][Y−E(Y)]$$\n\n## 协方差有以下性质：\n\n1. $Cov(X,Y)=Cov(Y,X)$\n1. $Cov(X,Y)=E(XY)−E(X)E(Y)$\n1. $Cov(aX,bY)=abCov(X,Y)$（a，b是常数）\n1. $Cov(X_1+X_2, Y) = Cov(X_1, Y) + Cov(X_2,Y)$\n\n## 相关系数\n假如我们现在有身高和体重这两个未知变量，对于一系列的样本我们算出的的协方差为30，那这究竟是多大的一个量呢？如果我们又发现，身高与鞋号的协方差为5，是否说明，相对于鞋号，身高与体重的的相关性更强呢？\n\n为了能进行这样的横向对比，我们计算相关系数(correlation coefficient)， 相关系数相当于是“归一化”的协方差。\n\n$$\\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}}$$\n相关系数是用协方差除以两个随机变量的标准差。**相关系数的大小在-1和1之间变化，等于0表示不相关**。再也不会出现因为计量单位变化，而数值变化较大的情况，而相关系数的大小的含义与协方差是一样的。\n\n需要注意的是上面提到的**相关**均指**线性相关**，$X,Y$ 不相关是指 $X,Y$ 之间不存在线性关系，但是他们还可能存在除线性关系以外的关系。因此，有以下结论: **$X,Y$ 相互独立则 $X,Y$ 一定不相关；反之 $X,Y$ 不相关，两者不一定相互独立。**\n\n\n\n# 矩和协方差矩阵\n## 矩\n下面介绍概率论中几种矩的定义\n\n设 $X,Y$ 为随机变量,则\n\n1. $E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩\n1. $E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距\n1. $E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩\n1. $E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩\n\n由以上定义我们可以知道，随机变量的期望是其**一阶原点矩，方差是其二阶中心距，协方差是其二阶混合中心矩。**\n\n## 协方差矩阵\n除此之外，另外一个常用的概念是协方差矩阵， 其定义如下：\n\n对于 $n$ 维随机变量 ($(X_1,X_2,X_3…,X_n)$) 构成的矩阵\n\n$$C= \\begin{bmatrix} c_{11} & c_{12} & \\cdots & c_{1n} \\\\ c_{21} & c_{22} & \\cdots & c_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ c_{n1} & c_{n2} & \\cdots & c_{nn} \\\\ \\end{bmatrix}$$\n其中各个元素为\n$$c_{ij} = Cov(X_i,X_j) = E((X_i - E[X_i])(X_j - E[X_j]))，i,j=1,2,3..n$$\n则称矩阵 $C$ 为协方差矩阵，由于 $c_{ij} = c_{ji}$ ， 因此上面的矩阵为一个对称矩阵。\n\n协方差矩阵其实是将二维随机变量的协方差一般化后拓展到了 $n$ 维随机变量上的一种表示形式，但是除了作为一种表示形式以外，协方差矩阵还存在着某些性质使得其在多个领域均有应用，如主成成分分析。\n","slug":"随机变量的统计特征","published":1,"updated":"2019-07-30T01:54:38.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1c006ihomj7befy1tl","content":"<p>随机变量的统计特征主要包括期望，方差，协方差以及相关系数。<br><a id=\"more\"></a></p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><ul>\n<li>离散型随机变量：<script type=\"math/tex; mode=display\">E(X) = \\sum_{k=1}^{ +\\infty}p_kx_k</script></li>\n<li>连续型随机变量：<script type=\"math/tex; mode=display\">E(X) = \\int_{-\\infty}^{ +\\infty} {xf(x)dx}</script></li>\n</ul>\n<h2 id=\"期望有以下性质-C为常数-其他均为随机变量\"><a href=\"#期望有以下性质-C为常数-其他均为随机变量\" class=\"headerlink\" title=\"期望有以下性质(C为常数,其他均为随机变量):\"></a>期望有以下性质(C为常数,其他均为随机变量):</h2><ol>\n<li>$E(C)=C$</li>\n<li>$E(CX)=CE(X)$</li>\n<li>$E(X+Y)=E(X)+E(Y)$</li>\n<li>$E(XY)=E(X)E(Y)$ （$X,Y$ 相互独立）</li>\n</ol>\n<h2 id=\"随机变量-X-的函数的期望\"><a href=\"#随机变量-X-的函数的期望\" class=\"headerlink\" title=\"随机变量 $X$ 的函数的期望\"></a>随机变量 $X$ 的函数的期望</h2><p>前面讨论随机变量的分布函数时，同时讨论了随机变量的函数的分布函数，这里同样对于<strong>随机变量 $X$ 的函数的期望</strong>进行讨论，其定义及求法如下所示。</p>\n<p>设 $Y$ 是随机变量 $X$ 的函数：$Y=g(X)$ ( $g$ 是连续函数)</p>\n<ol>\n<li>如果 $X$ 是离散型随机变量，它的分布律为<script type=\"math/tex; mode=display\">P(X=x_k) = p_k, k = 1,2,…</script>若 $\\sum_{k=1}^{\\infty}g(x_k)p_k$ 绝对收敛，则有<script type=\"math/tex; mode=display\">E(Y) = E[g(X)] = \\sum_{k=1}^{\\infty}g(x_k)p_k</script></li>\n<li>如果 $X$ 是连续型随机变量，它的概率密度函数为 $f(x)$, 若 $\\int_{-\\infty}^{\\infty}g(x)f(x)dx$ 绝对收敛，则有<script type=\"math/tex; mode=display\">E(Y) = E[g(X)] = \\int_{-\\infty}^{\\infty}g(x)f(x)dx</script></li>\n</ol>\n<p>这个定理的重要意义在于求 $E(Y)$ 的时候，不用再求 $Y$ 的分布律或概率密度函数，直接利用 $X$ 的分布律或概率密度函数即可。</p>\n<h1 id=\"方差\"><a href=\"#方差\" class=\"headerlink\" title=\"方差\"></a>方差</h1><p>方差的原始定义为</p>\n<script type=\"math/tex; mode=display\">D(X) = E[(X-E(X))^2] = E(X^2) - E(X)^2</script><h2 id=\"方差有以下性质：\"><a href=\"#方差有以下性质：\" class=\"headerlink\" title=\"方差有以下性质：\"></a>方差有以下性质：</h2><ol>\n<li>$D(C)=0$</li>\n<li>$D(CX)=C^2D(X)$</li>\n<li>$D(X+Y)=D(X)+D(Y)+2E([X−E(X)][Y−E(Y)])$<br>如果 $X，Y$ 是相互独立的，那么 $E([X−E(X)][Y−E(Y)])=0$ , 当这一项不为0的时候，称作变量 $X,Y$ 的协方差。</li>\n</ol>\n<h1 id=\"常见分布的期望和方差\"><a href=\"#常见分布的期望和方差\" class=\"headerlink\" title=\"常见分布的期望和方差\"></a>常见分布的期望和方差</h1><p>前面我们提到了若干种典型的离散分布和连续分布，下面是这几种分布的期望和方差，记住这些常用的期望和方差能够在使用的时候省去推导过程。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分布类型</th>\n<th style=\"text-align:center\">概率密度函数</th>\n<th style=\"text-align:center\">期望</th>\n<th style=\"text-align:center\">方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">伯努利分布~$B(1,p)$</td>\n<td style=\"text-align:center\">$p = p^x(1-p)^{1-x}$</td>\n<td style=\"text-align:center\">$p$</td>\n<td style=\"text-align:center\">$p(1−p)$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">二项分布~$B(n,p)$</td>\n<td style=\"text-align:center\">$p_i = C_n^i p^i(1-p)^{n-i}(i=1,2)$</td>\n<td style=\"text-align:center\">$np$</td>\n<td style=\"text-align:center\">$np(1−p)$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">泊松分布~$P(λ)$</td>\n<td style=\"text-align:center\">$p_i = \\frac{\\lambda^ki e^{-\\lambda}}{i!}(i = 1,2,…)$</td>\n<td style=\"text-align:center\">$λ$</td>\n<td style=\"text-align:center\">$λ$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">均匀分布~$U(a,b)$</td>\n<td style=\"text-align:center\">$f(x) = \\frac{1}{b-a}$</td>\n<td style=\"text-align:center\">$\\frac{a+b}{2}$</td>\n<td style=\"text-align:center\">$\\frac{(b-a)^2}{12}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">正态分布~$N(μ,σ^2)$</td>\n<td style=\"text-align:center\">$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$</td>\n<td style=\"text-align:center\">$μ$</td>\n<td style=\"text-align:center\">$σ^2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指数分布~$E(λ)$</td>\n<td style=\"text-align:center\">$f(x) = \\begin{cases}  \\lambda e^{-x\\lambda} &amp;{x&gt;0} \\\\ 0&amp;{其他}\\end{cases}$</td>\n<td style=\"text-align:center\">$\\frac{1}{\\lambda}$</td>\n<td style=\"text-align:center\">$\\frac{1}{\\lambda^2}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"切比雪夫不等式\"><a href=\"#切比雪夫不等式\" class=\"headerlink\" title=\"切比雪夫不等式\"></a>切比雪夫不等式</h1><p>切比雪夫不等式的定义如下：</p>\n<p>设随机变量 $X$ 具有数学期望 $E(X)=μ$, 方差 $D(X)=σ^2$, 则对于任意正数 $ϵ$, 下面的不等式成立</p>\n<script type=\"math/tex; mode=display\">P(|X-\\mu|\\ge \\epsilon) \\le \\frac{\\sigma^2}{\\epsilon^2}</script><p>从定义可知，切比雪夫不等式也可写成如下的形式：</p>\n<script type=\"math/tex; mode=display\">P(|X-\\mu| \\le \\epsilon) \\ge 1 - \\frac{\\sigma^2}{\\epsilon^2}</script><p>切比雪夫不等式的一个重要意义在于当随机变量 $X$ 的分布未知，只知道 $E(X)$ 和 $D(X)$ 的情况下，对于事件 $(|X−μ|≤ϵ)$ 概率的下限的估计。</p>\n<h1 id=\"协方差\"><a href=\"#协方差\" class=\"headerlink\" title=\"协方差\"></a>协方差</h1><p>协方差表达了两个随机变量的相关性，正的协方差表达了正相关性，负的协方差表达了负相关性。协方差为0 表示两者不相关，对于同样的两个随机变量来说，计算出的协方差的绝对值越大，相关性越强。</p>\n<p>协方差的定义入下:</p>\n<script type=\"math/tex; mode=display\">Cov(X,Y)=E[X−E(X)][Y−E(Y)]</script><h2 id=\"协方差有以下性质：\"><a href=\"#协方差有以下性质：\" class=\"headerlink\" title=\"协方差有以下性质：\"></a>协方差有以下性质：</h2><ol>\n<li>$Cov(X,Y)=Cov(Y,X)$</li>\n<li>$Cov(X,Y)=E(XY)−E(X)E(Y)$</li>\n<li>$Cov(aX,bY)=abCov(X,Y)$（a，b是常数）</li>\n<li>$Cov(X_1+X_2, Y) = Cov(X_1, Y) + Cov(X_2,Y)$</li>\n</ol>\n<h2 id=\"相关系数\"><a href=\"#相关系数\" class=\"headerlink\" title=\"相关系数\"></a>相关系数</h2><p>假如我们现在有身高和体重这两个未知变量，对于一系列的样本我们算出的的协方差为30，那这究竟是多大的一个量呢？如果我们又发现，身高与鞋号的协方差为5，是否说明，相对于鞋号，身高与体重的的相关性更强呢？</p>\n<p>为了能进行这样的横向对比，我们计算相关系数(correlation coefficient)， 相关系数相当于是“归一化”的协方差。</p>\n<script type=\"math/tex; mode=display\">\\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}}</script><p>相关系数是用协方差除以两个随机变量的标准差。<strong>相关系数的大小在-1和1之间变化，等于0表示不相关</strong>。再也不会出现因为计量单位变化，而数值变化较大的情况，而相关系数的大小的含义与协方差是一样的。</p>\n<p>需要注意的是上面提到的<strong>相关</strong>均指<strong>线性相关</strong>，$X,Y$ 不相关是指 $X,Y$ 之间不存在线性关系，但是他们还可能存在除线性关系以外的关系。因此，有以下结论: <strong>$X,Y$ 相互独立则 $X,Y$ 一定不相关；反之 $X,Y$ 不相关，两者不一定相互独立。</strong></p>\n<h1 id=\"矩和协方差矩阵\"><a href=\"#矩和协方差矩阵\" class=\"headerlink\" title=\"矩和协方差矩阵\"></a>矩和协方差矩阵</h1><h2 id=\"矩\"><a href=\"#矩\" class=\"headerlink\" title=\"矩\"></a>矩</h2><p>下面介绍概率论中几种矩的定义</p>\n<p>设 $X,Y$ 为随机变量,则</p>\n<ol>\n<li>$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩</li>\n<li>$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距</li>\n<li>$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩</li>\n<li>$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩</li>\n</ol>\n<p>由以上定义我们可以知道，随机变量的期望是其<strong>一阶原点矩，方差是其二阶中心距，协方差是其二阶混合中心矩。</strong></p>\n<h2 id=\"协方差矩阵\"><a href=\"#协方差矩阵\" class=\"headerlink\" title=\"协方差矩阵\"></a>协方差矩阵</h2><p>除此之外，另外一个常用的概念是协方差矩阵， 其定义如下：</p>\n<p>对于 $n$ 维随机变量 ($(X_1,X_2,X_3…,X_n)$) 构成的矩阵</p>\n<script type=\"math/tex; mode=display\">C= \\begin{bmatrix} c_{11} & c_{12} & \\cdots & c_{1n} \\\\ c_{21} & c_{22} & \\cdots & c_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ c_{n1} & c_{n2} & \\cdots & c_{nn} \\\\ \\end{bmatrix}</script><p>其中各个元素为</p>\n<script type=\"math/tex; mode=display\">c_{ij} = Cov(X_i,X_j) = E((X_i - E[X_i])(X_j - E[X_j]))，i,j=1,2,3..n</script><p>则称矩阵 $C$ 为协方差矩阵，由于 $c_{ij} = c_{ji}$ ， 因此上面的矩阵为一个对称矩阵。</p>\n<p>协方差矩阵其实是将二维随机变量的协方差一般化后拓展到了 $n$ 维随机变量上的一种表示形式，但是除了作为一种表示形式以外，协方差矩阵还存在着某些性质使得其在多个领域均有应用，如主成成分分析。</p>\n","site":{"data":{}},"excerpt":"<p>随机变量的统计特征主要包括期望，方差，协方差以及相关系数。<br></p>","more":"<p></p>\n<h1 id=\"期望\"><a href=\"#期望\" class=\"headerlink\" title=\"期望\"></a>期望</h1><ul>\n<li>离散型随机变量：<script type=\"math/tex; mode=display\">E(X) = \\sum_{k=1}^{ +\\infty}p_kx_k</script></li>\n<li>连续型随机变量：<script type=\"math/tex; mode=display\">E(X) = \\int_{-\\infty}^{ +\\infty} {xf(x)dx}</script></li>\n</ul>\n<h2 id=\"期望有以下性质-C为常数-其他均为随机变量\"><a href=\"#期望有以下性质-C为常数-其他均为随机变量\" class=\"headerlink\" title=\"期望有以下性质(C为常数,其他均为随机变量):\"></a>期望有以下性质(C为常数,其他均为随机变量):</h2><ol>\n<li>$E(C)=C$</li>\n<li>$E(CX)=CE(X)$</li>\n<li>$E(X+Y)=E(X)+E(Y)$</li>\n<li>$E(XY)=E(X)E(Y)$ （$X,Y$ 相互独立）</li>\n</ol>\n<h2 id=\"随机变量-X-的函数的期望\"><a href=\"#随机变量-X-的函数的期望\" class=\"headerlink\" title=\"随机变量 $X$ 的函数的期望\"></a>随机变量 $X$ 的函数的期望</h2><p>前面讨论随机变量的分布函数时，同时讨论了随机变量的函数的分布函数，这里同样对于<strong>随机变量 $X$ 的函数的期望</strong>进行讨论，其定义及求法如下所示。</p>\n<p>设 $Y$ 是随机变量 $X$ 的函数：$Y=g(X)$ ( $g$ 是连续函数)</p>\n<ol>\n<li>如果 $X$ 是离散型随机变量，它的分布律为<script type=\"math/tex; mode=display\">P(X=x_k) = p_k, k = 1,2,…</script>若 $\\sum_{k=1}^{\\infty}g(x_k)p_k$ 绝对收敛，则有<script type=\"math/tex; mode=display\">E(Y) = E[g(X)] = \\sum_{k=1}^{\\infty}g(x_k)p_k</script></li>\n<li>如果 $X$ 是连续型随机变量，它的概率密度函数为 $f(x)$, 若 $\\int_{-\\infty}^{\\infty}g(x)f(x)dx$ 绝对收敛，则有<script type=\"math/tex; mode=display\">E(Y) = E[g(X)] = \\int_{-\\infty}^{\\infty}g(x)f(x)dx</script></li>\n</ol>\n<p>这个定理的重要意义在于求 $E(Y)$ 的时候，不用再求 $Y$ 的分布律或概率密度函数，直接利用 $X$ 的分布律或概率密度函数即可。</p>\n<h1 id=\"方差\"><a href=\"#方差\" class=\"headerlink\" title=\"方差\"></a>方差</h1><p>方差的原始定义为</p>\n<script type=\"math/tex; mode=display\">D(X) = E[(X-E(X))^2] = E(X^2) - E(X)^2</script><h2 id=\"方差有以下性质：\"><a href=\"#方差有以下性质：\" class=\"headerlink\" title=\"方差有以下性质：\"></a>方差有以下性质：</h2><ol>\n<li>$D(C)=0$</li>\n<li>$D(CX)=C^2D(X)$</li>\n<li>$D(X+Y)=D(X)+D(Y)+2E([X−E(X)][Y−E(Y)])$<br>如果 $X，Y$ 是相互独立的，那么 $E([X−E(X)][Y−E(Y)])=0$ , 当这一项不为0的时候，称作变量 $X,Y$ 的协方差。</li>\n</ol>\n<h1 id=\"常见分布的期望和方差\"><a href=\"#常见分布的期望和方差\" class=\"headerlink\" title=\"常见分布的期望和方差\"></a>常见分布的期望和方差</h1><p>前面我们提到了若干种典型的离散分布和连续分布，下面是这几种分布的期望和方差，记住这些常用的期望和方差能够在使用的时候省去推导过程。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分布类型</th>\n<th style=\"text-align:center\">概率密度函数</th>\n<th style=\"text-align:center\">期望</th>\n<th style=\"text-align:center\">方差</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">伯努利分布~$B(1,p)$</td>\n<td style=\"text-align:center\">$p = p^x(1-p)^{1-x}$</td>\n<td style=\"text-align:center\">$p$</td>\n<td style=\"text-align:center\">$p(1−p)$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">二项分布~$B(n,p)$</td>\n<td style=\"text-align:center\">$p_i = C_n^i p^i(1-p)^{n-i}(i=1,2)$</td>\n<td style=\"text-align:center\">$np$</td>\n<td style=\"text-align:center\">$np(1−p)$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">泊松分布~$P(λ)$</td>\n<td style=\"text-align:center\">$p_i = \\frac{\\lambda^ki e^{-\\lambda}}{i!}(i = 1,2,…)$</td>\n<td style=\"text-align:center\">$λ$</td>\n<td style=\"text-align:center\">$λ$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">均匀分布~$U(a,b)$</td>\n<td style=\"text-align:center\">$f(x) = \\frac{1}{b-a}$</td>\n<td style=\"text-align:center\">$\\frac{a+b}{2}$</td>\n<td style=\"text-align:center\">$\\frac{(b-a)^2}{12}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">正态分布~$N(μ,σ^2)$</td>\n<td style=\"text-align:center\">$f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$</td>\n<td style=\"text-align:center\">$μ$</td>\n<td style=\"text-align:center\">$σ^2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">指数分布~$E(λ)$</td>\n<td style=\"text-align:center\">$f(x) = \\begin{cases}  \\lambda e^{-x\\lambda} &amp;{x&gt;0} \\\\ 0&amp;{其他}\\end{cases}$</td>\n<td style=\"text-align:center\">$\\frac{1}{\\lambda}$</td>\n<td style=\"text-align:center\">$\\frac{1}{\\lambda^2}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"切比雪夫不等式\"><a href=\"#切比雪夫不等式\" class=\"headerlink\" title=\"切比雪夫不等式\"></a>切比雪夫不等式</h1><p>切比雪夫不等式的定义如下：</p>\n<p>设随机变量 $X$ 具有数学期望 $E(X)=μ$, 方差 $D(X)=σ^2$, 则对于任意正数 $ϵ$, 下面的不等式成立</p>\n<script type=\"math/tex; mode=display\">P(|X-\\mu|\\ge \\epsilon) \\le \\frac{\\sigma^2}{\\epsilon^2}</script><p>从定义可知，切比雪夫不等式也可写成如下的形式：</p>\n<script type=\"math/tex; mode=display\">P(|X-\\mu| \\le \\epsilon) \\ge 1 - \\frac{\\sigma^2}{\\epsilon^2}</script><p>切比雪夫不等式的一个重要意义在于当随机变量 $X$ 的分布未知，只知道 $E(X)$ 和 $D(X)$ 的情况下，对于事件 $(|X−μ|≤ϵ)$ 概率的下限的估计。</p>\n<h1 id=\"协方差\"><a href=\"#协方差\" class=\"headerlink\" title=\"协方差\"></a>协方差</h1><p>协方差表达了两个随机变量的相关性，正的协方差表达了正相关性，负的协方差表达了负相关性。协方差为0 表示两者不相关，对于同样的两个随机变量来说，计算出的协方差的绝对值越大，相关性越强。</p>\n<p>协方差的定义入下:</p>\n<script type=\"math/tex; mode=display\">Cov(X,Y)=E[X−E(X)][Y−E(Y)]</script><h2 id=\"协方差有以下性质：\"><a href=\"#协方差有以下性质：\" class=\"headerlink\" title=\"协方差有以下性质：\"></a>协方差有以下性质：</h2><ol>\n<li>$Cov(X,Y)=Cov(Y,X)$</li>\n<li>$Cov(X,Y)=E(XY)−E(X)E(Y)$</li>\n<li>$Cov(aX,bY)=abCov(X,Y)$（a，b是常数）</li>\n<li>$Cov(X_1+X_2, Y) = Cov(X_1, Y) + Cov(X_2,Y)$</li>\n</ol>\n<h2 id=\"相关系数\"><a href=\"#相关系数\" class=\"headerlink\" title=\"相关系数\"></a>相关系数</h2><p>假如我们现在有身高和体重这两个未知变量，对于一系列的样本我们算出的的协方差为30，那这究竟是多大的一个量呢？如果我们又发现，身高与鞋号的协方差为5，是否说明，相对于鞋号，身高与体重的的相关性更强呢？</p>\n<p>为了能进行这样的横向对比，我们计算相关系数(correlation coefficient)， 相关系数相当于是“归一化”的协方差。</p>\n<script type=\"math/tex; mode=display\">\\rho_{XY} = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}}</script><p>相关系数是用协方差除以两个随机变量的标准差。<strong>相关系数的大小在-1和1之间变化，等于0表示不相关</strong>。再也不会出现因为计量单位变化，而数值变化较大的情况，而相关系数的大小的含义与协方差是一样的。</p>\n<p>需要注意的是上面提到的<strong>相关</strong>均指<strong>线性相关</strong>，$X,Y$ 不相关是指 $X,Y$ 之间不存在线性关系，但是他们还可能存在除线性关系以外的关系。因此，有以下结论: <strong>$X,Y$ 相互独立则 $X,Y$ 一定不相关；反之 $X,Y$ 不相关，两者不一定相互独立。</strong></p>\n<h1 id=\"矩和协方差矩阵\"><a href=\"#矩和协方差矩阵\" class=\"headerlink\" title=\"矩和协方差矩阵\"></a>矩和协方差矩阵</h1><h2 id=\"矩\"><a href=\"#矩\" class=\"headerlink\" title=\"矩\"></a>矩</h2><p>下面介绍概率论中几种矩的定义</p>\n<p>设 $X,Y$ 为随机变量,则</p>\n<ol>\n<li>$E(X^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩</li>\n<li>$E((X-E[X])^k), k=1,2,3….$ 称为 $X$ 的 $k$ 阶中心距</li>\n<li>$E(X^kY^l),k,l=1,2,…$ 称为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩</li>\n<li>$E((X-E[X])^k(Y-E[Y])^l)),k,l=1,2,…$称为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩</li>\n</ol>\n<p>由以上定义我们可以知道，随机变量的期望是其<strong>一阶原点矩，方差是其二阶中心距，协方差是其二阶混合中心矩。</strong></p>\n<h2 id=\"协方差矩阵\"><a href=\"#协方差矩阵\" class=\"headerlink\" title=\"协方差矩阵\"></a>协方差矩阵</h2><p>除此之外，另外一个常用的概念是协方差矩阵， 其定义如下：</p>\n<p>对于 $n$ 维随机变量 ($(X_1,X_2,X_3…,X_n)$) 构成的矩阵</p>\n<script type=\"math/tex; mode=display\">C= \\begin{bmatrix} c_{11} & c_{12} & \\cdots & c_{1n} \\\\ c_{21} & c_{22} & \\cdots & c_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ c_{n1} & c_{n2} & \\cdots & c_{nn} \\\\ \\end{bmatrix}</script><p>其中各个元素为</p>\n<script type=\"math/tex; mode=display\">c_{ij} = Cov(X_i,X_j) = E((X_i - E[X_i])(X_j - E[X_j]))，i,j=1,2,3..n</script><p>则称矩阵 $C$ 为协方差矩阵，由于 $c_{ij} = c_{ji}$ ， 因此上面的矩阵为一个对称矩阵。</p>\n<p>协方差矩阵其实是将二维随机变量的协方差一般化后拓展到了 $n$ 维随机变量上的一种表示形式，但是除了作为一种表示形式以外，协方差矩阵还存在着某些性质使得其在多个领域均有应用，如主成成分分析。</p>"},{"title":"静态链表","date":"2018-08-28T13:52:49.000Z","_content":"","source":"_posts/静态链表.md","raw":"---\ntitle: 静态链表\ndate: 2018-08-28 21:52:49\ntags:\n---\n","slug":"静态链表","published":1,"updated":"2019-07-30T01:54:38.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1f006lhomjcvt7zu06","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"随机森林","date":"2017-08-26T11:16:35.000Z","_content":"## Bagging（套袋法）\nbagging的算法过程如下：\n\n1. 从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）\n1. 对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）\n1. 对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）\n<!--more-->\n\n# 随机森林\n鉴于决策树容易过拟合的缺点，随机森林采用多个决策树的投票机制来改善决策树，其中每棵树都和其他树略有不同，随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保证树的预测能力，这可以在数学上严格证明。\n\n1. 从原始训练集中使用Bootstraping方法随机有放回采样选出m个样本，共进行n_tree次采样，生成n_tree个训练集\n1. 对于n_tree个训练集，我们分别训练n_tree个决策树模型\n1. 对于单个决策树模型，假设训练样本特征的个数为n，那么每次分裂时根据信息增益/信息增益比/基尼指数选择最好的特征进行分裂\n1. 每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝\n1. 将生成的多棵决策树组成随机森林。对于分类问题，按多棵树分类器投票决定最终分类结果；对于回归问题，由多棵树预测值的均值决定最终预测结果\n","source":"_posts/随机森林.md","raw":"---\ntitle: 随机森林\ndate: 2017-08-26 19:16:35\ntags: [人工智能,模型,树模型,集成学习]\ncategories: [机器学习]\n---\n## Bagging（套袋法）\nbagging的算法过程如下：\n\n1. 从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）\n1. 对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）\n1. 对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）\n<!--more-->\n\n# 随机森林\n鉴于决策树容易过拟合的缺点，随机森林采用多个决策树的投票机制来改善决策树，其中每棵树都和其他树略有不同，随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保证树的预测能力，这可以在数学上严格证明。\n\n1. 从原始训练集中使用Bootstraping方法随机有放回采样选出m个样本，共进行n_tree次采样，生成n_tree个训练集\n1. 对于n_tree个训练集，我们分别训练n_tree个决策树模型\n1. 对于单个决策树模型，假设训练样本特征的个数为n，那么每次分裂时根据信息增益/信息增益比/基尼指数选择最好的特征进行分裂\n1. 每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝\n1. 将生成的多棵决策树组成随机森林。对于分类问题，按多棵树分类器投票决定最终分类结果；对于回归问题，由多棵树预测值的均值决定最终预测结果\n","slug":"随机森林","published":1,"updated":"2019-07-30T01:54:38.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1h006ohomj791s4lgv","content":"<h2 id=\"Bagging（套袋法）\"><a href=\"#Bagging（套袋法）\" class=\"headerlink\" title=\"Bagging（套袋法）\"></a>Bagging（套袋法）</h2><p>bagging的算法过程如下：</p>\n<ol>\n<li>从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）</li>\n<li>对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）</li>\n<li>对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h1><p>鉴于决策树容易过拟合的缺点，随机森林采用多个决策树的投票机制来改善决策树，其中每棵树都和其他树略有不同，随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保证树的预测能力，这可以在数学上严格证明。</p>\n<ol>\n<li>从原始训练集中使用Bootstraping方法随机有放回采样选出m个样本，共进行n_tree次采样，生成n_tree个训练集</li>\n<li>对于n_tree个训练集，我们分别训练n_tree个决策树模型</li>\n<li>对于单个决策树模型，假设训练样本特征的个数为n，那么每次分裂时根据信息增益/信息增益比/基尼指数选择最好的特征进行分裂</li>\n<li>每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝</li>\n<li>将生成的多棵决策树组成随机森林。对于分类问题，按多棵树分类器投票决定最终分类结果；对于回归问题，由多棵树预测值的均值决定最终预测结果</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Bagging（套袋法）\"><a href=\"#Bagging（套袋法）\" class=\"headerlink\" title=\"Bagging（套袋法）\"></a>Bagging（套袋法）</h2><p>bagging的算法过程如下：</p>\n<ol>\n<li>从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）</li>\n<li>对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）</li>\n<li>对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）</li></ol>","more":"\n\n<h1 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h1><p>鉴于决策树容易过拟合的缺点，随机森林采用多个决策树的投票机制来改善决策树，其中每棵树都和其他树略有不同，随机森林背后的思想是，每棵树的预测可能都相对较好，但可能对部分数据过拟合。如果构造很多树，并且每棵树的预测都很好，但都以不同的方式过拟合，那么我们可以对这些树的结果取平均值来降低过拟合。既能减少过拟合又能保证树的预测能力，这可以在数学上严格证明。</p>\n<ol>\n<li>从原始训练集中使用Bootstraping方法随机有放回采样选出m个样本，共进行n_tree次采样，生成n_tree个训练集</li>\n<li>对于n_tree个训练集，我们分别训练n_tree个决策树模型</li>\n<li>对于单个决策树模型，假设训练样本特征的个数为n，那么每次分裂时根据信息增益/信息增益比/基尼指数选择最好的特征进行分裂</li>\n<li>每棵树都一直这样分裂下去，直到该节点的所有训练样例都属于同一类。在决策树的分裂过程中不需要剪枝</li>\n<li>将生成的多棵决策树组成随机森林。对于分类问题，按多棵树分类器投票决定最终分类结果；对于回归问题，由多棵树预测值的均值决定最终预测结果</li>\n</ol>"},{"title":"评估模型","date":"2019-08-07T10:22:37.000Z","_content":"\n\n\n| 真实类别 | 预测为正例 | 预测为反例 |\n| :------: | :--------: | :--------: |\n|   正例   | TP(真正例) | FN(假反例) |\n|   反例   | FP(假正例) | TN(真反例) |\n\n<!--more-->\n\n# 准确率、错误率、召回率、查准率\n\n| 名称                         | 公式                        | 说明                                                   |\n| ---------------------------- | --------------------------- | ------------------------------------------------------ |\n| 准确率（$Accuracy$）         | $\\frac{TP+TN}{TP+TN+FP+FN}$ | 预测正确的比例                                         |\n| 错误率（$Error$）            | $\\frac{FP+FN}{TP+TN+FP+FN}$ | 预测错误的比例                                         |\n| 召回率/查全率（$Recall$）    | $\\frac {TP}{TP+FN}$         | 真正例被预测正确的比例。有多少好瓜被选出来             |\n| 精确率/查准率（$Precision$） | $\\frac{TP}{TP+FP}$          | 预测为正例中正确的比例。预测为的好瓜的类别中有多少好瓜 |\n\n# P-R曲线、F1指数\n\n一般来说， 查准率高的时候，召回率偏低；召回率高的时候，查准率往往降低。以西瓜问题为例：查准率指的是所有预测为好瓜的西瓜中，真正的好瓜所占的比例；召回率指的是真正的好瓜中，有多少好瓜被挑出来了。如果所有西瓜都预测为好瓜则召回率为1，但是查准率就会降低因为所有坏瓜也预测为了好瓜。\n\n## P-R曲线\n\n以查准率P为纵轴，召回率R为横轴作图，就得到了查准率-召回率曲线，称为“P-R曲线”。\n\n![1565235635992](评估模型/1565235635992.png) \n$$\ny轴-查准率（精确率）P = \\frac {TP} {TP+FP} \\\\ \nx轴-查全率（召回率）R = \\frac {TP} {TP+FN}\n$$\n在比较两个模型的性能时，**如果一个学习器的P-R曲线被另外一个学习器P-R曲线包住，那么后者的性能优于前者（此时后者的查全率跟查准率都高于前者）**，如上图，A的性能优于C，B的性能也优于C；如果两个学习器的曲线有交叉点（如A和B），那么难以断定两个学习器性能的优劣，只能在具体的查准率或者查全率条件下进行比较。\n\n## 平衡点\n\n如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1度量断定两个学习器性能的优劣 \n**平衡点**(Break-Even Point，简称BEP)指得是“P=R”时候的取值，如上图，C的的BEP是0.64,。基于BEP的比较，可以认为学习器A优于B。\n\n## F1指数\n\n如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1指数断定两个学习器性能的优劣。BEP过于简单，更常用的是F1指数。F1指数实际为查准率和召回率的调和平均数。例如小明跑步10公里，前面5公里用了1小时，后面5公里用了2小时，其平均速度为$\\frac{10}{v}=(\\frac {5}{1}+\f \\frac {5}{2})$\n$$\n\\frac 1 {F1} =\\frac 1 2 (\\frac 1{P}+\\frac 1 R)\n$$\n\n## $F_\\beta$指数\n\n对于特定的应用场景，查准率和查全率的重视度是不一样的。例如在追捕逃犯时，希望尽可能的不遗漏逃犯，因此查全率较为重要；而在搜索引擎的搜索过程中，希望给用户精准的搜索信息，因此查准率更为重要。F1度量的更一般形式——$F_β$，修改了路程 \n$$\n\\frac{1}{F_\\beta }=\\frac{1}{1+\\beta ^2}(\\frac{1}{P}+\\frac{\\beta ^2}{R})\\\\\n$$\n$β=R/P$ ，其中$β$值越大召回率越重要，$β$值越小查准率越重要。$β$值为两者重要性的比例\n\n# G-mean指数\n\nG-mean是正例准确率与负例准确率的综合指标。**与F1的比较**：在数据平衡度不是很大的情况下，F1和G-mean可以作为较好的评测指标，但是当训练样本很不平衡时，F1更好。\n$$\nG - mean = \\sqrt{\\frac {TP}{TP+FN}\\times \\frac {TN}{TN+FP}} = \\sqrt {查全率（召回率）真正例率 \\times 真负例率}\n$$\n\n# ROC曲线与AUC\n\n## ROC曲线\n\n![1565246937404](评估模型/1565246937404.png)\n$$\ny轴-真正例率 TPR = \\frac {TP}{TP+FN} \\\\\nx轴-假正例率 FPR = \\frac {FP}{TN+FP}\n$$\n真正例率指的是真实正例中有多少被预测为正例，假正例率指的是真实反例中有多少被预测为正例。**可以看出TPR和Recall的形式是一样的，就是查全率了，FPR就是保证这样的查全率你所要付出的代价，就是把多少负样本也分成了正的了。**如果所有西瓜都预测为好瓜则查全率为1，但是假正例率也会升高因为所有坏瓜也预测为了好瓜。\n\n### 举例计算\n\n假设有4个样本，样本的标签分别为 $0,1,0,1$；模型的预测概率分别为$0.1,0.35,0.4,0.8$；\n\n| label | 0    | 1    | 0    | 1    |\n| ----- | ---- | ---- | ---- | ---- |\n| pred  | 0.1  | 0.35 | 0.4  | 0.8  |\n| 阈值  | 0.1  | 0.35 | 0.4  | 0.8  |\n\n那么在阈值分别取$0.1, 0.35, 0.4, 0.8$的时候。分别判断出每个`pred`是`TP/FP/TN/FP`中的哪个，进而得出当前阈值下的`TPR`和`FPR`，也就是`(FPR, TPR)`这一ROC曲线图上的点；对于所有阈值都计算相应的`(FPR, TPR)`,则得到完整的ROC曲线上的几个关键点。\n\n| 阈值 | 样本1 | 样本2 | 样本3 | 样本4 | $TPR=\\frac {TP}{TP+FN}$ | $FPR\\frac {FP}{TN+FP}$ |\n| ---- | ----- | ----- | ----- | ----- | ----------------------- | ---------------------- |\n| 0.1  | FP    | TP    | FP    | TP    | $\\frac{2}{2+0}=1$       | $\\frac{2}{0+2}=1$      |\n| 0.35 | TN    | TP    | FP    | TP    | $\\frac{2}{2+0}= 1 $     | $\\frac{1}{1+1}=0.5$    |\n| 0.4  | TN    | FN    | FP    | TP    | $\\frac{1}{1+1}=0.5$     | $\\frac{1}{1+1}=0.5 $   |\n| 0.8  | TN    | FN    | TN    | TP    | $\\frac {1} {1+1}=0.5$   | 0                      |\n\n![1565855471447](评估模型/1565855471447.png)\n\n## AUC指数\n\nAUC：**ROC曲线的线下面积。**与P-R曲线类似，如果学习器A的ROC曲线被学习器B完全“包住”，那么后者性能优于前者（相同的假正例率，其真正例率更高）。但是当两个曲线有交点时，则需要比较曲线下的面积AUC(Area Under ROC Curve)。\n\n# k-s指标\n\nK-S(Kolmogorov-Smirnov)统计量越大，表示模型能够将正、负客户区分开的程度越大。KS值的取值范围是[0，1] \n\n## ks曲线\n$$\nTPR = TP/(TP+FN) \\\\\nFPR = FP/(FP+TN)\n$$\n洛伦兹线：两条线，其横轴是模型评分的阈值，纵轴是$TPR$（真正类率）与$FPR$（假正类率）的值\n\nK-S曲线：洛伦兹线中两条线的差值（$TPR-FPR$），值范围[0，1] 。\n\n![img](评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg)\n\n\n\n我们用一个风控模型预测一个人是好人的概率，图中黑线的洛伦兹线（$TPR$与$FPR$）、红线的ks曲线。横坐标是模型评分的阈值，当阈值为0时，所有的用户被预测为坏用户，$TPR=FPR=0$；当阈值为1时，所有用户被预测为好用户，$TPR=FPR=1$。\n\n这两条曲线之间的差值（$TPR-FPR$），就是K-S曲线。如图所示，给定一个通过率20%（拒绝率80%），则该模型可以挑出来60%的好人，同时漏进来8%的坏人（92%的坏人都被拒绝掉了）。那么K-S曲线在这个通过率上的值，就是60%-8%=0.52。\n\n## K-S统计量\n\nK-S曲线中的最大值被称为K-S统计量。其取值在0到1之间。如果是随机抽样，好人的洛伦兹曲线跟坏人的是重合的，K-S统计量为0。而最理想的风控模型，好人和坏人完全分开，K-S统计量的值为1。\n\n","source":"_posts/评估模型.md","raw":"---\ntitle: 评估模型\ndate: 2019-08-07 18:22:37\ntags: [人工智能,评估]\ncategories: 机器学习\n---\n\n\n\n| 真实类别 | 预测为正例 | 预测为反例 |\n| :------: | :--------: | :--------: |\n|   正例   | TP(真正例) | FN(假反例) |\n|   反例   | FP(假正例) | TN(真反例) |\n\n<!--more-->\n\n# 准确率、错误率、召回率、查准率\n\n| 名称                         | 公式                        | 说明                                                   |\n| ---------------------------- | --------------------------- | ------------------------------------------------------ |\n| 准确率（$Accuracy$）         | $\\frac{TP+TN}{TP+TN+FP+FN}$ | 预测正确的比例                                         |\n| 错误率（$Error$）            | $\\frac{FP+FN}{TP+TN+FP+FN}$ | 预测错误的比例                                         |\n| 召回率/查全率（$Recall$）    | $\\frac {TP}{TP+FN}$         | 真正例被预测正确的比例。有多少好瓜被选出来             |\n| 精确率/查准率（$Precision$） | $\\frac{TP}{TP+FP}$          | 预测为正例中正确的比例。预测为的好瓜的类别中有多少好瓜 |\n\n# P-R曲线、F1指数\n\n一般来说， 查准率高的时候，召回率偏低；召回率高的时候，查准率往往降低。以西瓜问题为例：查准率指的是所有预测为好瓜的西瓜中，真正的好瓜所占的比例；召回率指的是真正的好瓜中，有多少好瓜被挑出来了。如果所有西瓜都预测为好瓜则召回率为1，但是查准率就会降低因为所有坏瓜也预测为了好瓜。\n\n## P-R曲线\n\n以查准率P为纵轴，召回率R为横轴作图，就得到了查准率-召回率曲线，称为“P-R曲线”。\n\n![1565235635992](评估模型/1565235635992.png) \n$$\ny轴-查准率（精确率）P = \\frac {TP} {TP+FP} \\\\ \nx轴-查全率（召回率）R = \\frac {TP} {TP+FN}\n$$\n在比较两个模型的性能时，**如果一个学习器的P-R曲线被另外一个学习器P-R曲线包住，那么后者的性能优于前者（此时后者的查全率跟查准率都高于前者）**，如上图，A的性能优于C，B的性能也优于C；如果两个学习器的曲线有交叉点（如A和B），那么难以断定两个学习器性能的优劣，只能在具体的查准率或者查全率条件下进行比较。\n\n## 平衡点\n\n如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1度量断定两个学习器性能的优劣 \n**平衡点**(Break-Even Point，简称BEP)指得是“P=R”时候的取值，如上图，C的的BEP是0.64,。基于BEP的比较，可以认为学习器A优于B。\n\n## F1指数\n\n如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1指数断定两个学习器性能的优劣。BEP过于简单，更常用的是F1指数。F1指数实际为查准率和召回率的调和平均数。例如小明跑步10公里，前面5公里用了1小时，后面5公里用了2小时，其平均速度为$\\frac{10}{v}=(\\frac {5}{1}+\f \\frac {5}{2})$\n$$\n\\frac 1 {F1} =\\frac 1 2 (\\frac 1{P}+\\frac 1 R)\n$$\n\n## $F_\\beta$指数\n\n对于特定的应用场景，查准率和查全率的重视度是不一样的。例如在追捕逃犯时，希望尽可能的不遗漏逃犯，因此查全率较为重要；而在搜索引擎的搜索过程中，希望给用户精准的搜索信息，因此查准率更为重要。F1度量的更一般形式——$F_β$，修改了路程 \n$$\n\\frac{1}{F_\\beta }=\\frac{1}{1+\\beta ^2}(\\frac{1}{P}+\\frac{\\beta ^2}{R})\\\\\n$$\n$β=R/P$ ，其中$β$值越大召回率越重要，$β$值越小查准率越重要。$β$值为两者重要性的比例\n\n# G-mean指数\n\nG-mean是正例准确率与负例准确率的综合指标。**与F1的比较**：在数据平衡度不是很大的情况下，F1和G-mean可以作为较好的评测指标，但是当训练样本很不平衡时，F1更好。\n$$\nG - mean = \\sqrt{\\frac {TP}{TP+FN}\\times \\frac {TN}{TN+FP}} = \\sqrt {查全率（召回率）真正例率 \\times 真负例率}\n$$\n\n# ROC曲线与AUC\n\n## ROC曲线\n\n![1565246937404](评估模型/1565246937404.png)\n$$\ny轴-真正例率 TPR = \\frac {TP}{TP+FN} \\\\\nx轴-假正例率 FPR = \\frac {FP}{TN+FP}\n$$\n真正例率指的是真实正例中有多少被预测为正例，假正例率指的是真实反例中有多少被预测为正例。**可以看出TPR和Recall的形式是一样的，就是查全率了，FPR就是保证这样的查全率你所要付出的代价，就是把多少负样本也分成了正的了。**如果所有西瓜都预测为好瓜则查全率为1，但是假正例率也会升高因为所有坏瓜也预测为了好瓜。\n\n### 举例计算\n\n假设有4个样本，样本的标签分别为 $0,1,0,1$；模型的预测概率分别为$0.1,0.35,0.4,0.8$；\n\n| label | 0    | 1    | 0    | 1    |\n| ----- | ---- | ---- | ---- | ---- |\n| pred  | 0.1  | 0.35 | 0.4  | 0.8  |\n| 阈值  | 0.1  | 0.35 | 0.4  | 0.8  |\n\n那么在阈值分别取$0.1, 0.35, 0.4, 0.8$的时候。分别判断出每个`pred`是`TP/FP/TN/FP`中的哪个，进而得出当前阈值下的`TPR`和`FPR`，也就是`(FPR, TPR)`这一ROC曲线图上的点；对于所有阈值都计算相应的`(FPR, TPR)`,则得到完整的ROC曲线上的几个关键点。\n\n| 阈值 | 样本1 | 样本2 | 样本3 | 样本4 | $TPR=\\frac {TP}{TP+FN}$ | $FPR\\frac {FP}{TN+FP}$ |\n| ---- | ----- | ----- | ----- | ----- | ----------------------- | ---------------------- |\n| 0.1  | FP    | TP    | FP    | TP    | $\\frac{2}{2+0}=1$       | $\\frac{2}{0+2}=1$      |\n| 0.35 | TN    | TP    | FP    | TP    | $\\frac{2}{2+0}= 1 $     | $\\frac{1}{1+1}=0.5$    |\n| 0.4  | TN    | FN    | FP    | TP    | $\\frac{1}{1+1}=0.5$     | $\\frac{1}{1+1}=0.5 $   |\n| 0.8  | TN    | FN    | TN    | TP    | $\\frac {1} {1+1}=0.5$   | 0                      |\n\n![1565855471447](评估模型/1565855471447.png)\n\n## AUC指数\n\nAUC：**ROC曲线的线下面积。**与P-R曲线类似，如果学习器A的ROC曲线被学习器B完全“包住”，那么后者性能优于前者（相同的假正例率，其真正例率更高）。但是当两个曲线有交点时，则需要比较曲线下的面积AUC(Area Under ROC Curve)。\n\n# k-s指标\n\nK-S(Kolmogorov-Smirnov)统计量越大，表示模型能够将正、负客户区分开的程度越大。KS值的取值范围是[0，1] \n\n## ks曲线\n$$\nTPR = TP/(TP+FN) \\\\\nFPR = FP/(FP+TN)\n$$\n洛伦兹线：两条线，其横轴是模型评分的阈值，纵轴是$TPR$（真正类率）与$FPR$（假正类率）的值\n\nK-S曲线：洛伦兹线中两条线的差值（$TPR-FPR$），值范围[0，1] 。\n\n![img](评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg)\n\n\n\n我们用一个风控模型预测一个人是好人的概率，图中黑线的洛伦兹线（$TPR$与$FPR$）、红线的ks曲线。横坐标是模型评分的阈值，当阈值为0时，所有的用户被预测为坏用户，$TPR=FPR=0$；当阈值为1时，所有用户被预测为好用户，$TPR=FPR=1$。\n\n这两条曲线之间的差值（$TPR-FPR$），就是K-S曲线。如图所示，给定一个通过率20%（拒绝率80%），则该模型可以挑出来60%的好人，同时漏进来8%的坏人（92%的坏人都被拒绝掉了）。那么K-S曲线在这个通过率上的值，就是60%-8%=0.52。\n\n## K-S统计量\n\nK-S曲线中的最大值被称为K-S统计量。其取值在0到1之间。如果是随机抽样，好人的洛伦兹曲线跟坏人的是重合的，K-S统计量为0。而最理想的风控模型，好人和坏人完全分开，K-S统计量的值为1。\n\n","slug":"评估模型","published":1,"updated":"2019-08-15T11:29:14.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1j006rhomjblh44tau","content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">真实类别</th>\n<th style=\"text-align:center\">预测为正例</th>\n<th style=\"text-align:center\">预测为反例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">正例</td>\n<td style=\"text-align:center\">TP(真正例)</td>\n<td style=\"text-align:center\">FN(假反例)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">反例</td>\n<td style=\"text-align:center\">FP(假正例)</td>\n<td style=\"text-align:center\">TN(真反例)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<a id=\"more\"></a>\n<h1 id=\"准确率、错误率、召回率、查准率\"><a href=\"#准确率、错误率、召回率、查准率\" class=\"headerlink\" title=\"准确率、错误率、召回率、查准率\"></a>准确率、错误率、召回率、查准率</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>公式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>准确率（$Accuracy$）</td>\n<td>$\\frac{TP+TN}{TP+TN+FP+FN}$</td>\n<td>预测正确的比例</td>\n</tr>\n<tr>\n<td>错误率（$Error$）</td>\n<td>$\\frac{FP+FN}{TP+TN+FP+FN}$</td>\n<td>预测错误的比例</td>\n</tr>\n<tr>\n<td>召回率/查全率（$Recall$）</td>\n<td>$\\frac {TP}{TP+FN}$</td>\n<td>真正例被预测正确的比例。有多少好瓜被选出来</td>\n</tr>\n<tr>\n<td>精确率/查准率（$Precision$）</td>\n<td>$\\frac{TP}{TP+FP}$</td>\n<td>预测为正例中正确的比例。预测为的好瓜的类别中有多少好瓜</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"P-R曲线、F1指数\"><a href=\"#P-R曲线、F1指数\" class=\"headerlink\" title=\"P-R曲线、F1指数\"></a>P-R曲线、F1指数</h1><p>一般来说， 查准率高的时候，召回率偏低；召回率高的时候，查准率往往降低。以西瓜问题为例：查准率指的是所有预测为好瓜的西瓜中，真正的好瓜所占的比例；召回率指的是真正的好瓜中，有多少好瓜被挑出来了。如果所有西瓜都预测为好瓜则召回率为1，但是查准率就会降低因为所有坏瓜也预测为了好瓜。</p>\n<h2 id=\"P-R曲线\"><a href=\"#P-R曲线\" class=\"headerlink\" title=\"P-R曲线\"></a>P-R曲线</h2><p>以查准率P为纵轴，召回率R为横轴作图，就得到了查准率-召回率曲线，称为“P-R曲线”。</p>\n<p><img src=\"/2019/08/07/评估模型/1565235635992.png\" alt=\"1565235635992\"> </p>\n<script type=\"math/tex; mode=display\">\ny轴-查准率（精确率）P = \\frac {TP} {TP+FP} \\\\ \nx轴-查全率（召回率）R = \\frac {TP} {TP+FN}</script><p>在比较两个模型的性能时，<strong>如果一个学习器的P-R曲线被另外一个学习器P-R曲线包住，那么后者的性能优于前者（此时后者的查全率跟查准率都高于前者）</strong>，如上图，A的性能优于C，B的性能也优于C；如果两个学习器的曲线有交叉点（如A和B），那么难以断定两个学习器性能的优劣，只能在具体的查准率或者查全率条件下进行比较。</p>\n<h2 id=\"平衡点\"><a href=\"#平衡点\" class=\"headerlink\" title=\"平衡点\"></a>平衡点</h2><p>如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1度量断定两个学习器性能的优劣<br><strong>平衡点</strong>(Break-Even Point，简称BEP)指得是“P=R”时候的取值，如上图，C的的BEP是0.64,。基于BEP的比较，可以认为学习器A优于B。</p>\n<h2 id=\"F1指数\"><a href=\"#F1指数\" class=\"headerlink\" title=\"F1指数\"></a>F1指数</h2><p>如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1指数断定两个学习器性能的优劣。BEP过于简单，更常用的是F1指数。F1指数实际为查准率和召回率的调和平均数。例如小明跑步10公里，前面5公里用了1小时，后面5公里用了2小时，其平均速度为$\\frac{10}{v}=(\\frac {5}{1}+\f \\frac {5}{2})$</p>\n<script type=\"math/tex; mode=display\">\n\\frac 1 {F1} =\\frac 1 2 (\\frac 1{P}+\\frac 1 R)</script><h2 id=\"F-beta-指数\"><a href=\"#F-beta-指数\" class=\"headerlink\" title=\"$F_\\beta$指数\"></a>$F_\\beta$指数</h2><p>对于特定的应用场景，查准率和查全率的重视度是不一样的。例如在追捕逃犯时，希望尽可能的不遗漏逃犯，因此查全率较为重要；而在搜索引擎的搜索过程中，希望给用户精准的搜索信息，因此查准率更为重要。F1度量的更一般形式——$F_β$，修改了路程 </p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{F_\\beta }=\\frac{1}{1+\\beta ^2}(\\frac{1}{P}+\\frac{\\beta ^2}{R})\\\\</script><p>$β=R/P$ ，其中$β$值越大召回率越重要，$β$值越小查准率越重要。$β$值为两者重要性的比例</p>\n<h1 id=\"G-mean指数\"><a href=\"#G-mean指数\" class=\"headerlink\" title=\"G-mean指数\"></a>G-mean指数</h1><p>G-mean是正例准确率与负例准确率的综合指标。<strong>与F1的比较</strong>：在数据平衡度不是很大的情况下，F1和G-mean可以作为较好的评测指标，但是当训练样本很不平衡时，F1更好。</p>\n<script type=\"math/tex; mode=display\">\nG - mean = \\sqrt{\\frac {TP}{TP+FN}\\times \\frac {TN}{TN+FP}} = \\sqrt {查全率（召回率）真正例率 \\times 真负例率}</script><h1 id=\"ROC曲线与AUC\"><a href=\"#ROC曲线与AUC\" class=\"headerlink\" title=\"ROC曲线与AUC\"></a>ROC曲线与AUC</h1><h2 id=\"ROC曲线\"><a href=\"#ROC曲线\" class=\"headerlink\" title=\"ROC曲线\"></a>ROC曲线</h2><p><img src=\"/2019/08/07/评估模型/1565246937404.png\" alt=\"1565246937404\"></p>\n<script type=\"math/tex; mode=display\">\ny轴-真正例率 TPR = \\frac {TP}{TP+FN} \\\\\nx轴-假正例率 FPR = \\frac {FP}{TN+FP}</script><p>真正例率指的是真实正例中有多少被预测为正例，假正例率指的是真实反例中有多少被预测为正例。<strong>可以看出TPR和Recall的形式是一样的，就是查全率了，FPR就是保证这样的查全率你所要付出的代价，就是把多少负样本也分成了正的了。</strong>如果所有西瓜都预测为好瓜则查全率为1，但是假正例率也会升高因为所有坏瓜也预测为了好瓜。</p>\n<h3 id=\"举例计算\"><a href=\"#举例计算\" class=\"headerlink\" title=\"举例计算\"></a>举例计算</h3><p>假设有4个样本，样本的标签分别为 $0,1,0,1$；模型的预测概率分别为$0.1,0.35,0.4,0.8$；</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>label</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pred</td>\n<td>0.1</td>\n<td>0.35</td>\n<td>0.4</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>阈值</td>\n<td>0.1</td>\n<td>0.35</td>\n<td>0.4</td>\n<td>0.8</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>那么在阈值分别取$0.1, 0.35, 0.4, 0.8$的时候。分别判断出每个<code>pred</code>是<code>TP/FP/TN/FP</code>中的哪个，进而得出当前阈值下的<code>TPR</code>和<code>FPR</code>，也就是<code>(FPR, TPR)</code>这一ROC曲线图上的点；对于所有阈值都计算相应的<code>(FPR, TPR)</code>,则得到完整的ROC曲线上的几个关键点。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>阈值</th>\n<th>样本1</th>\n<th>样本2</th>\n<th>样本3</th>\n<th>样本4</th>\n<th>$TPR=\\frac {TP}{TP+FN}$</th>\n<th>$FPR\\frac {FP}{TN+FP}$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.1</td>\n<td>FP</td>\n<td>TP</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{2}{2+0}=1$</td>\n<td>$\\frac{2}{0+2}=1$</td>\n</tr>\n<tr>\n<td>0.35</td>\n<td>TN</td>\n<td>TP</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{2}{2+0}= 1 $</td>\n<td>$\\frac{1}{1+1}=0.5$</td>\n</tr>\n<tr>\n<td>0.4</td>\n<td>TN</td>\n<td>FN</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{1}{1+1}=0.5$</td>\n<td>$\\frac{1}{1+1}=0.5 $</td>\n</tr>\n<tr>\n<td>0.8</td>\n<td>TN</td>\n<td>FN</td>\n<td>TN</td>\n<td>TP</td>\n<td>$\\frac {1} {1+1}=0.5$</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"/2019/08/07/评估模型/1565855471447.png\" alt=\"1565855471447\"></p>\n<h2 id=\"AUC指数\"><a href=\"#AUC指数\" class=\"headerlink\" title=\"AUC指数\"></a>AUC指数</h2><p>AUC：<strong>ROC曲线的线下面积。</strong>与P-R曲线类似，如果学习器A的ROC曲线被学习器B完全“包住”，那么后者性能优于前者（相同的假正例率，其真正例率更高）。但是当两个曲线有交点时，则需要比较曲线下的面积AUC(Area Under ROC Curve)。</p>\n<h1 id=\"k-s指标\"><a href=\"#k-s指标\" class=\"headerlink\" title=\"k-s指标\"></a>k-s指标</h1><p>K-S(Kolmogorov-Smirnov)统计量越大，表示模型能够将正、负客户区分开的程度越大。KS值的取值范围是[0，1] </p>\n<h2 id=\"ks曲线\"><a href=\"#ks曲线\" class=\"headerlink\" title=\"ks曲线\"></a>ks曲线</h2><script type=\"math/tex; mode=display\">\nTPR = TP/(TP+FN) \\\\\nFPR = FP/(FP+TN)</script><p>洛伦兹线：两条线，其横轴是模型评分的阈值，纵轴是$TPR$（真正类率）与$FPR$（假正类率）的值</p>\n<p>K-S曲线：洛伦兹线中两条线的差值（$TPR-FPR$），值范围[0，1] 。</p>\n<p><img src=\"/2019/08/07/评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg\" alt=\"img\"></p>\n<p>我们用一个风控模型预测一个人是好人的概率，图中黑线的洛伦兹线（$TPR$与$FPR$）、红线的ks曲线。横坐标是模型评分的阈值，当阈值为0时，所有的用户被预测为坏用户，$TPR=FPR=0$；当阈值为1时，所有用户被预测为好用户，$TPR=FPR=1$。</p>\n<p>这两条曲线之间的差值（$TPR-FPR$），就是K-S曲线。如图所示，给定一个通过率20%（拒绝率80%），则该模型可以挑出来60%的好人，同时漏进来8%的坏人（92%的坏人都被拒绝掉了）。那么K-S曲线在这个通过率上的值，就是60%-8%=0.52。</p>\n<h2 id=\"K-S统计量\"><a href=\"#K-S统计量\" class=\"headerlink\" title=\"K-S统计量\"></a>K-S统计量</h2><p>K-S曲线中的最大值被称为K-S统计量。其取值在0到1之间。如果是随机抽样，好人的洛伦兹曲线跟坏人的是重合的，K-S统计量为0。而最理想的风控模型，好人和坏人完全分开，K-S统计量的值为1。</p>\n","site":{"data":{}},"excerpt":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">真实类别</th>\n<th style=\"text-align:center\">预测为正例</th>\n<th style=\"text-align:center\">预测为反例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">正例</td>\n<td style=\"text-align:center\">TP(真正例)</td>\n<td style=\"text-align:center\">FN(假反例)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">反例</td>\n<td style=\"text-align:center\">FP(假正例)</td>\n<td style=\"text-align:center\">TN(真反例)</td>\n</tr>\n</tbody>\n</table>\n</div>","more":"<h1 id=\"准确率、错误率、召回率、查准率\"><a href=\"#准确率、错误率、召回率、查准率\" class=\"headerlink\" title=\"准确率、错误率、召回率、查准率\"></a>准确率、错误率、召回率、查准率</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>公式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>准确率（$Accuracy$）</td>\n<td>$\\frac{TP+TN}{TP+TN+FP+FN}$</td>\n<td>预测正确的比例</td>\n</tr>\n<tr>\n<td>错误率（$Error$）</td>\n<td>$\\frac{FP+FN}{TP+TN+FP+FN}$</td>\n<td>预测错误的比例</td>\n</tr>\n<tr>\n<td>召回率/查全率（$Recall$）</td>\n<td>$\\frac {TP}{TP+FN}$</td>\n<td>真正例被预测正确的比例。有多少好瓜被选出来</td>\n</tr>\n<tr>\n<td>精确率/查准率（$Precision$）</td>\n<td>$\\frac{TP}{TP+FP}$</td>\n<td>预测为正例中正确的比例。预测为的好瓜的类别中有多少好瓜</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"P-R曲线、F1指数\"><a href=\"#P-R曲线、F1指数\" class=\"headerlink\" title=\"P-R曲线、F1指数\"></a>P-R曲线、F1指数</h1><p>一般来说， 查准率高的时候，召回率偏低；召回率高的时候，查准率往往降低。以西瓜问题为例：查准率指的是所有预测为好瓜的西瓜中，真正的好瓜所占的比例；召回率指的是真正的好瓜中，有多少好瓜被挑出来了。如果所有西瓜都预测为好瓜则召回率为1，但是查准率就会降低因为所有坏瓜也预测为了好瓜。</p>\n<h2 id=\"P-R曲线\"><a href=\"#P-R曲线\" class=\"headerlink\" title=\"P-R曲线\"></a>P-R曲线</h2><p>以查准率P为纵轴，召回率R为横轴作图，就得到了查准率-召回率曲线，称为“P-R曲线”。</p>\n<p><img src=\"/2019/08/07/评估模型/1565235635992.png\" alt=\"1565235635992\"> </p>\n<script type=\"math/tex; mode=display\">\ny轴-查准率（精确率）P = \\frac {TP} {TP+FP} \\\\ \nx轴-查全率（召回率）R = \\frac {TP} {TP+FN}</script><p>在比较两个模型的性能时，<strong>如果一个学习器的P-R曲线被另外一个学习器P-R曲线包住，那么后者的性能优于前者（此时后者的查全率跟查准率都高于前者）</strong>，如上图，A的性能优于C，B的性能也优于C；如果两个学习器的曲线有交叉点（如A和B），那么难以断定两个学习器性能的优劣，只能在具体的查准率或者查全率条件下进行比较。</p>\n<h2 id=\"平衡点\"><a href=\"#平衡点\" class=\"headerlink\" title=\"平衡点\"></a>平衡点</h2><p>如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1度量断定两个学习器性能的优劣<br><strong>平衡点</strong>(Break-Even Point，简称BEP)指得是“P=R”时候的取值，如上图，C的的BEP是0.64,。基于BEP的比较，可以认为学习器A优于B。</p>\n<h2 id=\"F1指数\"><a href=\"#F1指数\" class=\"headerlink\" title=\"F1指数\"></a>F1指数</h2><p>如果两个学习器的P-R曲线有交叉点（如A和B），那么通过平衡点或者F1指数断定两个学习器性能的优劣。BEP过于简单，更常用的是F1指数。F1指数实际为查准率和召回率的调和平均数。例如小明跑步10公里，前面5公里用了1小时，后面5公里用了2小时，其平均速度为$\\frac{10}{v}=(\\frac {5}{1}+\f \\frac {5}{2})$</p>\n<script type=\"math/tex; mode=display\">\n\\frac 1 {F1} =\\frac 1 2 (\\frac 1{P}+\\frac 1 R)</script><h2 id=\"F-beta-指数\"><a href=\"#F-beta-指数\" class=\"headerlink\" title=\"$F_\\beta$指数\"></a>$F_\\beta$指数</h2><p>对于特定的应用场景，查准率和查全率的重视度是不一样的。例如在追捕逃犯时，希望尽可能的不遗漏逃犯，因此查全率较为重要；而在搜索引擎的搜索过程中，希望给用户精准的搜索信息，因此查准率更为重要。F1度量的更一般形式——$F_β$，修改了路程 </p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{F_\\beta }=\\frac{1}{1+\\beta ^2}(\\frac{1}{P}+\\frac{\\beta ^2}{R})\\\\</script><p>$β=R/P$ ，其中$β$值越大召回率越重要，$β$值越小查准率越重要。$β$值为两者重要性的比例</p>\n<h1 id=\"G-mean指数\"><a href=\"#G-mean指数\" class=\"headerlink\" title=\"G-mean指数\"></a>G-mean指数</h1><p>G-mean是正例准确率与负例准确率的综合指标。<strong>与F1的比较</strong>：在数据平衡度不是很大的情况下，F1和G-mean可以作为较好的评测指标，但是当训练样本很不平衡时，F1更好。</p>\n<script type=\"math/tex; mode=display\">\nG - mean = \\sqrt{\\frac {TP}{TP+FN}\\times \\frac {TN}{TN+FP}} = \\sqrt {查全率（召回率）真正例率 \\times 真负例率}</script><h1 id=\"ROC曲线与AUC\"><a href=\"#ROC曲线与AUC\" class=\"headerlink\" title=\"ROC曲线与AUC\"></a>ROC曲线与AUC</h1><h2 id=\"ROC曲线\"><a href=\"#ROC曲线\" class=\"headerlink\" title=\"ROC曲线\"></a>ROC曲线</h2><p><img src=\"/2019/08/07/评估模型/1565246937404.png\" alt=\"1565246937404\"></p>\n<script type=\"math/tex; mode=display\">\ny轴-真正例率 TPR = \\frac {TP}{TP+FN} \\\\\nx轴-假正例率 FPR = \\frac {FP}{TN+FP}</script><p>真正例率指的是真实正例中有多少被预测为正例，假正例率指的是真实反例中有多少被预测为正例。<strong>可以看出TPR和Recall的形式是一样的，就是查全率了，FPR就是保证这样的查全率你所要付出的代价，就是把多少负样本也分成了正的了。</strong>如果所有西瓜都预测为好瓜则查全率为1，但是假正例率也会升高因为所有坏瓜也预测为了好瓜。</p>\n<h3 id=\"举例计算\"><a href=\"#举例计算\" class=\"headerlink\" title=\"举例计算\"></a>举例计算</h3><p>假设有4个样本，样本的标签分别为 $0,1,0,1$；模型的预测概率分别为$0.1,0.35,0.4,0.8$；</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>label</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pred</td>\n<td>0.1</td>\n<td>0.35</td>\n<td>0.4</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>阈值</td>\n<td>0.1</td>\n<td>0.35</td>\n<td>0.4</td>\n<td>0.8</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>那么在阈值分别取$0.1, 0.35, 0.4, 0.8$的时候。分别判断出每个<code>pred</code>是<code>TP/FP/TN/FP</code>中的哪个，进而得出当前阈值下的<code>TPR</code>和<code>FPR</code>，也就是<code>(FPR, TPR)</code>这一ROC曲线图上的点；对于所有阈值都计算相应的<code>(FPR, TPR)</code>,则得到完整的ROC曲线上的几个关键点。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>阈值</th>\n<th>样本1</th>\n<th>样本2</th>\n<th>样本3</th>\n<th>样本4</th>\n<th>$TPR=\\frac {TP}{TP+FN}$</th>\n<th>$FPR\\frac {FP}{TN+FP}$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.1</td>\n<td>FP</td>\n<td>TP</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{2}{2+0}=1$</td>\n<td>$\\frac{2}{0+2}=1$</td>\n</tr>\n<tr>\n<td>0.35</td>\n<td>TN</td>\n<td>TP</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{2}{2+0}= 1 $</td>\n<td>$\\frac{1}{1+1}=0.5$</td>\n</tr>\n<tr>\n<td>0.4</td>\n<td>TN</td>\n<td>FN</td>\n<td>FP</td>\n<td>TP</td>\n<td>$\\frac{1}{1+1}=0.5$</td>\n<td>$\\frac{1}{1+1}=0.5 $</td>\n</tr>\n<tr>\n<td>0.8</td>\n<td>TN</td>\n<td>FN</td>\n<td>TN</td>\n<td>TP</td>\n<td>$\\frac {1} {1+1}=0.5$</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"/2019/08/07/评估模型/1565855471447.png\" alt=\"1565855471447\"></p>\n<h2 id=\"AUC指数\"><a href=\"#AUC指数\" class=\"headerlink\" title=\"AUC指数\"></a>AUC指数</h2><p>AUC：<strong>ROC曲线的线下面积。</strong>与P-R曲线类似，如果学习器A的ROC曲线被学习器B完全“包住”，那么后者性能优于前者（相同的假正例率，其真正例率更高）。但是当两个曲线有交点时，则需要比较曲线下的面积AUC(Area Under ROC Curve)。</p>\n<h1 id=\"k-s指标\"><a href=\"#k-s指标\" class=\"headerlink\" title=\"k-s指标\"></a>k-s指标</h1><p>K-S(Kolmogorov-Smirnov)统计量越大，表示模型能够将正、负客户区分开的程度越大。KS值的取值范围是[0，1] </p>\n<h2 id=\"ks曲线\"><a href=\"#ks曲线\" class=\"headerlink\" title=\"ks曲线\"></a>ks曲线</h2><script type=\"math/tex; mode=display\">\nTPR = TP/(TP+FN) \\\\\nFPR = FP/(FP+TN)</script><p>洛伦兹线：两条线，其横轴是模型评分的阈值，纵轴是$TPR$（真正类率）与$FPR$（假正类率）的值</p>\n<p>K-S曲线：洛伦兹线中两条线的差值（$TPR-FPR$），值范围[0，1] 。</p>\n<p><img src=\"/2019/08/07/评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg\" alt=\"img\"></p>\n<p>我们用一个风控模型预测一个人是好人的概率，图中黑线的洛伦兹线（$TPR$与$FPR$）、红线的ks曲线。横坐标是模型评分的阈值，当阈值为0时，所有的用户被预测为坏用户，$TPR=FPR=0$；当阈值为1时，所有用户被预测为好用户，$TPR=FPR=1$。</p>\n<p>这两条曲线之间的差值（$TPR-FPR$），就是K-S曲线。如图所示，给定一个通过率20%（拒绝率80%），则该模型可以挑出来60%的好人，同时漏进来8%的坏人（92%的坏人都被拒绝掉了）。那么K-S曲线在这个通过率上的值，就是60%-8%=0.52。</p>\n<h2 id=\"K-S统计量\"><a href=\"#K-S统计量\" class=\"headerlink\" title=\"K-S统计量\"></a>K-S统计量</h2><p>K-S曲线中的最大值被称为K-S统计量。其取值在0到1之间。如果是随机抽样，好人的洛伦兹曲线跟坏人的是重合的，K-S统计量为0。而最理想的风控模型，好人和坏人完全分开，K-S统计量的值为1。</p>"},{"title":"顺序表","date":"2017-08-28T13:52:29.000Z","_content":"\n# 定义\n顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素。通常都用数组来描述数据结构中的顺序存储结构。\n<!--more-->\n# 代码\n## 数据结构\n```c\n# include <stdio.h>\n# include <stdlib.h>\n# define LIST_INIT_SIZE 100\n# define OK 1\n# define ERROR -1\n\ntypedef int ElemType;\ntypedef int Status;\ntypedef struct {\n    ElemType elem[LIST_INIT_SIZE];    //顺序表大小，可根据实际需要而定\n    int length;                       //线性表长度\n    int listsize;                     //数组长度（以ElemType为单位）\n} SqList;       //由于c语言中数组的下标从0开始，因此线性表的第一个元素a1和最后一个元素a0分别存储在L.elem[0]和L.elem[L.length-1]\nStatus InitList_Sq(SqList & L);\nStatus ListInsert_Sq(SqList & L, int i, ElemType e);\nStatus ListDelete_Sq(SqList & L, int i, ElemType & e);\nint LocateElem_Sq(SqList L, ElemType e, Status (* compare)(ElemType, ElemType));\nvoid MergeList_Sq(SqList La, SqList Lb, SqList &Lc);\nStatus ShowList_Sq(SqList & L);\nStatus compare(ElemType a, ElemType b);\n\n/*******************\nStatus InitList(SqList &L)\n功能：初始化顺序线性表\n参数：\n    SqList &L：顺序线性表L\n返回值:\n    Status类型：OK为执行正确，ERROR为出错\n*******************/\nStatus InitList_Sq(SqList & L)            //&L  对线性表L的引用\n{\n    //算法2.3   List_Size\n    L.elem = new ElemType[LIST_INIT_SIZE];  //elem 数组的名称是一个指针，(ElemType *)返回一个指针\n    if(!L.elem) {\n        exit(OVERFLOW);\n    }\n    L.length = 0;\n    L.listsize = LIST_INIT_SIZE;\n    return OK;\n}\n/*******************\nVoid DestroyList_Sq(SqList)\n功能：销毁顺序表：\n*******************/\nvoid DestroyList_Sq(SqList) {\n//释放顺序表L所占用的存储空间\n    delete []L.elem;\n    L.length=0;\n    L.listsize=0;\n}\n/*******************\nStatus ListEmpty(SqList L)\n功能：\n    检测是否为空表\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n返回值:\n    Status类型：TRUE表示L为空表，否则返回FALSE\n*******************/\nStatus ListEmpty(SqList L)\n{\n    if(L.length == 0) return TRUE;\n    else   return FALSE;\n}\n/*******************\nStatus ClearList(SqList *L)\n功能：\n    将L重置为空表\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList &L：顺序线性表L\n返回值:\n    Status类型：OK表示执行正确\n*******************/\nStatus ClearList(SqList &L)\n    L->length=0;\n    return OK;\n}\n/*******************\nint ListLength(SqList L)\n功能：\n    获取L中数据元素个数\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n返回值:\n    int类型：返回L中数据元素个数\n*******************/\nint ListLength(SqList L) {\n    return L.length;\n}\n/*******************\nStatus GetElem(SqList L,int i,ElemType *e)\n功能：\n    用e返回L中第i个数据元素的值（注意i是指位置）\n限制：\n    初始条件：顺序线性表L已存在，1≤i≤ListLength(L)\n参数：\n    SqList L：顺序线性表L\n    int i：要取出元素的位置\n    ElemType *e：所取出的元素\n返回值:\n    Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus GetElem(SqList L,int i,ElemType *e)\n{\n    if(L.length==0 || i<1 || i>L.length) return ERROR;\n     *e=L.elem[i-1];\n     return ok;\n}\n/*******************\nStatus ListInsert(SqList &L,int i,ElemType x)\n功能：\n     在L中第i个位置前插入新的数据元素x\n限制：\n     初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)\n参数：\n     SqList &L：顺序线性表L\n     int i：位置i ElemType x：新的数据元素x\n返回值:\n     Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus ListInsert_Sq(SqList & L, int i, ElemType x)\n{\n    //算法2.4\n    //在顺序线性表L中第i个元素之前插入x\n    if(i < 1 || i > L.length + 1)  return ERROR;\n    if(L.length >= L.listsize)  return ERROR;\n    ElemType *q = & (L.elem[i - 1]);\n    for(ElemType *p = & (L.elem[L.length - 1]); p >= q; --p) {\n        *(p + 1) = *p;              //元素后移\n    }\n    *q = x;\n    ++L.length;              //长度加1\n    return OK;\n}\n/*******************\nStatus ListDelete(SqList —L,int i,ElemType e)\n功能：\n    删除L的第i个数据元素\n限制：\n    初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)\n参数：\n    SqList —L：顺序线性表L\n    int i：位置i\n返回值:\n    Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus ListDelete_Sq(SqList &L, int i)\n{\n    //算法2.5\n    if(i < 1 || i > L.length)    return ERROR;    //输出错误\n    ElemType *p = & (L.elem[i - 1]);\n    ElemType *q = L.elem + L.length - 1;\n    for(++p; p <= q; ++p) {\n        * (p - 1) = * p;      //元素前移\n    }\n    --L.length;\n    return OK;\n}\n/*******************\nint LocateElem_Sq(SqList L,ElemType x)\n功能：\n    找出L中第1个与x满足相等关系的数据元素的位序\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n    ElemType x：元素x\n返回值:\n    int类型：返回L中第1个与e满足相等关系的数据元素的位序；若这样的数据元素不存在，则返回值为0 *******************/\nint LocateElem_Sq(SqList L, ElemType x)\n{\n    //算法2.6\n    //指向函数的指针的使用\n    int i = 1;\n    ElemType * p = L.elem;\n    while((i <= L.length )&& (*p++ != x))  ++i;\n    if(i <= L.length) {\n        return i;\n    } else {\n        return 0;\n}\n```\n## 测试代码\n```c\n\nint main(void)\n{\n    //测试函数\n    SqList L;\n    InitList_Sq(L);\n    for(int i = 10; i > 0; i--) {\n        ListInsert_Sq(L, 1, i);\n    }\n    ShowList_Sq(L);    //print L\n    int e;\n    ListDelete_Sq(L, 4, e);\n    ShowList_Sq(L);    //print L\n    printf(\"%d\\n\", LocateElem_Sq(L, 3, * compare));    //print location of 3\n    //函数做参数如何传值呢？？\n    SqList Lb;\n    InitList_Sq(Lb);\n    for(int i = 10; i > 0; i--) {\n        ListInsert_Sq(Lb, 1, 2 * i);\n    }\n    ShowList_Sq(Lb);    //print Lb\n    SqList Lc;\n    InitList_Sq(Lc);\n    ShowList_Sq(Lc);    //print Lc\n    MergeList_Sq(L, Lb, Lc);\n    ShowList_Sq(Lc);    //print Lc\n    return 0;\n}\n```\n# 缺点\n线性表的顺序存储结构，最大的缺点就是插入和删除时需要移动大量的元素，这显然需要耗费时间。导致这个问题的原因是在于相邻元素的存储位置具有邻居关系，它们在内存中的位置是紧挨着的，中间没有间隙，当然无法快速插入和删除。\n","source":"_posts/顺序表.md","raw":"---\ntitle: 顺序表\ndate: 2017-08-28 21:52:29\ntags: [线性表]\ncategories: 数据结构\n---\n\n# 定义\n顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素。通常都用数组来描述数据结构中的顺序存储结构。\n<!--more-->\n# 代码\n## 数据结构\n```c\n# include <stdio.h>\n# include <stdlib.h>\n# define LIST_INIT_SIZE 100\n# define OK 1\n# define ERROR -1\n\ntypedef int ElemType;\ntypedef int Status;\ntypedef struct {\n    ElemType elem[LIST_INIT_SIZE];    //顺序表大小，可根据实际需要而定\n    int length;                       //线性表长度\n    int listsize;                     //数组长度（以ElemType为单位）\n} SqList;       //由于c语言中数组的下标从0开始，因此线性表的第一个元素a1和最后一个元素a0分别存储在L.elem[0]和L.elem[L.length-1]\nStatus InitList_Sq(SqList & L);\nStatus ListInsert_Sq(SqList & L, int i, ElemType e);\nStatus ListDelete_Sq(SqList & L, int i, ElemType & e);\nint LocateElem_Sq(SqList L, ElemType e, Status (* compare)(ElemType, ElemType));\nvoid MergeList_Sq(SqList La, SqList Lb, SqList &Lc);\nStatus ShowList_Sq(SqList & L);\nStatus compare(ElemType a, ElemType b);\n\n/*******************\nStatus InitList(SqList &L)\n功能：初始化顺序线性表\n参数：\n    SqList &L：顺序线性表L\n返回值:\n    Status类型：OK为执行正确，ERROR为出错\n*******************/\nStatus InitList_Sq(SqList & L)            //&L  对线性表L的引用\n{\n    //算法2.3   List_Size\n    L.elem = new ElemType[LIST_INIT_SIZE];  //elem 数组的名称是一个指针，(ElemType *)返回一个指针\n    if(!L.elem) {\n        exit(OVERFLOW);\n    }\n    L.length = 0;\n    L.listsize = LIST_INIT_SIZE;\n    return OK;\n}\n/*******************\nVoid DestroyList_Sq(SqList)\n功能：销毁顺序表：\n*******************/\nvoid DestroyList_Sq(SqList) {\n//释放顺序表L所占用的存储空间\n    delete []L.elem;\n    L.length=0;\n    L.listsize=0;\n}\n/*******************\nStatus ListEmpty(SqList L)\n功能：\n    检测是否为空表\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n返回值:\n    Status类型：TRUE表示L为空表，否则返回FALSE\n*******************/\nStatus ListEmpty(SqList L)\n{\n    if(L.length == 0) return TRUE;\n    else   return FALSE;\n}\n/*******************\nStatus ClearList(SqList *L)\n功能：\n    将L重置为空表\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList &L：顺序线性表L\n返回值:\n    Status类型：OK表示执行正确\n*******************/\nStatus ClearList(SqList &L)\n    L->length=0;\n    return OK;\n}\n/*******************\nint ListLength(SqList L)\n功能：\n    获取L中数据元素个数\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n返回值:\n    int类型：返回L中数据元素个数\n*******************/\nint ListLength(SqList L) {\n    return L.length;\n}\n/*******************\nStatus GetElem(SqList L,int i,ElemType *e)\n功能：\n    用e返回L中第i个数据元素的值（注意i是指位置）\n限制：\n    初始条件：顺序线性表L已存在，1≤i≤ListLength(L)\n参数：\n    SqList L：顺序线性表L\n    int i：要取出元素的位置\n    ElemType *e：所取出的元素\n返回值:\n    Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus GetElem(SqList L,int i,ElemType *e)\n{\n    if(L.length==0 || i<1 || i>L.length) return ERROR;\n     *e=L.elem[i-1];\n     return ok;\n}\n/*******************\nStatus ListInsert(SqList &L,int i,ElemType x)\n功能：\n     在L中第i个位置前插入新的数据元素x\n限制：\n     初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)\n参数：\n     SqList &L：顺序线性表L\n     int i：位置i ElemType x：新的数据元素x\n返回值:\n     Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus ListInsert_Sq(SqList & L, int i, ElemType x)\n{\n    //算法2.4\n    //在顺序线性表L中第i个元素之前插入x\n    if(i < 1 || i > L.length + 1)  return ERROR;\n    if(L.length >= L.listsize)  return ERROR;\n    ElemType *q = & (L.elem[i - 1]);\n    for(ElemType *p = & (L.elem[L.length - 1]); p >= q; --p) {\n        *(p + 1) = *p;              //元素后移\n    }\n    *q = x;\n    ++L.length;              //长度加1\n    return OK;\n}\n/*******************\nStatus ListDelete(SqList —L,int i,ElemType e)\n功能：\n    删除L的第i个数据元素\n限制：\n    初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)\n参数：\n    SqList —L：顺序线性表L\n    int i：位置i\n返回值:\n    Status类型：OK表示执行正确，ERROR为出错\n*******************/\nStatus ListDelete_Sq(SqList &L, int i)\n{\n    //算法2.5\n    if(i < 1 || i > L.length)    return ERROR;    //输出错误\n    ElemType *p = & (L.elem[i - 1]);\n    ElemType *q = L.elem + L.length - 1;\n    for(++p; p <= q; ++p) {\n        * (p - 1) = * p;      //元素前移\n    }\n    --L.length;\n    return OK;\n}\n/*******************\nint LocateElem_Sq(SqList L,ElemType x)\n功能：\n    找出L中第1个与x满足相等关系的数据元素的位序\n限制：\n    初始条件：顺序线性表L已存在\n参数：\n    SqList L：顺序线性表L\n    ElemType x：元素x\n返回值:\n    int类型：返回L中第1个与e满足相等关系的数据元素的位序；若这样的数据元素不存在，则返回值为0 *******************/\nint LocateElem_Sq(SqList L, ElemType x)\n{\n    //算法2.6\n    //指向函数的指针的使用\n    int i = 1;\n    ElemType * p = L.elem;\n    while((i <= L.length )&& (*p++ != x))  ++i;\n    if(i <= L.length) {\n        return i;\n    } else {\n        return 0;\n}\n```\n## 测试代码\n```c\n\nint main(void)\n{\n    //测试函数\n    SqList L;\n    InitList_Sq(L);\n    for(int i = 10; i > 0; i--) {\n        ListInsert_Sq(L, 1, i);\n    }\n    ShowList_Sq(L);    //print L\n    int e;\n    ListDelete_Sq(L, 4, e);\n    ShowList_Sq(L);    //print L\n    printf(\"%d\\n\", LocateElem_Sq(L, 3, * compare));    //print location of 3\n    //函数做参数如何传值呢？？\n    SqList Lb;\n    InitList_Sq(Lb);\n    for(int i = 10; i > 0; i--) {\n        ListInsert_Sq(Lb, 1, 2 * i);\n    }\n    ShowList_Sq(Lb);    //print Lb\n    SqList Lc;\n    InitList_Sq(Lc);\n    ShowList_Sq(Lc);    //print Lc\n    MergeList_Sq(L, Lb, Lc);\n    ShowList_Sq(Lc);    //print Lc\n    return 0;\n}\n```\n# 缺点\n线性表的顺序存储结构，最大的缺点就是插入和删除时需要移动大量的元素，这显然需要耗费时间。导致这个问题的原因是在于相邻元素的存储位置具有邻居关系，它们在内存中的位置是紧挨着的，中间没有间隙，当然无法快速插入和删除。\n","slug":"顺序表","published":1,"updated":"2019-07-30T01:54:38.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzdr6j1l006uhomj9874dm13","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素。通常都用数组来描述数据结构中的顺序存储结构。<br><a id=\"more\"></a></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> LIST_INIT_SIZE 100</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElemType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ElemType elem[LIST_INIT_SIZE];    <span class=\"comment\">//顺序表大小，可根据实际需要而定</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;                       <span class=\"comment\">//线性表长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listsize;                     <span class=\"comment\">//数组长度（以ElemType为单位）</span></span><br><span class=\"line\">&#125; SqList;       <span class=\"comment\">//由于c语言中数组的下标从0开始，因此线性表的第一个元素a1和最后一个元素a0分别存储在L.elem[0]和L.elem[L.length-1]</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp; L)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType e)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType &amp; e)</span></span>;</span><br><span class=\"line\">int LocateElem_Sq(SqList L, ElemType e, Status (* compare)(ElemType, ElemType));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_Sq</span><span class=\"params\">(SqList La, SqList Lb, SqList &amp;Lc)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ShowList_Sq</span><span class=\"params\">(SqList &amp; L)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">compare</span><span class=\"params\">(ElemType a, ElemType b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status InitList(SqList &amp;L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：初始化顺序线性表</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK为执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp; L)</span>            <span class=\"comment\">//&amp;L  对线性表L的引用</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.3   List_Size</span></span><br><span class=\"line\">    L.elem = <span class=\"keyword\">new</span> ElemType[LIST_INIT_SIZE];  <span class=\"comment\">//elem 数组的名称是一个指针，(ElemType *)返回一个指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!L.elem) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    L.listsize = LIST_INIT_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Void DestroyList_Sq(SqList)</span></span><br><span class=\"line\"><span class=\"comment\">功能：销毁顺序表：</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestroyList_Sq</span><span class=\"params\">(SqList)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//释放顺序表L所占用的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []L.elem;</span><br><span class=\"line\">    L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    L.listsize=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListEmpty(SqList L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    检测是否为空表</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：TRUE表示L为空表，否则返回FALSE</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListEmpty</span><span class=\"params\">(SqList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>   <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ClearList(SqList *L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    将L重置为空表</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(SqList &amp;L)</span></span></span><br><span class=\"line\">    L-&gt;length=0;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">int ListLength(SqList L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    获取L中数据元素个数</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    int类型：返回L中数据元素个数</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength</span><span class=\"params\">(SqList L)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status GetElem(SqList L,int i,ElemType *e)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    用e返回L中第i个数据元素的值（注意i是指位置）</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    int i：要取出元素的位置</span></span><br><span class=\"line\"><span class=\"comment\">    ElemType *e：所取出的元素</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem</span><span class=\"params\">(SqList L,<span class=\"keyword\">int</span> i,ElemType *e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length==<span class=\"number\">0</span> || i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">     *e=L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ok;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListInsert(SqList &amp;L,int i,ElemType x)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">     在L中第i个位置前插入新的数据元素x</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">     初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">     SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">     int i：位置i ElemType x：新的数据元素x</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">     Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.4</span></span><br><span class=\"line\">    <span class=\"comment\">//在顺序线性表L中第i个元素之前插入x</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i &gt; L.length + <span class=\"number\">1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length &gt;= L.listsize)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    ElemType *q = &amp; (L.elem[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ElemType *p = &amp; (L.elem[L.length - <span class=\"number\">1</span>]); p &gt;= q; --p) &#123;</span><br><span class=\"line\">        *(p + <span class=\"number\">1</span>) = *p;              <span class=\"comment\">//元素后移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *q = x;</span><br><span class=\"line\">    ++L.length;              <span class=\"comment\">//长度加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListDelete(SqList —L,int i,ElemType e)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    删除L的第i个数据元素</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList —L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    int i：位置i</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.5</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i &gt; L.length)    <span class=\"keyword\">return</span> ERROR;    <span class=\"comment\">//输出错误</span></span><br><span class=\"line\">    ElemType *p = &amp; (L.elem[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    ElemType *q = L.elem + L.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(++p; p &lt;= q; ++p) &#123;</span><br><span class=\"line\">        * (p - <span class=\"number\">1</span>) = * p;      <span class=\"comment\">//元素前移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    --L.length;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">int LocateElem_Sq(SqList L,ElemType x)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    找出L中第1个与x满足相等关系的数据元素的位序</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    ElemType x：元素x</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    int类型：返回L中第1个与e满足相等关系的数据元素的位序；若这样的数据元素不存在，则返回值为0 *******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem_Sq</span><span class=\"params\">(SqList L, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.6</span></span><br><span class=\"line\">    <span class=\"comment\">//指向函数的指针的使用</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ElemType * p = L.elem;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((i &lt;= L.length )&amp;&amp; (*p++ != x))  ++i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt;= L.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//测试函数</span></span><br><span class=\"line\">    SqList L;</span><br><span class=\"line\">    InitList_Sq(L);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        ListInsert_Sq(L, <span class=\"number\">1</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowList_Sq(L);    <span class=\"comment\">//print L</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    ListDelete_Sq(L, <span class=\"number\">4</span>, e);</span><br><span class=\"line\">    ShowList_Sq(L);    <span class=\"comment\">//print L</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, LocateElem_Sq(L, <span class=\"number\">3</span>, * compare));    <span class=\"comment\">//print location of 3</span></span><br><span class=\"line\">    <span class=\"comment\">//函数做参数如何传值呢？？</span></span><br><span class=\"line\">    SqList Lb;</span><br><span class=\"line\">    InitList_Sq(Lb);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        ListInsert_Sq(Lb, <span class=\"number\">1</span>, <span class=\"number\">2</span> * i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowList_Sq(Lb);    <span class=\"comment\">//print Lb</span></span><br><span class=\"line\">    SqList Lc;</span><br><span class=\"line\">    InitList_Sq(Lc);</span><br><span class=\"line\">    ShowList_Sq(Lc);    <span class=\"comment\">//print Lc</span></span><br><span class=\"line\">    MergeList_Sq(L, Lb, Lc);</span><br><span class=\"line\">    ShowList_Sq(Lc);    <span class=\"comment\">//print Lc</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>线性表的顺序存储结构，最大的缺点就是插入和删除时需要移动大量的元素，这显然需要耗费时间。导致这个问题的原因是在于相邻元素的存储位置具有邻居关系，它们在内存中的位置是紧挨着的，中间没有间隙，当然无法快速插入和删除。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素。通常都用数组来描述数据结构中的顺序存储结构。<br></p>","more":"<p></p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> LIST_INIT_SIZE 100</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">define</span> ERROR -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ElemType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    ElemType elem[LIST_INIT_SIZE];    <span class=\"comment\">//顺序表大小，可根据实际需要而定</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;                       <span class=\"comment\">//线性表长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listsize;                     <span class=\"comment\">//数组长度（以ElemType为单位）</span></span><br><span class=\"line\">&#125; SqList;       <span class=\"comment\">//由于c语言中数组的下标从0开始，因此线性表的第一个元素a1和最后一个元素a0分别存储在L.elem[0]和L.elem[L.length-1]</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp; L)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType e)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType &amp; e)</span></span>;</span><br><span class=\"line\">int LocateElem_Sq(SqList L, ElemType e, Status (* compare)(ElemType, ElemType));</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MergeList_Sq</span><span class=\"params\">(SqList La, SqList Lb, SqList &amp;Lc)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ShowList_Sq</span><span class=\"params\">(SqList &amp; L)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">compare</span><span class=\"params\">(ElemType a, ElemType b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status InitList(SqList &amp;L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：初始化顺序线性表</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK为执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitList_Sq</span><span class=\"params\">(SqList &amp; L)</span>            <span class=\"comment\">//&amp;L  对线性表L的引用</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.3   List_Size</span></span><br><span class=\"line\">    L.elem = <span class=\"keyword\">new</span> ElemType[LIST_INIT_SIZE];  <span class=\"comment\">//elem 数组的名称是一个指针，(ElemType *)返回一个指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!L.elem) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    L.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    L.listsize = LIST_INIT_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Void DestroyList_Sq(SqList)</span></span><br><span class=\"line\"><span class=\"comment\">功能：销毁顺序表：</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DestroyList_Sq</span><span class=\"params\">(SqList)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//释放顺序表L所占用的存储空间</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> []L.elem;</span><br><span class=\"line\">    L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    L.listsize=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListEmpty(SqList L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    检测是否为空表</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：TRUE表示L为空表，否则返回FALSE</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListEmpty</span><span class=\"params\">(SqList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>   <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ClearList(SqList *L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    将L重置为空表</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearList</span><span class=\"params\">(SqList &amp;L)</span></span></span><br><span class=\"line\">    L-&gt;length=0;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">int ListLength(SqList L)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    获取L中数据元素个数</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    int类型：返回L中数据元素个数</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ListLength</span><span class=\"params\">(SqList L)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status GetElem(SqList L,int i,ElemType *e)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    用e返回L中第i个数据元素的值（注意i是指位置）</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在，1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    int i：要取出元素的位置</span></span><br><span class=\"line\"><span class=\"comment\">    ElemType *e：所取出的元素</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetElem</span><span class=\"params\">(SqList L,<span class=\"keyword\">int</span> i,ElemType *e)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length==<span class=\"number\">0</span> || i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">     *e=L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ok;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListInsert(SqList &amp;L,int i,ElemType x)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">     在L中第i个位置前插入新的数据元素x</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">     初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">     SqList &amp;L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">     int i：位置i ElemType x：新的数据元素x</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">     Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListInsert_Sq</span><span class=\"params\">(SqList &amp; L, <span class=\"keyword\">int</span> i, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.4</span></span><br><span class=\"line\">    <span class=\"comment\">//在顺序线性表L中第i个元素之前插入x</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i &gt; L.length + <span class=\"number\">1</span>)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L.length &gt;= L.listsize)  <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    ElemType *q = &amp; (L.elem[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ElemType *p = &amp; (L.elem[L.length - <span class=\"number\">1</span>]); p &gt;= q; --p) &#123;</span><br><span class=\"line\">        *(p + <span class=\"number\">1</span>) = *p;              <span class=\"comment\">//元素后移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *q = x;</span><br><span class=\"line\">    ++L.length;              <span class=\"comment\">//长度加1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">Status ListDelete(SqList —L,int i,ElemType e)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    删除L的第i个数据元素</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在，,1≤i≤ListLength(L)</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList —L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    int i：位置i</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    Status类型：OK表示执行正确，ERROR为出错</span></span><br><span class=\"line\"><span class=\"comment\">*******************/</span></span><br><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ListDelete_Sq</span><span class=\"params\">(SqList &amp;L, <span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.5</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i &gt; L.length)    <span class=\"keyword\">return</span> ERROR;    <span class=\"comment\">//输出错误</span></span><br><span class=\"line\">    ElemType *p = &amp; (L.elem[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    ElemType *q = L.elem + L.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(++p; p &lt;= q; ++p) &#123;</span><br><span class=\"line\">        * (p - <span class=\"number\">1</span>) = * p;      <span class=\"comment\">//元素前移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    --L.length;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*******************</span></span><br><span class=\"line\"><span class=\"comment\">int LocateElem_Sq(SqList L,ElemType x)</span></span><br><span class=\"line\"><span class=\"comment\">功能：</span></span><br><span class=\"line\"><span class=\"comment\">    找出L中第1个与x满足相等关系的数据元素的位序</span></span><br><span class=\"line\"><span class=\"comment\">限制：</span></span><br><span class=\"line\"><span class=\"comment\">    初始条件：顺序线性表L已存在</span></span><br><span class=\"line\"><span class=\"comment\">参数：</span></span><br><span class=\"line\"><span class=\"comment\">    SqList L：顺序线性表L</span></span><br><span class=\"line\"><span class=\"comment\">    ElemType x：元素x</span></span><br><span class=\"line\"><span class=\"comment\">返回值:</span></span><br><span class=\"line\"><span class=\"comment\">    int类型：返回L中第1个与e满足相等关系的数据元素的位序；若这样的数据元素不存在，则返回值为0 *******************/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateElem_Sq</span><span class=\"params\">(SqList L, ElemType x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//算法2.6</span></span><br><span class=\"line\">    <span class=\"comment\">//指向函数的指针的使用</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ElemType * p = L.elem;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((i &lt;= L.length )&amp;&amp; (*p++ != x))  ++i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt;= L.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//测试函数</span></span><br><span class=\"line\">    SqList L;</span><br><span class=\"line\">    InitList_Sq(L);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        ListInsert_Sq(L, <span class=\"number\">1</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowList_Sq(L);    <span class=\"comment\">//print L</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    ListDelete_Sq(L, <span class=\"number\">4</span>, e);</span><br><span class=\"line\">    ShowList_Sq(L);    <span class=\"comment\">//print L</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, LocateElem_Sq(L, <span class=\"number\">3</span>, * compare));    <span class=\"comment\">//print location of 3</span></span><br><span class=\"line\">    <span class=\"comment\">//函数做参数如何传值呢？？</span></span><br><span class=\"line\">    SqList Lb;</span><br><span class=\"line\">    InitList_Sq(Lb);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        ListInsert_Sq(Lb, <span class=\"number\">1</span>, <span class=\"number\">2</span> * i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ShowList_Sq(Lb);    <span class=\"comment\">//print Lb</span></span><br><span class=\"line\">    SqList Lc;</span><br><span class=\"line\">    InitList_Sq(Lc);</span><br><span class=\"line\">    ShowList_Sq(Lc);    <span class=\"comment\">//print Lc</span></span><br><span class=\"line\">    MergeList_Sq(L, Lb, Lc);</span><br><span class=\"line\">    ShowList_Sq(Lc);    <span class=\"comment\">//print Lc</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>线性表的顺序存储结构，最大的缺点就是插入和删除时需要移动大量的元素，这显然需要耗费时间。导致这个问题的原因是在于相邻元素的存储位置具有邻居关系，它们在内存中的位置是紧挨着的，中间没有间隙，当然无法快速插入和删除。</p>"}],"PostAsset":[{"_id":"source/_posts/linux子系统-win10/tempsnip.png","slug":"tempsnip.png","post":"cjzdr6iz90030homjablgi8p8","modified":1,"renderable":0},{"_id":"source/_posts/spark/15052983161313.jpg","slug":"15052983161313.jpg","post":"cjzdr6ize003bhomjv1senrqg","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/h-d1f99bfd.png","slug":"h-d1f99bfd.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/关系运算-SQL/1564990536278.png","slug":"1564990536278.png","post":"cjzdr6izq003xhomj8bjenbsg","modified":1,"renderable":0},{"_id":"source/_posts/评估模型/1565246937404.png","slug":"1565246937404.png","post":"cjzdr6j1j006rhomjblh44tau","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/h-5847b944.png","slug":"h-5847b944.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/xgboost-5847b944.png","slug":"xgboost-5847b944.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/xgboost-3eee29c4.png","slug":"xgboost-3eee29c4.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/xgboost-994eafca.png","slug":"xgboost-994eafca.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/核函数/核函数-7d4cb2e5.png","slug":"核函数-7d4cb2e5.png","post":"cjzdr6j0l005ahomjvkkrntak","modified":1,"renderable":0},{"_id":"source/_posts/C-变量作用域/C-变量作用域-c93f02eb.png","post":"cjzdr6iwd0008homjejpnxwjt","slug":"C-变量作用域-c93f02eb.png","modified":1,"renderable":1},{"_id":"source/_posts/C-指针/C-指针-16dac5ec.png","post":"cjzdr6iwr000nhomjkfr10pxw","slug":"C-指针-16dac5ec.png","modified":1,"renderable":1},{"_id":"source/_posts/C-数据类型/C-数据类型-271b9c4a.png","post":"cjzdr6iwt000phomjcv5wuwx0","slug":"C-数据类型-271b9c4a.png","modified":1,"renderable":1},{"_id":"source/_posts/DML-SQL/sql.tgn","post":"cjzdr6iy6001lhomjjvm1s79z","slug":"sql.tgn","modified":1,"renderable":1},{"_id":"source/_posts/HDFS/2608446-66ac838fbd1c4c6d.webp","post":"cjzdr6iyi001qhomj07gym6f7","slug":"2608446-66ac838fbd1c4c6d.webp","modified":1,"renderable":1},{"_id":"source/_posts/LDA线性判别分析/LDA线性判别分析-c7a32c02.png","post":"cjzdr6iym001yhomjxxpk2c9h","slug":"LDA线性判别分析-c7a32c02.png","modified":1,"renderable":1},{"_id":"source/_posts/SQL-spark/spark_sql_architecture.jpg","post":"cjzdr6iyq0024homjbsr0p8tr","slug":"spark_sql_architecture.jpg","modified":1,"renderable":1},{"_id":"source/_posts/SQL/sql.tgn","post":"cjzdr6iyv002bhomj7ze2rg38","slug":"sql.tgn","modified":1,"renderable":1},{"_id":"source/_posts/vim/1564556925963.png","post":"cjzdr6izg003ghomjaddjkvjx","slug":"1564556925963.png","modified":1,"renderable":1},{"_id":"source/_posts/二维随机变量/二维随机变量-a083d527.png","post":"cjzdr6izm003qhomjbgyqv6dw","slug":"二维随机变量-a083d527.png","modified":1,"renderable":1},{"_id":"source/_posts/微积分/微积分-ce2b007e.png","post":"cjzdr6j08004qhomjsg966bv0","slug":"微积分-ce2b007e.png","modified":1,"renderable":1},{"_id":"source/_posts/循环链表/循环链表-30ed5658.png","post":"cjzdr6j0a004thomjrakviz9z","slug":"循环链表-30ed5658.png","modified":1,"renderable":1},{"_id":"source/_posts/梯度类方法与对偶算法/梯度类方法与对偶算法-de1c1034.png","post":"cjzdr6j0o005dhomjj5v6pe7g","slug":"梯度类方法与对偶算法-de1c1034.png","modified":1,"renderable":1},{"_id":"source/_posts/概率/v2-2382a6108d0a7518ef0c78018cbf718c_b.gif","post":"cjzdr6j0q005hhomj2l67o87o","slug":"v2-2382a6108d0a7518ef0c78018cbf718c_b.gif","modified":1,"renderable":1},{"_id":"source/_posts/矩阵的基础概念/矩阵的基础概念-bced7336.png","post":"cjzdr6j10005zhomjikqgmpzb","slug":"矩阵的基础概念-bced7336.png","modified":1,"renderable":1},{"_id":"source/_posts/正定二次型和正定矩阵/正定二次型和正定矩阵-57d8d59d.png","post":"cjzdr6j0s005lhomjn0eu9ii7","slug":"正定二次型和正定矩阵-57d8d59d.png","modified":1,"renderable":1},{"_id":"source/_posts/正定二次型和正定矩阵/正定二次型和正定矩阵-b6250792.png","post":"cjzdr6j0s005lhomjn0eu9ii7","slug":"正定二次型和正定矩阵-b6250792.png","modified":1,"renderable":1},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-79fd8d28.png","post":"cjzdr6iyo0022homjxqw0kkj4","slug":"PCA主成分分析-79fd8d28.png","modified":1,"renderable":1},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-81a55a1f.png","post":"cjzdr6iyo0022homjxqw0kkj4","slug":"PCA主成分分析-81a55a1f.png","modified":1,"renderable":1},{"_id":"source/_posts/PCA主成分分析/PCA主成分分析-dc898119.png","post":"cjzdr6iyo0022homjxqw0kkj4","slug":"PCA主成分分析-dc898119.png","modified":1,"renderable":1},{"_id":"source/_posts/hadoop/1565782138575.png","slug":"1565782138575.png","post":"cjzdr6iyy002ghomjbnm8yvqk","modified":1,"renderable":0},{"_id":"source/_posts/hadoop/hadoop.tgn","post":"cjzdr6iyy002ghomjbnm8yvqk","slug":"hadoop.tgn","modified":1,"renderable":1},{"_id":"source/_posts/hadoop/hadoopFamilyRoadmap.png","post":"cjzdr6iyy002ghomjbnm8yvqk","slug":"hadoopFamilyRoadmap.png","modified":1,"renderable":1},{"_id":"source/_posts/核函数/核函数-e3fe62f2.png","post":"cjzdr6j0l005ahomjvkkrntak","slug":"核函数-e3fe62f2.png","modified":1,"renderable":1},{"_id":"source/_posts/核函数/核函数-f46521d0.png","post":"cjzdr6j0l005ahomjvkkrntak","slug":"核函数-f46521d0.png","modified":1,"renderable":1},{"_id":"source/_posts/特征值与特征向量/499a2ac1bc4a5887b31d67a795e19128.gif","slug":"499a2ac1bc4a5887b31d67a795e19128.gif","post":"cjzdr6j0y005uhomj1jsjhd7s","modified":1,"renderable":0},{"_id":"source/_posts/特征值与特征向量/9553ee95232883adcf8266498d10940e.gif","slug":"9553ee95232883adcf8266498d10940e.gif","post":"cjzdr6j0y005uhomj1jsjhd7s","modified":1,"renderable":0},{"_id":"source/_posts/特征值与特征向量/b913d5fe665fdfb4c375bd44c0472610.gif","slug":"b913d5fe665fdfb4c375bd44c0472610.gif","post":"cjzdr6j0y005uhomj1jsjhd7s","modified":1,"renderable":0},{"_id":"source/_posts/线性方程求解/1cd01c9a0b354d94efa893a2a1a4f2fd.gif","slug":"1cd01c9a0b354d94efa893a2a1a4f2fd.gif","post":"cjzdr6j18006dhomjnfqp9not","modified":1,"renderable":0},{"_id":"source/_posts/线性方程求解/72bb3bac2bd86faaa30a96afcfe71de5.gif","slug":"72bb3bac2bd86faaa30a96afcfe71de5.gif","post":"cjzdr6j18006dhomjnfqp9not","modified":1,"renderable":0},{"_id":"source/_posts/线性方程求解/9c9224945da3a91a5fe229aea5c06a2d.gif","slug":"9c9224945da3a91a5fe229aea5c06a2d.gif","post":"cjzdr6j18006dhomjnfqp9not","modified":1,"renderable":0},{"_id":"source/_posts/线性方程求解/c6434a24e6ccf9742ac38be2ceeb6393.gif","slug":"c6434a24e6ccf9742ac38be2ceeb6393.gif","post":"cjzdr6j18006dhomjnfqp9not","modified":1,"renderable":0},{"_id":"source/_posts/评估模型/1565235635992.png","post":"cjzdr6j1j006rhomjblh44tau","slug":"1565235635992.png","modified":1,"renderable":1},{"_id":"source/_posts/评估模型/1565855471447.png","post":"cjzdr6j1j006rhomjblh44tau","slug":"1565855471447.png","modified":1,"renderable":1},{"_id":"source/_posts/评估模型/6c9cd5825bc443459b66f7b20b6f8588_th.jpg","post":"cjzdr6j1j006rhomjblh44tau","slug":"6c9cd5825bc443459b66f7b20b6f8588_th.jpg","modified":1,"renderable":1},{"_id":"source/_posts/一维随机变量/一维随机变量-0b775c82.png","post":"cjzdr6izk003mhomjeyq94pg2","slug":"一维随机变量-0b775c82.png","modified":1,"renderable":1},{"_id":"source/_posts/一维随机变量/一维随机变量-42feaec2.png","post":"cjzdr6izk003mhomjeyq94pg2","slug":"一维随机变量-42feaec2.png","modified":1,"renderable":1},{"_id":"source/_posts/一维随机变量/一维随机变量-a664c725.png","post":"cjzdr6izk003mhomjeyq94pg2","slug":"一维随机变量-a664c725.png","modified":1,"renderable":1},{"_id":"source/_posts/一维随机变量/一维随机变量-a7f11452.png","post":"cjzdr6izk003mhomjeyq94pg2","slug":"一维随机变量-a7f11452.png","modified":1,"renderable":1},{"_id":"source/_posts/一维随机变量/一维随机变量-e5379494.png","post":"cjzdr6izk003mhomjeyq94pg2","slug":"一维随机变量-e5379494.png","modified":1,"renderable":1},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-41658fd8.png","post":"cjzdr6izu0044homj6wqfpckb","slug":"凸集，凸函数和凸优化-41658fd8.png","modified":1,"renderable":1},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-49202716.png","post":"cjzdr6izu0044homj6wqfpckb","slug":"凸集，凸函数和凸优化-49202716.png","modified":1,"renderable":1},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-6040dc5b.png","post":"cjzdr6izu0044homj6wqfpckb","slug":"凸集，凸函数和凸优化-6040dc5b.png","modified":1,"renderable":1},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-703dae26.png","post":"cjzdr6izu0044homj6wqfpckb","slug":"凸集，凸函数和凸优化-703dae26.png","modified":1,"renderable":1},{"_id":"source/_posts/凸集，凸函数和凸优化/凸集，凸函数和凸优化-a587ad27.png","post":"cjzdr6izu0044homj6wqfpckb","slug":"凸集，凸函数和凸优化-a587ad27.png","modified":1,"renderable":1},{"_id":"source/_posts/行列式/行列式-1194e010.png","post":"cjzdr6j1a006fhomjf97d37sc","slug":"行列式-1194e010.png","modified":1,"renderable":1},{"_id":"source/_posts/行列式/行列式-8ca7d05d.png","post":"cjzdr6j1a006fhomjf97d37sc","slug":"行列式-8ca7d05d.png","modified":1,"renderable":1},{"_id":"source/_posts/行列式/行列式-b8781bc3.png","post":"cjzdr6j1a006fhomjf97d37sc","slug":"行列式-b8781bc3.png","modified":1,"renderable":1},{"_id":"source/_posts/行列式/行列式-cc80fd31.png","post":"cjzdr6j1a006fhomjf97d37sc","slug":"行列式-cc80fd31.png","modified":1,"renderable":1},{"_id":"source/_posts/行列式/行列式-ec72909a.png","slug":"行列式-ec72909a.png","post":"cjzdr6j1a006fhomjf97d37sc","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15050362138086.jpg","slug":"15050362138086.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15050363083877.jpg","slug":"15050363083877.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15050364198942.jpg","slug":"15050364198942.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15050414638959-1565678738397.jpg","slug":"15050414638959-1565678738397.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15050414638959.jpg","slug":"15050414638959.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/RDD-Spark/15051361379636.jpg","slug":"15051361379636.jpg","post":"cjzdr6iyt0028homjd9kwomm6","modified":1,"renderable":0},{"_id":"source/_posts/linux子系统-win10/1565005516655.png","post":"cjzdr6iz90030homjablgi8p8","slug":"1565005516655.png","modified":1,"renderable":1},{"_id":"source/_posts/linux子系统-win10/1565005612829.png","post":"cjzdr6iz90030homjablgi8p8","slug":"1565005612829.png","modified":1,"renderable":1},{"_id":"source/_posts/linux子系统-win10/20171212111834391.jpg","post":"cjzdr6iz90030homjablgi8p8","slug":"20171212111834391.jpg","modified":1,"renderable":1},{"_id":"source/_posts/linux子系统-win10/dff1d38a0f699e19488e71c1ad7ad8805cc.jpg","post":"cjzdr6iz90030homjablgi8p8","slug":"dff1d38a0f699e19488e71c1ad7ad8805cc.jpg","modified":1,"renderable":1},{"_id":"source/_posts/linux子系统-win10/tempsnip-1565012471202.png","post":"cjzdr6iz90030homjablgi8p8","slug":"tempsnip-1565012471202.png","modified":1,"renderable":1},{"_id":"source/_posts/spark/1565692989730.png","post":"cjzdr6ize003bhomjv1senrqg","slug":"1565692989730.png","modified":1,"renderable":1},{"_id":"source/_posts/spark/211415584105513.jpg","post":"cjzdr6ize003bhomjv1senrqg","slug":"211415584105513.jpg","modified":1,"renderable":1},{"_id":"source/_posts/spark/211416257386962.gif","post":"cjzdr6ize003bhomjv1senrqg","slug":"211416257386962.gif","modified":1,"renderable":1},{"_id":"source/_posts/spark/76738fed8d7a40e7f3f646f73a61e8bd.jpg","slug":"76738fed8d7a40e7f3f646f73a61e8bd.jpg","post":"cjzdr6ize003bhomjv1senrqg","modified":1,"renderable":0},{"_id":"source/_posts/spark/MLTable.png","post":"cjzdr6ize003bhomjv1senrqg","slug":"MLTable.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-398aa4f1.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-398aa4f1.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-48556a99.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-48556a99.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-494bd225.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-494bd225.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-7c030c8b.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-7c030c8b.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-909cf753.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-909cf753.png","modified":1,"renderable":1},{"_id":"source/_posts/参数估计/参数估计-cd1a5ccf.png","post":"cjzdr6j02004ehomjrz6id8r5","slug":"参数估计-cd1a5ccf.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-23c9f784.png","slug":"回归树-23c9f784.png","post":"cjzdr6j04004ihomjrloyczew","modified":1,"renderable":0},{"_id":"source/_posts/回归树/回归树-7ea432c5.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-7ea432c5.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-ae6f77ba.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-ae6f77ba.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-ce859c9e.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-ce859c9e.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-d82a16be.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-d82a16be.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-e50e2ac3.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-e50e2ac3.png","modified":1,"renderable":1},{"_id":"source/_posts/回归树/回归树-eb149128.png","post":"cjzdr6j04004ihomjrloyczew","slug":"回归树-eb149128.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-0a6c68e5.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-0a6c68e5.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-35e6599e.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-35e6599e.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-3e85fbb1.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-3e85fbb1.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-7688d0c8.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-7688d0c8.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-79d1c781.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-79d1c781.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-80c1cca7.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-80c1cca7.png","modified":1,"renderable":1},{"_id":"source/_posts/样本以及抽样分布/样本以及抽样分布-bc11bcfe.png","post":"cjzdr6j0j0057homj5nfajqab","slug":"样本以及抽样分布-bc11bcfe.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-0b256cfe.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-0b256cfe.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-3e1777ec.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-3e1777ec.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-66761a16.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-66761a16.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-705b6f10.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-705b6f10.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-7d04b421.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-7d04b421.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-d8cb92d5.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-d8cb92d5.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-eb44ea5a.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-eb44ea5a.png","modified":1,"renderable":1},{"_id":"source/_posts/C-环境配置/C-环境配置-eed71799.png","post":"cjzdr6ix3000vhomj8vk2j2ps","slug":"C-环境配置-eed71799.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-03065a1a.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-03065a1a.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-2ab90e01.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-2ab90e01.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-49620760.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-49620760.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-4abd1db5.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-4abd1db5.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-b46cf4a2.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-b46cf4a2.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-d82a16be.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-d82a16be.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-eaef32cd.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-eaef32cd.png","modified":1,"renderable":1},{"_id":"source/_posts/决策树/决策树-f545d0d4.png","post":"cjzdr6izr003zhomja0voofmm","slug":"决策树-f545d0d4.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-0ba6fdac.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-0ba6fdac.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-124d9ba6.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-124d9ba6.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-1369f690.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-1369f690.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-18baeb56.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-18baeb56.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-2b9c28f6.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-2b9c28f6.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-51712dc0.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-51712dc0.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-7a61442f.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-7a61442f.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-92b2d31d.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-92b2d31d.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-d7b11def.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-d7b11def.png","modified":1,"renderable":1},{"_id":"source/_posts/SVM支持向量机/SVM支持向量机-f41dd70d.png","post":"cjzdr6iyx002ehomjtq12em8q","slug":"SVM支持向量机-f41dd70d.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-19fece56.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-19fece56.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-1ec8b0bd.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-1ec8b0bd.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-4145988e.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-4145988e.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-42bbe544.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-42bbe544.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-45e7f8e1.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-45e7f8e1.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-8717e980.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-8717e980.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-94935eb2.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-94935eb2.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-b9b2986e.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-b9b2986e.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-d03da63b.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-d03da63b.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-df9b76dd.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-df9b76dd.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-f5523f89.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-f5523f89.png","modified":1,"renderable":1},{"_id":"source/_posts/GBDT/GBDT-fca6b0f9.png","post":"cjzdr6iyb001nhomj0ya1z1v0","slug":"GBDT-fca6b0f9.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/一维随机变量-0b775c82.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"一维随机变量-0b775c82.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/一维随机变量-42feaec2.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"一维随机变量-42feaec2.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/一维随机变量-a664c725.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"一维随机变量-a664c725.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/一维随机变量-a7f11452.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"一维随机变量-a7f11452.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/一维随机变量-e5379494.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"一维随机变量-e5379494.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-0a6c68e5.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-0a6c68e5.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-35e6599e.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-35e6599e.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-3e85fbb1.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-3e85fbb1.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-7688d0c8.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-7688d0c8.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-79d1c781.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-79d1c781.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-80c1cca7.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-80c1cca7.png","modified":1,"renderable":1},{"_id":"source/_posts/常见分布/样本以及抽样分布-bc11bcfe.png","post":"cjzdr6j06004mhomjmyk3fhll","slug":"样本以及抽样分布-bc11bcfe.png","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/2795ec839c5dc195ef20cbf0df83fc62.gif","slug":"2795ec839c5dc195ef20cbf0df83fc62.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/28438eadcaecbaf01bdba5a3ab686013.gif","slug":"28438eadcaecbaf01bdba5a3ab686013.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/3b1487edc5ffdf73e5ba1a4ca584ccc6.gif","slug":"3b1487edc5ffdf73e5ba1a4ca584ccc6.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg","post":"cjzdr6j160068homj01i8dhh1","slug":"5c015b85-c644-4f1b-b875-ac7aa17a8476.jpg","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/5f3bf3e31768e8bd9646eb487736a234.gif","slug":"5f3bf3e31768e8bd9646eb487736a234.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/5fed7bb9f99639d6299756bba298111b.gif","slug":"5fed7bb9f99639d6299756bba298111b.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/8d40107d18c971c5999be6beb599d618.gif","slug":"8d40107d18c971c5999be6beb599d618.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/dfd1a4e00fcd38eb599ca8183a7d0c5c.gif","slug":"dfd1a4e00fcd38eb599ca8183a7d0c5c.gif","post":"cjzdr6j160068homj01i8dhh1","modified":1,"renderable":0},{"_id":"source/_posts/线性代数基础/线性代数基础-20a01623.png","post":"cjzdr6j160068homj01i8dhh1","slug":"线性代数基础-20a01623.png","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/线性代数基础-76c02b4b.png","post":"cjzdr6j160068homj01i8dhh1","slug":"线性代数基础-76c02b4b.png","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/线性代数基础-93e8ff75.png","post":"cjzdr6j160068homj01i8dhh1","slug":"线性代数基础-93e8ff75.png","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/线性代数基础-c1b237dd.png","post":"cjzdr6j160068homj01i8dhh1","slug":"线性代数基础-c1b237dd.png","modified":1,"renderable":1},{"_id":"source/_posts/线性代数基础/线性代数基础-fb168ecc.png","post":"cjzdr6j160068homj01i8dhh1","slug":"线性代数基础-fb168ecc.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-18fe29f8.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-18fe29f8.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-22546ba5.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-22546ba5.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-234d5b3a.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-234d5b3a.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-2d09c3cb.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-2d09c3cb.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-57908c27.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-57908c27.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-597ed097.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-597ed097.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-a1fde941.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-a1fde941.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/h-ecc2bb96.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"h-ecc2bb96.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/xgboost-5a61a64a.png","slug":"xgboost-5a61a64a.png","post":"cjzdr6izi003ihomj8gl3p9qq","modified":1,"renderable":0},{"_id":"source/_posts/xgboost/xgboost-634b5dbd.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"xgboost-634b5dbd.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/xgboost-b2122f64.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"xgboost-b2122f64.png","modified":1,"renderable":1},{"_id":"source/_posts/xgboost/xgboost-b691aaff.png","post":"cjzdr6izi003ihomj8gl3p9qq","slug":"xgboost-b691aaff.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564974606036.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564974606036.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564974696180.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564974696180.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564974788006.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564974788006.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564974826998.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564974826998.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564974862127.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564974862127.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564988154852.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564988154852.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564988631599.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564988631599.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564988876263.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564988876263.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564989251630.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564989251630.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564989369086.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564989369086.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564989613458.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564989613458.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564994840753.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564994840753.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564994851980.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564994851980.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1564994863174.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1564994863174.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1565058855783.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1565058855783.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1565060112787.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1565060112787.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1565060172932.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1565060172932.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1565060913297.png","post":"cjzdr6izq003xhomj8bjenbsg","slug":"1565060913297.png","modified":1,"renderable":1},{"_id":"source/_posts/关系运算-SQL/1565063996276.png","slug":"1565063996276.png","post":"cjzdr6izq003xhomj8bjenbsg","modified":1,"renderable":0},{"_id":"source/_posts/关系运算-SQL/1565064351620.png","slug":"1565064351620.png","post":"cjzdr6izq003xhomj8bjenbsg","modified":1,"renderable":0},{"_id":"source/_posts/MapReduce/14019352-0c530b046636edd0.webp","slug":"14019352-0c530b046636edd0.webp","post":"cjzdr6iyk001uhomjuimlsg65","modified":1,"renderable":0},{"_id":"source/_posts/MapReduce/1089769-20180418222127341-658345249.png","slug":"1089769-20180418222127341-658345249.png","post":"cjzdr6iyk001uhomjuimlsg65","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjzdr6iwb0007homjyqsem5mj","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iwk000dhomjyhs7onez"},{"post_id":"cjzdr6iw00001homji4ecgwlc","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iwo000hhomjzzywg3rt"},{"post_id":"cjzdr6iwd0008homjejpnxwjt","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iwq000khomjq8fgcidw"},{"post_id":"cjzdr6iwg000bhomjzxq6vaz5","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iws000ohomjetlo9mrh"},{"post_id":"cjzdr6iw50003homjgx9qahiz","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iwu000qhomjwpqswz1i"},{"post_id":"cjzdr6iwj000chomjpyt79yb0","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iwz000thomjf14u8s4y"},{"post_id":"cjzdr6iwm000ghomjv1auwm32","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ix4000whomjnsuej2o5"},{"post_id":"cjzdr6iwa0006homjxw6989t5","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ix90010homj6tmgau83"},{"post_id":"cjzdr6iwp000jhomj1dxclsu1","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ixe0013homjz88s36iz"},{"post_id":"cjzdr6iwr000nhomjkfr10pxw","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ixj0017homjqdet8y62"},{"post_id":"cjzdr6iwt000phomjcv5wuwx0","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ixn001ahomjaik3blmw"},{"post_id":"cjzdr6iwy000shomjnvr661uy","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ixs001dhomj44pzz3yi"},{"post_id":"cjzdr6ix3000vhomj8vk2j2ps","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6ixx001ghomjg3kiq1fv"},{"post_id":"cjzdr6ix8000zhomju23h5t6n","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iy2001ihomjng8njiib"},{"post_id":"cjzdr6ixd0012homjhi8szbmd","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iy7001mhomjm2y5jwya"},{"post_id":"cjzdr6ixi0016homj37fqr4xn","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iyc001ohomjle0r8drs"},{"post_id":"cjzdr6ixm0019homjoltnusqs","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iyk001shomjp7z7a74s"},{"post_id":"cjzdr6ixr001chomjn7pymlyk","category_id":"cjzdr6iw70004homjcx63frb6","_id":"cjzdr6iyl001vhomjmlt80e6t"},{"post_id":"cjzdr6ixw001fhomji28hop5r","category_id":"cjzdr6iy6001khomjla3rcwar","_id":"cjzdr6iyo0020homjws3gx86s"},{"post_id":"cjzdr6iy1001hhomjftfztunx","category_id":"cjzdr6iy6001khomjla3rcwar","_id":"cjzdr6iys0026homjxaequ855"},{"post_id":"cjzdr6iy6001lhomjjvm1s79z","category_id":"cjzdr6iy6001khomjla3rcwar","_id":"cjzdr6iyw002chomjj5gg5049"},{"post_id":"cjzdr6iyb001nhomj0ya1z1v0","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6iyz002hhomjeh7cp6hl"},{"post_id":"cjzdr6iyv002bhomj7ze2rg38","category_id":"cjzdr6iy6001khomjla3rcwar","_id":"cjzdr6iz2002lhomju2uyz7nf"},{"post_id":"cjzdr6iyx002ehomjtq12em8q","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6iz3002phomj8y962lyn"},{"post_id":"cjzdr6iyi001qhomj07gym6f7","category_id":"cjzdr6iyw002dhomj19kst15r","_id":"cjzdr6iz6002thomjsf1gyhwg"},{"post_id":"cjzdr6iyy002ghomjbnm8yvqk","category_id":"cjzdr6iyw002dhomj19kst15r","_id":"cjzdr6iz8002whomjqmse5uiu"},{"post_id":"cjzdr6iyk001uhomjuimlsg65","category_id":"cjzdr6iyw002dhomj19kst15r","_id":"cjzdr6iza0031homj1ol05wlv"},{"post_id":"cjzdr6iz2002nhomjzi7eu01k","category_id":"cjzdr6iyw002dhomj19kst15r","_id":"cjzdr6izb0034homjomxyuhtv"},{"post_id":"cjzdr6iym001yhomjxxpk2c9h","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6ize0039homjr5033ypj"},{"post_id":"cjzdr6iyo0022homjxqw0kkj4","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6izf003chomjua6jyoab"},{"post_id":"cjzdr6iyq0024homjbsr0p8tr","category_id":"cjzdr6izc0035homj8ihi8mbo","_id":"cjzdr6izk003lhomjiwhae339"},{"post_id":"cjzdr6ize003bhomjv1senrqg","category_id":"cjzdr6izc0035homj8ihi8mbo","_id":"cjzdr6izm003ohomj20h3t710"},{"post_id":"cjzdr6iyt0028homjd9kwomm6","category_id":"cjzdr6izc0035homj8ihi8mbo","_id":"cjzdr6izo003rhomjz0t5jv6h"},{"post_id":"cjzdr6izi003ihomj8gl3p9qq","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6izq003whomjq5d1nrpw"},{"post_id":"cjzdr6iz1002khomj4sd61ldy","category_id":"cjzdr6izj003khomjoe8hvwoy","_id":"cjzdr6izs0040homjw0tkltqd"},{"post_id":"cjzdr6izq003xhomj8bjenbsg","category_id":"cjzdr6iy6001khomjla3rcwar","_id":"cjzdr6izx0047homjnf3vkv6n"},{"post_id":"cjzdr6iz5002shomjud74dujb","category_id":"cjzdr6izp003uhomjwhpx3muf","_id":"cjzdr6j01004chomjhp33vhat"},{"post_id":"cjzdr6izr003zhomja0voofmm","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j03004fhomjkx6e1xa2"},{"post_id":"cjzdr6iz90030homjablgi8p8","category_id":"cjzdr6izp003uhomjwhpx3muf","_id":"cjzdr6j05004jhomj3zrkcabp"},{"post_id":"cjzdr6iza0033homji7ch9aym","category_id":"cjzdr6izp003uhomjwhpx3muf","_id":"cjzdr6j07004nhomjdl650cg0"},{"post_id":"cjzdr6j04004ihomjrloyczew","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j0b004uhomjpp68c290"},{"post_id":"cjzdr6izd0038homju4h4wbii","category_id":"cjzdr6j03004ghomjmlvuhj7p","_id":"cjzdr6j0d004yhomjauad26fo"},{"post_id":"cjzdr6izg003ghomjaddjkvjx","category_id":"cjzdr6izp003uhomjwhpx3muf","_id":"cjzdr6j0g0052homjghb57wvb"},{"post_id":"cjzdr6izk003mhomjeyq94pg2","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0k0059homjxda08ukp"},{"post_id":"cjzdr6j0e0051homjup5t4c8d","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j0n005chomjbkzkdboc"},{"post_id":"cjzdr6izm003qhomjbgyqv6dw","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0p005ghomjaojmgwhj"},{"post_id":"cjzdr6j0j0057homj5nfajqab","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0s005khomjbahgcvn5"},{"post_id":"cjzdr6j0l005ahomjvkkrntak","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j0u005nhomjdfd7qvaq"},{"post_id":"cjzdr6izo003thomj569m2p5j","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0v005qhomjlkvcubrg"},{"post_id":"cjzdr6j0o005dhomjj5v6pe7g","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0x005thomjx31hrgwz"},{"post_id":"cjzdr6j0q005hhomj2l67o87o","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j0z005yhomj7yui2r33"},{"post_id":"cjzdr6izu0044homj6wqfpckb","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j110060homj4kg7s5m4"},{"post_id":"cjzdr6j0s005lhomjn0eu9ii7","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j130064homjj75oc7ry"},{"post_id":"cjzdr6j0w005rhomjgykposhj","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j160067homjvxrbissv"},{"post_id":"cjzdr6izw0046homjus5hzgty","category_id":"cjzdr6j0t005mhomjmgst1nz7","_id":"cjzdr6j18006bhomjw71w142j"},{"post_id":"cjzdr6j0y005uhomj1jsjhd7s","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j19006ehomjq11b9a2g"},{"post_id":"cjzdr6j10005zhomjikqgmpzb","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1b006hhomjswiqtisa"},{"post_id":"cjzdr6j02004ehomjrz6id8r5","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1f006khomjr6xt8xqn"},{"post_id":"cjzdr6j110061homjsg6ha64l","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1h006nhomjkjnhx5cl"},{"post_id":"cjzdr6j140065homjz3lyvy23","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1j006qhomjtdx3rbtr"},{"post_id":"cjzdr6j06004mhomjmyk3fhll","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1l006thomjmu846kmy"},{"post_id":"cjzdr6j160068homj01i8dhh1","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1n006whomjx81znkrv"},{"post_id":"cjzdr6j18006dhomjnfqp9not","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1o006yhomjfwuep4qi"},{"post_id":"cjzdr6j08004qhomjsg966bv0","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1p0071homjsiqeyomg"},{"post_id":"cjzdr6j1a006fhomjf97d37sc","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1p0073homju1mkzw1w"},{"post_id":"cjzdr6j1c006ihomj7befy1tl","category_id":"cjzdr6j0c004vhomjinsdd2i8","_id":"cjzdr6j1p0075homjxvirdaqd"},{"post_id":"cjzdr6j0a004thomjrakviz9z","category_id":"cjzdr6j0t005mhomjmgst1nz7","_id":"cjzdr6j1q0078homjlsgo5fpm"},{"post_id":"cjzdr6j1h006ohomj791s4lgv","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j1r007ahomjbhed8nwf"},{"post_id":"cjzdr6j0c004xhomjv890246w","category_id":"cjzdr6j1g006mhomjrehzmtn1","_id":"cjzdr6j1r007chomjxllhour4"},{"post_id":"cjzdr6j1j006rhomjblh44tau","category_id":"cjzdr6iyr0025homjifo79ncy","_id":"cjzdr6j1s007dhomj9kc6ms9q"},{"post_id":"cjzdr6j1l006uhomj9874dm13","category_id":"cjzdr6j0t005mhomjmgst1nz7","_id":"cjzdr6j1t007ghomjbk8gessi"},{"post_id":"cjzdr6j0h0055homjq6341jtr","category_id":"cjzdr6j0t005mhomjmgst1nz7","_id":"cjzdr6j1t007ihomjj3opp23o"}],"PostTag":[{"post_id":"cjzdr6iw00001homji4ecgwlc","tag_id":"cjzdr6iw90005homjng6w2jee","_id":"cjzdr6iwo000ihomjkats3cb6"},{"post_id":"cjzdr6iw00001homji4ecgwlc","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6iwq000lhomj7vj8j0xd"},{"post_id":"cjzdr6iw50003homjgx9qahiz","tag_id":"cjzdr6iwm000fhomjxwmvs9yu","_id":"cjzdr6ix0000uhomj6jng7z75"},{"post_id":"cjzdr6iw50003homjgx9qahiz","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6ix5000xhomja6x2pxib"},{"post_id":"cjzdr6iwy000shomjnvr661uy","tag_id":"cjzdr6iwm000fhomjxwmvs9yu","_id":"cjzdr6ixa0011homjmfvuzv80"},{"post_id":"cjzdr6iwy000shomjnvr661uy","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6ixf0014homjnflvz20k"},{"post_id":"cjzdr6iwa0006homjxw6989t5","tag_id":"cjzdr6iwx000rhomjb1bfox5y","_id":"cjzdr6ixm0018homj3uyqo3sv"},{"post_id":"cjzdr6iwa0006homjxw6989t5","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6ixr001bhomj21gvnbl9"},{"post_id":"cjzdr6iwb0007homjyqsem5mj","tag_id":"cjzdr6ixh0015homjvz9jv7lr","_id":"cjzdr6iyk001thomjdv6w6uvj"},{"post_id":"cjzdr6iwb0007homjyqsem5mj","tag_id":"cjzdr6ixs001ehomjd8a3qnd6","_id":"cjzdr6iyl001whomjapbzgn7p"},{"post_id":"cjzdr6iwb0007homjyqsem5mj","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6iyo0021homjjce0awml"},{"post_id":"cjzdr6iwd0008homjejpnxwjt","tag_id":"cjzdr6iwm000fhomjxwmvs9yu","_id":"cjzdr6iys0027homj3d3wapd9"},{"post_id":"cjzdr6iwd0008homjejpnxwjt","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6iyu0029homj6mx5we23"},{"post_id":"cjzdr6iwg000bhomjzxq6vaz5","tag_id":"cjzdr6iyp0023homjplq2fxsi","_id":"cjzdr6iz0002jhomjr75i654k"},{"post_id":"cjzdr6iwg000bhomjzxq6vaz5","tag_id":"cjzdr6iyv002ahomjti2nfxls","_id":"cjzdr6iz2002mhomjhpzzlsp9"},{"post_id":"cjzdr6iwg000bhomjzxq6vaz5","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6iz4002rhomj4t1aptxd"},{"post_id":"cjzdr6iwj000chomjpyt79yb0","tag_id":"cjzdr6iyy002fhomjy8o8lg6s","_id":"cjzdr6iz6002uhomjm0vove8n"},{"post_id":"cjzdr6iwj000chomjpyt79yb0","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6iz9002zhomj9pzmfm9i"},{"post_id":"cjzdr6iwm000ghomjv1auwm32","tag_id":"cjzdr6iz3002ohomjjth9hbt1","_id":"cjzdr6iza0032homj7kkdhius"},{"post_id":"cjzdr6iwm000ghomjv1auwm32","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izc0037homjsopwy73b"},{"post_id":"cjzdr6iwp000jhomj1dxclsu1","tag_id":"cjzdr6iz8002xhomjh93g7d2e","_id":"cjzdr6ize003ahomj9kb3vjbs"},{"post_id":"cjzdr6iwp000jhomj1dxclsu1","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izf003dhomjayeo63a9"},{"post_id":"cjzdr6iwr000nhomjkfr10pxw","tag_id":"cjzdr6izc0036homjs9525xf9","_id":"cjzdr6izh003hhomjv9kpg5te"},{"post_id":"cjzdr6iwr000nhomjkfr10pxw","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izj003jhomj9nind25e"},{"post_id":"cjzdr6iwt000phomjcv5wuwx0","tag_id":"cjzdr6izg003fhomjswdhtn82","_id":"cjzdr6izm003phomjvsojdan8"},{"post_id":"cjzdr6iwt000phomjcv5wuwx0","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izo003shomj2ncrdv7h"},{"post_id":"cjzdr6ix3000vhomj8vk2j2ps","tag_id":"cjzdr6izl003nhomjuwxokh2v","_id":"cjzdr6izr003yhomjexw01zqc"},{"post_id":"cjzdr6ix3000vhomj8vk2j2ps","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izs0041homj1sg2yfkr"},{"post_id":"cjzdr6ix8000zhomju23h5t6n","tag_id":"cjzdr6izp003vhomjdcvhaxp2","_id":"cjzdr6izv0045homj4gflgv44"},{"post_id":"cjzdr6ix8000zhomju23h5t6n","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6izy0049homjbj8fl5xk"},{"post_id":"cjzdr6ixd0012homjhi8szbmd","tag_id":"cjzdr6izt0043homj8n9v1zg7","_id":"cjzdr6j02004dhomjxxonjbb4"},{"post_id":"cjzdr6ixd0012homjhi8szbmd","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6j04004hhomjovomybdp"},{"post_id":"cjzdr6ixi0016homj37fqr4xn","tag_id":"cjzdr6izz004ahomjyx25wgur","_id":"cjzdr6j06004lhomju3be8rzp"},{"post_id":"cjzdr6ixi0016homj37fqr4xn","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6j08004phomjor3sn83v"},{"post_id":"cjzdr6ixm0019homjoltnusqs","tag_id":"cjzdr6izg003fhomjswdhtn82","_id":"cjzdr6j0a004shomjii4expp2"},{"post_id":"cjzdr6ixm0019homjoltnusqs","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6j0c004whomjtgjr3clp"},{"post_id":"cjzdr6ixr001chomjn7pymlyk","tag_id":"cjzdr6izc0036homjs9525xf9","_id":"cjzdr6j0e0050homjy97uilv6"},{"post_id":"cjzdr6ixr001chomjn7pymlyk","tag_id":"cjzdr6iwe000ahomj2l5asglp","_id":"cjzdr6j0h0054homjwel2eavz"},{"post_id":"cjzdr6ixw001fhomji28hop5r","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j0p005ehomj4a7a8qn9"},{"post_id":"cjzdr6ixw001fhomji28hop5r","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j0r005ihomjj265ww03"},{"post_id":"cjzdr6iy1001hhomjftfztunx","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j0x005shomja6imu7wm"},{"post_id":"cjzdr6iy1001hhomjftfztunx","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j0z005whomjre15zvt5"},{"post_id":"cjzdr6iy6001lhomjjvm1s79z","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j150066homjic22o0x5"},{"post_id":"cjzdr6iy6001lhomjjvm1s79z","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j17006ahomjgx2zgwt4"},{"post_id":"cjzdr6iyb001nhomj0ya1z1v0","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1o006xhomjwhxuxizo"},{"post_id":"cjzdr6iyb001nhomj0ya1z1v0","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j1o006zhomjqrvs7e4n"},{"post_id":"cjzdr6iyb001nhomj0ya1z1v0","tag_id":"cjzdr6j1e006jhomjpiuynyki","_id":"cjzdr6j1p0072homjswx0fyla"},{"post_id":"cjzdr6iyb001nhomj0ya1z1v0","tag_id":"cjzdr6j1i006phomjazpw2zhn","_id":"cjzdr6j1p0074homjk6fni6tb"},{"post_id":"cjzdr6iyi001qhomj07gym6f7","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1q0077homjhy30f9uk"},{"post_id":"cjzdr6iyi001qhomj07gym6f7","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j1r0079homjx9h7phei"},{"post_id":"cjzdr6iyk001uhomjuimlsg65","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1s007fhomjeau97x68"},{"post_id":"cjzdr6iyk001uhomjuimlsg65","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j1t007hhomjkph9t0gs"},{"post_id":"cjzdr6iym001yhomjxxpk2c9h","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1u007mhomjn50mjwh9"},{"post_id":"cjzdr6iym001yhomjxxpk2c9h","tag_id":"cjzdr6j1t007jhomj8fyjrsay","_id":"cjzdr6j1v007nhomjflqm4tax"},{"post_id":"cjzdr6iym001yhomjxxpk2c9h","tag_id":"cjzdr6j1t007khomjbpxylsz7","_id":"cjzdr6j1v007phomjoeose6gr"},{"post_id":"cjzdr6iyo0022homjxqw0kkj4","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1w007shomjtsighk3h"},{"post_id":"cjzdr6iyo0022homjxqw0kkj4","tag_id":"cjzdr6j1t007jhomj8fyjrsay","_id":"cjzdr6j1x007thomj7dcd2532"},{"post_id":"cjzdr6iyo0022homjxqw0kkj4","tag_id":"cjzdr6j1t007khomjbpxylsz7","_id":"cjzdr6j1x007vhomjf99g6sew"},{"post_id":"cjzdr6iyq0024homjbsr0p8tr","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j1z007yhomj0v59v252"},{"post_id":"cjzdr6iyq0024homjbsr0p8tr","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j1z007zhomjxz9tgwod"},{"post_id":"cjzdr6iyq0024homjbsr0p8tr","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j200081homjdbffzddo"},{"post_id":"cjzdr6iyt0028homjd9kwomm6","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j210083homjpxpa62qh"},{"post_id":"cjzdr6iyt0028homjd9kwomm6","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j210084homj1twb5ga6"},{"post_id":"cjzdr6iyv002bhomj7ze2rg38","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j220087homj6o11h1d7"},{"post_id":"cjzdr6iyv002bhomj7ze2rg38","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j220088homj55hn9vtb"},{"post_id":"cjzdr6iyx002ehomjtq12em8q","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j24008chomjt8wg15be"},{"post_id":"cjzdr6iyx002ehomjtq12em8q","tag_id":"cjzdr6j220089homjsl0drgre","_id":"cjzdr6j24008dhomjmd6otrrk"},{"post_id":"cjzdr6iyx002ehomjtq12em8q","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j25008fhomj8xs5k1o7"},{"post_id":"cjzdr6iyy002ghomjbnm8yvqk","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j25008hhomjtav6bze4"},{"post_id":"cjzdr6iyy002ghomjbnm8yvqk","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j26008ihomjzplaxanu"},{"post_id":"cjzdr6iz1002khomj4sd61ldy","tag_id":"cjzdr6j25008ghomj665tguj7","_id":"cjzdr6j26008khomjivetxvna"},{"post_id":"cjzdr6iz2002nhomjzi7eu01k","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j28008nhomj4z8h62up"},{"post_id":"cjzdr6iz2002nhomjzi7eu01k","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j28008ohomje4bcpta7"},{"post_id":"cjzdr6iz5002shomjud74dujb","tag_id":"cjzdr6j27008mhomjybinnzrz","_id":"cjzdr6j28008qhomjsl3luv6i"},{"post_id":"cjzdr6iz90030homjablgi8p8","tag_id":"cjzdr6j28008phomjxrfrmvf0","_id":"cjzdr6j29008thomjqkvja41e"},{"post_id":"cjzdr6iz90030homjablgi8p8","tag_id":"cjzdr6j28008rhomjzri6mfhu","_id":"cjzdr6j29008uhomjdh4fjrfn"},{"post_id":"cjzdr6iza0033homji7ch9aym","tag_id":"cjzdr6j28008phomjxrfrmvf0","_id":"cjzdr6j2b008xhomj9ebtc3i7"},{"post_id":"cjzdr6iza0033homji7ch9aym","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j2b008yhomjteuz0ek8"},{"post_id":"cjzdr6izd0038homju4h4wbii","tag_id":"cjzdr6j2a008whomj2t9tq0hn","_id":"cjzdr6j2c0090homj0u688djj"},{"post_id":"cjzdr6ize003bhomjv1senrqg","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2d0093homj9y9pdwxk"},{"post_id":"cjzdr6ize003bhomjv1senrqg","tag_id":"cjzdr6j1o0070homj18x5kquv","_id":"cjzdr6j2d0094homjm2nta0tv"},{"post_id":"cjzdr6izg003ghomjaddjkvjx","tag_id":"cjzdr6j28008phomjxrfrmvf0","_id":"cjzdr6j2e0097homj5dw6gqz3"},{"post_id":"cjzdr6izg003ghomjaddjkvjx","tag_id":"cjzdr6j2d0095homj6lvquwpp","_id":"cjzdr6j2e0098homjmvjtxszg"},{"post_id":"cjzdr6izi003ihomj8gl3p9qq","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2k009dhomjg7boan44"},{"post_id":"cjzdr6izi003ihomj8gl3p9qq","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j2k009ehomjgv6z4jll"},{"post_id":"cjzdr6izi003ihomj8gl3p9qq","tag_id":"cjzdr6j1e006jhomjpiuynyki","_id":"cjzdr6j2l009ghomjulludp2h"},{"post_id":"cjzdr6izi003ihomj8gl3p9qq","tag_id":"cjzdr6j1i006phomjazpw2zhn","_id":"cjzdr6j2l009hhomjk7niikt4"},{"post_id":"cjzdr6izk003mhomjeyq94pg2","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2m009khomjfqfph99l"},{"post_id":"cjzdr6izk003mhomjeyq94pg2","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j2n009lhomjc3lw7mnb"},{"post_id":"cjzdr6izk003mhomjeyq94pg2","tag_id":"cjzdr6j2l009ihomji4j2hgbi","_id":"cjzdr6j2o009nhomjfust7s2t"},{"post_id":"cjzdr6izm003qhomjbgyqv6dw","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2p009qhomjcgweufx8"},{"post_id":"cjzdr6izm003qhomjbgyqv6dw","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j2p009rhomj645amxj0"},{"post_id":"cjzdr6izm003qhomjbgyqv6dw","tag_id":"cjzdr6j2l009ihomji4j2hgbi","_id":"cjzdr6j2q009thomj36gok2yv"},{"post_id":"cjzdr6izo003thomj569m2p5j","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2s009whomjb099cjnm"},{"post_id":"cjzdr6izo003thomj569m2p5j","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j2s009xhomjal09rlv5"},{"post_id":"cjzdr6izo003thomj569m2p5j","tag_id":"cjzdr6j2q009uhomjeyllppn6","_id":"cjzdr6j2t009zhomj6epyi4cg"},{"post_id":"cjzdr6izq003xhomj8bjenbsg","tag_id":"cjzdr6j0d004zhomjgyntjarz","_id":"cjzdr6j2u00a1homjmosm3w43"},{"post_id":"cjzdr6izq003xhomj8bjenbsg","tag_id":"cjzdr6j0i0056homj3t82wt3s","_id":"cjzdr6j2v00a2homjgl4cq7su"},{"post_id":"cjzdr6izr003zhomja0voofmm","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2x00a6homjgacd6v5s"},{"post_id":"cjzdr6izr003zhomja0voofmm","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j2x00a7homjx4uos6w6"},{"post_id":"cjzdr6izr003zhomja0voofmm","tag_id":"cjzdr6j1e006jhomjpiuynyki","_id":"cjzdr6j2y00a9homj2vwtodb6"},{"post_id":"cjzdr6izu0044homj6wqfpckb","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j2z00abhomj5c24db8c"},{"post_id":"cjzdr6izu0044homj6wqfpckb","tag_id":"cjzdr6j2y00a8homjtokfn5ot","_id":"cjzdr6j2z00achomjqtp7ofv5"},{"post_id":"cjzdr6izw0046homjus5hzgty","tag_id":"cjzdr6j2y00aahomjtbf76uwf","_id":"cjzdr6j3000aehomjjp3j1hlc"},{"post_id":"cjzdr6j02004ehomjrz6id8r5","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3100aihomj4alvpfh0"},{"post_id":"cjzdr6j02004ehomjrz6id8r5","tag_id":"cjzdr6j2q009uhomjeyllppn6","_id":"cjzdr6j3200ajhomj6ol6akt6"},{"post_id":"cjzdr6j02004ehomjrz6id8r5","tag_id":"cjzdr6j3000aghomj2msnd3d8","_id":"cjzdr6j3800alhomji35j85pl"},{"post_id":"cjzdr6j04004ihomjrloyczew","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3a00aohomjlalzkkrg"},{"post_id":"cjzdr6j04004ihomjrloyczew","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j3a00aphomjia358e2o"},{"post_id":"cjzdr6j04004ihomjrloyczew","tag_id":"cjzdr6j1e006jhomjpiuynyki","_id":"cjzdr6j3b00arhomjx3bzdeld"},{"post_id":"cjzdr6j06004mhomjmyk3fhll","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3d00avhomjlcqa7x31"},{"post_id":"cjzdr6j06004mhomjmyk3fhll","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j3d00awhomjchmd5305"},{"post_id":"cjzdr6j06004mhomjmyk3fhll","tag_id":"cjzdr6j2l009ihomji4j2hgbi","_id":"cjzdr6j3e00ayhomj9cummf9g"},{"post_id":"cjzdr6j06004mhomjmyk3fhll","tag_id":"cjzdr6j2q009uhomjeyllppn6","_id":"cjzdr6j3e00azhomjseaberx2"},{"post_id":"cjzdr6j08004qhomjsg966bv0","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3f00b1homjlztievca"},{"post_id":"cjzdr6j08004qhomjsg966bv0","tag_id":"cjzdr6j3e00axhomjwf4ydpeh","_id":"cjzdr6j3f00b2homjz3dup87g"},{"post_id":"cjzdr6j0a004thomjrakviz9z","tag_id":"cjzdr6j2y00aahomjtbf76uwf","_id":"cjzdr6j3g00b4homjmyf5s3aj"},{"post_id":"cjzdr6j0c004xhomjv890246w","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3i00b8homjvgvqd5o0"},{"post_id":"cjzdr6j0c004xhomjv890246w","tag_id":"cjzdr6j3g00b5homji8szv300","_id":"cjzdr6j3i00b9homjxzujb1el"},{"post_id":"cjzdr6j0c004xhomjv890246w","tag_id":"cjzdr6j2y00a8homjtokfn5ot","_id":"cjzdr6j3i00bbhomj3oo1ovxm"},{"post_id":"cjzdr6j0e0051homjup5t4c8d","tag_id":"cjzdr6j3h00b7homjln12few3","_id":"cjzdr6j3k00behomjfkue7rt1"},{"post_id":"cjzdr6j0e0051homjup5t4c8d","tag_id":"cjzdr6j2y00a8homjtokfn5ot","_id":"cjzdr6j3k00bfhomjblnn8hgv"},{"post_id":"cjzdr6j0e0051homjup5t4c8d","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3l00bhhomjotdc0r19"},{"post_id":"cjzdr6j0h0055homjq6341jtr","tag_id":"cjzdr6j3j00bdhomjza16w52h","_id":"cjzdr6j3l00bihomjip5xcklx"},{"post_id":"cjzdr6j0j0057homj5nfajqab","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3n00bmhomjalepeqpm"},{"post_id":"cjzdr6j0j0057homj5nfajqab","tag_id":"cjzdr6j2q009uhomjeyllppn6","_id":"cjzdr6j3n00bnhomjl06z45x1"},{"post_id":"cjzdr6j0j0057homj5nfajqab","tag_id":"cjzdr6j3m00bkhomjq7jahg4c","_id":"cjzdr6j3q00bphomjkm875pw1"},{"post_id":"cjzdr6j0l005ahomjvkkrntak","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3r00brhomjd84o7cit"},{"post_id":"cjzdr6j0l005ahomjvkkrntak","tag_id":"cjzdr6j3q00bohomjs76cut1l","_id":"cjzdr6j3r00bshomjbn0vxvtt"},{"post_id":"cjzdr6j0o005dhomjj5v6pe7g","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3t00bvhomjpeyl9run"},{"post_id":"cjzdr6j0o005dhomjj5v6pe7g","tag_id":"cjzdr6j3h00b7homjln12few3","_id":"cjzdr6j3t00bwhomjyoxqaabp"},{"post_id":"cjzdr6j0q005hhomj2l67o87o","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3v00c1homji2zaq48u"},{"post_id":"cjzdr6j0q005hhomj2l67o87o","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j3w00c2homjlo1c37gc"},{"post_id":"cjzdr6j0q005hhomj2l67o87o","tag_id":"cjzdr6j3u00byhomjo9rik3ai","_id":"cjzdr6j3w00c4homjjz2orrf0"},{"post_id":"cjzdr6j0q005hhomj2l67o87o","tag_id":"cjzdr6j3u00bzhomjp7kiz5n6","_id":"cjzdr6j3w00c5homjhjl42jwc"},{"post_id":"cjzdr6j0s005lhomjn0eu9ii7","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j3x00c8homj2a1ppv0f"},{"post_id":"cjzdr6j0s005lhomjn0eu9ii7","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j3y00c9homjj9faqc49"},{"post_id":"cjzdr6j0s005lhomjn0eu9ii7","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j3y00cbhomjdz6o5ewf"},{"post_id":"cjzdr6j0w005rhomjgykposhj","tag_id":"cjzdr6j3h00b7homjln12few3","_id":"cjzdr6j4000cehomjgbkj7sxr"},{"post_id":"cjzdr6j0w005rhomjgykposhj","tag_id":"cjzdr6j2y00a8homjtokfn5ot","_id":"cjzdr6j4000cfhomjjydlbjgh"},{"post_id":"cjzdr6j0w005rhomjgykposhj","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4100chhomjjbbsz5vt"},{"post_id":"cjzdr6j0y005uhomj1jsjhd7s","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4200ckhomjieen68yl"},{"post_id":"cjzdr6j0y005uhomj1jsjhd7s","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4200clhomjetaiygsu"},{"post_id":"cjzdr6j0y005uhomj1jsjhd7s","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4300cnhomj3et3n7ik"},{"post_id":"cjzdr6j10005zhomjikqgmpzb","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4500cqhomjbjk1w0o4"},{"post_id":"cjzdr6j10005zhomjikqgmpzb","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4500crhomjcbm7mzmp"},{"post_id":"cjzdr6j10005zhomjikqgmpzb","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4500cthomj3p5loe7p"},{"post_id":"cjzdr6j110061homjsg6ha64l","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4700cwhomjnoo85nlc"},{"post_id":"cjzdr6j110061homjsg6ha64l","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4700cxhomjzo35oulq"},{"post_id":"cjzdr6j110061homjsg6ha64l","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4800czhomjgsdxq6zs"},{"post_id":"cjzdr6j140065homjz3lyvy23","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4800d0homjbnl5qvio"},{"post_id":"cjzdr6j140065homjz3lyvy23","tag_id":"cjzdr6j3e00axhomjwf4ydpeh","_id":"cjzdr6j4900d2homj0k1ekfbh"},{"post_id":"cjzdr6j160068homj01i8dhh1","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4a00d5homj51lprjq5"},{"post_id":"cjzdr6j160068homj01i8dhh1","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4b00d6homjzbu0rvxc"},{"post_id":"cjzdr6j160068homj01i8dhh1","tag_id":"cjzdr6j4800d1homj7j9abb13","_id":"cjzdr6j4b00d8homj4839dmnp"},{"post_id":"cjzdr6j160068homj01i8dhh1","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4c00d9homjmf567i6a"},{"post_id":"cjzdr6j18006dhomjnfqp9not","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4d00dchomjwuqkbmgi"},{"post_id":"cjzdr6j18006dhomjnfqp9not","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4d00ddhomj1mo76f8s"},{"post_id":"cjzdr6j18006dhomjnfqp9not","tag_id":"cjzdr6j4800d1homj7j9abb13","_id":"cjzdr6j4e00dfhomjaib1l7yr"},{"post_id":"cjzdr6j18006dhomjnfqp9not","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4e00dghomj4y73ggvj"},{"post_id":"cjzdr6j1a006fhomjf97d37sc","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4f00dihomjbm8if687"},{"post_id":"cjzdr6j1a006fhomjf97d37sc","tag_id":"cjzdr6j3w00c3homj1sfejuwc","_id":"cjzdr6j4f00djhomjmgscjw8w"},{"post_id":"cjzdr6j1a006fhomjf97d37sc","tag_id":"cjzdr6j3w00c6homjkvr3jsa2","_id":"cjzdr6j4g00dlhomjfnpummnp"},{"post_id":"cjzdr6j1c006ihomj7befy1tl","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4h00dnhomj9mr7jt5z"},{"post_id":"cjzdr6j1c006ihomj7befy1tl","tag_id":"cjzdr6j2k009fhomj7y5w2qis","_id":"cjzdr6j4h00dohomjs0v3stk0"},{"post_id":"cjzdr6j1c006ihomj7befy1tl","tag_id":"cjzdr6j2q009uhomjeyllppn6","_id":"cjzdr6j4i00dqhomjc9wygfop"},{"post_id":"cjzdr6j1h006ohomj791s4lgv","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4i00drhomjmawoptaq"},{"post_id":"cjzdr6j1h006ohomj791s4lgv","tag_id":"cjzdr6j18006chomjq12fnneb","_id":"cjzdr6j4j00dthomjelbq5ei2"},{"post_id":"cjzdr6j1h006ohomj791s4lgv","tag_id":"cjzdr6j1e006jhomjpiuynyki","_id":"cjzdr6j4j00duhomjz74vbtun"},{"post_id":"cjzdr6j1h006ohomj791s4lgv","tag_id":"cjzdr6j1i006phomjazpw2zhn","_id":"cjzdr6j4k00dvhomjemawln0f"},{"post_id":"cjzdr6j1j006rhomjblh44tau","tag_id":"cjzdr6j130063homjuqbbs44l","_id":"cjzdr6j4k00dwhomj2oluhaka"},{"post_id":"cjzdr6j1j006rhomjblh44tau","tag_id":"cjzdr6j4h00dphomjfwda6mf5","_id":"cjzdr6j4k00dxhomj4q8y9v87"},{"post_id":"cjzdr6j1l006uhomj9874dm13","tag_id":"cjzdr6j2y00aahomjtbf76uwf","_id":"cjzdr6j4k00dyhomjec5tr5ge"}],"Tag":[{"name":"STL","_id":"cjzdr6iw90005homjng6w2jee"},{"name":"语言","_id":"cjzdr6iwe000ahomj2l5asglp"},{"name":"变量作用域","_id":"cjzdr6iwm000fhomjxwmvs9yu"},{"name":"关键字","_id":"cjzdr6iwx000rhomjb1bfox5y"},{"name":"多态","_id":"cjzdr6ixh0015homjvz9jv7lr"},{"name":"虚函数","_id":"cjzdr6ixs001ehomjd8a3qnd6"},{"name":"循环语句","_id":"cjzdr6iyp0023homjplq2fxsi"},{"name":"条件语句","_id":"cjzdr6iyv002ahomjti2nfxls"},{"name":"引用","_id":"cjzdr6iyy002fhomjy8o8lg6s"},{"name":"存储类","_id":"cjzdr6iz3002ohomjjth9hbt1"},{"name":"数字","_id":"cjzdr6iz8002xhomjh93g7d2e"},{"name":"指针","_id":"cjzdr6izc0036homjs9525xf9"},{"name":"数据类型","_id":"cjzdr6izg003fhomjswdhtn82"},{"name":"环境配置","_id":"cjzdr6izl003nhomjuwxokh2v"},{"name":"类和对象","_id":"cjzdr6izp003vhomjdcvhaxp2"},{"name":"结构体","_id":"cjzdr6izt0043homj8n9v1zg7"},{"name":"继承","_id":"cjzdr6izz004ahomjyx25wgur"},{"name":"数据库","_id":"cjzdr6j0d004zhomjgyntjarz"},{"name":"编程语言","_id":"cjzdr6j0i0056homj3t82wt3s"},{"name":"人工智能","_id":"cjzdr6j130063homjuqbbs44l"},{"name":"模型","_id":"cjzdr6j18006chomjq12fnneb"},{"name":"树模型","_id":"cjzdr6j1e006jhomjpiuynyki"},{"name":"集成学习","_id":"cjzdr6j1i006phomjazpw2zhn"},{"name":"分布式系统","_id":"cjzdr6j1o0070homj18x5kquv"},{"name":"特征工程","_id":"cjzdr6j1t007jhomj8fyjrsay"},{"name":"降维","_id":"cjzdr6j1t007khomjbpxylsz7"},{"name":"线性分类器","_id":"cjzdr6j220089homjsl0drgre"},{"name":"testing","_id":"cjzdr6j25008ghomj665tguj7"},{"name":"操作系统，编程语言","_id":"cjzdr6j27008mhomjybinnzrz"},{"name":"操作系统","_id":"cjzdr6j28008phomjxrfrmvf0"},{"name":"开发环境","_id":"cjzdr6j28008rhomjzri6mfhu"},{"name":"test","_id":"cjzdr6j2a008whomj2t9tq0hn"},{"name":"编辑器","_id":"cjzdr6j2d0095homj6lvquwpp"},{"name":"概率","_id":"cjzdr6j2k009fhomj7y5w2qis"},{"name":"分布","_id":"cjzdr6j2l009ihomji4j2hgbi"},{"name":"统计","_id":"cjzdr6j2q009uhomjeyllppn6"},{"name":"凸优化","_id":"cjzdr6j2y00a8homjtokfn5ot"},{"name":"线性表","_id":"cjzdr6j2y00aahomjtbf76uwf"},{"name":"参数估计","_id":"cjzdr6j3000aghomj2msnd3d8"},{"name":"高数","_id":"cjzdr6j3e00axhomjwf4ydpeh"},{"name":"感知器","_id":"cjzdr6j3g00b5homji8szv300"},{"name":"优化","_id":"cjzdr6j3h00b7homjln12few3"},{"name":"目录","_id":"cjzdr6j3j00bdhomjza16w52h"},{"name":"抽样分布","_id":"cjzdr6j3m00bkhomjq7jahg4c"},{"name":"数学","_id":"cjzdr6j3q00bohomjs76cut1l"},{"name":"中心极限定理","_id":"cjzdr6j3u00byhomjo9rik3ai"},{"name":"大数定律","_id":"cjzdr6j3u00bzhomjp7kiz5n6"},{"name":"线性代数","_id":"cjzdr6j3w00c3homj1sfejuwc"},{"name":"矩阵","_id":"cjzdr6j3w00c6homjkvr3jsa2"},{"name":"向量","_id":"cjzdr6j4800d1homj7j9abb13"},{"name":"评估","_id":"cjzdr6j4h00dphomjfwda6mf5"}]}}